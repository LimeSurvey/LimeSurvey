{"version":3,"file":"js/emailtemplates.js","sources":["webpack:///webpack/bootstrap","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/ckeditorerror.js","webpack:///./node_modules/lodash/lodash.js","webpack:///./node_modules/circular-json/build/circular-json.node.js","webpack:///./node_modules/vue/dist/vue.esm.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/config.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/spy.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/uid.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/priorities.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/mix.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/comparearrays.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/node.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/text.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/objecttomap.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/isiterable.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/matcher.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/element.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/containerelement.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/editableelement.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/rooteditableelement.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/count.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/selection.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/documentselection.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/collection.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/document.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/attributeelement.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/env.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/keyboard.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/uielement.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/documentfragment.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/istext.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/filler.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/fastdiff.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/diff.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/insertat.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/remove.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/isnode.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/indexof.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/getancestors.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/getcommonancestor.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/iswindow.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/emittermixin.js","webpack:///../meta/LsCkeditor/node_modules/lodash-es/isSymbol.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/fakeselectionobserver.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/isrange.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/getborderwidths.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/rect.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/scroll.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/tomap.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/view.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/element.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcastdispatcher.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/liverange.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/documentselection.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversionhelpers.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/controller/editingcontroller.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-core/src/plugincollection.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-core/src/commandcollection.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/translation-service.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/batch.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/history.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/unicode.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/document.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/liveposition.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertcontent.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/modifyselection.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/getselectedcontent.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/keystrokehandler.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-core/src/editor/editor.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-core/src/editor/utils/dataapimixin.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/setdatainelement.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-core/src/editor/utils/elementapimixin.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-core/src/editor/utils/attachtoform.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/basichtmlwriter.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/componentfactory.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/focustracker.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-core/src/editor/editorui.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/toolbar/enabletoolbarkeyboardfocus.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/toolbar/normalizetoolbarconfig.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/placeholder.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/elementreplacer.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/viewcollection.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/template.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/view.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/editorui/editoruiview.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/tounit.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarseparatorview.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/bindings/preventdefault.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarview.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/getdatafromelement.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditor.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-clipboard/src/datatransfer.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-clipboard/src/clipboard.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-core/src/command.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-enter/src/enterobserver.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-enter/src/shiftentercommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-enter/src/shiftenter.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/difftochanges.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-typing/src/utils/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-typing/src/utils/injecttypingmutationshandling.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-typing/src/input.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-typing/src/utils/injectandroidbackspacemutationshandling.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-typing/src/delete.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-undo/src/undocommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-autoformat/src/autoformat.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-basic-styles/src/attributecommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/first.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-block-quote/src/blockquotecommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-block-quote/src/blockquoteediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-paragraph/src/paragraph.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-heading/src/headingediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownpanelview.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/getpositionedancestor.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/dom/position.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownview.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/dropdown/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-heading/src/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-heading/src/headingui.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-alignment/src/alignmentcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-alignment/src/alignmentediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-link/src/findlinkrange.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-link/src/linkcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-link/src/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/utils/bindtwostepcarettoattribute.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-link/src/linkediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/bindings/submithandler.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-link/src/link.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-list/src/listcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-list/src/indentcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-list/src/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-list/src/converters.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-list/src/listediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/commands/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/converters/upcasttable.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/tablewalker.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-widget/src/highlightstack.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-widget/src/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/converters/downcast.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/commands/inserttablecommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/commands/insertrowcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/commands/mergecellcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/commands/removerowcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/commands/setheaderrowcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/commands/setheadercolumncommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/tableutils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/converters/table-layout-post-fixer.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/converters/table-cell-content-post-fixer.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/converters/tablecell-post-fixer.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/tableediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-table/src/table.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-media-embed/src/converters.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-media-embed/src/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-media-embed/src/mediaembedcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-media-embed/src/mediaembed.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/space.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/parse.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-engine/src/view/upcastwriter.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/list.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/image.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-paste-from-office/src/pastefromoffice.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/image/converters.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/image/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/image/imageinsertcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/image/imageediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativecommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/image/ui/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativeui.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imagecaption/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imagecaption/imagecaptionediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imagecaption.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imagestyle/converters.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imagestyle/imagestyleediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imagestyle.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-widget/src/widgettoolbarrepository.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imagetoolbar.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imageupload/utils.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadui.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-upload/src/filereader.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-upload/src/filerepository.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-ui/src/notification/notification.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadcommand.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadediting.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-image/src/imageupload.js","webpack:///./node_modules/vuex/dist/vuex.esm.js","webpack:///../meta/LsCkeditor/node_modules/@ckeditor/ckeditor5-utils/src/log.js","webpack:///./node_modules/vue-localstorage/dist/vue-local-storage.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import \"core-js/modules/es6.regexp.match\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\nimport _wrapNativeSuper from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/wrapNativeSuper\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/ckeditorerror\n */\n\n/**\n * URL to the documentation with error codes.\n */\nexport var DOCUMENTATION_URL = 'https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html';\n/**\n * The CKEditor error class.\n *\n * All errors will be shortened during the minification process in order to reduce the code size.\n * Therefore, all error messages should be documented in the same way as those in {@link module:utils/log}.\n *\n * Read more in the {@link module:utils/log} module.\n *\n * @extends Error\n */\n\nvar CKEditorError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(CKEditorError, _Error);\n\n  /**\n   * Creates an instance of the CKEditorError class.\n   *\n   * Read more about error logging in the {@link module:utils/log} module.\n   *\n   * @param {String} message The error message in an `error-name: Error message.` format.\n   * During the minification process the \"Error message\" part will be removed to limit the code size\n   * and a link to this error documentation will be added to the `message`.\n   * @param {Object} [data] Additional data describing the error. A stringified version of this object\n   * will be appended to the error message, so the data are quickly visible in the console. The original\n   * data object will also be later available under the {@link #data} property.\n   */\n  function CKEditorError(message, data) {\n    var _this;\n\n    _classCallCheck(this, CKEditorError);\n\n    message = attachLinkToDocumentation(message);\n\n    if (data) {\n      message += ' ' + JSON.stringify(data);\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CKEditorError).call(this, message));\n    /**\n     * @member {String}\n     */\n\n    _this.name = 'CKEditorError';\n    /**\n     * The additional error data passed to the constructor. Undefined if none was passed.\n     *\n     * @member {Object|undefined}\n     */\n\n    _this.data = data;\n    return _this;\n  }\n  /**\n   * Checks if error is an instance of CKEditorError class.\n   *\n   * @param {Object} error Object to check.\n   * @returns {Boolean}\n   */\n\n\n  _createClass(CKEditorError, null, [{\n    key: \"isCKEditorError\",\n    value: function isCKEditorError(error) {\n      return error instanceof CKEditorError;\n    }\n  }]);\n\n  return CKEditorError;\n}(_wrapNativeSuper(Error));\n/**\n * Attaches link to the documentation at the end of the error message.\n *\n * @param {String} message Message to be logged.\n * @returns {String}\n */\n\n\nexport { CKEditorError as default };\nexport function attachLinkToDocumentation(message) {\n  var matchedErrorName = message.match(/^([^:]+):/);\n\n  if (!matchedErrorName) {\n    return message;\n  }\n\n  return message + \" Read more: \".concat(DOCUMENTATION_URL, \"#error-\").concat(matchedErrorName[1], \"\\n\");\n}","/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.11';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n\n        return result;\n      }\n\n      if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n\n        return result;\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        if (isObject(srcValue)) {\n          stack || (stack = new Stack);\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      var index = -1;\n      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array == null ? 0 : array.length,\n          valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(array);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('dj vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      var sourceURL = '//# sourceURL=' +\n        ('sourceURL' in options\n          ? options.sourceURL\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = (lodashFunc.name + ''),\n            names = realNames[key] || (realNames[key] = []);\n\n        names.push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = _)._ = _;\n    // Export for CommonJS support.\n    freeExports._ = _;\n  }\n  else {\n    // Export to the global object.\n    root._ = _;\n  }\n}.call(this));\n","/*!\nCopyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\nvar\n  // should be a not so common char\n  // possibly one JSON does not encode\n  // possibly one encodeURIComponent does not encode\n  // right now this char is '~' but this might change in the future\n  specialChar = '~',\n  safeSpecialChar = '\\\\x' + (\n    '0' + specialChar.charCodeAt(0).toString(16)\n  ).slice(-2),\n  escapedSafeSpecialChar = '\\\\' + safeSpecialChar,\n  specialCharRG = new RegExp(safeSpecialChar, 'g'),\n  safeSpecialCharRG = new RegExp(escapedSafeSpecialChar, 'g'),\n\n  safeStartWithSpecialCharRG = new RegExp('(?:^|([^\\\\\\\\]))' + escapedSafeSpecialChar),\n\n  indexOf = [].indexOf || function(v){\n    for(var i=this.length;i--&&this[i]!==v;);\n    return i;\n  },\n  $String = String  // there's no way to drop warnings in JSHint\n                    // about new String ... well, I need that here!\n                    // faked, and happy linter!\n;\n\nfunction generateReplacer(value, replacer, resolve) {\n  var\n    doNotIgnore = false,\n    inspect = !!replacer,\n    path = [],\n    all  = [value],\n    seen = [value],\n    mapp = [resolve ? specialChar : '[Circular]'],\n    last = value,\n    lvl  = 1,\n    i, fn\n  ;\n  if (inspect) {\n    fn = typeof replacer === 'object' ?\n      function (key, value) {\n        return key !== '' && replacer.indexOf(key) < 0 ? void 0 : value;\n      } :\n      replacer;\n  }\n  return function(key, value) {\n    // the replacer has rights to decide\n    // if a new object should be returned\n    // or if there's some key to drop\n    // let's call it here rather than \"too late\"\n    if (inspect) value = fn.call(this, key, value);\n\n    // first pass should be ignored, since it's just the initial object\n    if (doNotIgnore) {\n      if (last !== this) {\n        i = lvl - indexOf.call(all, this) - 1;\n        lvl -= i;\n        all.splice(lvl, all.length);\n        path.splice(lvl - 1, path.length);\n        last = this;\n      }\n      // console.log(lvl, key, path);\n      if (typeof value === 'object' && value) {\n    \t// if object isn't referring to parent object, add to the\n        // object path stack. Otherwise it is already there.\n        if (indexOf.call(all, value) < 0) {\n          all.push(last = value);\n        }\n        lvl = all.length;\n        i = indexOf.call(seen, value);\n        if (i < 0) {\n          i = seen.push(value) - 1;\n          if (resolve) {\n            // key cannot contain specialChar but could be not a string\n            path.push(('' + key).replace(specialCharRG, safeSpecialChar));\n            mapp[i] = specialChar + path.join(specialChar);\n          } else {\n            mapp[i] = mapp[0];\n          }\n        } else {\n          value = mapp[i];\n        }\n      } else {\n        if (typeof value === 'string' && resolve) {\n          // ensure no special char involved on deserialization\n          // in this case only first char is important\n          // no need to replace all value (better performance)\n          value = value .replace(safeSpecialChar, escapedSafeSpecialChar)\n                        .replace(specialChar, safeSpecialChar);\n        }\n      }\n    } else {\n      doNotIgnore = true;\n    }\n    return value;\n  };\n}\n\nfunction retrieveFromPath(current, keys) {\n  for(var i = 0, length = keys.length; i < length; current = current[\n    // keys should be normalized back here\n    keys[i++].replace(safeSpecialCharRG, specialChar)\n  ]);\n  return current;\n}\n\nfunction generateReviver(reviver) {\n  return function(key, value) {\n    var isString = typeof value === 'string';\n    if (isString && value.charAt(0) === specialChar) {\n      return new $String(value.slice(1));\n    }\n    if (key === '') value = regenerate(value, value, {});\n    // again, only one needed, do not use the RegExp for this replacement\n    // only keys need the RegExp\n    if (isString) value = value .replace(safeStartWithSpecialCharRG, '$1' + specialChar)\n                                .replace(escapedSafeSpecialChar, safeSpecialChar);\n    return reviver ? reviver.call(this, key, value) : value;\n  };\n}\n\nfunction regenerateArray(root, current, retrieve) {\n  for (var i = 0, length = current.length; i < length; i++) {\n    current[i] = regenerate(root, current[i], retrieve);\n  }\n  return current;\n}\n\nfunction regenerateObject(root, current, retrieve) {\n  for (var key in current) {\n    if (current.hasOwnProperty(key)) {\n      current[key] = regenerate(root, current[key], retrieve);\n    }\n  }\n  return current;\n}\n\nfunction regenerate(root, current, retrieve) {\n  return current instanceof Array ?\n    // fast Array reconstruction\n    regenerateArray(root, current, retrieve) :\n    (\n      current instanceof $String ?\n        (\n          // root is an empty string\n          current.length ?\n            (\n              retrieve.hasOwnProperty(current) ?\n                retrieve[current] :\n                retrieve[current] = retrieveFromPath(\n                  root, current.split(specialChar)\n                )\n            ) :\n            root\n        ) :\n        (\n          current instanceof Object ?\n            // dedicated Object parser\n            regenerateObject(root, current, retrieve) :\n            // value as it is\n            current\n        )\n    )\n  ;\n}\n\nvar CircularJSON = {\n  stringify: function stringify(value, replacer, space, doNotResolve) {\n    return CircularJSON.parser.stringify(\n      value,\n      generateReplacer(value, replacer, !doNotResolve),\n      space\n    );\n  },\n  parse: function parse(text, reviver) {\n    return CircularJSON.parser.parse(\n      text,\n      generateReviver(reviver)\n    );\n  },\n  // A parser should be an API 1:1 compatible with JSON\n  // it should expose stringify and parse methods.\n  // The default parser is the native JSON.\n  parser: JSON\n};\n\nmodule.exports = CircularJSON;\n","/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if (process.env.NODE_ENV !== 'production' && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) { return a.id - b.id; });\n  }\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (process.env.NODE_ENV !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (process.env.NODE_ENV !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    // skip validation for weex recycle-list child component props\n    !(false)\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      // perf.clearMeasures(name)\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\n      \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n      'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n      'prevent conflicts with Vue internals' +\n      'See: https://vuejs.org/v2/api/#data',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) ||\n        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n      if (!has && !isAllowed) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if (process.env.NODE_ENV !== 'production' && key !== '' && key !== null) {\n      // null is a speical value for explicitly removing a binding\n      warn(\n        (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n        this\n      );\n    }\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (process.env.NODE_ENV !== 'production') {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack becaues all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\n        flushSchedulerQueue();\n        return\n      }\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof methods[key] !== 'function') {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function () {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production' && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.10';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\n\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn (msg, range) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n/* eslint-enable no-unused-vars */\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value, range, dynamic) {\n  var attrs = dynamic\n    ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n    : (el.attrs || (el.attrs = []));\n  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  isDynamicArg,\n  modifiers,\n  range\n) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker (symbol, name, dynamic) {\n  return dynamic\n    ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n    : symbol + name // mark the event as captured\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn,\n  range,\n  dynamic\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    process.env.NODE_ENV !== 'production' && warn &&\n    modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.',\n      range\n    );\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr (\n  el,\n  name\n) {\n  return el.rawAttrsMap[':' + name] ||\n    el.rawAttrsMap['v-bind:' + name] ||\n    el.rawAttrsMap[name]\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\nfunction getAndRemoveAttrByRegex (\n  el,\n  name\n) {\n  var list = el.attrsList;\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr\n    }\n  }\n}\n\nfunction rangeSetItem (\n  item,\n  range\n) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n  return item\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: JSON.stringify(value),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.',\n      el.rawAttrsMap['v-model']\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  if (process.env.NODE_ENV !== 'production') {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally',\n        el.rawAttrsMap[binding]\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        process.env.NODE_ENV !== 'production' &&\n        process.env.NODE_ENV !== 'test'\n      ) {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' &&\n      process.env.NODE_ENV !== 'test' &&\n      config.productionTip !== false &&\n      typeof console !== 'undefined'\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n        el.rawAttrsMap['class']\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n          el.rawAttrsMap['style']\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being pased as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n      if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n        attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n        attrs[i].end = args.end;\n      }\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n            { start: stack[i].start, end: stack[i].end }\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\nvar slotRE = /^v-slot(:|$)|^#/;\n\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\n\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\nvar decodeHTMLCached = cached(he.decode);\n\nvar emptySlotScopeToken = \"_empty_\";\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement (element) {\n    trimEndingWhitespace(element);\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    }\n    // tree management\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkRootConstraints(element);\n        }\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (process.env.NODE_ENV !== 'production') {\n        warnOnce(\n          \"Component template should contain exactly one root element. \" +\n          \"If you are using v-if on multiple elements, \" +\n          \"use v-else-if to chain them instead.\",\n          { start: element.start }\n        );\n      }\n    }\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"'\n          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    }\n\n    // final children cleanup\n    // filter out scoped slots\n    element.children = element.children.filter(function (c) { return !(c).slotScope; });\n    // remove trailing whitespace node again\n    trimEndingWhitespace(element);\n\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace (el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n      while (\n        (lastNode = el.children[el.children.length - 1]) &&\n        lastNode.type === 3 &&\n        lastNode.text === ' '\n      ) {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints (el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\n        \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n        'contain multiple nodes.',\n        { start: el.start }\n      );\n    }\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce(\n        'Cannot use v-for on stateful component root element because ' +\n        'it renders multiple elements.',\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start (tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (options.outputSourceRange) {\n          element.start = start$1;\n          element.end = end;\n          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n            cumulated[attr.name] = attr;\n            return cumulated\n          }, {});\n        }\n        attrs.forEach(function (attr) {\n          if (invalidAttributeRE.test(attr.name)) {\n            warn$2(\n              \"Invalid dynamic argument expression: attribute names cannot contain \" +\n              \"spaces, quotes, <, >, / or =.\",\n              {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              }\n            );\n          }\n        });\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.',\n          { start: element.start }\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n        if (process.env.NODE_ENV !== 'production') {\n          checkRootConstraints(root);\n        }\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end (tag, start, end$1) {\n      var element = stack[stack.length - 1];\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n        element.end = end$1;\n      }\n      closeElement(element);\n    },\n\n    chars: function chars (text, start, end) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.',\n              { start: start }\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n              { start: start }\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n        var res;\n        var child;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n        if (child) {\n          if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment (text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n        if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n          child.start = start;\n          child.end = end;\n        }\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var list = el.attrsList;\n  var len = list.length;\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (\n  element,\n  options\n) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = (\n    !element.key &&\n    !element.scopedSlots &&\n    !element.attrsList.length\n  );\n\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n  return element\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (el.tag === 'template') {\n        warn$2(\n          \"<template> cannot be keyed. Place the key on real elements instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n      if (el.for) {\n        var iterator = el.iterator2 || el.iterator1;\n        var parent = el.parent;\n        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n          warn$2(\n            \"Do not use v-for index as key on <transition-group> children, \" +\n            \"this is the same as not using keys.\",\n            getRawBindingAttr(el, 'key'),\n            true /* tip */\n          );\n        }\n      }\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp),\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\",\n          children[i]\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent (el) {\n  var slotScope;\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && slotScope) {\n      warn$2(\n        \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n        \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n        \"can also be used on plain elements in addition to <template> to \" +\n        \"denote scoped slots.\",\n        el.rawAttrsMap['scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && el.attrsMap['v-for']) {\n      warn$2(\n        \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n        \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n        \"scoped slot to make it clearer.\",\n        el.rawAttrsMap['slot-scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope;\n  }\n\n  // slot=\"xxx\"\n  var slotTarget = getBindingAttr(el, 'slot');\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n    // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  }\n\n  // 2.6 v-slot syntax\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.slotTarget || el.slotScope) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.parent && !maybeComponent(el.parent)) {\n            warn$2(\n              \"<template v-slot> can only appear at the root level inside \" +\n              \"the receiving the component\",\n              el\n            );\n          }\n        }\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding$1) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (!maybeComponent(el)) {\n            warn$2(\n              \"v-slot can only be used on components or <template>.\",\n              slotBinding$1\n            );\n          }\n          if (el.slotScope || el.slotTarget) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.scopedSlots) {\n            warn$2(\n              \"To avoid scope ambiguity, the default slot should also use \" +\n              \"<template> syntax when there are other named slots.\",\n              slotBinding$1\n            );\n          }\n        }\n        // add the component's children to its default slot\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n        // remove children as they are returned from scopedSlots now\n        el.children = [];\n        // mark el non-plain so data gets generated\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName (binding) {\n  var name = binding.name.replace(slotRE, '');\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn$2(\n        \"v-slot shorthand syntax requires a slot name.\",\n        binding\n      );\n    }\n  }\n  return dynamicArgRE.test(name)\n    // dynamic [name]\n    ? { name: name.slice(1, -1), dynamic: true }\n    // static name\n    : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n}\n\n// handle <slot/> outlets\nfunction processSlotOutlet (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\",\n        getRawBindingAttr(el, 'key')\n      );\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name.replace(dirRE, ''));\n      // support .foo shorthand syntax for the .prop modifier\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        if (\n          process.env.NODE_ENV !== 'production' &&\n          value.trim().length === 0\n        ) {\n          warn$2(\n            (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n          );\n        }\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n            if (!isDynamic) {\n              addHandler(\n                el,\n                (\"update:\" + (camelize(name))),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i]\n              );\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(\n                  el,\n                  (\"update:\" + (hyphenate(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(\n                el,\n                (\"\\\"update:\\\"+(\" + name + \")\"),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i],\n                true // dynamic\n              );\n            }\n          }\n        }\n        if ((modifiers && modifiers.prop) || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n            list[i]\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value), list[i]);\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative\n) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n  staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n  } else {\n    return prefix + staticHandlers\n  }\n}\n\nfunction genHandler (handler) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : isFunctionInvocation\n          ? (\"return \" + (handler.value))\n          : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" +\n    (keys.map(genFilterCode).join('&&')) + \")return null;\"\n  )\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n\n\n\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n      if (!el.plain || (el.pre && state.maybeComponent(el))) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n  var originalPreState = state.pre;\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  state.pre = originalPreState;\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \",\n        el.rawAttrsMap['v-once']\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (process.env.NODE_ENV !== 'production' &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      el.rawAttrsMap['v-for'],\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:\" + (genProps(el.props)) + \",\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n  }\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length !== 1 || ast.type !== 1\n  )) {\n    state.warn(\n      'Inline-template components must have exactly one child element.',\n      { start: el.start }\n    );\n  }\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  el,\n  slots,\n  state\n) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return (\n      slot.slotTargetDynamic ||\n      slot.if ||\n      slot.for ||\n      containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    )\n  });\n\n  // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n  var needsKey = !!el.if;\n\n  // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n    while (parent) {\n      if (\n        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n        parent.for\n      ) {\n        needsForceUpdate = true;\n        break\n      }\n      if (parent.if) {\n        needsKey = true;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots)\n    .map(function (key) { return genScopedSlot(slots[key], state); })\n    .join(',');\n\n  return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n  return hash >>> 0\n}\n\nfunction containsSlotChild (el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true\n    }\n    return el.children.some(containsSlotChild)\n  }\n  return false\n}\n\nfunction genScopedSlot (\n  el,\n  state\n) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\")\n  }\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot)\n  }\n  var slotScope = el.slotScope === emptySlotScopeToken\n    ? \"\"\n    : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if && isLegacySyntax\n        ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  // reverse proxy v-slot without scope on this.$slots\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      var normalizationType = checkSkip\n        ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n        : \"\";\n      return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n    }\n    var normalizationType$1 = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs || el.dynamicAttrs\n    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      }); }))\n    : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n    if (prop.dynamic) {\n      dynamicProps += (prop.name) + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n    }\n  }\n  staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n  if (dynamicProps) {\n    return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n  } else {\n    return staticProps\n  }\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode (node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          var range = node.rawAttrsMap[name];\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent (exp, text, warn, range) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n      range\n    );\n  }\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor (node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  warn,\n  range\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n    }\n  }\n}\n\nfunction checkExpression (exp, text, warn, range) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      warn(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n        range\n      );\n    } else {\n      warn(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\",\n        range\n      );\n    }\n  }\n}\n\n/*  */\n\nvar range = 2;\n\nfunction generateCodeFrame (\n  source,\n  start,\n  end\n) {\n  if ( start === void 0 ) start = 0;\n  if ( end === void 0 ) end = source.length;\n\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) { continue }\n        res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n        var lineLength = lines[j].length;\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n          count += lineLength + 1;\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n\nfunction repeat$1 (str, n) {\n  var result = '';\n  if (n > 0) {\n    while (true) { // eslint-disable-line\n      if (n & 1) { result += str; }\n      n >>>= 1;\n      if (n <= 0) { break }\n      str += str;\n    }\n  }\n  return result\n}\n\n/*  */\n\n\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        if (options.outputSourceRange) {\n          compiled.errors.forEach(function (e) {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n              generateCodeFrame(template, e.start, e.end),\n              vm\n            );\n          });\n        } else {\n          warn$$1(\n            \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n            compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n            vm\n          );\n        }\n      }\n      if (compiled.tips && compiled.tips.length) {\n        if (options.outputSourceRange) {\n          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n        } else {\n          compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n        }\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n          // $flow-disable-line\n          var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n          warn = function (msg, range, tip) {\n            var data = { msg: msg };\n            if (range) {\n              if (range.start != null) {\n                data.start = range.start + leadingSpaceLength;\n              }\n              if (range.end != null) {\n                data.end = range.end + leadingSpaceLength;\n              }\n            }\n            (tip ? tips : errors).push(data);\n          };\n        }\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n\n      var compiled = baseCompile(template.trim(), finalOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        detectErrors(compiled.ast, warn);\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\nexport default Vue;\n","import \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.regexp.split\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/config\n */\nimport { isPlainObject, isElement, cloneDeepWith } from 'lodash-es';\n/**\n * Handles a configuration dictionary.\n */\n\nvar Config =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the {@link ~Config} class.\n   *\n   * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.\n   * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.\n   */\n  function Config(configurations, defaultConfigurations) {\n    _classCallCheck(this, Config);\n\n    /**\n     * Store for the whole configuration.\n     *\n     * @private\n     * @member {Object}\n     */\n    this._config = {}; // Set default configuration.\n\n    if (defaultConfigurations) {\n      this.define(defaultConfigurations);\n    } // Set initial configuration.\n\n\n    if (configurations) {\n      this._setObjectToTarget(this._config, configurations);\n    }\n  }\n  /**\n   * Set configuration values.\n   *\n   * It accepts both a name/value pair or an object, which properties and values will be used to set\n   * configurations.\n   *\n   * It also accepts setting a \"deep configuration\" by using dots in the name. For example, `'resize.width'` sets\n   * the value for the `width` configuration in the `resize` subset.\n   *\n   *\t\tconfig.set( 'width', 500 );\n   *\t\tconfig.set( 'toolbar.collapsed', true );\n   *\n   *\t\t// Equivalent to:\n   *\t\tconfig.set( {\n   *\t\t\twidth: 500\n   *\t\t\ttoolbar: {\n   *\t\t\t\tcollapsed: true\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Passing an object as the value will amend the configuration, not replace it.\n   *\n   *\t\tconfig.set( 'toolbar', {\n   *\t\t\tcollapsed: true,\n   *\t\t} );\n   *\n   *\t\tconfig.set( 'toolbar', {\n   *\t\t\tcolor: 'red',\n   *\t\t} );\n   *\n   *\t\tconfig.get( 'toolbar.collapsed' ); // true\n   *\t\tconfig.get( 'toolbar.color' ); // 'red'\n   *\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   */\n\n\n  _createClass(Config, [{\n    key: \"set\",\n    value: function set(name, value) {\n      this._setToTarget(this._config, name, value);\n    }\n    /**\n     * Does exactly the same as {@link #set} with one exception  passed configuration extends\n     * existing one, but does not overwrite already defined values.\n     *\n     * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be\n     * rarely used for other needs.\n     *\n     * @param {String|Object} name The configuration name or an object from which take properties as\n     * configuration entries. Configuration names are case-sensitive.\n     * @param {*} value The configuration value. Used if a name is passed.\n     */\n\n  }, {\n    key: \"define\",\n    value: function define(name, value) {\n      var isDefine = true;\n\n      this._setToTarget(this._config, name, value, isDefine);\n    }\n    /**\n     * Gets the value for a configuration entry.\n     *\n     *\t\tconfig.get( 'name' );\n     *\n     * Deep configurations can be retrieved by separating each part with a dot.\n     *\n     *\t\tconfig.get( 'toolbar.collapsed' );\n     *\n     * @param {String} name The configuration name. Configuration names are case-sensitive.\n     * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      return this._getFromSource(this._config, name);\n    }\n    /**\n     * Saves passed configuration to the specified target (nested object).\n     *\n     * @private\n     * @param {Object} target Nested config object.\n     * @param {String|Object} name The configuration name or an object from which take properties as\n     * configuration entries. Configuration names are case-sensitive.\n     * @param {*} value The configuration value. Used if a name is passed.\n     * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.\n     */\n\n  }, {\n    key: \"_setToTarget\",\n    value: function _setToTarget(target, name, value) {\n      var isDefine = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      // In case of an object, iterate through it and call `_setToTarget` again for each property.\n      if (isPlainObject(name)) {\n        this._setObjectToTarget(target, name, isDefine);\n\n        return;\n      } // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n\n\n      var parts = name.split('.'); // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\n      name = parts.pop(); // Iterate over parts to check if currently stored configuration has proper structure.\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var part = _step.value;\n\n          // If there is no object for specified part then create one.\n          if (!isPlainObject(target[part])) {\n            target[part] = {};\n          } // Nested object becomes a target.\n\n\n          target = target[part];\n        } // In case of value is an object.\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (isPlainObject(value)) {\n        // We take care of proper config structure.\n        if (!isPlainObject(target[name])) {\n          target[name] = {};\n        }\n\n        target = target[name]; // And iterate through this object calling `_setToTarget` again for each property.\n\n        this._setObjectToTarget(target, value, isDefine);\n\n        return;\n      } // Do nothing if we are defining configuration for non empty name.\n\n\n      if (isDefine && typeof target[name] != 'undefined') {\n        return;\n      }\n\n      target[name] = value;\n    }\n    /**\n     * Get specified configuration from specified source (nested object).\n     *\n     * @private\n     * @param {Object} source level of nested object.\n     * @param {String} name The configuration name. Configuration names are case-sensitive.\n     * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n     */\n\n  }, {\n    key: \"_getFromSource\",\n    value: function _getFromSource(source, name) {\n      // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n      var parts = name.split('.'); // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\n      name = parts.pop(); // Iterate over parts to check if currently stored configuration has proper structure.\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = parts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var part = _step2.value;\n\n          if (!isPlainObject(source[part])) {\n            source = null;\n            break;\n          } // Nested object becomes a source.\n\n\n          source = source[part];\n        } // Always returns undefined for non existing configuration.\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return source ? cloneConfig(source[name]) : undefined;\n    }\n    /**\n     * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.\n     *\n     * @private\n     * @param {Object} target Nested config object.\n     * @param {Object} configuration Configuration data set\n     * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.\n     */\n\n  }, {\n    key: \"_setObjectToTarget\",\n    value: function _setObjectToTarget(target, configuration, isDefine) {\n      var _this = this;\n\n      Object.keys(configuration).forEach(function (key) {\n        _this._setToTarget(target, key, configuration[key], isDefine);\n      });\n    }\n  }]);\n\n  return Config;\n}(); // Clones configuration object or value.\n// @param {*} source Source configuration\n// @returns {*} Cloned configuration value.\n\n\nexport { Config as default };\n\nfunction cloneConfig(source) {\n  return cloneDeepWith(source, leaveDOMReferences);\n} // A customizer function for cloneDeepWith.\n// It will leave references to DOM Elements instead of cloning them.\n//\n// @param {*} value\n// @returns {Element|undefined}\n\n\nfunction leaveDOMReferences(value) {\n  return isElement(value) ? value : undefined;\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/spy\n */\n\n/**\n * Creates a spy function (ala Sinon.js) that can be used to inspect call to it.\n *\n * The following are the present features:\n *\n * * spy.called: property set to `true` if the function has been called at least once.\n *\n * @returns {Function} The spy function.\n */\nfunction spy() {\n  return function spy() {\n    spy.called = true;\n  };\n}\n\nexport default spy;","import \"core-js/modules/es6.regexp.to-string\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/uid\n */\n\n/**\n * Returns a unique id. This id consist of an 'e' character and a randomly generated string of 32 aphanumeric characters.\n * Each character in uid string represents a hexadecimal digit (base 16).\n *\n * @returns {String} A hexadecimal number representing the id.\n */\nexport default function uid() {\n  var uuid = 'e'; // Make sure that id does not start with number.\n\n  for (var i = 0; i < 8; i++) {\n    uuid += Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n\n  return uuid;\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/priorities\n */\n\n/**\n * String representing a priority value.\n *\n * @typedef {'highest'|'high'|'normal'|'low'|'lowest'} module:utils/priorities~PriorityString\n */\n\n/**\n * Provides group of constants to use instead of hardcoding numeric priority values.\n *\n * @namespace\n */\nvar priorities = {\n  /**\n   * Converts a string with priority name to it's numeric value. If `Number` is given, it just returns it.\n   *\n   * @static\n   * @param {module:utils/priorities~PriorityString|Number} priority Priority to convert.\n   * @returns {Number} Converted priority.\n   */\n  get: function get(priority) {\n    if (typeof priority != 'number') {\n      return this[priority] || this.normal;\n    } else {\n      return priority;\n    }\n  },\n  highest: 100000,\n  high: 1000,\n  normal: 0,\n  low: -1000,\n  lowest: -100000\n};\nexport default priorities;","import \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/mix\n */\n\n/**\n * Copies enumerable properties and symbols from the objects given as 2nd+ parameters to the\n * prototype of first object (a constructor).\n *\n *\t\tclass Editor {\n *\t\t\t...\n *\t\t}\n *\n *\t\tconst SomeMixin = {\n *\t\t\ta() {\n *\t\t\t\treturn 'a';\n *\t\t\t}\n *\t\t};\n *\n *\t\tmix( Editor, SomeMixin, ... );\n *\n *\t\tnew Editor().a(); // -> 'a'\n *\n * Note: Properties which already exist in the base class will not be overriden.\n *\n * @param {Function} [baseClass] Class which prototype will be extended.\n * @param {Object} [...mixins] Objects from which to get properties.\n */\nexport default function mix(baseClass) {\n  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    mixins[_key - 1] = arguments[_key];\n  }\n\n  mixins.forEach(function (mixin) {\n    Object.getOwnPropertyNames(mixin).concat(Object.getOwnPropertySymbols(mixin)).forEach(function (key) {\n      if (key in baseClass.prototype) {\n        return;\n      }\n\n      var sourceDescriptor = Object.getOwnPropertyDescriptor(mixin, key);\n      sourceDescriptor.enumerable = false;\n      Object.defineProperty(baseClass.prototype, key, sourceDescriptor);\n    });\n  });\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/comparearrays\n */\n\n/**\n * Compares how given arrays relate to each other. One array can be: same as another array, prefix of another array\n * or completely different. If arrays are different, first index at which they differ is returned. Otherwise,\n * a flag specifying the relation is returned. Flags are negative numbers, so whenever a number >= 0 is returned\n * it means that arrays differ.\n *\n *\t\tcompareArrays( [ 0, 2 ], [ 0, 2 ] );\t\t// 'same'\n *\t\tcompareArrays( [ 0, 2 ], [ 0, 2, 1 ] );\t\t// 'prefix'\n *\t\tcompareArrays( [ 0, 2 ], [ 0 ] );\t\t\t// 'extension'\n *\t\tcompareArrays( [ 0, 2 ], [ 1, 2 ] );\t\t// 0\n *\t\tcompareArrays( [ 0, 2 ], [ 0, 1 ] );\t\t// 1\n *\n * @param {Array} a Array that is compared.\n * @param {Array} b Array to compare with.\n * @returns {module:utils/comparearrays~ArrayRelation} How array `a` is related to `b`.\n */\nexport default function compareArrays(a, b) {\n  var minLen = Math.min(a.length, b.length);\n\n  for (var i = 0; i < minLen; i++) {\n    if (a[i] != b[i]) {\n      // The arrays are different.\n      return i;\n    }\n  } // Both arrays were same at all points.\n\n\n  if (a.length == b.length) {\n    // If their length is also same, they are the same.\n    return 'same';\n  } else if (a.length < b.length) {\n    // Compared array is shorter so it is a prefix of the other array.\n    return 'prefix';\n  } else {\n    // Compared array is longer so it is an extension of the other array.\n    return 'extension';\n  }\n}\n/**\n * @typedef {'extension'|'same'|'prefix'} module:utils/comparearrays~ArrayRelation\n */","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/node\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport { clone } from 'lodash-es'; // To check if component is loaded more than once.\n\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Abstract tree view node class.\n *\n * This is an abstract class. Its constructor should not be used directly.\n * Use the {@link module:engine/view/element~Element} class to create view elements\n * or {@link module:engine/view/text~Text} class to create view text nodes.\n *\n * @abstract\n */\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a tree view node.\n   */\n  function Node() {\n    _classCallCheck(this, Node);\n\n    /**\n     * Parent element. Null by default. Set by {@link module:engine/view/element~Element#_insertChild}.\n     *\n     * @readonly\n     * @member {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}\n     */\n    this.parent = null;\n  }\n  /**\n   * Index of the node in the parent element or null if the node has no parent.\n   *\n   * Accessing this property throws an error if this node's parent element does not contain it.\n   * This means that view tree got broken.\n   *\n   * @readonly\n   * @type {Number|null}\n   */\n\n\n  _createClass(Node, [{\n    key: \"getPath\",\n\n    /**\n     * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,\n     * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.\n     *\n     *\t\tconst abc = downcastWriter.createText( 'abc' );\n     *\t\tconst foo = downcastWriter.createText( 'foo' );\n     *\t\tconst h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );\n     *\t\tconst p = downcastWriter.createElement( 'p', null, [ abc, foo ] );\n     *\t\tconst div = downcastWriter.createElement( 'div', null, [ h1, p ] );\n     *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n     *\t\th1.getPath(); // Returns [ 0 ].\n     *\t\tdiv.getPath(); // Returns [].\n     *\n     * @returns {Array.<Number>} The path.\n     */\n    value: function getPath() {\n      var path = [];\n      var node = this; // eslint-disable-line consistent-this\n\n      while (node.parent) {\n        path.unshift(node.index);\n        node = node.parent;\n      }\n\n      return path;\n    }\n    /**\n     * Returns ancestors array of this node.\n     *\n     * @param {Object} options Options object.\n     * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n     * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n     * otherwise root element will be the first item in the array.\n     * @returns {Array} Array with ancestors.\n     */\n\n  }, {\n    key: \"getAncestors\",\n    value: function getAncestors() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        includeSelf: false,\n        parentFirst: false\n      };\n      var ancestors = [];\n      var parent = options.includeSelf ? this : this.parent;\n\n      while (parent) {\n        ancestors[options.parentFirst ? 'push' : 'unshift'](parent);\n        parent = parent.parent;\n      }\n\n      return ancestors;\n    }\n    /**\n     * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}\n     * which is a common ancestor of both nodes.\n     *\n     * @param {module:engine/view/node~Node} node The second node.\n     * @param {Object} options Options object.\n     * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n     * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n     * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}\n     */\n\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor(node) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ancestorsA = this.getAncestors(options);\n      var ancestorsB = node.getAncestors(options);\n      var i = 0;\n\n      while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n        i++;\n      }\n\n      return i === 0 ? null : ancestorsA[i - 1];\n    }\n    /**\n     * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n     * in different {@link module:engine/view/documentfragment~DocumentFragment}s).\n     *\n     * @param {module:engine/view/node~Node} node Node to compare with.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isBefore\",\n    value: function isBefore(node) {\n      // Given node is not before this node if they are same.\n      if (this == node) {\n        return false;\n      } // Return `false` if it is impossible to compare nodes.\n\n\n      if (this.root !== node.root) {\n        return false;\n      }\n\n      var thisPath = this.getPath();\n      var nodePath = node.getPath();\n      var result = compareArrays(thisPath, nodePath);\n\n      switch (result) {\n        case 'prefix':\n          return true;\n\n        case 'extension':\n          return false;\n\n        default:\n          return thisPath[result] < nodePath[result];\n      }\n    }\n    /**\n     * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n     * in different {@link module:engine/view/documentfragment~DocumentFragment}s).\n     *\n     * @param {module:engine/view/node~Node} node Node to compare with.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isAfter\",\n    value: function isAfter(node) {\n      // Given node is not before this node if they are same.\n      if (this == node) {\n        return false;\n      } // Return `false` if it is impossible to compare nodes.\n\n\n      if (this.root !== node.root) {\n        return false;\n      } // In other cases, just check if the `node` is before, and return the opposite.\n\n\n      return !this.isBefore(node);\n    }\n    /**\n     * Removes node from parent.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      this.parent._removeChildren(this.index);\n    }\n    /**\n     * @protected\n     * @param {module:engine/view/document~ChangeType} type Type of the change.\n     * @param {module:engine/view/node~Node} node Changed node.\n     * @fires change\n     */\n\n  }, {\n    key: \"_fireChange\",\n    value: function _fireChange(type, node) {\n      this.fire('change:' + type, node);\n\n      if (this.parent) {\n        this.parent._fireChange(type, node);\n      }\n    }\n    /**\n     * Custom toJSON method to solve child-parent circular dependencies.\n     *\n     * @returns {Object} Clone of this object with the parent property removed.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = clone(this); // Due to circular references we need to remove parent reference.\n\n      delete json.parent;\n      return json;\n    }\n    /**\n     * Checks whether this view object is of the given type.\n     *\n     * This method is useful when processing view tree objects that are of unknown type. For example, a function\n     * may return {@link module:engine/view/documentfragment~DocumentFragment} or {@link module:engine/view/node~Node}\n     * that can be either text node or element. This method can be used to check what kind of object is returned.\n     *\n     *\t\tobj.is( 'node' ); // true for any node, false for document fragment and text fragment\n     *\t\tobj.is( 'documentFragment' ); // true for document fragment, false for any node\n     *\t\tobj.is( 'element' ); // true for any element, false for text node or document fragment\n     *\t\tobj.is( 'element', 'p' ); // true only for element which name is 'p'\n     *\t\tobj.is( 'p' ); // shortcut for obj.is( 'element', 'p' )\n     *\t\tobj.is( 'text' ); // true for text node, false for element and document fragment\n     *\n     * @param {'element'|'containerElement'|'attributeElement'|'emptyElement'|'uiElement'|\n     * 'rootElement'|'documentFragment'|'text'|'textProxy'} type\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type == 'node';\n    }\n    /**\n     * Clones this node.\n     *\n     * @protected\n     * @method #_clone\n     * @returns {module:engine/view/node~Node} Clone of this node.\n     */\n\n    /**\n     * Checks if provided node is similar to this node.\n     *\n     * @method #isSimilar\n     * @returns {Boolean} True if nodes are similar.\n     */\n\n  }, {\n    key: \"index\",\n    get: function get() {\n      var pos;\n\n      if (!this.parent) {\n        return null;\n      } // No parent or child doesn't exist in parent's children.\n\n\n      if ((pos = this.parent.getChildIndex(this)) == -1) {\n        /**\n         * The node's parent does not contain this node. It means that the document tree is corrupted.\n         *\n         * @error view-node-not-found-in-parent\n         */\n        throw new CKEditorError('view-node-not-found-in-parent: The node\\'s parent does not contain this node.');\n      }\n\n      return pos;\n    }\n    /**\n     * Node's next sibling, or `null` if it is the last child.\n     *\n     * @readonly\n     * @type {module:engine/view/node~Node|null}\n     */\n\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var index = this.index;\n      return index !== null && this.parent.getChild(index + 1) || null;\n    }\n    /**\n     * Node's previous sibling, or `null` if it is the first child.\n     *\n     * @readonly\n     * @type {module:engine/view/node~Node|null}\n     */\n\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      var index = this.index;\n      return index !== null && this.parent.getChild(index - 1) || null;\n    }\n    /**\n     * Top-most ancestor of the node. If the node has no parent it is the root itself.\n     *\n     * @readonly\n     * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      var root = this; // eslint-disable-line consistent-this\n\n      while (root.parent) {\n        root = root.parent;\n      }\n\n      return root;\n    }\n    /**\n     * {@link module:engine/view/document~Document View document} that owns this node, or `null` if the node is inside\n     * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n     *\n     * @readonly\n     * @type {module:engine/view/document~Document|null}\n     */\n\n  }, {\n    key: \"document\",\n    get: function get() {\n      // Parent might be Node, null or DocumentFragment.\n      if (this.parent instanceof Node) {\n        return this.parent.document;\n      } else {\n        return null;\n      }\n    }\n  }]);\n\n  return Node;\n}();\n/**\n * Fired when list of {@link module:engine/view/element~Element elements} children changes.\n *\n * Change event is bubbled  it is fired on all ancestors.\n *\n * @event change:children\n * @param {module:engine/view/node~Node} changedNode\n */\n\n/**\n * Fired when list of {@link module:engine/view/element~Element elements} attributes changes.\n *\n * Change event is bubbled  it is fired on all ancestors.\n *\n * @event change:attributes\n * @param {module:engine/view/node~Node} changedNode\n */\n\n/**\n * Fired when {@link module:engine/view/text~Text text nodes} data changes.\n *\n * Change event is bubbled  it is fired on all ancestors.\n *\n * @event change:text\n * @param {module:engine/view/node~Node} changedNode\n */\n\n/**\n * @event change\n */\n\n\nexport { Node as default };\nmix(Node, EmitterMixin);","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/text\n */\nimport Node from \"./node\";\n/**\n * Tree view text node.\n *\n * The constructor of this class shouldn't be used directly. To create new Text instances\n * use the {@link module:engine/view/downcastwriter~DowncastWriter#createText `DowncastWriter#createText()`}\n * method when working on data downcasted from the model or the\n * {@link module:engine/view/upcastwriter~UpcastWriter#createText `UpcastWriter#createText()`}\n * method when working on non-semantic views.\n *\n * @extends module:engine/view/node~Node\n */\n\nvar Text =\n/*#__PURE__*/\nfunction (_Node) {\n  _inherits(Text, _Node);\n\n  /**\n   * Creates a tree view text node.\n   *\n   * @protected\n   * @param {String} data The text's data.\n   */\n  function Text(data) {\n    var _this;\n\n    _classCallCheck(this, Text);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this));\n    /**\n     * The text content.\n     *\n     * Setting the data fires the {@link module:engine/view/node~Node#event:change:text change event}.\n     *\n     * @protected\n     * @member {String} module:engine/view/text~Text#_textData\n     */\n\n    _this._textData = data;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(Text, [{\n    key: \"is\",\n    value: function is(type) {\n      return type == 'text' || _get(_getPrototypeOf(Text.prototype), \"is\", this).call(this, type);\n    }\n    /**\n     * The text content.\n     *\n     * @readonly\n     * @type {String}\n     */\n\n  }, {\n    key: \"isSimilar\",\n\n    /**\n     * Checks if this text node is similar to other text node.\n     * Both nodes should have the same data to be considered as similar.\n     *\n     * @param {module:engine/view/text~Text} otherNode Node to check if it is same as this node.\n     * @returns {Boolean}\n     */\n    value: function isSimilar(otherNode) {\n      if (!(otherNode instanceof Text)) {\n        return false;\n      }\n\n      return this === otherNode || this.data === otherNode.data;\n    }\n    /**\n     * Clones this node.\n     *\n     * @protected\n     * @returns {module:engine/view/text~Text} Text node that is a clone of this node.\n     */\n\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      return new Text(this.data);\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._textData;\n    }\n    /**\n     * This getter is required when using the addition assignment operator on protected property:\n     *\n     *\t\tconst foo = downcastWriter.createText( 'foo' );\n     *\t\tconst bar = downcastWriter.createText( 'bar' );\n     *\n     *\t\tfoo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`\n     *\t\tconsole.log( foo.data ); // prints: 'foobar'\n     *\n     * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.\n     *\n     * @protected\n     * @type {String}\n     */\n\n  }, {\n    key: \"_data\",\n    get: function get() {\n      return this.data;\n    }\n    /**\n     * Sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.\n     *\n     * @protected\n     * @fires change:text\n     * @param {String} data New data for the text node.\n     */\n    ,\n    set: function set(data) {\n      this._fireChange('text', this);\n\n      this._textData = data;\n    }\n  }]);\n\n  return Text;\n}(Node);\n\nexport { Text as default };","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/objecttomap\n */\n\n/**\n * Transforms object to map.\n *\n *\t\tconst map = objectToMap( { 'foo': 1, 'bar': 2 } );\n *\t\tmap.get( 'foo' ); // 1\n *\n * @param {Object} obj Object to transform.\n * @returns {Map} Map created from object.\n */\nexport default function objectToMap(obj) {\n  var map = new Map();\n\n  for (var key in obj) {\n    map.set(key, obj[key]);\n  }\n\n  return map;\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/isiterable\n */\n\n/**\n * Checks if value implements iterator interface.\n *\n * @param {*} value The value to check.\n * @returns {Boolean} True if value implements iterator interface.\n */\nexport default function isIterable(value) {\n  return !!(value && value[Symbol.iterator]);\n}","import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/matcher\n */\n\n/**\n * View matcher class.\n * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.\n */\nvar Matcher =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates new instance of Matcher.\n   *\n   * @param {String|RegExp|Object} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for\n   * more information.\n   */\n  function Matcher() {\n    _classCallCheck(this, Matcher);\n\n    /**\n     * @private\n     * @type {Array<String|RegExp|Object>}\n     */\n    this._patterns = [];\n    this.add.apply(this, arguments);\n  }\n  /**\n   * Adds pattern or patterns to matcher instance.\n   *\n   *\t\t// String.\n   *\t\tmatcher.add( 'div' );\n   *\n   *\t\t// Regular expression.\n   *\t\tmatcher.add( /^\\w/ );\n   *\n   *\t\t// Single class.\n   *\t\tmatcher.add( {\n   *\t\t\tclasses: 'foobar'\n   *\t\t} );\n   *\n   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.\n   *\n   * Multiple patterns can be added in one call:\n   *\n   * \t\tmatcher.add( 'div', { classes: 'foobar' } );\n   *\n   * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression\n   * is provided it will be used to match element's name. Pattern can be also provided in a form\n   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.\n   * Function's return value will be stored under `match` key of the object returned from\n   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.\n   * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.\n   * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key\n   * represents attribute name. Value under that key can be either:\n   * * `true` - then attribute is just required (can be empty),\n   * * a string - then attribute has to be equal, or\n   * * a regular expression - then attribute has to match the expression.\n   * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be\n   * provided in a form of string or regular expression.\n   * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key\n   * represents style name. Value under that key can be either a string or a regular expression and it will be used\n   * to match style value.\n   */\n\n\n  _createClass(Matcher, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, pattern = new Array(_len), _key = 0; _key < _len; _key++) {\n        pattern[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _pattern = pattern; _i < _pattern.length; _i++) {\n        var item = _pattern[_i];\n\n        // String or RegExp pattern is used as element's name.\n        if (typeof item == 'string' || item instanceof RegExp) {\n          item = {\n            name: item\n          };\n        } // Single class name/RegExp can be provided.\n\n\n        if (item.classes && (typeof item.classes == 'string' || item.classes instanceof RegExp)) {\n          item.classes = [item.classes];\n        }\n\n        this._patterns.push(item);\n      }\n    }\n    /**\n     * Matches elements for currently stored patterns. Returns match information about first found\n     * {@link module:engine/view/element~Element element}, otherwise returns `null`.\n     *\n     * Example of returned object:\n     *\n     *\t\t{\n     *\t\t\telement: <instance of found element>,\n     *\t\t\tpattern: <pattern used to match found element>,\n     *\t\t\tmatch: {\n     *\t\t\t\tname: true,\n     *\t\t\t\tattributes: [ 'title', 'href' ],\n     *\t\t\t\tclasses: [ 'foo' ],\n     *\t\t\t\tstyles: [ 'color', 'position' ]\n     *\t\t\t}\n     *\t\t}\n     *\n     * @see module:engine/view/matcher~Matcher#add\n     * @see module:engine/view/matcher~Matcher#matchAll\n     * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n     * @returns {Object|null} result\n     * @returns {module:engine/view/element~Element} result.element Matched view element.\n     * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.\n     * @returns {Object} result.match Object representing matched element parts.\n     * @returns {Boolean} [result.match.name] True if name of the element was matched.\n     * @returns {Array} [result.match.attributes] Array with matched attribute names.\n     * @returns {Array} [result.match.classes] Array with matched class names.\n     * @returns {Array} [result.match.styles] Array with matched style names.\n     */\n\n  }, {\n    key: \"match\",\n    value: function match() {\n      for (var _len2 = arguments.length, element = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        element[_key2] = arguments[_key2];\n      }\n\n      for (var _i2 = 0, _element = element; _i2 < _element.length; _i2++) {\n        var singleElement = _element[_i2];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this._patterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var pattern = _step.value;\n            var match = isElementMatching(singleElement, pattern);\n\n            if (match) {\n              return {\n                element: singleElement,\n                pattern: pattern,\n                match: match\n              };\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Matches elements for currently stored patterns. Returns array of match information with all found\n     * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.\n     *\n     * @see module:engine/view/matcher~Matcher#add\n     * @see module:engine/view/matcher~Matcher#match\n     * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n     * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information\n     * see {@link module:engine/view/matcher~Matcher#match match method} description.\n     */\n\n  }, {\n    key: \"matchAll\",\n    value: function matchAll() {\n      var results = [];\n\n      for (var _len3 = arguments.length, element = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        element[_key3] = arguments[_key3];\n      }\n\n      for (var _i3 = 0, _element2 = element; _i3 < _element2.length; _i3++) {\n        var singleElement = _element2[_i3];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this._patterns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var pattern = _step2.value;\n            var match = isElementMatching(singleElement, pattern);\n\n            if (match) {\n              results.push({\n                element: singleElement,\n                pattern: pattern,\n                match: match\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      return results.length > 0 ? results : null;\n    }\n    /**\n     * Returns the name of the element to match if there is exactly one pattern added to the matcher instance\n     * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.\n     *\n     * @returns {String|null} Element name trying to match.\n     */\n\n  }, {\n    key: \"getElementName\",\n    value: function getElementName() {\n      if (this._patterns.length !== 1) {\n        return null;\n      }\n\n      var pattern = this._patterns[0];\n      var name = pattern.name;\n      return typeof pattern != 'function' && name && !(name instanceof RegExp) ? name : null;\n    }\n  }]);\n\n  return Matcher;\n}(); // Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.\n// If element cannot be matched to provided pattern - returns `null`.\n//\n// @param {module:engine/view/element~Element} element\n// @param {Object|String|RegExp|Function} pattern\n// @returns {Object|null} Returns object with match information or null if element is not matching.\n\n\nexport { Matcher as default };\n\nfunction isElementMatching(element, pattern) {\n  // If pattern is provided as function - return result of that function;\n  if (typeof pattern == 'function') {\n    return pattern(element);\n  }\n\n  var match = {}; // Check element's name.\n\n  if (pattern.name) {\n    match.name = matchName(pattern.name, element.name);\n\n    if (!match.name) {\n      return null;\n    }\n  } // Check element's attributes.\n\n\n  if (pattern.attributes) {\n    match.attributes = matchAttributes(pattern.attributes, element);\n\n    if (!match.attributes) {\n      return null;\n    }\n  } // Check element's classes.\n\n\n  if (pattern.classes) {\n    match.classes = matchClasses(pattern.classes, element);\n\n    if (!match.classes) {\n      return false;\n    }\n  } // Check element's styles.\n\n\n  if (pattern.styles) {\n    match.styles = matchStyles(pattern.styles, element);\n\n    if (!match.styles) {\n      return false;\n    }\n  }\n\n  return match;\n} // Checks if name can be matched by provided pattern.\n//\n// @param {String|RegExp} pattern\n// @param {String} name\n// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.\n\n\nfunction matchName(pattern, name) {\n  // If pattern is provided as RegExp - test against this regexp.\n  if (pattern instanceof RegExp) {\n    return pattern.test(name);\n  }\n\n  return pattern === name;\n} // Checks if attributes of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about attributes to match. Each key of the object will be\n// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.\n// @param {module:engine/view/element~Element} element Element which attributes will be tested.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\n\n\nfunction matchAttributes(patterns, element) {\n  var match = [];\n\n  for (var name in patterns) {\n    var pattern = patterns[name];\n\n    if (element.hasAttribute(name)) {\n      var attribute = element.getAttribute(name);\n\n      if (pattern === true) {\n        match.push(name);\n      } else if (pattern instanceof RegExp) {\n        if (pattern.test(attribute)) {\n          match.push(name);\n        } else {\n          return null;\n        }\n      } else if (attribute === pattern) {\n        match.push(name);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  return match;\n} // Checks if classes of provided element can be matched against provided patterns.\n//\n// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.\n// @param {module:engine/view/element~Element} element Element which classes will be tested.\n// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.\n\n\nfunction matchClasses(patterns, element) {\n  var match = [];\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = patterns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var pattern = _step3.value;\n\n      if (pattern instanceof RegExp) {\n        var classes = element.getClassNames();\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = classes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var name = _step4.value;\n\n            if (pattern.test(name)) {\n              match.push(name);\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        if (match.length === 0) {\n          return null;\n        }\n      } else if (element.hasClass(pattern)) {\n        match.push(pattern);\n      } else {\n        return null;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return match;\n} // Checks if styles of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about styles to match. Each key of the object will be\n// used as style name. Value of each key can be a string or regular expression to match against style value.\n// @param {module:engine/view/element~Element} element Element which styles will be tested.\n// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.\n\n\nfunction matchStyles(patterns, element) {\n  var match = [];\n\n  for (var name in patterns) {\n    var pattern = patterns[name];\n\n    if (element.hasStyle(name)) {\n      var style = element.getStyle(name);\n\n      if (pattern instanceof RegExp) {\n        if (pattern.test(style)) {\n          match.push(name);\n        } else {\n          return null;\n        }\n      } else if (style === pattern) {\n        match.push(name);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  return match;\n}\n/**\n * An entity that is a valid pattern recognized by a matcher. `MatcherPattern` is used by {@link ~Matcher} to recognize\n * if a view element fits in a group of view elements described by the pattern.\n *\n * `MatcherPattern` can be given as a `String`, a `RegExp`, an `Object` or a `Function`.\n *\n * If `MatcherPattern` is given as a `String` or `RegExp`, it will match any view element that has a matching name:\n *\n *\t\t// Match any element with name equal to 'div'.\n *\t\tconst pattern = 'div';\n *\n *\t\t// Match any element which name starts on 'p'.\n *\t\tconst pattern = /^p/;\n *\n * If `MatcherPattern` is given as an `Object`, all the object's properties will be matched with view element properties.\n *\n *\t\t// Match view element's name.\n *\t\tconst pattern = { name: /^p/ };\n *\n *\t\t// Match view element which has matching attributes.\n *\t\tconst pattern = {\n *\t\t\tattributes: {\n *\t\t\t\ttitle: 'foobar',\t// Attribute title should equal 'foobar'.\n *\t\t\t\tfoo: /^\\w+/,\t\t// Attribute foo should match /^\\w+/ regexp.\n *\t\t\t\tbar: true\t\t\t// Attribute bar should be set (can be empty).\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has given class.\n *\t\tconst pattern = {\n *\t\t\tclasses: 'foobar'\n *\t\t};\n *\n *\t\t// Match view element class using regular expression.\n *\t\tconst pattern = {\n *\t\t\tclasses: /foo.../\n *\t\t};\n *\n *\t\t// Multiple classes to match.\n *\t\tconst pattern = {\n *\t\t\tclasses: [ 'baz', 'bar', /foo.../ ]\n *\t\t};\n *\n *\t\t// Match view element which has given styles.\n *\t\tconst pattern = {\n *\t\t\tstyles: {\n *\t\t\t\tposition: 'absolute',\n *\t\t\t\tcolor: /^\\w*blue$/\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Pattern with multiple properties.\n *\t\tconst pattern = {\n *\t\t\tname: 'span',\n *\t\t\tstyles: {\n *\t\t\t\t'font-weight': 'bold'\n *\t\t\t},\n *\t\t\tclasses: 'highlighted'\n *\t\t};\n *\n * If `MatcherPattern` is given as a `Function`, the function takes a view element as a first and only parameter and\n * the function should decide whether that element matches. If so, it should return what part of the view element has been matched.\n * Otherwise, the function should return `null`. The returned result will be included in `match` property of the object\n * returned by {@link ~Matcher#match} call.\n *\n *\t\t// Match an empty <div> element.\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'div' && element.childCount > 0 ) {\n *\t\t\t\t// Return which part of the element was matched.\n *\t\t\t\treturn { name: true };\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n *\t\t// Match a <p> element with big font (\"heading-like\" element).\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'p' ) {\n *\t\t\t\tconst fontSize = element.getStyle( 'font-size' );\n *\t\t\t\tconst size = fontSize.match( /(\\d+)/px );\n *\n *\t\t\t\tif ( size && Number( size[ 1 ] ) > 26 ) {\n *\t\t\t\t\treturn { name: true, attribute: [ 'font-size' ] };\n *\t\t\t\t}\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n * `MatcherPattern` is defined in a way that it is a superset of {@link module:engine/view/elementdefinition~ElementDefinition},\n * that is, every `ElementDefinition` also can be used as a `MatcherPattern`.\n *\n * @typedef {String|RegExp|Object|Function} module:engine/view/matcher~MatcherPattern\n *\n * @property {String|RegExp} [name] View element name to match.\n * @property {String|RegExp|Array.<String|RegExp>} [classes] View element's class name(s) to match.\n * @property {Object} [styles] Object with key-value pairs representing styles to match.\n * Each object key represents style name. Value can be given as `String` or `RegExp`.\n * @property {Object} [attributes] Object with key-value pairs representing attributes to match.\n * Each object key represents attribute name. Value can be given as `String` or `RegExp`.\n */","import \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.regexp.match\";\nimport _construct from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/construct\";\nimport _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"regenerator-runtime/runtime\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.map\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/element\n */\nimport Node from \"./node\";\nimport Text from \"./text\";\nimport TextProxy from \"./textproxy\";\nimport objectToMap from '@ckeditor/ckeditor5-utils/src/objecttomap';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Matcher from \"./matcher\";\nimport { isPlainObject } from 'lodash-es';\n/**\n * View element.\n *\n * The editing engine does not define a fixed semantics of its elements (it is \"DTD-free\").\n * This is why the type of the {@link module:engine/view/element~Element} need to\n * be defined by the feature developer. When creating an element you should use one of the following methods:\n *\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement `downcastWriter#createContainerElement()`}\n * in order to create a {@link module:engine/view/containerelement~ContainerElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement `downcastWriter#createAttributeElement()`}\n * in order to create a {@link module:engine/view/attributeelement~AttributeElement},\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement `downcastWriter#createEmptyElement()`}\n * in order to create a {@link module:engine/view/emptyelement~EmptyElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}\n * in order to create a {@link module:engine/view/uielement~UIElement}.\n * * {@link module:engine/view/downcastwriter~DowncastWriter#createEditableElement `downcastWriter#createEditableElement()`}\n * in order to create a {@link module:engine/view/editableelement~EditableElement}.\n *\n * Note that for view elements which are not created from the model, like elements from mutations, paste or\n * {@link module:engine/controller/datacontroller~DataController#set data.set} it is not possible to define the type of the element.\n * In such cases the {@link module:engine/view/upcastwriter~UpcastWriter#createElement `UpcastWriter#createElement()`} method\n * should be used to create generic view elements.\n *\n * @extends module:engine/view/node~Node\n */\n\nvar Element =\n/*#__PURE__*/\nfunction (_Node) {\n  _inherits(Element, _Node);\n\n  /**\n   * Creates a view element.\n   *\n   * Attributes can be passed in various formats:\n   *\n   *\t\tnew Element( 'div', { class: 'editor', contentEditable: 'true' } ); // object\n   *\t\tnew Element( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator\n   *\t\tnew Element( 'div', mapOfAttributes ); // map\n   *\n   * @protected\n   * @param {String} name Node name.\n   * @param {Object|Iterable} [attrs] Collection of attributes.\n   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n   * A list of nodes to be inserted into created element.\n   */\n  function Element(name, attrs, children) {\n    var _this;\n\n    _classCallCheck(this, Element);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this));\n    /**\n     * Name of the element.\n     *\n     * @readonly\n     * @member {String}\n     */\n\n    _this.name = name;\n    /**\n     * Map of attributes, where attributes names are keys and attributes values are values.\n     *\n     * @protected\n     * @member {Map} #_attrs\n     */\n\n    _this._attrs = parseAttributes(attrs);\n    /**\n     * Array of child nodes.\n     *\n     * @protected\n     * @member {Array.<module:engine/view/node~Node>}\n     */\n\n    _this._children = [];\n\n    if (children) {\n      _this._insertChild(0, children);\n    }\n    /**\n     * Set of classes associated with element instance.\n     *\n     * @protected\n     * @member {Set}\n     */\n\n\n    _this._classes = new Set();\n\n    if (_this._attrs.has('class')) {\n      // Remove class attribute and handle it by class set.\n      var classString = _this._attrs.get('class');\n\n      parseClasses(_this._classes, classString);\n\n      _this._attrs.delete('class');\n    }\n    /**\n     * Map of styles.\n     *\n     * @protected\n     * @member {Map} module:engine/view/element~Element#_styles\n     */\n\n\n    _this._styles = new Map();\n\n    if (_this._attrs.has('style')) {\n      // Remove style attribute and handle it by styles map.\n      parseInlineStyles(_this._styles, _this._attrs.get('style'));\n\n      _this._attrs.delete('style');\n    }\n    /**\n     * Map of custom properties.\n     * Custom properties can be added to element instance, will be cloned but not rendered into DOM.\n     *\n     * @protected\n     * @member {Map}\n     */\n\n\n    _this._customProperties = new Map();\n    return _this;\n  }\n  /**\n   * Number of element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  _createClass(Element, [{\n    key: \"is\",\n\n    /**\n     * Checks whether this view object is of the given type.\n     *\n     *\t\tobj.is( 'element' ); // true\n     *\t\tobj.is( 'li' ); // true\n     *\t\tobj.is( 'element', 'li' ); // true\n     *\t\tobj.is( 'text' ); // false\n     *\t\tobj.is( 'element', 'img' ); // false\n     *\n     * Read more in {@link module:engine/view/node~Node#is `Node#is()`}.\n     *\n     * @param {String} type\n     * @param {String} [name] Element name.\n     * @returns {Boolean}\n     */\n    value: function is(type) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!name) {\n        return type == 'element' || type == this.name || _get(_getPrototypeOf(Element.prototype), \"is\", this).call(this, type);\n      } else {\n        return type == 'element' && name == this.name;\n      }\n    }\n    /**\n     * Gets child at the given index.\n     *\n     * @param {Number} index Index of child.\n     * @returns {module:engine/view/node~Node} Child node.\n     */\n\n  }, {\n    key: \"getChild\",\n    value: function getChild(index) {\n      return this._children[index];\n    }\n    /**\n     * Gets index of the given child node. Returns `-1` if child node is not found.\n     *\n     * @param {module:engine/view/node~Node} node Child node.\n     * @returns {Number} Index of the child node.\n     */\n\n  }, {\n    key: \"getChildIndex\",\n    value: function getChildIndex(node) {\n      return this._children.indexOf(node);\n    }\n    /**\n     * Gets child nodes iterator.\n     *\n     * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this._children[Symbol.iterator]();\n    }\n    /**\n     * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.\n     *\n     * @returns {Iterable.<String>} Keys for attributes.\n     */\n\n  }, {\n    key: \"getAttributeKeys\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function getAttributeKeys() {\n      return regeneratorRuntime.wrap(function getAttributeKeys$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this._classes.size > 0)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return 'class';\n\n            case 3:\n              if (!(this._styles.size > 0)) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 6;\n              return 'style';\n\n            case 6:\n              return _context.delegateYield(this._attrs.keys(), \"t0\", 7);\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, getAttributeKeys, this);\n    })\n    /**\n     * Returns iterator that iterates over this element's attributes.\n     *\n     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n     *\n     * @returns {Iterable.<*>}\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function getAttributes() {\n      return regeneratorRuntime.wrap(function getAttributes$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.delegateYield(this._attrs.entries(), \"t0\", 1);\n\n            case 1:\n              if (!(this._classes.size > 0)) {\n                _context2.next = 4;\n                break;\n              }\n\n              _context2.next = 4;\n              return ['class', this.getAttribute('class')];\n\n            case 4:\n              if (!(this._styles.size > 0)) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 7;\n              return ['style', this.getAttribute('style')];\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, getAttributes, this);\n    })\n    /**\n     * Gets attribute by key. If attribute is not present - returns undefined.\n     *\n     * @param {String} key Attribute key.\n     * @returns {String|undefined} Attribute value.\n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      if (key == 'class') {\n        if (this._classes.size > 0) {\n          return _toConsumableArray(this._classes).join(' ');\n        }\n\n        return undefined;\n      }\n\n      if (key == 'style') {\n        if (this._styles.size > 0) {\n          var styleString = '';\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = this._styles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                  property = _step$value[0],\n                  value = _step$value[1];\n\n              styleString += \"\".concat(property, \":\").concat(value, \";\");\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          return styleString;\n        }\n\n        return undefined;\n      }\n\n      return this._attrs.get(key);\n    }\n    /**\n     * Returns a boolean indicating whether an attribute with the specified key exists in the element.\n     *\n     * @param {String} key Attribute key.\n     * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.\n     */\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      if (key == 'class') {\n        return this._classes.size > 0;\n      }\n\n      if (key == 'style') {\n        return this._styles.size > 0;\n      }\n\n      return this._attrs.has(key);\n    }\n    /**\n     * Checks if this element is similar to other element.\n     * Both elements should have the same name and attributes to be considered as similar. Two similar elements\n     * can contain different set of children nodes.\n     *\n     * @param {module:engine/view/element~Element} otherElement\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSimilar\",\n    value: function isSimilar(otherElement) {\n      if (!(otherElement instanceof Element)) {\n        return false;\n      } // If exactly the same Element is provided - return true immediately.\n\n\n      if (this === otherElement) {\n        return true;\n      } // Check element name.\n\n\n      if (this.name != otherElement.name) {\n        return false;\n      } // Check number of attributes, classes and styles.\n\n\n      if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {\n        return false;\n      } // Check if attributes are the same.\n\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._attrs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              key = _step2$value[0],\n              value = _step2$value[1];\n\n          if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {\n            return false;\n          }\n        } // Check if classes are the same.\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this._classes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var className = _step3.value;\n\n          if (!otherElement._classes.has(className)) {\n            return false;\n          }\n        } // Check if styles are the same.\n\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this._styles[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              property = _step4$value[0],\n              value = _step4$value[1];\n\n          if (!otherElement._styles.has(property) || otherElement._styles.get(property) !== value) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Returns true if class is present.\n     * If more then one class is provided - returns true only when all classes are present.\n     *\n     *\t\telement.hasClass( 'foo' ); // Returns true if 'foo' class is present.\n     *\t\telement.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.\n     *\n     * @param {...String} className\n     */\n\n  }, {\n    key: \"hasClass\",\n    value: function hasClass() {\n      for (var _len = arguments.length, className = new Array(_len), _key = 0; _key < _len; _key++) {\n        className[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _className = className; _i < _className.length; _i++) {\n        var name = _className[_i];\n\n        if (!this._classes.has(name)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Returns iterator that contains all class names.\n     *\n     * @returns {Iterable.<String>}\n     */\n\n  }, {\n    key: \"getClassNames\",\n    value: function getClassNames() {\n      return this._classes.keys();\n    }\n    /**\n     * Returns style value for given property.\n     * Undefined is returned if style does not exist.\n     *\n     * @param {String} property\n     * @returns {String|undefined}\n     */\n\n  }, {\n    key: \"getStyle\",\n    value: function getStyle(property) {\n      return this._styles.get(property);\n    }\n    /**\n     * Returns iterator that contains all style names.\n     *\n     * @returns {Iterable.<String>}\n     */\n\n  }, {\n    key: \"getStyleNames\",\n    value: function getStyleNames() {\n      return this._styles.keys();\n    }\n    /**\n     * Returns true if style keys are present.\n     * If more then one style property is provided - returns true only when all properties are present.\n     *\n     *\t\telement.hasStyle( 'color' ); // Returns true if 'border-top' style is present.\n     *\t\telement.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.\n     *\n     * @param {...String} property\n     */\n\n  }, {\n    key: \"hasStyle\",\n    value: function hasStyle() {\n      for (var _len2 = arguments.length, property = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        property[_key2] = arguments[_key2];\n      }\n\n      for (var _i2 = 0, _property = property; _i2 < _property.length; _i2++) {\n        var name = _property[_i2];\n\n        if (!this._styles.has(name)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Returns ancestor element that match specified pattern.\n     * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.\n     *\n     * @see module:engine/view/matcher~Matcher\n     * @param {Object|String|RegExp|Function} patterns Patterns used to match correct ancestor.\n     * See {@link module:engine/view/matcher~Matcher}.\n     * @returns {module:engine/view/element~Element|null} Found element or `null` if no matching ancestor was found.\n     */\n\n  }, {\n    key: \"findAncestor\",\n    value: function findAncestor() {\n      for (var _len3 = arguments.length, patterns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        patterns[_key3] = arguments[_key3];\n      }\n\n      var matcher = _construct(Matcher, patterns);\n\n      var parent = this.parent;\n\n      while (parent) {\n        if (matcher.match(parent)) {\n          return parent;\n        }\n\n        parent = parent.parent;\n      }\n\n      return null;\n    }\n    /**\n     * Returns the custom property value for the given key.\n     *\n     * @param {String|Symbol} key\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getCustomProperty\",\n    value: function getCustomProperty(key) {\n      return this._customProperties.get(key);\n    }\n    /**\n     * Returns an iterator which iterates over this element's custom properties.\n     * Iterator provides `[ key, value ]` pairs for each stored property.\n     *\n     * @returns {Iterable.<*>}\n     */\n\n  }, {\n    key: \"getCustomProperties\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function getCustomProperties() {\n      return regeneratorRuntime.wrap(function getCustomProperties$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.delegateYield(this._customProperties.entries(), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, getCustomProperties, this);\n    })\n    /**\n     * Returns identity string based on element's name, styles, classes and other attributes.\n     * Two elements that {@link #isSimilar are similar} will have same identity string.\n     * It has the following format:\n     *\n     *\t\t'name class=\"class1,class2\" style=\"style1:value1;style2:value2\" attr1=\"val1\" attr2=\"val2\"'\n    \t *\n     * For example:\n     *\n     *\t\tconst element = writer.createContainerElement( 'foo', {\n     *\t\t\tbanana: '10',\n     *\t\t\tapple: '20',\n     *\t\t\tstyle: 'color: red; border-color: white;',\n     *\t\t\tclass: 'baz'\n     *\t\t} );\n     *\n     *\t\t// returns 'foo class=\"baz\" style=\"border-color:white;color:red\" apple=\"20\" banana=\"10\"'\n     *\t\telement.getIdentity();\n     *\n     * NOTE: Classes, styles and other attributes are sorted alphabetically.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getIdentity\",\n    value: function getIdentity() {\n      var classes = Array.from(this._classes).sort().join(',');\n      var styles = Array.from(this._styles).map(function (i) {\n        return \"\".concat(i[0], \":\").concat(i[1]);\n      }).sort().join(';');\n      var attributes = Array.from(this._attrs).map(function (i) {\n        return \"\".concat(i[0], \"=\\\"\").concat(i[1], \"\\\"\");\n      }).sort().join(' ');\n      return this.name + (classes == '' ? '' : \" class=\\\"\".concat(classes, \"\\\"\")) + (styles == '' ? '' : \" style=\\\"\".concat(styles, \"\\\"\")) + (attributes == '' ? '' : \" \".concat(attributes));\n    }\n    /**\n     * Clones provided element.\n     *\n     * @protected\n     * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n     * element will be cloned without any children.\n     * @returns {module:engine/view/element~Element} Clone of this element.\n     */\n\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var childrenClone = [];\n\n      if (deep) {\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = this.getChildren()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var child = _step5.value;\n            childrenClone.push(child._clone(deep));\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      } // ContainerElement and AttributeElement should be also cloned properly.\n\n\n      var cloned = new this.constructor(this.name, this._attrs, childrenClone); // Classes and styles are cloned separately - this solution is faster than adding them back to attributes and\n      // parse once again in constructor.\n\n      cloned._classes = new Set(this._classes);\n      cloned._styles = new Map(this._styles); // Clone custom properties.\n\n      cloned._customProperties = new Map(this._customProperties); // Clone filler offset method.\n      // We can't define this method in a prototype because it's behavior which\n      // is changed by e.g. toWidget() function from ckeditor5-widget. Perhaps this should be one of custom props.\n\n      cloned.getFillerOffset = this.getFillerOffset;\n      return cloned;\n    }\n    /**\n     * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node\n     * and sets the parent of these nodes to this element.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#insert\n     * @protected\n     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n     * @fires module:engine/view/node~Node#change\n     * @returns {Number} Number of appended nodes.\n     */\n\n  }, {\n    key: \"_appendChild\",\n    value: function _appendChild(items) {\n      return this._insertChild(this.childCount, items);\n    }\n    /**\n     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n     * this element.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#insert\n     * @protected\n     * @param {Number} index Position where nodes should be inserted.\n     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n     * @fires module:engine/view/node~Node#change\n     * @returns {Number} Number of inserted nodes.\n     */\n\n  }, {\n    key: \"_insertChild\",\n    value: function _insertChild(index, items) {\n      this._fireChange('children', this);\n\n      var count = 0;\n      var nodes = normalize(items);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = nodes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var node = _step6.value;\n\n          // If node that is being added to this element is already inside another element, first remove it from the old parent.\n          if (node.parent !== null) {\n            node._remove();\n          }\n\n          node.parent = this;\n\n          this._children.splice(index, 0, node);\n\n          index++;\n          count++;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return count;\n    }\n    /**\n     * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#remove\n     * @protected\n     * @param {Number} index Number of the first node to remove.\n     * @param {Number} [howMany=1] Number of nodes to remove.\n     * @fires module:engine/view/node~Node#change\n     * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n     */\n\n  }, {\n    key: \"_removeChildren\",\n    value: function _removeChildren(index) {\n      var howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      this._fireChange('children', this);\n\n      for (var i = index; i < index + howMany; i++) {\n        this._children[i].parent = null;\n      }\n\n      return this._children.splice(index, howMany);\n    }\n    /**\n     * Adds or overwrite attribute with a specified key and value.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute\n     * @protected\n     * @param {String} key Attribute key.\n     * @param {String} value Attribute value.\n     * @fires module:engine/view/node~Node#change\n     */\n\n  }, {\n    key: \"_setAttribute\",\n    value: function _setAttribute(key, value) {\n      value = String(value);\n\n      this._fireChange('attributes', this);\n\n      if (key == 'class') {\n        parseClasses(this._classes, value);\n      } else if (key == 'style') {\n        parseInlineStyles(this._styles, value);\n      } else {\n        this._attrs.set(key, value);\n      }\n    }\n    /**\n     * Removes attribute from the element.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute\n     * @protected\n     * @param {String} key Attribute key.\n     * @returns {Boolean} Returns true if an attribute existed and has been removed.\n     * @fires module:engine/view/node~Node#change\n     */\n\n  }, {\n    key: \"_removeAttribute\",\n    value: function _removeAttribute(key) {\n      this._fireChange('attributes', this); // Remove class attribute.\n\n\n      if (key == 'class') {\n        if (this._classes.size > 0) {\n          this._classes.clear();\n\n          return true;\n        }\n\n        return false;\n      } // Remove style attribute.\n\n\n      if (key == 'style') {\n        if (this._styles.size > 0) {\n          this._styles.clear();\n\n          return true;\n        }\n\n        return false;\n      } // Remove other attributes.\n\n\n      return this._attrs.delete(key);\n    }\n    /**\n     * Adds specified class.\n     *\n     *\t\telement._addClass( 'foo' ); // Adds 'foo' class.\n     *\t\telement._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#addClass\n     * @protected\n     * @param {Array.<String>|String} className\n     * @fires module:engine/view/node~Node#change\n     */\n\n  }, {\n    key: \"_addClass\",\n    value: function _addClass(className) {\n      var _this2 = this;\n\n      this._fireChange('attributes', this);\n\n      className = Array.isArray(className) ? className : [className];\n      className.forEach(function (name) {\n        return _this2._classes.add(name);\n      });\n    }\n    /**\n     * Removes specified class.\n     *\n     *\t\telement._removeClass( 'foo' );  // Removes 'foo' class.\n     *\t\telement._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#removeClass\n     * @protected\n     * @param {Array.<String>|String} className\n     * @fires module:engine/view/node~Node#change\n     */\n\n  }, {\n    key: \"_removeClass\",\n    value: function _removeClass(className) {\n      var _this3 = this;\n\n      this._fireChange('attributes', this);\n\n      className = Array.isArray(className) ? className : [className];\n      className.forEach(function (name) {\n        return _this3._classes.delete(name);\n      });\n    }\n    /**\n     * Adds style to the element.\n     *\n     *\t\telement._setStyle( 'color', 'red' );\n     *\t\telement._setStyle( {\n     *\t\t\tcolor: 'red',\n     *\t\t\tposition: 'fixed'\n     *\t\t} );\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#setStyle\n     * @protected\n     * @param {String|Object} property Property name or object with key - value pairs.\n     * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n     * @fires module:engine/view/node~Node#change\n     */\n\n  }, {\n    key: \"_setStyle\",\n    value: function _setStyle(property, value) {\n      this._fireChange('attributes', this);\n\n      if (isPlainObject(property)) {\n        var keys = Object.keys(property);\n\n        for (var _i3 = 0, _keys = keys; _i3 < _keys.length; _i3++) {\n          var key = _keys[_i3];\n\n          this._styles.set(key, property[key]);\n        }\n      } else {\n        this._styles.set(property, value);\n      }\n    }\n    /**\n     * Removes specified style.\n     *\n     *\t\telement._removeStyle( 'color' );  // Removes 'color' style.\n     *\t\telement._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle\n     * @protected\n     * @param {Array.<String>|String} property\n     * @fires module:engine/view/node~Node#change\n     */\n\n  }, {\n    key: \"_removeStyle\",\n    value: function _removeStyle(property) {\n      var _this4 = this;\n\n      this._fireChange('attributes', this);\n\n      property = Array.isArray(property) ? property : [property];\n      property.forEach(function (name) {\n        return _this4._styles.delete(name);\n      });\n    }\n    /**\n     * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,\n     * so they can be used to add special data to elements.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty\n     * @protected\n     * @param {String|Symbol} key\n     * @param {*} value\n     */\n\n  }, {\n    key: \"_setCustomProperty\",\n    value: function _setCustomProperty(key, value) {\n      this._customProperties.set(key, value);\n    }\n    /**\n     * Removes the custom property stored under the given key.\n     *\n     * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty\n     * @protected\n     * @param {String|Symbol} key\n     * @returns {Boolean} Returns true if property was removed.\n     */\n\n  }, {\n    key: \"_removeCustomProperty\",\n    value: function _removeCustomProperty(key) {\n      return this._customProperties.delete(key);\n    }\n    /**\n     * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n     *\n     * @abstract\n     * @method module:engine/view/element~Element#getFillerOffset\n     */\n\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this._children.length;\n    }\n    /**\n     * Is `true` if there are no nodes inside this element, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._children.length === 0;\n    }\n  }]);\n\n  return Element;\n}(Node); // Parses attributes provided to the element constructor before they are applied to an element. If attributes are passed\n// as an object (instead of `Map`), the object is transformed to the map. Attributes with `null` value are removed.\n// Attributes with non-`String` value are converted to `String`.\n//\n// @param {Object|Map} attrs Attributes to parse.\n// @returns {Map} Parsed attributes.\n\n\nexport { Element as default };\n\nfunction parseAttributes(attrs) {\n  if (isPlainObject(attrs)) {\n    attrs = objectToMap(attrs);\n  } else {\n    attrs = new Map(attrs);\n  }\n\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = attrs[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var _step7$value = _slicedToArray(_step7.value, 2),\n          key = _step7$value[0],\n          value = _step7$value[1];\n\n      if (value === null) {\n        attrs.delete(key);\n      } else if (typeof value != 'string') {\n        attrs.set(key, String(value));\n      }\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n\n  return attrs;\n} // Parses inline styles and puts property - value pairs into styles map.\n// Styles map is cleared before insertion.\n//\n// @param {Map.<String, String>} stylesMap Map to insert parsed properties and values.\n// @param {String} stylesString Styles to parse.\n\n\nfunction parseInlineStyles(stylesMap, stylesString) {\n  // `null` if no quote was found in input string or last found quote was a closing quote. See below.\n  var quoteType = null;\n  var propertyNameStart = 0;\n  var propertyValueStart = 0;\n  var propertyName = null;\n  stylesMap.clear(); // Do not set anything if input string is empty.\n\n  if (stylesString === '') {\n    return;\n  } // Fix inline styles that do not end with `;` so they are compatible with algorithm below.\n\n\n  if (stylesString.charAt(stylesString.length - 1) != ';') {\n    stylesString = stylesString + ';';\n  } // Seek the whole string for \"special characters\".\n\n\n  for (var i = 0; i < stylesString.length; i++) {\n    var char = stylesString.charAt(i);\n\n    if (quoteType === null) {\n      // No quote found yet or last found quote was a closing quote.\n      switch (char) {\n        case ':':\n          // Most of time colon means that property name just ended.\n          // Sometimes however `:` is found inside property value (for example in background image url).\n          if (!propertyName) {\n            // Treat this as end of property only if property name is not already saved.\n            // Save property name.\n            propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart); // Save this point as the start of property value.\n\n            propertyValueStart = i + 1;\n          }\n\n          break;\n\n        case '\"':\n        case '\\'':\n          // Opening quote found (this is an opening quote, because `quoteType` is `null`).\n          quoteType = char;\n          break;\n\n        case ';':\n          {\n            // Property value just ended.\n            // Use previously stored property value start to obtain property value.\n            var propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);\n\n            if (propertyName) {\n              // Save parsed part.\n              stylesMap.set(propertyName.trim(), propertyValue.trim());\n            }\n\n            propertyName = null; // Save this point as property name start. Property name starts immediately after previous property value ends.\n\n            propertyNameStart = i + 1;\n            break;\n          }\n      }\n    } else if (char === quoteType) {\n      // If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.\n      quoteType = null;\n    }\n  }\n} // Parses class attribute and puts all classes into classes set.\n// Classes set s cleared before insertion.\n//\n// @param {Set.<String>} classesSet Set to insert parsed classes.\n// @param {String} classesString String with classes to parse.\n\n\nfunction parseClasses(classesSet, classesString) {\n  var classArray = classesString.split(/\\s+/);\n  classesSet.clear();\n  classArray.forEach(function (name) {\n    return classesSet.add(name);\n  });\n} // Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\n\n\nfunction normalize(nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(nodes)];\n  }\n\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  } // Array.from to enable .map() on non-arrays.\n\n\n  return Array.from(nodes).map(function (node) {\n    if (typeof node == 'string') {\n      return new Text(node);\n    }\n\n    if (node instanceof TextProxy) {\n      return new Text(node.data);\n    }\n\n    return node;\n  });\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/containerelement\n */\nimport Element from \"./element\";\n/**\n * Containers are elements which define document structure. They define boundaries for\n * {@link module:engine/view/attributeelement~AttributeElement attributes}. They are mostly used for block elements like `<p>` or `<div>`.\n *\n * Editing engine does not define a fixed HTML DTD. This is why a feature developer needs to choose between various\n * types (container element, {@link module:engine/view/attributeelement~AttributeElement attribute element},\n * {@link module:engine/view/emptyelement~EmptyElement empty element}, etc) when developing a feature.\n *\n * The container element should be your default choice when writing a converter, unless:\n *\n * * this element represents a model text attribute (then use {@link module:engine/view/attributeelement~AttributeElement}),\n * * this is an empty element like `<img>` (then use {@link module:engine/view/emptyelement~EmptyElement}),\n * * this is a root element,\n * * this is a nested editable element (then use  {@link module:engine/view/editableelement~EditableElement}).\n *\n * To create a new container element instance use the\n * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement `DowncastWriter#createContainerElement()`}\n * method.\n *\n * @extends module:engine/view/element~Element\n */\n\nvar ContainerElement =\n/*#__PURE__*/\nfunction (_Element) {\n  _inherits(ContainerElement, _Element);\n\n  /**\n   * Creates a container element.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#createContainerElement\n   * @see module:engine/view/element~Element\n   * @protected\n   */\n  function ContainerElement(name, attrs, children) {\n    var _this;\n\n    _classCallCheck(this, ContainerElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ContainerElement).call(this, name, attrs, children));\n    /**\n     * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n     *\n     * @method #getFillerOffset\n     * @returns {Number|null} Block filler offset or `null` if block filler is not needed.\n     */\n\n    _this.getFillerOffset = getFillerOffset;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(ContainerElement, [{\n    key: \"is\",\n    value: function is(type) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!name) {\n        return type == 'containerElement' || _get(_getPrototypeOf(ContainerElement.prototype), \"is\", this).call(this, type);\n      } else {\n        return type == 'containerElement' && name == this.name || _get(_getPrototypeOf(ContainerElement.prototype), \"is\", this).call(this, type, name);\n      }\n    }\n  }]);\n\n  return ContainerElement;\n}(Element);\n/**\n * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n *\n * @returns {Number|null} Block filler offset or `null` if block filler is not needed.\n */\n\n\nexport { ContainerElement as default };\nexport function getFillerOffset() {\n  var children = _toConsumableArray(this.getChildren());\n\n  var lastChild = children[this.childCount - 1]; // Block filler is required after a `<br>` if it's the last element in its container. See #1422.\n\n  if (lastChild && lastChild.is('element', 'br')) {\n    return this.childCount;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var child = _step.value;\n\n      // If there's any non-UI element  don't render the bogus.\n      if (!child.is('uiElement')) {\n        return null;\n      }\n    } // If there are only UI elements  render the bogus at the end of the element.\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return this.childCount;\n}","import \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/editableelement\n */\nimport ContainerElement from \"./containerelement\";\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nvar documentSymbol = Symbol('document');\n/**\n * Editable element which can be a {@link module:engine/view/rooteditableelement~RootEditableElement root}\n * or nested editable area in the editor.\n *\n * Editable is automatically read-only when its {@link module:engine/view/document~Document Document} is read-only.\n *\n * The constructor of this class shouldn't be used directly. To create new `EditableElement` use the\n * {@link module:engine/view/downcastwriter~DowncastWriter#createEditableElement `downcastWriter#createEditableElement()`} method.\n *\n * @extends module:engine/view/containerelement~ContainerElement\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar EditableElement =\n/*#__PURE__*/\nfunction (_ContainerElement) {\n  _inherits(EditableElement, _ContainerElement);\n\n  /**\n   * Creates an editable element.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement\n   * @protected\n   */\n  function EditableElement(name, attrs, children) {\n    var _this;\n\n    _classCallCheck(this, EditableElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EditableElement).call(this, name, attrs, children));\n    /**\n     * Whether the editable is in read-write or read-only mode.\n     *\n     * @observable\n     * @member {Boolean} module:engine/view/editableelement~EditableElement#isReadOnly\n     */\n\n    _this.set('isReadOnly', false);\n    /**\n     * Whether the editable is focused.\n     *\n     * This property updates when {@link module:engine/view/document~Document#isFocused document.isFocused} or view\n     * selection is changed.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/editableelement~EditableElement#isFocused\n     */\n\n\n    _this.set('isFocused', false);\n    /**\n     * The {@link module:engine/view/document~Document} which is an owner of this root.\n     * Can only by set once.\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-editableelement-document-already-set`\n     * when document is already set.\n     *\n     * @member {module:engine/view/document~Document} #document\n     */\n\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(EditableElement, [{\n    key: \"is\",\n    value: function is(type) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!name) {\n        return type == 'editableElement' || _get(_getPrototypeOf(EditableElement.prototype), \"is\", this).call(this, type);\n      } else {\n        return type == 'editableElement' && name == this.name || _get(_getPrototypeOf(EditableElement.prototype), \"is\", this).call(this, type, name);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stopListening();\n    }\n    /**\n     * Returns document associated with the editable.\n     *\n     * @readonly\n     * @returns {module:engine/view/document~Document}\n     */\n\n  }, {\n    key: \"document\",\n    get: function get() {\n      return this.getCustomProperty(documentSymbol);\n    }\n    /**\n     * Sets document of this editable element.\n     *\n     * @protected\n     * @param {module:engine/view/document~Document} document\n     */\n\n  }, {\n    key: \"_document\",\n    set: function set(document) {\n      var _this2 = this;\n\n      if (this.getCustomProperty(documentSymbol)) {\n        /**\n         * View document is already set. It can only be set once.\n         *\n         * @error view-editableelement-document-already-set\n         */\n        throw new CKEditorError('view-editableelement-document-already-set: View document is already set.');\n      }\n\n      this._setCustomProperty(documentSymbol, document);\n\n      this.bind('isReadOnly').to(document);\n      this.bind('isFocused').to(document, 'isFocused', function (isFocused) {\n        return isFocused && document.selection.editableElement == _this2;\n      }); // Update focus state based on selection changes.\n\n      this.listenTo(document.selection, 'change', function () {\n        _this2.isFocused = document.isFocused && document.selection.editableElement == _this2;\n      });\n    }\n  }]);\n\n  return EditableElement;\n}(ContainerElement);\n\nexport { EditableElement as default };\nmix(EditableElement, ObservableMixin);","import \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/rooteditableelement\n */\nimport EditableElement from \"./editableelement\";\nvar rootNameSymbol = Symbol('rootName');\n/**\n * Class representing a single root in the data view. A root can be either {@link ~RootEditableElement#isReadOnly editable or read-only},\n * but in both cases it is called \"an editable\". Roots can contain other {@link module:engine/view/editableelement~EditableElement\n * editable elements} making them \"nested editables\".\n *\n * @extends module:engine/view/editableelement~EditableElement\n */\n\nvar RootEditableElement =\n/*#__PURE__*/\nfunction (_EditableElement) {\n  _inherits(RootEditableElement, _EditableElement);\n\n  /**\n   * Creates root editable element.\n   *\n   * @param {String} name Node name.\n   */\n  function RootEditableElement(name) {\n    var _this;\n\n    _classCallCheck(this, RootEditableElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RootEditableElement).call(this, name));\n    /**\n     * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no\n     * other name is set, `main` name is used.\n     *\n     * @readonly\n     * @member {String}\n     */\n\n    _this.rootName = 'main';\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(RootEditableElement, [{\n    key: \"is\",\n    value: function is(type) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!name) {\n        return type == 'rootElement' || _get(_getPrototypeOf(RootEditableElement.prototype), \"is\", this).call(this, type);\n      } else {\n        return type == 'rootElement' && name == this.name || _get(_getPrototypeOf(RootEditableElement.prototype), \"is\", this).call(this, type, name);\n      }\n    }\n  }, {\n    key: \"rootName\",\n    get: function get() {\n      return this.getCustomProperty(rootNameSymbol);\n    },\n    set: function set(rootName) {\n      this._setCustomProperty(rootNameSymbol, rootName);\n    }\n    /**\n     * Overrides old element name and sets new one.\n     * This is needed because view roots are created before they are attached to the DOM.\n     * The name of the root element is temporary at this stage. It has to be changed when the\n     * view root element is attached to the DOM element.\n     *\n     * @protected\n     * @param {String} name The new name of element.\n     */\n\n  }, {\n    key: \"_name\",\n    set: function set(name) {\n      this.name = name;\n    }\n  }]);\n\n  return RootEditableElement;\n}(EditableElement);\n\nexport { RootEditableElement as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/count\n */\n\n/**\n * Returns the number of items return by the iterator.\n *\n *\t\tcount( [ 1, 2, 3, 4, 5 ] ); // 5;\n *\n * @param {Iterable.<*>} iterator Any iterator.\n * @returns {Number} Number of items returned by that iterator.\n */\nexport default function count(iterator) {\n  var count = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = iterator[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ = _step.value;\n      // eslint-disable-line no-unused-vars\n      count++;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return count;\n}","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.string.anchor\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"regenerator-runtime/runtime\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/selection\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Range from \"./range\";\nimport Position from \"./position\";\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport Node from \"./node\";\nimport Element from \"./element\";\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport DocumentSelection from \"./documentselection\";\n/**\n * Class representing an arbirtary selection in the view.\n * See also {@link module:engine/view/documentselection~DocumentSelection}.\n *\n * New selection instances can be created via the constructor or one these methods:\n *\n * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n *\n * A selection can consist of {@link module:engine/view/range~Range ranges} that can be set by using\n * the {@link module:engine/view/selection~Selection#setTo `Selection#setTo()`} method.\n */\n\nvar Selection =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates new selection instance.\n   *\n   * **Note**: The selection constructor is available as a factory method:\n   *\n   * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},\n   * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.\n   *\n   * \t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the document selection.\n   *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n   *\n   * \t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * (and be  properly handled by screen readers).\n   *\n   *\t\t// Creates fake selection with label.\n   *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} [selectable=null]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n  function Selection() {\n    var selectable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var placeOrOffset = arguments.length > 1 ? arguments[1] : undefined;\n    var options = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, Selection);\n\n    /**\n     * Stores all ranges that are selected.\n     *\n     * @protected\n     * @member {Array.<module:engine/view/range~Range>}\n     */\n    this._ranges = [];\n    /**\n     * Specifies whether the last added range was added as a backward or forward range.\n     *\n     * @protected\n     * @member {Boolean}\n     */\n\n    this._lastRangeBackward = false;\n    /**\n     * Specifies whether selection instance is fake.\n     *\n     * @private\n     * @member {Boolean}\n     */\n\n    this._isFake = false;\n    /**\n     * Fake selection's label.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._fakeSelectionLabel = '';\n    this.setTo(selectable, placeOrOffset, options);\n  }\n  /**\n   * Returns true if selection instance is marked as `fake`.\n   *\n   * @see #setTo\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getRanges\",\n\n    /**\n     * Returns an iterable that contains copies of all ranges added to the selection.\n     *\n     * @returns {Iterable.<module:engine/view/range~Range>}\n     */\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function getRanges() {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, range;\n\n      return regeneratorRuntime.wrap(function getRanges$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 3;\n              _iterator = this._ranges[Symbol.iterator]();\n\n            case 5:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 12;\n                break;\n              }\n\n              range = _step.value;\n              _context.next = 9;\n              return range.clone();\n\n            case 9:\n              _iteratorNormalCompletion = true;\n              _context.next = 5;\n              break;\n\n            case 12:\n              _context.next = 18;\n              break;\n\n            case 14:\n              _context.prev = 14;\n              _context.t0 = _context[\"catch\"](3);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 18:\n              _context.prev = 18;\n              _context.prev = 19;\n\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n\n            case 21:\n              _context.prev = 21;\n\n              if (!_didIteratorError) {\n                _context.next = 24;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 24:\n              return _context.finish(21);\n\n            case 25:\n              return _context.finish(18);\n\n            case 26:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, getRanges, this, [[3, 14, 18, 26], [19,, 21, 25]]);\n    })\n    /**\n     * Returns copy of the first range in the selection. First range is the one which\n     * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start\n     * position of all other ranges (not to confuse with the first range added to the selection).\n     * Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/range~Range|null}\n     */\n\n  }, {\n    key: \"getFirstRange\",\n    value: function getFirstRange() {\n      var first = null;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var range = _step2.value;\n\n          if (!first || range.start.isBefore(first.start)) {\n            first = range;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return first ? first.clone() : null;\n    }\n    /**\n     * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}\n     * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse\n     * with the last range added to the selection). Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/range~Range|null}\n     */\n\n  }, {\n    key: \"getLastRange\",\n    value: function getLastRange() {\n      var last = null;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this._ranges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var range = _step3.value;\n\n          if (!last || range.end.isAfter(last.end)) {\n            last = range;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return last ? last.clone() : null;\n    }\n    /**\n     * Returns copy of the first position in the selection. First position is the position that\n     * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.\n     * Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/position~Position|null}\n     */\n\n  }, {\n    key: \"getFirstPosition\",\n    value: function getFirstPosition() {\n      var firstRange = this.getFirstRange();\n      return firstRange ? firstRange.start.clone() : null;\n    }\n    /**\n     * Returns copy of the last position in the selection. Last position is the position that\n     * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.\n     * Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/position~Position|null}\n     */\n\n  }, {\n    key: \"getLastPosition\",\n    value: function getLastPosition() {\n      var lastRange = this.getLastRange();\n      return lastRange ? lastRange.end.clone() : null;\n    }\n    /**\n     * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,\n     * same number of ranges and all ranges from one selection equal to a range from other selection.\n     *\n     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n     * Selection to compare with.\n     * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(otherSelection) {\n      if (this.isFake != otherSelection.isFake) {\n        return false;\n      }\n\n      if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {\n        return false;\n      }\n\n      if (this.rangeCount != otherSelection.rangeCount) {\n        return false;\n      } else if (this.rangeCount === 0) {\n        return true;\n      }\n\n      if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {\n        return false;\n      }\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this._ranges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var thisRange = _step4.value;\n          var found = false;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = otherSelection._ranges[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var otherRange = _step5.value;\n\n              if (thisRange.isEqual(otherRange)) {\n                found = true;\n                break;\n              }\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n\n          if (!found) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same\n     * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are\n     * equal to any trimmed range from other selection.\n     *\n     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n     * Selection to compare with.\n     * @returns {Boolean} `true` if selections are similar, `false` otherwise.\n     */\n\n  }, {\n    key: \"isSimilar\",\n    value: function isSimilar(otherSelection) {\n      if (this.isBackward != otherSelection.isBackward) {\n        return false;\n      }\n\n      var numOfRangesA = count(this.getRanges());\n      var numOfRangesB = count(otherSelection.getRanges()); // If selections have different number of ranges, they cannot be similar.\n\n      if (numOfRangesA != numOfRangesB) {\n        return false;\n      } // If both selections have no ranges, they are similar.\n\n\n      if (numOfRangesA == 0) {\n        return true;\n      } // Check if each range in one selection has a similar range in other selection.\n\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.getRanges()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var rangeA = _step6.value;\n          rangeA = rangeA.getTrimmed();\n          var found = false;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = otherSelection.getRanges()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var rangeB = _step7.value;\n              rangeB = rangeB.getTrimmed();\n\n              if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {\n                found = true;\n                break;\n              }\n            } // For `rangeA`, neither range in `otherSelection` was similar. So selections are not similar.\n\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n\n          if (!found) {\n            return false;\n          }\n        } // There were no ranges that weren't matched. Selections are similar.\n\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only\n     * one range in the selection, and that range contains exactly one element.\n     * Returns `null` if there is no selected element.\n     *\n     * @returns {module:engine/view/element~Element|null}\n     */\n\n  }, {\n    key: \"getSelectedElement\",\n    value: function getSelectedElement() {\n      if (this.rangeCount !== 1) {\n        return null;\n      }\n\n      var range = this.getFirstRange();\n      var nodeAfterStart = range.start.nodeAfter;\n      var nodeBeforeEnd = range.end.nodeBefore; // Handle the situation when selection position is at the beginning / at the end of a text node.\n      // In such situation `.nodeAfter` and `.nodeBefore` are `null` but the selection still might be spanning\n      // over one element.\n      //\n      // <p>Foo{<span class=\"widget\"></span>}bar</p> vs <p>Foo[<span class=\"widget\"></span>]bar</p>\n      //\n      // These are basically the same selections, only the difference is if the selection position is at\n      // at the end/at the beginning of a text node or just before/just after the text node.\n      //\n\n      if (range.start.parent.is('text') && range.start.isAtEnd && range.start.parent.nextSibling) {\n        nodeAfterStart = range.start.parent.nextSibling;\n      }\n\n      if (range.end.parent.is('text') && range.end.isAtStart && range.end.parent.previousSibling) {\n        nodeBeforeEnd = range.end.parent.previousSibling;\n      }\n\n      return nodeAfterStart instanceof Element && nodeAfterStart == nodeBeforeEnd ? nodeAfterStart : null;\n    }\n    /**\n     * Sets this selection's ranges and direction to the specified location based on the given\n     * {@link module:engine/view/selection~Selectable selectable}.\n     *\n     *\t\t// Sets selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tselection.setTo( range );\n     *\n     *\t\t// Sets selection to given ranges.\n     * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tselection.setTo( range );\n     *\n     *\t\t// Sets selection to the other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tselection.setTo( otherSelection );\n     *\n     *\t \t// Sets selection to contents of DocumentSelection.\n     *\t\tselection.setTo( editor.editing.view.document.selection );\n     *\n     * \t\t// Sets collapsed selection at the given position.\n     *\t\tconst position = writer.createPositionAt( root, path );\n     *\t\tselection.setTo( position );\n     *\n     * \t\t// Sets collapsed selection at the position of given item and offset.\n     *\t\tselection.setTo( paragraph, offset );\n     *\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     *\t\tselection.setTo( paragraph, 'in' );\n     *\n     * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n     *\n     *\t\tselection.setTo( paragraph, 'on' );\n     *\n     * \t\t// Clears selection. Removes all ranges.\n     *\t\tselection.setTo( null );\n     *\n     * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n     *\n     *\t\t// Sets selection as backward.\n     *\t\tselection.setTo( range, { backward: true } );\n     *\n     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n     * represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n     * (and be  properly handled by screen readers).\n     *\n     *\t\t// Creates fake selection with label.\n     *\t\tselection.setTo( range, { fake: true, label: 'foo' } );\n     *\n     * @fires change\n     * @param {module:engine/view/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n     * @param {String} [options.label] Label for the fake selection.\n     */\n\n  }, {\n    key: \"setTo\",\n    value: function setTo(selectable, placeOrOffset, options) {\n      if (selectable === null) {\n        this._setRanges([]);\n\n        this._setFakeOptions(placeOrOffset);\n      } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n        this._setRanges(selectable.getRanges(), selectable.isBackward);\n\n        this._setFakeOptions({\n          fake: selectable.isFake,\n          label: selectable.fakeSelectionLabel\n        });\n      } else if (selectable instanceof Range) {\n        this._setRanges([selectable], placeOrOffset && placeOrOffset.backward);\n\n        this._setFakeOptions(placeOrOffset);\n      } else if (selectable instanceof Position) {\n        this._setRanges([new Range(selectable)]);\n\n        this._setFakeOptions(placeOrOffset);\n      } else if (selectable instanceof Node) {\n        var backward = !!options && !!options.backward;\n        var range;\n\n        if (placeOrOffset === undefined) {\n          /**\n           * selection.setTo requires the second parameter when the first parameter is a node.\n           *\n           * @error view-selection-setTo-required-second-parameter\n           */\n          throw new CKEditorError('view-selection-setTo-required-second-parameter: ' + 'selection.setTo requires the second parameter when the first parameter is a node.');\n        } else if (placeOrOffset == 'in') {\n          range = Range._createIn(selectable);\n        } else if (placeOrOffset == 'on') {\n          range = Range._createOn(selectable);\n        } else {\n          range = new Range(Position._createAt(selectable, placeOrOffset));\n        }\n\n        this._setRanges([range], backward);\n\n        this._setFakeOptions(options);\n      } else if (isIterable(selectable)) {\n        // We assume that the selectable is an iterable of ranges.\n        // Array.from() is used to prevent setting ranges to the old iterable\n        this._setRanges(selectable, placeOrOffset && placeOrOffset.backward);\n\n        this._setFakeOptions(placeOrOffset);\n      } else {\n        /**\n         * Cannot set selection to given place.\n         *\n         * @error view-selection-setTo-not-selectable\n         */\n        throw new CKEditorError('view-selection-setTo-not-selectable: Cannot set selection to given place.');\n      }\n\n      this.fire('change');\n    }\n    /**\n     * Moves {@link #focus} to the specified location.\n     *\n     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n     * parameters.\n     *\n     * @fires change\n     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     */\n\n  }, {\n    key: \"setFocus\",\n    value: function setFocus(itemOrPosition, offset) {\n      if (this.anchor === null) {\n        /**\n         * Cannot set selection focus if there are no ranges in selection.\n         *\n         * @error view-selection-setFocus-no-ranges\n         */\n        throw new CKEditorError('view-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.');\n      }\n\n      var newFocus = Position._createAt(itemOrPosition, offset);\n\n      if (newFocus.compareWith(this.focus) == 'same') {\n        return;\n      }\n\n      var anchor = this.anchor;\n\n      this._ranges.pop();\n\n      if (newFocus.compareWith(anchor) == 'before') {\n        this._addRange(new Range(newFocus, anchor), true);\n      } else {\n        this._addRange(new Range(anchor, newFocus));\n      }\n\n      this.fire('change');\n    }\n    /**\n     * Checks whether object is of given type following the convention set by\n     * {@link module:engine/view/node~Node#is `Node#is()`}.\n     *\n     *\t\tconst selection = new Selection( ... );\n     *\n     *\t\tselection.is( 'selection' ); // true\n     *\t\tselection.is( 'node' ); // false\n     *\t\tselection.is( 'element' ); // false\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type == 'selection';\n    }\n    /**\n     * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n     * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.\n     * Accepts a flag describing in which way the selection is made.\n     *\n     * @private\n     * @param {Iterable.<module:engine/view/range~Range>} newRanges Iterable object of ranges to set.\n     * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end\n     * (`false`) or backward - from end to start (`true`). Defaults to `false`.\n     */\n\n  }, {\n    key: \"_setRanges\",\n    value: function _setRanges(newRanges) {\n      var isLastBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // New ranges should be copied to prevent removing them by setting them to `[]` first.\n      // Only applies to situations when selection is set to the same selection or same selection's ranges.\n      newRanges = Array.from(newRanges);\n      this._ranges = [];\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = newRanges[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var range = _step8.value;\n\n          this._addRange(range);\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      this._lastRangeBackward = !!isLastBackward;\n    }\n    /**\n     * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection\n     * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to\n     * the user and selection over elements can be represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be\n     * properly handled by screen readers).\n     *\n     * @private\n     * @param {Object} [options] Options.\n     * @param {Boolean} [options.fake] If set to true selection will be marked as `fake`.\n     * @param {String} [options.label=''] Fake selection label.\n     */\n\n  }, {\n    key: \"_setFakeOptions\",\n    value: function _setFakeOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._isFake = !!options.fake;\n      this._fakeSelectionLabel = options.fake ? options.label || '' : '';\n    }\n    /**\n     * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the\n     * selection instance and you can safely operate on it.\n     *\n     * Accepts a flag describing in which way the selection is made - passed range might be selected from\n     * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}\n     * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.\n     * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n     * with ranges already stored in Selection instance.\n     *\n     * @private\n     * @fires change\n     * @param {module:engine/view/range~Range} range\n     * @param {Boolean} [isBackward]\n     */\n\n  }, {\n    key: \"_addRange\",\n    value: function _addRange(range) {\n      var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!(range instanceof Range)) {\n        /**\n         * Selection range set to an object that is not an instance of {@link module:engine/view/range~Range}.\n         *\n         * @error view-selection-add-range-not-range\n         */\n        throw new CKEditorError('view-selection-add-range-not-range: ' + 'Selection range set to an object that is not an instance of view.Range');\n      }\n\n      this._pushRange(range);\n\n      this._lastRangeBackward = !!isBackward;\n    }\n    /**\n     * Adds range to selection - creates copy of given range so it can be safely used and modified.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n     * with ranges already stored in selection instance.\n     *\n     * @private\n     * @param {module:engine/view/range~Range} range\n     */\n\n  }, {\n    key: \"_pushRange\",\n    value: function _pushRange(range) {\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = this._ranges[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var storedRange = _step9.value;\n\n          if (range.isIntersecting(storedRange)) {\n            /**\n             * Trying to add a range that intersects with another range from selection.\n             *\n             * @error view-selection-range-intersects\n             * @param {module:engine/view/range~Range} addedRange Range that was added to the selection.\n             * @param {module:engine/view/range~Range} intersectingRange Range from selection that intersects with `addedRange`.\n             */\n            throw new CKEditorError('view-selection-range-intersects: Trying to add a range that intersects with another range from selection.', {\n              addedRange: range,\n              intersectingRange: storedRange\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      this._ranges.push(new Range(range.start, range.end));\n    }\n    /**\n     * Fired whenever selection ranges are changed through {@link ~Selection Selection API}.\n     *\n     * @event change\n     */\n\n  }, {\n    key: \"isFake\",\n    get: function get() {\n      return this._isFake;\n    }\n    /**\n     * Returns fake selection label.\n     *\n     * @see #setTo\n     * @returns {String}\n     */\n\n  }, {\n    key: \"fakeSelectionLabel\",\n    get: function get() {\n      return this._fakeSelectionLabel;\n    }\n    /**\n     * Selection anchor. Anchor may be described as a position where the selection starts. Together with\n     * {@link #focus focus} they define the direction of selection, which is important\n     * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.\n     * It may be a bit unintuitive when there are multiple ranges in selection.\n     *\n     * @see #focus\n     * @type {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      if (!this._ranges.length) {\n        return null;\n      }\n\n      var range = this._ranges[this._ranges.length - 1];\n      var anchor = this._lastRangeBackward ? range.end : range.start;\n      return anchor.clone();\n    }\n    /**\n     * Selection focus. Focus is a position where the selection ends.\n     *\n     * @see #anchor\n     * @type {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"focus\",\n    get: function get() {\n      if (!this._ranges.length) {\n        return null;\n      }\n\n      var range = this._ranges[this._ranges.length - 1];\n      var focus = this._lastRangeBackward ? range.start : range.end;\n      return focus.clone();\n    }\n    /**\n     * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n     * collapsed.\n     *\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isCollapsed\",\n    get: function get() {\n      return this.rangeCount === 1 && this._ranges[0].isCollapsed;\n    }\n    /**\n     * Returns number of ranges in selection.\n     *\n     * @type {Number}\n     */\n\n  }, {\n    key: \"rangeCount\",\n    get: function get() {\n      return this._ranges.length;\n    }\n    /**\n     * Specifies whether the {@link #focus} precedes {@link #anchor}.\n     *\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isBackward\",\n    get: function get() {\n      return !this.isCollapsed && this._lastRangeBackward;\n    }\n    /**\n     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`\n     * if the selection is not inside an editable element.\n     *\n     * @type {module:engine/view/editableelement~EditableElement|null}\n     */\n\n  }, {\n    key: \"editableElement\",\n    get: function get() {\n      if (this.anchor) {\n        return this.anchor.editableElement;\n      }\n\n      return null;\n    }\n  }]);\n\n  return Selection;\n}();\n\nexport { Selection as default };\nmix(Selection, EmitterMixin);\n/**\n * An entity that is used to set selection.\n *\n * See also {@link module:engine/view/selection~Selection#setTo}\n *\n * @typedef {\n *    module:engine/view/selection~Selection|\n *    module:engine/view/documentselection~DocumentSelection|\n *    module:engine/view/position~Position|\n *    Iterable.<module:engine/view/range~Range>|\n *    module:engine/view/range~Range|\n *    module:engine/view/item~Item|\n *    null\n * } module:engine/view/selection~Selectable\n */","import \"core-js/modules/es6.string.anchor\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"regenerator-runtime/runtime\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/documentselection\n */\nimport Selection from \"./selection\";\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n/**\n * Class representing the document selection in the view.\n *\n * Its instance is available in {@link module:engine/view/document~Document#selection `Document#selection`}.\n *\n * It is similar to {@link module:engine/view/selection~Selection} but\n * it has a read-only API and can be modified only by the writer available in\n * the {@link module:engine/view/view~View#change `View#change()`} block\n * (so via {@link module:engine/view/downcastwriter~DowncastWriter#setSelection `DowncastWriter#setSelection()`}).\n */\n\nvar DocumentSelection =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates new DocumentSelection instance.\n   *\n   * \t\t// Creates empty selection without ranges.\n   *\t\tconst selection = new DocumentSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = new DocumentSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n   *\t\tconst selection = new DocumentSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = new DocumentSelection( otherSelection );\n   *\n   * \t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionAt( root, offset );\n   *\t\tconst selection = new DocumentSelection( position );\n   *\n   *\t\t// Creates collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n   *\t\tconst selection = new DocumentSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = new DocumentSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = new DocumentSelection( paragraph, 'on' );\n   *\n   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = new DocumentSelection( range, { backward: true } );\n   *\n   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * (and be  properly handled by screen readers).\n   *\n   *\t\t// Creates fake selection with label.\n   *\t\tconst selection = new DocumentSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} [selectable=null]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n  function DocumentSelection() {\n    var selectable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var placeOrOffset = arguments.length > 1 ? arguments[1] : undefined;\n    var options = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, DocumentSelection);\n\n    /**\n     * Selection is used internally (`DocumentSelection` is a proxy to that selection).\n     *\n     * @private\n     * @member {module:engine/view/selection~Selection}\n     */\n    this._selection = new Selection(); // Delegate change event to be fired on DocumentSelection instance.\n\n    this._selection.delegate('change').to(this); // Set selection data.\n\n\n    this._selection.setTo(selectable, placeOrOffset, options);\n  }\n  /**\n   * Returns true if selection instance is marked as `fake`.\n   *\n   * @see #_setTo\n   * @returns {Boolean}\n   */\n\n\n  _createClass(DocumentSelection, [{\n    key: \"getRanges\",\n\n    /**\n     * Returns an iterable that contains copies of all ranges added to the selection.\n     *\n     * @returns {Iterable.<module:engine/view/range~Range>}\n     */\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function getRanges() {\n      return regeneratorRuntime.wrap(function getRanges$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this._selection.getRanges(), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, getRanges, this);\n    })\n    /**\n     * Returns copy of the first range in the selection. First range is the one which\n     * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start\n     * position of all other ranges (not to confuse with the first range added to the selection).\n     * Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/range~Range|null}\n     */\n\n  }, {\n    key: \"getFirstRange\",\n    value: function getFirstRange() {\n      return this._selection.getFirstRange();\n    }\n    /**\n     * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}\n     * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse\n     * with the last range added to the selection). Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/range~Range|null}\n     */\n\n  }, {\n    key: \"getLastRange\",\n    value: function getLastRange() {\n      return this._selection.getLastRange();\n    }\n    /**\n     * Returns copy of the first position in the selection. First position is the position that\n     * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.\n     * Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/position~Position|null}\n     */\n\n  }, {\n    key: \"getFirstPosition\",\n    value: function getFirstPosition() {\n      return this._selection.getFirstPosition();\n    }\n    /**\n     * Returns copy of the last position in the selection. Last position is the position that\n     * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.\n     * Returns `null` if no ranges are added to selection.\n     *\n     * @returns {module:engine/view/position~Position|null}\n     */\n\n  }, {\n    key: \"getLastPosition\",\n    value: function getLastPosition() {\n      return this._selection.getLastPosition();\n    }\n    /**\n     * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only\n     * one range in the selection, and that range contains exactly one element.\n     * Returns `null` if there is no selected element.\n     *\n     * @returns {module:engine/view/element~Element|null}\n     */\n\n  }, {\n    key: \"getSelectedElement\",\n    value: function getSelectedElement() {\n      return this._selection.getSelectedElement();\n    }\n    /**\n     * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,\n     * same number of ranges and all ranges from one selection equal to a range from other selection.\n     *\n     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n     * Selection to compare with.\n     * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(otherSelection) {\n      return this._selection.isEqual(otherSelection);\n    }\n    /**\n     * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same\n     * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are\n     * equal to any trimmed range from other selection.\n     *\n     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n     * Selection to compare with.\n     * @returns {Boolean} `true` if selections are similar, `false` otherwise.\n     */\n\n  }, {\n    key: \"isSimilar\",\n    value: function isSimilar(otherSelection) {\n      return this._selection.isSimilar(otherSelection);\n    }\n    /**\n     * Checks whether object is of given type following the convention set by\n     * {@link module:engine/view/node~Node#is `Node#is()`}.\n     *\n     *\t\tconst selection = new DocumentSelection( ... );\n     *\n     *\t\tselection.is( 'selection' ); // true\n     *\t\tselection.is( 'documentSelection' ); // true\n     *\t\tselection.is( 'node' ); // false\n     *\t\tselection.is( 'element' ); // false\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type == 'selection' || type == 'documentSelection';\n    }\n    /**\n     * Sets this selection's ranges and direction to the specified location based on the given\n     * {@link module:engine/view/selection~Selectable selectable}.\n     *\n     *\t\t// Sets selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tdocumentSelection._setTo( range );\n     *\n     *\t\t// Sets selection to given ranges.\n     * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n     *\t\tdocumentSelection._setTo( range );\n     *\n     *\t\t// Sets selection to the other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tdocumentSelection._setTo( otherSelection );\n     *\n     * \t\t// Sets collapsed selection at the given position.\n     *\t\tconst position = writer.createPositionAt( root, offset );\n     *\t\tdocumentSelection._setTo( position );\n     *\n     * \t\t// Sets collapsed selection at the position of given item and offset.\n     *\t\tdocumentSelection._setTo( paragraph, offset );\n     *\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     *\t\tdocumentSelection._setTo( paragraph, 'in' );\n     *\n     * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n     *\n     *\t\tdocumentSelection._setTo( paragraph, 'on' );\n     *\n     * \t\t// Clears selection. Removes all ranges.\n     *\t\tdocumentSelection._setTo( null );\n     *\n     * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n     *\n     *\t\t// Sets selection as backward.\n     *\t\tdocumentSelection._setTo( range, { backward: true } );\n     *\n     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n     * represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM\n     * (and be  properly handled by screen readers).\n     *\n     *\t\t// Creates fake selection with label.\n     *\t\tdocumentSelection._setTo( range, { fake: true, label: 'foo' } );\n     *\n     * @protected\n     * @fires change\n     * @param {module:engine/view/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n     * @param {String} [options.label] Label for the fake selection.\n     */\n\n  }, {\n    key: \"_setTo\",\n    value: function _setTo(selectable, placeOrOffset, options) {\n      this._selection.setTo(selectable, placeOrOffset, options);\n    }\n    /**\n     * Moves {@link #focus} to the specified location.\n     *\n     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n     * parameters.\n     *\n     * @protected\n     * @fires change\n     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     */\n\n  }, {\n    key: \"_setFocus\",\n    value: function _setFocus(itemOrPosition, offset) {\n      this._selection.setFocus(itemOrPosition, offset);\n    }\n    /**\n     * Fired whenever selection ranges are changed through {@link ~DocumentSelection Selection API}.\n     *\n     * @event change\n     */\n\n  }, {\n    key: \"isFake\",\n    get: function get() {\n      return this._selection.isFake;\n    }\n    /**\n     * Returns fake selection label.\n     *\n     * @see #_setTo\n     * @returns {String}\n     */\n\n  }, {\n    key: \"fakeSelectionLabel\",\n    get: function get() {\n      return this._selection.fakeSelectionLabel;\n    }\n    /**\n     * Selection anchor. Anchor may be described as a position where the selection starts. Together with\n     * {@link #focus focus} they define the direction of selection, which is important\n     * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.\n     * It may be a bit unintuitive when there are multiple ranges in selection.\n     *\n     * @see #focus\n     * @type {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      return this._selection.anchor;\n    }\n    /**\n     * Selection focus. Focus is a position where the selection ends.\n     *\n     * @see #anchor\n     * @type {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"focus\",\n    get: function get() {\n      return this._selection.focus;\n    }\n    /**\n     * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n     * collapsed.\n     *\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isCollapsed\",\n    get: function get() {\n      return this._selection.isCollapsed;\n    }\n    /**\n     * Returns number of ranges in selection.\n     *\n     * @type {Number}\n     */\n\n  }, {\n    key: \"rangeCount\",\n    get: function get() {\n      return this._selection.rangeCount;\n    }\n    /**\n     * Specifies whether the {@link #focus} precedes {@link #anchor}.\n     *\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isBackward\",\n    get: function get() {\n      return this._selection.isBackward;\n    }\n    /**\n     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`\n     * if the selection is not inside an editable element.\n     *\n     * @type {module:engine/view/editableelement~EditableElement|null}\n     */\n\n  }, {\n    key: \"editableElement\",\n    get: function get() {\n      return this._selection.editableElement;\n    }\n    /**\n     * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_ranges\",\n    get: function get() {\n      return this._selection._ranges;\n    }\n  }]);\n\n  return DocumentSelection;\n}();\n\nexport { DocumentSelection as default };\nmix(DocumentSelection, EmitterMixin);","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.weak-map\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/collection\n */\nimport EmitterMixin from \"./emittermixin\";\nimport CKEditorError from \"./ckeditorerror\";\nimport uid from \"./uid\";\nimport mix from \"./mix\";\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar Collection =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new Collection instance.\n   *\n   * @param {Object} [options={}] The options object.\n   * @param {String} [options.idProperty='id'] The name of the property which is considered to identify an item.\n   */\n  function Collection() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Collection);\n\n    /**\n     * The internal list of items in the collection.\n     *\n     * @private\n     * @member {Object[]}\n     */\n    this._items = [];\n    /**\n     * The internal map of items in the collection.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._itemMap = new Map();\n    /**\n     * The name of the property which is considered to identify an item.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._idProperty = options.idProperty || 'id';\n    /**\n     * A helper mapping external items of a bound collection ({@link #bindTo})\n     * and actual items of this collection. It provides information\n     * necessary to properly remove items bound to another collection.\n     *\n     * See {@link #_bindToInternalToExternalMap}.\n     *\n     * @protected\n     * @member {WeakMap}\n     */\n\n    this._bindToExternalToInternalMap = new WeakMap();\n    /**\n     * A helper mapping items of this collection to external items of a bound collection\n     * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.\n     * to avoid loops in twoway bindings.\n     *\n     * See {@link #_bindToExternalToInternalMap}.\n     *\n     * @protected\n     * @member {WeakMap}\n     */\n\n    this._bindToInternalToExternalMap = new WeakMap();\n    /**\n     * Stores indexes of skipped items from bound external collection.\n     *\n     * @private\n     * @member {Array}\n     */\n\n    this._skippedIndexesFromExternal = [];\n    /**\n     * A collection instance this collection is bound to as a result\n     * of calling {@link #bindTo} method.\n     *\n     * @protected\n     * @member {module:utils/collection~Collection} #_bindToCollection\n     */\n  }\n  /**\n   * The number of items available in the collection.\n   *\n   * @member {Number} #length\n   */\n\n\n  _createClass(Collection, [{\n    key: \"add\",\n\n    /**\n     * Adds an item into the collection.\n     *\n     * If the item does not have an id, then it will be automatically generated and set on the item.\n     *\n     * @chainable\n     * @param {Object} item\n     * @param {Number} [index] The position of the item in the collection. The item\n     * is pushed to the collection when `index` not specified.\n     * @fires add\n     */\n    value: function add(item, index) {\n      var itemId;\n      var idProperty = this._idProperty;\n\n      if (idProperty in item) {\n        itemId = item[idProperty];\n\n        if (typeof itemId != 'string') {\n          /**\n           * This item's id should be a string.\n           *\n           * @error collection-add-invalid-id\n           */\n          throw new CKEditorError('collection-add-invalid-id');\n        }\n\n        if (this.get(itemId)) {\n          /**\n           * This item already exists in the collection.\n           *\n           * @error collection-add-item-already-exists\n           */\n          throw new CKEditorError('collection-add-item-already-exists');\n        }\n      } else {\n        item[idProperty] = itemId = uid();\n      } // TODO: Use ES6 default function argument.\n\n\n      if (index === undefined) {\n        index = this._items.length;\n      } else if (index > this._items.length || index < 0) {\n        /**\n         * The index number has invalid value.\n         *\n         * @error collection-add-item-bad-index\n         */\n        throw new CKEditorError('collection-add-item-invalid-index');\n      }\n\n      this._items.splice(index, 0, item);\n\n      this._itemMap.set(itemId, item);\n\n      this.fire('add', item, index);\n      return this;\n    }\n    /**\n     * Gets item by its id or index.\n     *\n     * @param {String|Number} idOrIndex The item id or index in the collection.\n     * @returns {Object|null} The requested item or `null` if such item does not exist.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(idOrIndex) {\n      var item;\n\n      if (typeof idOrIndex == 'string') {\n        item = this._itemMap.get(idOrIndex);\n      } else if (typeof idOrIndex == 'number') {\n        item = this._items[idOrIndex];\n      } else {\n        /**\n         * Index or id must be given.\n         *\n         * @error collection-get-invalid-arg\n         */\n        throw new CKEditorError('collection-get-invalid-arg: Index or id must be given.');\n      }\n\n      return item || null;\n    }\n    /**\n     * Returns a boolean indicating whether the collection contains an item.\n     *\n     * @param {Object|String} itemOrId The item or its id in the collection.\n     * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(itemOrId) {\n      if (typeof itemOrId == 'string') {\n        return this._itemMap.has(itemOrId);\n      } else {\n        // Object\n        var idProperty = this._idProperty;\n        var id = itemOrId[idProperty];\n        return this._itemMap.has(id);\n      }\n    }\n    /**\n     * Gets index of item in the collection.\n     * When item is not defined in the collection then index will be equal -1.\n     *\n     * @param {Object|String} itemOrId The item or its id in the collection.\n     * @returns {Number} Index of given item.\n     */\n\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(itemOrId) {\n      var item;\n\n      if (typeof itemOrId == 'string') {\n        item = this._itemMap.get(itemOrId);\n      } else {\n        item = itemOrId;\n      }\n\n      return this._items.indexOf(item);\n    }\n    /**\n     * Removes an item from the collection.\n     *\n     * @param {Object|Number|String} subject The item to remove, its id or index in the collection.\n     * @returns {Object} The removed item.\n     * @fires remove\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(subject) {\n      var index, id, item;\n      var itemDoesNotExist = false;\n      var idProperty = this._idProperty;\n\n      if (typeof subject == 'string') {\n        id = subject;\n        item = this._itemMap.get(id);\n        itemDoesNotExist = !item;\n\n        if (item) {\n          index = this._items.indexOf(item);\n        }\n      } else if (typeof subject == 'number') {\n        index = subject;\n        item = this._items[index];\n        itemDoesNotExist = !item;\n\n        if (item) {\n          id = item[idProperty];\n        }\n      } else {\n        item = subject;\n        id = item[idProperty];\n        index = this._items.indexOf(item);\n        itemDoesNotExist = index == -1 || !this._itemMap.get(id);\n      }\n\n      if (itemDoesNotExist) {\n        /**\n         * Item not found.\n         *\n         * @error collection-remove-404\n         */\n        throw new CKEditorError('collection-remove-404: Item not found.');\n      }\n\n      this._items.splice(index, 1);\n\n      this._itemMap.delete(id);\n\n      var externalItem = this._bindToInternalToExternalMap.get(item);\n\n      this._bindToInternalToExternalMap.delete(item);\n\n      this._bindToExternalToInternalMap.delete(externalItem);\n\n      this.fire('remove', item, index);\n      return item;\n    }\n    /**\n     * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n     *\n     * @param {Function} callback\n     * @param {Object} callback.item\n     * @param {Number} callback.index\n     * @param {Object} ctx Context in which the `callback` will be called.\n     * @returns {Array} The result of mapping.\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(callback, ctx) {\n      return this._items.map(callback, ctx);\n    }\n    /**\n     * Finds the first item in the collection for which the `callback` returns a true value.\n     *\n     * @param {Function} callback\n     * @param {Object} callback.item\n     * @param {Number} callback.index\n     * @param {Object} ctx Context in which the `callback` will be called.\n     * @returns {Object} The item for which `callback` returned a true value.\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(callback, ctx) {\n      return this._items.find(callback, ctx);\n    }\n    /**\n     * Returns an array with items for which the `callback` returned a true value.\n     *\n     * @param {Function} callback\n     * @param {Object} callback.item\n     * @param {Number} callback.index\n     * @param {Object} ctx Context in which the `callback` will be called.\n     * @returns {Object[]} The array with matching items.\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(callback, ctx) {\n      return this._items.filter(callback, ctx);\n    }\n    /**\n     * Removes all items from the collection and destroys the binding created using\n     * {@link #bindTo}.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this._bindToCollection) {\n        this.stopListening(this._bindToCollection);\n        this._bindToCollection = null;\n      }\n\n      while (this.length) {\n        this.remove(0);\n      }\n    }\n    /**\n     * Binds and synchronizes the collection with another one.\n     *\n     * The binding can be a simple factory:\n     *\n     *\t\tclass FactoryClass {\n     *\t\t\tconstructor( data ) {\n     *\t\t\t\tthis.label = data.label;\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tconst source = new Collection( { idProperty: 'label' } );\n     *\t\tconst target = new Collection();\n     *\n     *\t\ttarget.bindTo( source ).as( FactoryClass );\n     *\n     *\t\tsource.add( { label: 'foo' } );\n     *\t\tsource.add( { label: 'bar' } );\n     *\n     *\t\tconsole.log( target.length ); // 2\n     *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n     *\n     *\t\tsource.remove( 0 );\n     *\t\tconsole.log( target.length ); // 1\n     *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n     *\n     * or the factory driven by a custom callback:\n     *\n     *\t\tclass FooClass {\n     *\t\t\tconstructor( data ) {\n     *\t\t\t\tthis.label = data.label;\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tclass BarClass {\n     *\t\t\tconstructor( data ) {\n     *\t\t\t\tthis.label = data.label;\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tconst source = new Collection( { idProperty: 'label' } );\n     *\t\tconst target = new Collection();\n     *\n     *\t\ttarget.bindTo( source ).using( ( item ) => {\n     *\t\t\tif ( item.label == 'foo' ) {\n     *\t\t\t\treturn new FooClass( item );\n     *\t\t\t} else {\n     *\t\t\t\treturn new BarClass( item );\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\tsource.add( { label: 'foo' } );\n     *\t\tsource.add( { label: 'bar' } );\n     *\n     *\t\tconsole.log( target.length ); // 2\n     *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n     *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n     *\n     * or the factory out of property name:\n     *\n     *\t\tconst source = new Collection( { idProperty: 'label' } );\n     *\t\tconst target = new Collection();\n     *\n     *\t\ttarget.bindTo( source ).using( 'label' );\n     *\n     *\t\tsource.add( { label: { value: 'foo' } } );\n     *\t\tsource.add( { label: { value: 'bar' } } );\n     *\n     *\t\tconsole.log( target.length ); // 2\n     *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n     *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n     *\n     * It's possible to skip specified items by returning falsy value:\n     *\n     *\t\tconst source = new Collection();\n     *\t\tconst target = new Collection();\n     *\n     *\t\ttarget.bindTo( source ).using( item => {\n     *\t\t\tif ( item.hidden ) {\n     *\t\t\t\treturn null;\n     *\t\t\t}\n     *\n     *\t\t\treturn item;\n     *\t\t} );\n     *\n     *\t\tsource.add( { hidden: true } );\n     *\t\tsource.add( { hidden: false } );\n     *\n     *\t\tconsole.log( source.length ); // 2\n     *\t\tconsole.log( target.length ); // 1\n     *\n     * **Note**: {@link #clear} can be used to break the binding.\n     *\n     * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n     * @returns {Object}\n     * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.\n     */\n\n  }, {\n    key: \"bindTo\",\n    value: function bindTo(externalCollection) {\n      var _this = this;\n\n      if (this._bindToCollection) {\n        /**\n         * The collection cannot be bound more than once.\n         *\n         * @error collection-bind-to-rebind\n         */\n        throw new CKEditorError('collection-bind-to-rebind: The collection cannot be bound more than once.');\n      }\n\n      this._bindToCollection = externalCollection;\n      return {\n        as: function as(Class) {\n          _this._setUpBindToBinding(function (item) {\n            return new Class(item);\n          });\n        },\n        using: function using(callbackOrProperty) {\n          if (typeof callbackOrProperty == 'function') {\n            _this._setUpBindToBinding(function (item) {\n              return callbackOrProperty(item);\n            });\n          } else {\n            _this._setUpBindToBinding(function (item) {\n              return item[callbackOrProperty];\n            });\n          }\n        }\n      };\n    }\n    /**\n     * Finalizes and activates a binding initiated by {#bindTo}.\n     *\n     * @protected\n     * @param {Function} factory A function which produces collection items.\n     */\n\n  }, {\n    key: \"_setUpBindToBinding\",\n    value: function _setUpBindToBinding(factory) {\n      var _this2 = this;\n\n      var externalCollection = this._bindToCollection; // Adds the item to the collection once a change has been done to the external collection.\n      //\n      // @private\n\n      var addItem = function addItem(evt, externalItem, index) {\n        var isExternalBoundToThis = externalCollection._bindToCollection == _this2;\n\n        var externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem); // If an external collection is bound to this collection, which makes it a 2way binding,\n        // and the particular external collection item is already bound, don't add it here.\n        // The external item has been created **out of this collection's item** and (re)adding it will\n        // cause a loop.\n\n\n        if (isExternalBoundToThis && externalItemBound) {\n          _this2._bindToExternalToInternalMap.set(externalItem, externalItemBound);\n\n          _this2._bindToInternalToExternalMap.set(externalItemBound, externalItem);\n        } else {\n          var item = factory(externalItem); // When there is no item we need to remember skipped index first and then we can skip this item.\n\n          if (!item) {\n            _this2._skippedIndexesFromExternal.push(index);\n\n            return;\n          } // Lets try to put item at the same index as index in external collection\n          // but when there are a skipped items in one or both collections we need to recalculate this index.\n\n\n          var finalIndex = index; // When we try to insert item after some skipped items from external collection we need\n          // to include this skipped items and decrease index.\n          //\n          // For the following example:\n          // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n          // internal -> [ A ]\n          //\n          // Another item is been added at the end of external collection:\n          // external.add( 'D' )\n          // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n          //\n          // We can't just add 'D' to internal at the same index as index in external because\n          // this will produce empty indexes what is invalid:\n          // internal -> [ 'A', empty, empty, 'D' ]\n          //\n          // So we need to include skipped items and decrease index\n          // internal -> [ 'A', 'D' ]\n\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = _this2._skippedIndexesFromExternal[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var skipped = _step.value;\n\n              if (index > skipped) {\n                finalIndex--;\n              }\n            } // We need to take into consideration that external collection could skip some items from\n            // internal collection.\n            //\n            // For the following example:\n            // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n            // external -> [ A ]\n            //\n            // Another item is been added at the end of external collection:\n            // external.add( 'D' )\n            // external -> [ 'A', 'D' ]\n            //\n            // We need to include skipped items and place new item after them:\n            // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = externalCollection._skippedIndexesFromExternal[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _skipped = _step2.value;\n\n              if (finalIndex >= _skipped) {\n                finalIndex++;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          _this2._bindToExternalToInternalMap.set(externalItem, item);\n\n          _this2._bindToInternalToExternalMap.set(item, externalItem);\n\n          _this2.add(item, finalIndex); // After adding new element to internal collection we need update indexes\n          // of skipped items in external collection.\n\n\n          for (var i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {\n            if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {\n              externalCollection._skippedIndexesFromExternal[i]++;\n            }\n          }\n        }\n      }; // Load the initial content of the collection.\n\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = externalCollection[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var externalItem = _step3.value;\n          addItem(null, externalItem, externalCollection.getIndex(externalItem));\n        } // Synchronize the with collection as new items are added.\n\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      this.listenTo(externalCollection, 'add', addItem); // Synchronize the with collection as new items are removed.\n\n      this.listenTo(externalCollection, 'remove', function (evt, externalItem, index) {\n        var item = _this2._bindToExternalToInternalMap.get(externalItem);\n\n        if (item) {\n          _this2.remove(item);\n        } // After removing element from external collection we need update/remove indexes\n        // of skipped items in internal collection.\n\n\n        _this2._skippedIndexesFromExternal = _this2._skippedIndexesFromExternal.reduce(function (result, skipped) {\n          if (index < skipped) {\n            result.push(skipped - 1);\n          }\n\n          if (index > skipped) {\n            result.push(skipped);\n          }\n\n          return result;\n        }, []);\n      });\n    }\n    /**\n     * Iterable interface.\n     *\n     * @returns {Iterable.<*>}\n     */\n\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this._items[Symbol.iterator]();\n    }\n    /**\n     * Fired when an item is added to the collection.\n     *\n     * @event add\n     * @param {Object} item The added item.\n     */\n\n    /**\n     * Fired when an item is removed from the collection.\n     *\n     * @event remove\n     * @param {Object} item The removed item.\n     * @param {Number} index Index from which item was removed.\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._items.length;\n    }\n    /**\n     * Returns the first item from the collection or null when collection is empty.\n     *\n     * @returns {Object|null} The first item or `null` if collection is empty.\n     */\n\n  }, {\n    key: \"first\",\n    get: function get() {\n      return this._items[0] || null;\n    }\n    /**\n     * Returns the last item from the collection or null when collection is empty.\n     *\n     * @returns {Object|null} The last item or `null` if collection is empty.\n     */\n\n  }, {\n    key: \"last\",\n    get: function get() {\n      return this._items[this.length - 1] || null;\n    }\n  }]);\n\n  return Collection;\n}();\n\nexport { Collection as default };\nmix(Collection, EmitterMixin);\n/**\n * An object returned by the {@link module:utils/collection~Collection#bindTo `bindTo()`} method\n * providing functions that specify the type of the binding.\n *\n * See the {@link module:utils/collection~Collection#bindTo `bindTo()`} documentation for examples.\n *\n * @interface module:utils/collection~CollectionBindToChain\n */\n\n/**\n * Creates a callback or a property binding.\n *\n * @method #using\n * @param {Function|String} callbackOrProperty  When the function is passed, it should return\n * the collection items. When the string is provided, the property value is used to create the bound collection items.\n */\n\n/**\n * Creates the class factory binding in which items of the source collection are passed to\n * the constructor of the specified class.\n *\n * @method #as\n * @param {Function} Class The class constructor used to create instances in the factory.\n */","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/document\n */\nimport DocumentSelection from \"./documentselection\";\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\n/**\n * Document class creates an abstract layer over the content editable area, contains a tree of view elements and\n * {@link module:engine/view/documentselection~DocumentSelection view selection} associated with this document.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Document =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a Document instance.\n   */\n  function Document() {\n    _classCallCheck(this, Document);\n\n    /**\n     * Selection done on this document.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection} module:engine/view/document~Document#selection\n     */\n    this.selection = new DocumentSelection();\n    /**\n     * Roots of the view tree. Collection of the {@link module:engine/view/element~Element view elements}.\n     *\n     * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and\n     * {@link module:engine/model/document~Document#roots} and this is handled by\n     * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create\n     * model root using {@link module:engine/model/document~Document#createRoot}.\n     *\n     * @readonly\n     * @member {module:utils/collection~Collection} module:engine/view/document~Document#roots\n     */\n\n    this.roots = new Collection({\n      idProperty: 'rootName'\n    });\n    /**\n     * Defines whether document is in read-only mode.\n     *\n     * When document is read-ony then all roots are read-only as well and caret placed inside this root is hidden.\n     *\n     * @observable\n     * @member {Boolean} #isReadOnly\n     */\n\n    this.set('isReadOnly', false);\n    /**\n     * True if document is focused.\n     *\n     * This property is updated by the {@link module:engine/view/observer/focusobserver~FocusObserver}.\n     * If the {@link module:engine/view/observer/focusobserver~FocusObserver} is disabled this property will not change.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isFocused\n     */\n\n    this.set('isFocused', false);\n    /**\n     * True if composition is in progress inside the document.\n     *\n     * This property is updated by the {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n     * If the {@link module:engine/view/observer/compositionobserver~CompositionObserver} is disabled this property will not change.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isComposing\n     */\n\n    this.set('isComposing', false);\n    /**\n     * Post-fixer callbacks registered to the view document.\n     *\n     * @private\n     * @member {Set}\n     */\n\n    this._postFixers = new Set();\n  }\n  /**\n   * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not\n   * specific \"main\" root is returned.\n   *\n   * @param {String} [name='main'] Name of the root.\n   * @returns {module:engine/view/rooteditableelement~RootEditableElement|null} The view root element with the specified name\n   * or null when there is no root of given name.\n   */\n\n\n  _createClass(Document, [{\n    key: \"getRoot\",\n    value: function getRoot() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n      return this.roots.get(name);\n    }\n    /**\n     * Used to register a post-fixer callback. A post-fixers mechanism allows to update view tree just before rendering\n     * to the DOM.\n     *\n     * Post-fixers are fired just after all changes from the outermost change block were applied but\n     * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made\n     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n     * not be fixed in the new document tree state.\n     *\n     * View post-fixers are useful when you wants to update view structure whenever it changes, for instance add some classes\n     * to elements based on the view structure or selection. However, is you need DOM elements to be already updated, use\n     * {@link module:engine/view/view~View#event:render render event}.\n     *\n     * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}\n     * instance connected with the executed changes block.\n     *\n     * Note that registering a post-fixer won't re-render the editor's view. If the view should change after registering the post-fixer then\n     * it should be done manually calling `view.forceRender();`.\n     *\n     * @param {Function} postFixer\n     */\n\n  }, {\n    key: \"registerPostFixer\",\n    value: function registerPostFixer(postFixer) {\n      this._postFixers.add(postFixer);\n    }\n    /**\n     * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.roots.map(function (root) {\n        return root.destroy();\n      });\n      this.stopListening();\n    }\n    /**\n     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n     *\n     * @protected\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n     */\n\n  }, {\n    key: \"_callPostFixers\",\n    value: function _callPostFixers(writer) {\n      var wasFixed = false;\n\n      do {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this._postFixers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var callback = _step.value;\n            wasFixed = callback(writer);\n\n            if (wasFixed) {\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } while (wasFixed);\n    }\n    /**\n     * Event fired whenever document content layout changes. It is fired whenever content is\n     * {@link module:engine/view/view~View#event:render rendered}, but should be also fired by observers in case of\n     * other actions which may change layout, for instance when image loads.\n     *\n     * @event layoutChanged\n     */\n\n  }]);\n\n  return Document;\n}();\n\nexport { Document as default };\nmix(Document, ObservableMixin);\n/**\n * Enum representing type of the change.\n *\n * Possible values:\n *\n * * `children` - for child list changes,\n * * `attributes` - for element attributes changes,\n * * `text` - for text nodes changes.\n *\n * @typedef {String} module:engine/view/document~ChangeType\n */","import \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/attributeelement\n */\nimport Element from \"./element\";\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror'; // Default attribute priority.\n\nvar DEFAULT_PRIORITY = 10;\n/**\n * Attribute elements are used to represent formatting elements in the view (think  `<b>`, `<span style=\"font-size: 2em\">`, etc.).\n * Most often they are created when downcasting model text attributes.\n *\n * Editing engine does not define a fixed HTML DTD. This is why a feature developer needs to choose between various\n * types (container element, {@link module:engine/view/attributeelement~AttributeElement attribute element},\n * {@link module:engine/view/emptyelement~EmptyElement empty element}, etc) when developing a feature.\n *\n * To create a new attribute element instance use the\n * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement `DowncastWriter#createAttributeElement()`} method.\n *\n * @extends module:engine/view/element~Element\n */\n\nvar AttributeElement =\n/*#__PURE__*/\nfunction (_Element) {\n  _inherits(AttributeElement, _Element);\n\n  /**\n   * Creates an attribute element.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#createAttributeElement\n   * @see module:engine/view/element~Element\n   * @protected\n   */\n  function AttributeElement(name, attrs, children) {\n    var _this;\n\n    _classCallCheck(this, AttributeElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AttributeElement).call(this, name, attrs, children));\n    /**\n     * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n     *\n     * @method #getFillerOffset\n     * @returns {Number|null} Block filler offset or `null` if block filler is not needed.\n     */\n\n    _this.getFillerOffset = getFillerOffset;\n    /**\n     * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.\n     *\n     * @protected\n     * @member {Number}\n     */\n\n    _this._priority = DEFAULT_PRIORITY;\n    /**\n     * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},\n     * and then two elements are considered similar if, and only if they have the same `_id`.\n     *\n     * @protected\n     * @member {String|Number}\n     */\n\n    _this._id = null;\n    /**\n     * Keeps all the attribute elements that have the same {@link module:engine/view/attributeelement~AttributeElement#id ids}\n     * and still exist in the view tree.\n     *\n     * This property is managed by {@link module:engine/view/downcastwriter~DowncastWriter}.\n     *\n     * @protected\n     * @member {Set.<module:engine/view/attributeelement~AttributeElement>|null}\n     */\n\n    _this._clonesGroup = null;\n    return _this;\n  }\n  /**\n   * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  _createClass(AttributeElement, [{\n    key: \"getElementsWithSameId\",\n\n    /**\n     * Returns all {@link module:engine/view/attributeelement~AttributeElement attribute elements} that has the\n     * same {@link module:engine/view/attributeelement~AttributeElement#id id} and are in the view tree (were not removed).\n     *\n     * Note: If this element has been removed from the tree, returned set will not include it.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}\n     * if this element has no `id`.\n     *\n     * @returns {Set.<module:engine/view/attributeelement~AttributeElement>} Set containing all the attribute elements\n     * with the same `id` that were added and not removed from the view tree.\n     */\n    value: function getElementsWithSameId() {\n      if (this.id === null) {\n        /**\n         * Cannot get elements with the same id for an attribute element without id.\n         *\n         * @error attribute-element-get-elements-with-same-id-no-id\n         */\n        throw new CKEditorError('attribute-element-get-elements-with-same-id-no-id: ' + 'Cannot get elements with the same id for an attribute element without id.');\n      }\n\n      return new Set(this._clonesGroup);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!name) {\n        return type == 'attributeElement' || _get(_getPrototypeOf(AttributeElement.prototype), \"is\", this).call(this, type);\n      } else {\n        return type == 'attributeElement' && name == this.name || _get(_getPrototypeOf(AttributeElement.prototype), \"is\", this).call(this, type, name);\n      }\n    }\n    /**\n     * Checks if this element is similar to other element.\n     *\n     * If none of elements has set {@link module:engine/view/attributeelement~AttributeElement#id}, then both elements\n     * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain\n     * different set of children nodes.\n     *\n     * If at least one element has {@link module:engine/view/attributeelement~AttributeElement#id} set, then both\n     * elements have to have the same {@link module:engine/view/attributeelement~AttributeElement#id} value to be\n     * considered similar.\n     *\n     * Similarity is important for {@link module:engine/view/downcastwriter~DowncastWriter}. For example:\n     *\n     * * two following similar elements can be merged together into one, longer element,\n     * * {@link module:engine/view/downcastwriter~DowncastWriter#unwrap} checks similarity of passed element and processed element to\n     * decide whether processed element should be unwrapped,\n     * * etc.\n     *\n     * @param {module:engine/view/element~Element} otherElement\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSimilar\",\n    value: function isSimilar(otherElement) {\n      // If any element has an `id` set, just compare the ids.\n      if (this.id !== null || otherElement.id !== null) {\n        return this.id === otherElement.id;\n      }\n\n      return _get(_getPrototypeOf(AttributeElement.prototype), \"isSimilar\", this).call(this, otherElement) && this.priority == otherElement.priority;\n    }\n    /**\n     * Clones provided element with priority.\n     *\n     * @protected\n     * @param {Boolean} deep If set to `true` clones element and all its children recursively. When set to `false`,\n     * element will be cloned without any children.\n     * @returns {module:engine/view/attributeelement~AttributeElement} Clone of this element.\n     */\n\n  }, {\n    key: \"_clone\",\n    value: function _clone(deep) {\n      var cloned = _get(_getPrototypeOf(AttributeElement.prototype), \"_clone\", this).call(this, deep); // Clone priority too.\n\n\n      cloned._priority = this._priority; // And id too.\n\n      cloned._id = this._id;\n      return cloned;\n    }\n  }, {\n    key: \"priority\",\n    get: function get() {\n      return this._priority;\n    }\n    /**\n     * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},\n     * and then two elements are considered similar if, and only if they have the same `id`.\n     *\n     * @readonly\n     * @type {String|Number}\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n  }]);\n\n  return AttributeElement;\n}(Element);\n/**\n * Default attribute priority.\n *\n * @member {Number} module:engine/view/attributeelement~AttributeElement.DEFAULT_PRIORITY\n */\n\n\nexport { AttributeElement as default };\nAttributeElement.DEFAULT_PRIORITY = DEFAULT_PRIORITY; // Returns block {@link module:engine/view/filler~Filler filler} offset or `null` if block filler is not needed.\n//\n// @returns {Number|null} Block filler offset or `null` if block filler is not needed.\n\nfunction getFillerOffset() {\n  // <b>foo</b> does not need filler.\n  if (nonUiChildrenCount(this)) {\n    return null;\n  }\n\n  var element = this.parent; // <p><b></b></p> needs filler -> <p><b><br></b></p>\n\n  while (element && element.is('attributeElement')) {\n    if (nonUiChildrenCount(element) > 1) {\n      return null;\n    }\n\n    element = element.parent;\n  }\n\n  if (!element || nonUiChildrenCount(element) > 1) {\n    return null;\n  } // Render block filler at the end of element (after all ui elements).\n\n\n  return this.childCount;\n} // Returns total count of children that are not {@link module:engine/view/uielement~UIElement UIElements}.\n//\n// @param {module:engine/view/element~Element} element\n// @returns {Number}\n\n\nfunction nonUiChildrenCount(element) {\n  return Array.from(element.getChildren()).filter(function (element) {\n    return !element.is('uiElement');\n  }).length;\n}","import \"core-js/modules/es6.regexp.match\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals navigator:false */\n\n/**\n * @module utils/env\n */\nvar userAgent = navigator.userAgent.toLowerCase();\n/**\n * A namespace containing environment and browser information.\n *\n * @namespace\n */\n\nvar env = {\n  /**\n   * Indicates that the application is running on Macintosh.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  isMac: isMac(userAgent),\n\n  /**\n   * Indicates that the application is running in Microsoft Edge.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  isEdge: isEdge(userAgent),\n\n  /**\n   * Indicates that the application is running in Firefox (Gecko).\n   *\n   * @static\n   * @type {Boolean}\n   */\n  isGecko: isGecko(userAgent),\n\n  /**\n   * Indicates that the application is running in Safari.\n   *\n   * @static\n   * @type {Boolean}\n   */\n  isSafari: isSafari(userAgent)\n};\nexport default env;\n/**\n * Checks if User Agent represented by the string is running on Macintosh.\n *\n * @param {String} userAgent **Lowercase** `navigator.userAgent` string.\n * @returns {Boolean} Whether User Agent is running on Macintosh or not.\n */\n\nexport function isMac(userAgent) {\n  return userAgent.indexOf('macintosh') > -1;\n}\n/**\n * Checks if User Agent represented by the string is Microsoft Edge.\n *\n * @param {String} userAgent **Lowercase** `navigator.userAgent` string.\n * @returns {Boolean} Whether User Agent is Edge or not.\n */\n\nexport function isEdge(userAgent) {\n  return !!userAgent.match(/edge\\/(\\d+.?\\d*)/);\n}\n/**\n * Checks if User Agent represented by the string is Firefox (Gecko).\n *\n * @param {String} userAgent **Lowercase** `navigator.userAgent` string.\n * @returns {Boolean} Whether User Agent is Firefox or not.\n */\n\nexport function isGecko(userAgent) {\n  return !!userAgent.match(/gecko\\/\\d+/);\n}\n/**\n * Checks if User Agent represented by the string is Safari.\n *\n * @param {String} userAgent **Lowercase** `navigator.userAgent` string.\n * @returns {Boolean} Whether User Agent is Safari or not.\n */\n\nexport function isSafari(userAgent) {\n  return userAgent.indexOf(' applewebkit/') > -1 && userAgent.indexOf('chrome') === -1;\n}","import \"core-js/modules/es6.regexp.split\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Set of utils related to keyboard support.\n *\n * @module utils/keyboard\n */\nimport CKEditorError from \"./ckeditorerror\";\nimport env from \"./env\";\nvar macGlyphsToModifiers = {\n  '': 'ctrl',\n  '': 'shift',\n  '': 'alt'\n};\nvar modifiersToMacGlyphs = {\n  'ctrl': '',\n  'shift': '',\n  'alt': ''\n};\n/**\n * Object with `keyName => keyCode` pairs for a set of known keys.\n *\n * Contains:\n *\n * * `a-z`,\n * * `0-9`,\n * * `f1-f12`,\n * * `arrow(left|up|right|bottom)`,\n * * `backspace`, `delete`, `enter`, `esc`, `tab`,\n * * `ctrl`, `cmd`, `shift`, `alt`.\n */\n\nexport var keyCodes = generateKnownKeyCodes();\n/**\n * Converts a key name or a {@link module:utils/keyboard~KeystrokeInfo keystroke info} into a key code.\n *\n * Note: Key names are matched with {@link module:utils/keyboard~keyCodes} in a case-insensitive way.\n *\n * @param {String|module:utils/keyboard~KeystrokeInfo} Key name (see {@link module:utils/keyboard~keyCodes})\n * or a keystroke data object.\n * @returns {Number} Key or keystroke code.\n */\n\nexport function getCode(key) {\n  var keyCode;\n\n  if (typeof key == 'string') {\n    keyCode = keyCodes[key.toLowerCase()];\n\n    if (!keyCode) {\n      /**\n       * Unknown key name. Only key names contained by the {@link module:utils/keyboard~keyCodes} can be used.\n       *\n       * @errror keyboard-unknown-key\n       * @param {String} key\n       */\n      throw new CKEditorError('keyboard-unknown-key: Unknown key name.', {\n        key: key\n      });\n    }\n  } else {\n    keyCode = key.keyCode + (key.altKey ? keyCodes.alt : 0) + (key.ctrlKey ? keyCodes.ctrl : 0) + (key.shiftKey ? keyCodes.shift : 0);\n  }\n\n  return keyCode;\n}\n/**\n * Parses keystroke and returns a keystroke code that will match the code returned by\n * link {@link module:utils/keyboard.getCode} for a corresponding {@link module:utils/keyboard~KeystrokeInfo keystroke info}.\n *\n * The keystroke can be passed in two formats:\n *\n * * as a single string  e.g. `ctrl + A`,\n * * as an array of {@link module:utils/keyboard~keyCodes known key names} and key codes  e.g.:\n *   * `[ 'ctrl', 32 ]` (ctrl + space),\n *   * `[ 'ctrl', 'a' ]` (ctrl + A).\n *\n * Note: Key names are matched with {@link module:utils/keyboard~keyCodes} in a case-insensitive way.\n *\n * Note: Only keystrokes with a single non-modifier key are supported (e.g. `ctrl+A` is OK, but `ctrl+A+B` is not).\n *\n * @param {String|Array.<Number|String>} keystroke Keystroke definition.\n * @returns {Number} Keystroke code.\n */\n\nexport function parseKeystroke(keystroke) {\n  if (typeof keystroke == 'string') {\n    keystroke = splitKeystrokeText(keystroke);\n  }\n\n  return keystroke.map(function (key) {\n    return typeof key == 'string' ? getCode(key) : key;\n  }).reduce(function (key, sum) {\n    return sum + key;\n  }, 0);\n}\n/**\n * It translates any keystroke string text like `\"CTRL+A\"` to an\n * environmentspecific keystroke, i.e. `\"A\"` on Mac OSX.\n *\n * @param {String} keystroke Keystroke text.\n * @returns {String} Keystroke text specific for the environment.\n */\n\nexport function getEnvKeystrokeText(keystroke) {\n  if (!env.isMac) {\n    return keystroke;\n  }\n\n  return splitKeystrokeText(keystroke) // Replace modifiers (e.g. \"ctrl\") with Mac glyphs (e.g. \"\") first.\n  .map(function (key) {\n    return modifiersToMacGlyphs[key.toLowerCase()] || key;\n  }) // Decide whether to put \"+\" between keys in the keystroke or not.\n  .reduce(function (value, key) {\n    if (value.slice(-1) in macGlyphsToModifiers) {\n      return value + key;\n    } else {\n      return value + '+' + key;\n    }\n  });\n}\n\nfunction generateKnownKeyCodes() {\n  var keyCodes = {\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    backspace: 8,\n    delete: 46,\n    enter: 13,\n    space: 32,\n    esc: 27,\n    tab: 9,\n    // The idea about these numbers is that they do not collide with any real key codes, so we can use them\n    // like bit masks.\n    ctrl: 0x110000,\n    // Has the same code as ctrl, because their behaviour should be unified across the editor.\n    // See http://ckeditor.github.io/editor-recommendations/general-policies#ctrl-vs-cmd\n    cmd: 0x110000,\n    shift: 0x220000,\n    alt: 0x440000\n  }; // a-z\n\n  for (var code = 65; code <= 90; code++) {\n    var letter = String.fromCharCode(code);\n    keyCodes[letter.toLowerCase()] = code;\n  } // 0-9\n\n\n  for (var _code = 48; _code <= 57; _code++) {\n    keyCodes[_code - 48] = _code;\n  } // F1-F12\n\n\n  for (var _code2 = 112; _code2 <= 123; _code2++) {\n    keyCodes['f' + (_code2 - 111)] = _code2;\n  }\n\n  return keyCodes;\n}\n\nfunction splitKeystrokeText(keystroke) {\n  return keystroke.split(/\\s*\\+\\s*/);\n}\n/**\n * Information about a keystroke.\n *\n * @interface module:utils/keyboard~KeystrokeInfo\n */\n\n/**\n * The [key code](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode).\n *\n * @member {Number} module:utils/keyboard~KeystrokeInfo#keyCode\n */\n\n/**\n * Whether the <kbd>Alt</kbd> modifier was pressed.\n *\n * @member {Bolean} module:utils/keyboard~KeystrokeInfo#altKey\n */\n\n/**\n * Whether the <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> modifier was pressed.\n *\n * @member {Bolean} module:utils/keyboard~KeystrokeInfo#ctrlKey\n */\n\n/**\n * Whether the <kbd>Shift</kbd> modifier was pressed.\n *\n * @member {Bolean} module:utils/keyboard~KeystrokeInfo#shiftKey\n */","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/uielement\n */\nimport Element from \"./element\";\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Node from \"./node\";\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n/**\n * UI element class. It should be used to represent editing UI which needs to be injected into the editing view\n * If possible, you should keep your UI outside the editing view. However, if that is not possible,\n * UI elements can be used.\n *\n * How a UI element is rendered is in your control (you pass a callback to\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}).\n * The editor will ignore your UI element  the selection cannot be placed in it, it is skipped (invisible) when\n * the user modifies the selection by using arrow keys and the editor does not listen to any mutations which\n * happen inside your UI elements.\n *\n * The limitation is that you cannot convert a model element to a UI element. UI elements need to be\n * created for {@link module:engine/model/markercollection~Marker markers} or as additinal elements\n * inside normal {@link module:engine/view/containerelement~ContainerElement container elements}.\n *\n * To create a new UI element use the\n * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`} method.\n *\n * @extends module:engine/view/element~Element\n */\n\nvar UIElement =\n/*#__PURE__*/\nfunction (_Element) {\n  _inherits(UIElement, _Element);\n\n  /**\n   * Creates new instance of UIElement.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,\n   * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement\n   * @protected\n   * @param {String} name Node name.\n   * @param {Object|Iterable} [attributes] Collection of attributes.\n   */\n  function UIElement(name, attributes, children) {\n    var _this;\n\n    _classCallCheck(this, UIElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(UIElement).call(this, name, attributes, children));\n    /**\n     * Returns `null` because filler is not needed for UIElements.\n     *\n     * @method #getFillerOffset\n     * @returns {null} Always returns null.\n     */\n\n    _this.getFillerOffset = getFillerOffset;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(UIElement, [{\n    key: \"is\",\n    value: function is(type) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!name) {\n        return type == 'uiElement' || _get(_getPrototypeOf(UIElement.prototype), \"is\", this).call(this, type);\n      } else {\n        return type == 'uiElement' && name == this.name || _get(_getPrototypeOf(UIElement.prototype), \"is\", this).call(this, type, name);\n      }\n    }\n    /**\n     * Overrides {@link module:engine/view/element~Element#_insertChild} method.\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes\n     * to UIElement.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_insertChild\",\n    value: function _insertChild(index, nodes) {\n      if (nodes && (nodes instanceof Node || Array.from(nodes).length > 0)) {\n        /**\n         * Cannot add children to {@link module:engine/view/uielement~UIElement}.\n         *\n         * @error view-uielement-cannot-add\n         */\n        throw new CKEditorError('view-uielement-cannot-add: Cannot add child nodes to UIElement instance.');\n      }\n    }\n    /**\n     * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by\n     * {@link module:engine/view/domconverter~DomConverter}.\n     * Do not use inheritance to create custom rendering method, replace `render()` method instead:\n     *\n     *\t\tconst myUIElement = downcastWriter.createUIElement( 'span' );\n     *\t\tmyUIElement.render = function( domDocument ) {\n     *\t\t\tconst domElement = this.toDomElement( domDocument );\n     *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n     *\n     *\t\t\treturn domElement;\n     *\t\t};\n     *\n     * @param {Document} domDocument\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(domDocument) {\n      return this.toDomElement(domDocument);\n    }\n    /**\n     * Creates DOM element based on this view UIElement.\n     * Note that each time this method is called new DOM element is created.\n     *\n     * @param {Document} domDocument\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"toDomElement\",\n    value: function toDomElement(domDocument) {\n      var domElement = domDocument.createElement(this.name);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.getAttributeKeys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          domElement.setAttribute(key, this.getAttribute(key));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return domElement;\n    }\n  }]);\n\n  return UIElement;\n}(Element);\n/**\n * This function injects UI element handling to the given {@link module:engine/view/document~Document document}.\n *\n * A callback is added to {@link module:engine/view/document~Document#event:keydown document keydown event}.\n * The callback handles the situation when right arrow key is pressed and selection is collapsed before a UI element.\n * Without this handler, it would be impossible to \"jump over\" UI element using right arrow key.\n *\n * @param {module:engine/view/view~View} view View controller to which the quirks handling will be injected.\n */\n\n\nexport { UIElement as default };\nexport function injectUiElementHandling(view) {\n  view.document.on('keydown', function (evt, data) {\n    return jumpOverUiElement(evt, data, view.domConverter);\n  });\n} // Returns `null` because block filler is not needed for UIElements.\n//\n// @returns {null}\n\nfunction getFillerOffset() {\n  return null;\n} // Selection cannot be placed in a `UIElement`. Whenever it is placed there, it is moved before it. This\n// causes a situation when it is impossible to jump over `UIElement` using right arrow key, because the selection\n// ends up in ui element (in DOM) and is moved back to the left. This handler fixes this situation.\n\n\nfunction jumpOverUiElement(evt, data, domConverter) {\n  if (data.keyCode == keyCodes.arrowright) {\n    var domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n    var domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed; // Jump over UI element if selection is collapsed or shift key is pressed. These are the cases when selection would extend.\n\n    if (domSelectionCollapsed || data.shiftKey) {\n      var domParent = domSelection.focusNode;\n      var domOffset = domSelection.focusOffset;\n      var viewPosition = domConverter.domPositionToView(domParent, domOffset); // In case if dom element is not converted to view or is not mapped or something. Happens for example in some tests.\n\n      if (viewPosition === null) {\n        return;\n      } // Skip all following ui elements.\n\n\n      var jumpedOverAnyUiElement = false;\n      var nextViewPosition = viewPosition.getLastMatchingPosition(function (value) {\n        if (value.item.is('uiElement')) {\n          // Remember that there was at least one ui element.\n          jumpedOverAnyUiElement = true;\n        } // Jump over ui elements, jump over empty attribute elements, move up from inside of attribute element.\n\n\n        if (value.item.is('uiElement') || value.item.is('attributeElement')) {\n          return true;\n        } // Don't jump over text or don't get out of container element.\n\n\n        return false;\n      }); // If anything has been skipped, fix position.\n      // This `if` could be possibly omitted but maybe it is better not to mess with DOM selection if not needed.\n\n      if (jumpedOverAnyUiElement) {\n        var newDomPosition = domConverter.viewPositionToDom(nextViewPosition);\n\n        if (domSelectionCollapsed) {\n          // Selection was collapsed, so collapse it at further position.\n          domSelection.collapse(newDomPosition.parent, newDomPosition.offset);\n        } else {\n          // Selection was not collapse, so extend it instead of collapsing.\n          domSelection.extend(newDomPosition.parent, newDomPosition.offset);\n        }\n      }\n    }\n  }\n}","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/documentfragment\n */\nimport Text from \"./text\";\nimport TextProxy from \"./textproxy\";\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n/**\n * Document fragment.\n *\n * To create a new document fragment instance use the\n * {@link module:engine/view/upcastwriter~UpcastWriter#createDocumentFragment `UpcastWriter#createDocumentFragment()`}\n * method.\n */\n\nvar DocumentFragment =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates new DocumentFragment instance.\n   *\n   * @protected\n   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n   * A list of nodes to be inserted into the created document fragment.\n   */\n  function DocumentFragment(children) {\n    _classCallCheck(this, DocumentFragment);\n\n    /**\n     * Array of child nodes.\n     *\n     * @protected\n     * @member {Array.<module:engine/view/element~Element>} module:engine/view/documentfragment~DocumentFragment#_children\n     */\n    this._children = [];\n\n    if (children) {\n      this._insertChild(0, children);\n    }\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over nodes added to this document fragment.\n   *\n   * @returns {Iterable.<module:engine/view/node~Node>}\n   */\n\n\n  _createClass(DocumentFragment, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this._children[Symbol.iterator]();\n    }\n    /**\n     * Number of child nodes in this document fragment.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n  }, {\n    key: \"is\",\n\n    /**\n     * Checks whether given view tree object is of given type.\n     *\n     * Read more in {@link module:engine/view/node~Node#is}.\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n    value: function is(type) {\n      return type == 'documentFragment';\n    }\n    /**\n     * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end\n     * and sets the parent of these nodes to this fragment.\n     *\n     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n     * @returns {Number} Number of appended nodes.\n     */\n\n  }, {\n    key: \"_appendChild\",\n    value: function _appendChild(items) {\n      return this._insertChild(this.childCount, items);\n    }\n    /**\n     * Gets child at the given index.\n     *\n     * @param {Number} index Index of child.\n     * @returns {module:engine/view/node~Node} Child node.\n     */\n\n  }, {\n    key: \"getChild\",\n    value: function getChild(index) {\n      return this._children[index];\n    }\n    /**\n     * Gets index of the given child node. Returns `-1` if child node is not found.\n     *\n     * @param {module:engine/view/node~Node} node Child node.\n     * @returns {Number} Index of the child node.\n     */\n\n  }, {\n    key: \"getChildIndex\",\n    value: function getChildIndex(node) {\n      return this._children.indexOf(node);\n    }\n    /**\n     * Gets child nodes iterator.\n     *\n     * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this._children[Symbol.iterator]();\n    }\n    /**\n     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n     * this fragment.\n     *\n     * @param {Number} index Position where nodes should be inserted.\n     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n     * @returns {Number} Number of inserted nodes.\n     */\n\n  }, {\n    key: \"_insertChild\",\n    value: function _insertChild(index, items) {\n      this._fireChange('children', this);\n\n      var count = 0;\n      var nodes = normalize(items);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var node = _step.value;\n\n          // If node that is being added to this element is already inside another element, first remove it from the old parent.\n          if (node.parent !== null) {\n            node._remove();\n          }\n\n          node.parent = this;\n\n          this._children.splice(index, 0, node);\n\n          index++;\n          count++;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return count;\n    }\n    /**\n     * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n     *\n     * @param {Number} index Number of the first node to remove.\n     * @param {Number} [howMany=1] Number of nodes to remove.\n     * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n     */\n\n  }, {\n    key: \"_removeChildren\",\n    value: function _removeChildren(index) {\n      var howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      this._fireChange('children', this);\n\n      for (var i = index; i < index + howMany; i++) {\n        this._children[i].parent = null;\n      }\n\n      return this._children.splice(index, howMany);\n    }\n    /**\n     * Fires `change` event with given type of the change.\n     *\n     * @private\n     * @param {module:engine/view/document~ChangeType} type Type of the change.\n     * @param {module:engine/view/node~Node} node Changed node.\n     * @fires module:engine/view/node~Node#change\n     */\n\n  }, {\n    key: \"_fireChange\",\n    value: function _fireChange(type, node) {\n      this.fire('change:' + type, node);\n    }\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this._children.length;\n    }\n    /**\n     * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.childCount === 0;\n    }\n    /**\n     * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n     *\n     * @readonly\n     * @type {module:engine/model/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this;\n    }\n    /**\n     * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n     *\n     * @readonly\n     * @type {null}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return null;\n    }\n  }]);\n\n  return DocumentFragment;\n}();\n\nexport { DocumentFragment as default };\nmix(DocumentFragment, EmitterMixin); // Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\n\nfunction normalize(nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(nodes)];\n  }\n\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  } // Array.from to enable .map() on non-arrays.\n\n\n  return Array.from(nodes).map(function (node) {\n    if (typeof node == 'string') {\n      return new Text(node);\n    }\n\n    if (node instanceof TextProxy) {\n      return new Text(node.data);\n    }\n\n    return node;\n  });\n}","import \"core-js/modules/es6.regexp.to-string\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/istext\n */\n\n/**\n * Checks if the object is a native DOM Text node.\n *\n * @param {*} obj\n * @returns {Boolean}\n */\nexport default function isText(obj) {\n  return Object.prototype.toString.call(obj) == '[object Text]';\n}","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.weak-map\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals window */\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\n/**\n * Set of utils related to block and inline fillers handling.\n *\n * Browsers do not allow to put caret in elements which does not have height. Because of it, we need to fill all\n * empty elements which should be selectable with elements or characters called \"fillers\". Unfortunately there is no one\n * universal filler, this is why two types are uses:\n *\n * * Block filler is an element which fill block elements, like `<p>`. CKEditor uses `<br>` as a block filler during the editing,\n * as browsers do natively. So instead of an empty `<p>` there will be `<p><br></p>`. The advantage of block filler is that\n * it is transparent for the selection, so when the caret is before the `<br>` and user presses right arrow he will be\n * moved to the next paragraph, not after the `<br>`. The disadvantage is that it breaks a block, so it can not be used\n * in the middle of a line of text. The {@link module:engine/view/filler~BR_FILLER `<br>` filler} can be replaced with any other\n * character in the data output, for instance {@link module:engine/view/filler~NBSP_FILLER non-breaking space}.\n *\n * * Inline filler is a filler which does not break a line of text, so it can be used inside the text, for instance in the empty\n * `<b>` surrendered by text: `foo<b></b>bar`, if we want to put the caret there. CKEditor uses a sequence of the zero-width\n * spaces as an {@link module:engine/view/filler~INLINE_FILLER inline filler} having the predetermined\n * {@link module:engine/view/filler~INLINE_FILLER_LENGTH length}. A sequence is used, instead of a single character to\n * avoid treating random zero-width spaces as the inline filler. Disadvantage of the inline filler is that it is not\n * transparent for the selection. The arrow key moves the caret between zero-width spaces characters, so the additional\n * code is needed to handle the caret.\n *\n * Both inline and block fillers are handled by the {@link module:engine/view/renderer~Renderer renderer} and are not present in the\n * view.\n *\n * @module engine/view/filler\n */\n\n/**\n * `<br>` filler creator. This is a function which creates `<br data-cke-filler=\"true\">` element.\n * It defines how the filler is created.\n *\n * @see module:engine/view/filler~NBSP_FILLER\n * @function\n */\n\nexport var BR_FILLER = function BR_FILLER(domDocument) {\n  var fillerBr = domDocument.createElement('br');\n  fillerBr.dataset.ckeFiller = true;\n  return fillerBr;\n};\n/**\n * Non-breaking space filler creator. This is a function which creates `&nbsp;` text node.\n * It defines how the filler is created.\n *\n * @see module:engine/view/filler~BR_FILLER\n * @function\n */\n\nexport var NBSP_FILLER = function NBSP_FILLER(domDocument) {\n  return domDocument.createTextNode(\"\\xA0\");\n};\n/**\n * Length of the {@link module:engine/view/filler~INLINE_FILLER INLINE_FILLER}.\n */\n\nexport var INLINE_FILLER_LENGTH = 7;\n/**\n * Inline filler which is sequence of the zero width spaces.\n */\n\nexport var INLINE_FILLER = '';\n\nfor (var i = 0; i < INLINE_FILLER_LENGTH; i++) {\n  INLINE_FILLER += \"\\u200B\";\n}\n/**\n * Checks if the node is a text node which starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n *\n *\t\tstartsWithFiller( document.createTextNode( INLINE_FILLER ) ); // true\n *\t\tstartsWithFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // true\n *\t\tstartsWithFiller( document.createTextNode( 'foo' ) ); // false\n *\t\tstartsWithFiller( document.createElement( 'p' ) ); // false\n *\n * @param {Node} domNode DOM node.\n * @returns {Boolean} True if the text node starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\n\n\nexport function startsWithFiller(domNode) {\n  return isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;\n}\n/**\n * Checks if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n *\n *\t\tisInlineFiller( document.createTextNode( INLINE_FILLER ) ); // true\n *\t\tisInlineFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // false\n *\n * @param {Text} domText DOM text node.\n * @returns {Boolean} True if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\n\nexport function isInlineFiller(domText) {\n  return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);\n}\n/**\n * Get string data from the text node, removing an {@link module:engine/view/filler~INLINE_FILLER inline filler} from it,\n * if text node contains it.\n *\n *\t\tgetDataWithoutFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ) == 'foo' // true\n *\t\tgetDataWithoutFiller( document.createTextNode( 'foo' ) ) == 'foo' // true\n *\n * @param {Text} domText DOM text node, possible with inline filler.\n * @returns {String} Data without filler.\n */\n\nexport function getDataWithoutFiller(domText) {\n  if (startsWithFiller(domText)) {\n    return domText.data.slice(INLINE_FILLER_LENGTH);\n  } else {\n    return domText.data;\n  }\n} // Cache block fillers templates to improve performance.\n\nvar templateBlockFillers = new WeakMap();\n/**\n * Checks if the node is an instance of the block filler of the given type.\n *\n *\t\tconst brFillerInstance = BR_FILLER( document );\n *\t\tisBlockFiller( brFillerInstance, BR_FILLER ); // true\n *\n * @param {Node} domNode DOM node to check.\n * @param {Function} blockFiller Block filler creator.\n * @returns {Boolean} True if text node contains only {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\n\nexport function isBlockFiller(domNode, blockFiller) {\n  var templateBlockFiller = templateBlockFillers.get(blockFiller);\n\n  if (!templateBlockFiller) {\n    templateBlockFiller = blockFiller(window.document);\n    templateBlockFillers.set(blockFiller, templateBlockFiller);\n  }\n\n  return domNode.isEqualNode(templateBlockFiller);\n}\n/**\n * Assign key observer which move cursor from the end of the inline filler to the beginning of it when\n * the left arrow is pressed, so the filler does not break navigation.\n *\n * @param {module:engine/view/view~View} view View controller instance we should inject quirks handling on.\n */\n\nexport function injectQuirksHandling(view) {\n  view.document.on('keydown', jumpOverInlineFiller);\n} // Move cursor from the end of the inline filler to the beginning of it when, so the filler does not break navigation.\n\nfunction jumpOverInlineFiller(evt, data) {\n  if (data.keyCode == keyCodes.arrowleft) {\n    var domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n\n    if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {\n      var domParent = domSelection.getRangeAt(0).startContainer;\n      var domOffset = domSelection.getRangeAt(0).startOffset;\n\n      if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {\n        domSelection.collapse(domParent, 0);\n      }\n    }\n  }\n}","import \"core-js/modules/es6.array.fill\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/fastdiff\n */\n\n/**\n * Finds positions of the first and last change in the given string/array and generates a set of changes:\n *\n *\t\tfastDiff( '12a', '12xyza' );\n *\t\t// [ { index: 2, type: 'insert', values: [ 'x', 'y', 'z' ] } ]\n *\n *\t\tfastDiff( '12a', '12aa' );\n *\t\t// [ { index: 3, type: 'insert', values: [ 'a' ] } ]\n *\n *\t\tfastDiff( '12xyza', '12a' );\n *\t\t// [ { index: 2, type: 'delete', howMany: 3 } ]\n *\n *\t\tfastDiff( [ '1', '2', 'a', 'a' ], [ '1', '2', 'a' ] );\n *\t\t// [ { index: 3, type: 'delete', howMany: 1 } ]\n *\n *\t\tfastDiff( [ '1', '2', 'a', 'b', 'c', '3' ], [ '2', 'a', 'b' ] );\n *\t\t// [ { index: 0, type: 'insert', values: [ '2', 'a', 'b' ] }, { index: 3, type: 'delete', howMany: 6 } ]\n *\n * Passed arrays can contain any type of data, however to compare them correctly custom comparator function\n * should be passed as a third parameter:\n *\n *\t\tfastDiff( [ { value: 1 }, { value: 2 } ], [ { value: 1 }, { value: 3 } ], ( a, b ) => {\n *\t\t\treturn a.value === b.value;\n *\t\t} );\n *\t\t// [ { index: 1, type: 'insert', values: [ { value: 3 } ] }, { index: 2, type: 'delete', howMany: 1 } ]\n *\n * The resulted set of changes can be applied to the input in order to transform it into the output, for example:\n *\n *\t\tlet input = '12abc3';\n *\t\tconst output = '2ab';\n *\t\tconst changes = fastDiff( input, output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + change.values.join( '' ) + input.substring( change.index );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + input.substring( change.index + change.howMany );\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// input equals output now\n *\n * or in case of arrays:\n *\n *\t\tlet input = [ '1', '2', 'a', 'b', 'c', '3' ];\n *\t\tconst output = [ '2', 'a', 'b' ];\n *\t\tconst changes = fastDiff( input, output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput = input.slice( 0, change.index ).concat( change.values, input.slice( change.index ) );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput = input.slice( 0, change.index ).concat( input.slice( change.index + change.howMany ) );\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// input equals output now\n *\n * By passing `true` as the fourth parameter (`atomicChanges`) the output of this function will become compatible with\n * the {@link module:utils/diff~diff `diff()`} function:\n *\n *\t\tfastDiff( '12a', '12xyza' );\n *\t\t// [ 'equal', 'equal', 'insert', 'insert', 'insert', 'equal' ]\n *\n * The default output format of this function is compatible with the output format of\n * {@link module:utils/difftochanges~diffToChanges `diffToChanges()`}. The `diffToChanges()` input format is, in turn,\n * compatible with the output of {@link module:utils/diff~diff `diff()`}:\n *\n *\t\tconst a = '1234';\n *\t\tconst b = '12xyz34';\n *\n *\t\t// Both calls will return the same results (grouped changes format).\n *\t\tfastDiff( a, b );\n *\t\tdiffToChanges( diff( a, b ) );\n *\n *\t\t// Again, both calls will return the same results (atomic changes format).\n *\t\tfastDiff( a, b, null, true );\n *\t\tdiff( a, b );\n *\n *\n * @param {Array|String} a Input array or string.\n * @param {Array|String} b Input array or string.\n * @param {Function} [cmp] Optional function used to compare array values, by default `===` (strict equal operator) is used.\n * @param {Boolean} [atomicChanges=false] Whether an array of `inset|delete|equal` operations should\n * be returned instead of changes set. This makes this function compatible with {@link module:utils/diff~diff `diff()`}.\n * @returns {Array} Array of changes.\n */\nexport default function fastDiff(a, b, cmp) {\n  var atomicChanges = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  // Set the comparator function.\n  cmp = cmp || function (a, b) {\n    return a === b;\n  }; // Transform text or any iterable into arrays for easier, consistent processing.\n\n\n  if (!Array.isArray(a)) {\n    a = Array.from(a);\n  }\n\n  if (!Array.isArray(b)) {\n    b = Array.from(b);\n  } // Find first and last change.\n\n\n  var changeIndexes = findChangeBoundaryIndexes(a, b, cmp); // Transform into changes array.\n\n  return atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, b.length) : changeIndexesToChanges(b, changeIndexes);\n} // Finds position of the first and last change in the given arrays. For example:\n//\n//\t\tconst indexes = findChangeBoundaryIndexes( [ '1', '2', '3', '4' ], [ '1', '3', '4', '2', '4' ] );\n//\t\tconsole.log( indexes ); // { firstIndex: 1, lastIndexOld: 3, lastIndexNew: 4 }\n//\n// The above indexes means that in the first array the modified part is `1[23]4` and in the second array it is `1[342]4`.\n// Based on such indexes, array with `insert`/`delete` operations which allows transforming first value into the second one\n// can be generated.\n//\n// @param {Array} arr1\n// @param {Array} arr2\n// @param {Function} cmp Comparator function.\n// @returns {Object}\n// @returns {Number} return.firstIndex Index of the first change in both values (always the same for both).\n// @returns {Number} result.lastIndexOld Index of the last common value in `arr1`.\n// @returns {Number} result.lastIndexNew Index of the last common value in `arr2`.\n\nfunction findChangeBoundaryIndexes(arr1, arr2, cmp) {\n  // Find the first difference between passed values.\n  var firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp); // If arrays are equal return -1 indexes object.\n\n  if (firstIndex === -1) {\n    return {\n      firstIndex: -1,\n      lastIndexOld: -1,\n      lastIndexNew: -1\n    };\n  } // Remove the common part of each value and reverse them to make it simpler to find the last difference between them.\n\n\n  var oldArrayReversed = cutAndReverse(arr1, firstIndex);\n  var newArrayReversed = cutAndReverse(arr2, firstIndex); // Find the first difference between reversed values.\n  // It should be treated as \"how many elements from the end the last difference occurred\".\n  //\n  // For example:\n  //\n  // \t\t\t\tinitial\t->\tafter cut\t-> reversed:\n  // oldValue:\t'321ba'\t->\t'21ba'\t\t-> 'ab12'\n  // newValue:\t'31xba'\t->\t'1xba'\t\t-> 'abx1'\n  // lastIndex:\t\t\t\t\t\t\t-> 2\n  //\n  // So the last change occurred two characters from the end of the arrays.\n\n  var lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp); // Use `lastIndex` to calculate proper offset, starting from the beginning (`lastIndex` kind of starts from the end).\n\n  var lastIndexOld = arr1.length - lastIndex;\n  var lastIndexNew = arr2.length - lastIndex;\n  return {\n    firstIndex: firstIndex,\n    lastIndexOld: lastIndexOld,\n    lastIndexNew: lastIndexNew\n  };\n} // Returns a first index on which given arrays differ. If both arrays are the same, -1 is returned.\n//\n// @param {Array} arr1\n// @param {Array} arr2\n// @param {Function} cmp Comparator function.\n// @returns {Number}\n\n\nfunction findFirstDifferenceIndex(arr1, arr2, cmp) {\n  for (var i = 0; i < Math.max(arr1.length, arr2.length); i++) {\n    if (arr1[i] === undefined || arr2[i] === undefined || !cmp(arr1[i], arr2[i])) {\n      return i;\n    }\n  }\n\n  return -1; // Return -1 if arrays are equal.\n} // Returns a copy of the given array with `howMany` elements removed starting from the beginning and in reversed order.\n//\n// @param {Array} arr Array to be processed.\n// @param {Number} howMany How many elements from array beginning to remove.\n// @returns {Array} Shortened and reversed array.\n\n\nfunction cutAndReverse(arr, howMany) {\n  return arr.slice(howMany).reverse();\n} // Generates changes array based on change indexes from `findChangeBoundaryIndexes` function. This function will\n// generate array with 0 (no changes), 1 (deletion or insertion) or 2 records (insertion and deletion).\n//\n// @param {Array} newArray New array for which change indexes were calculated.\n// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.\n// @returns {Array.<Object>} Array of changes compatible with {@link module:utils/difftochanges~diffToChanges} format.\n\n\nfunction changeIndexesToChanges(newArray, changeIndexes) {\n  var result = [];\n  var firstIndex = changeIndexes.firstIndex,\n      lastIndexOld = changeIndexes.lastIndexOld,\n      lastIndexNew = changeIndexes.lastIndexNew; // Order operations as 'insert', 'delete' array to keep compatibility with {@link module:utils/difftochanges~diffToChanges}\n  // in most cases. However, 'diffToChanges' does not stick to any order so in some cases\n  // (for example replacing '12345' with 'abcd') it will generate 'delete', 'insert' order.\n\n  if (lastIndexNew - firstIndex > 0) {\n    result.push({\n      index: firstIndex,\n      type: 'insert',\n      values: newArray.slice(firstIndex, lastIndexNew)\n    });\n  }\n\n  if (lastIndexOld - firstIndex > 0) {\n    result.push({\n      index: firstIndex + (lastIndexNew - firstIndex),\n      // Increase index of what was inserted.\n      type: 'delete',\n      howMany: lastIndexOld - firstIndex\n    });\n  }\n\n  return result;\n} // Generates array with set `equal|insert|delete` operations based on change indexes from `findChangeBoundaryIndexes` function.\n//\n// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.\n// @param {Number} newLength Length of the new array on which `findChangeBoundaryIndexes` calculated change indexes.\n// @returns {Array.<String>} Array of changes compatible with {@link module:utils/diff~diff} format.\n\n\nfunction changeIndexesToAtomicChanges(changeIndexes, newLength) {\n  var firstIndex = changeIndexes.firstIndex,\n      lastIndexOld = changeIndexes.lastIndexOld,\n      lastIndexNew = changeIndexes.lastIndexNew; // No changes.\n\n  if (firstIndex === -1) {\n    return Array(newLength).fill('equal');\n  }\n\n  var result = [];\n\n  if (firstIndex > 0) {\n    result = result.concat(Array(firstIndex).fill('equal'));\n  }\n\n  if (lastIndexNew - firstIndex > 0) {\n    result = result.concat(Array(lastIndexNew - firstIndex).fill('insert'));\n  }\n\n  if (lastIndexOld - firstIndex > 0) {\n    result = result.concat(Array(lastIndexOld - firstIndex).fill('delete'));\n  }\n\n  if (lastIndexNew < newLength) {\n    result = result.concat(Array(newLength - lastIndexNew).fill('equal'));\n  }\n\n  return result;\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/diff\n */\nimport fastDiff from \"../src/fastdiff\"; // The following code is based on the \"O(NP) Sequence Comparison Algorithm\"\n// by Sun Wu, Udi Manber, Gene Myers, Webb Miller.\n\n/**\n * Calculates the difference between two arrays or strings producing an array containing a list of changes\n * necessary to transform input into output.\n *\n *\t\tdiff( 'aba', 'acca' ); // [ 'equal', 'insert', 'insert', 'delete', 'equal' ]\n *\n * This function is based on the \"O(NP) Sequence Comparison Algorithm\" by Sun Wu, Udi Manber, Gene Myers, Webb Miller.\n * Unfortunately, while it gives the most precise results, its to complex for longer strings/arrow (above 200 items).\n * Therefore, `diff()` automatically switches to {@link module:utils/fastdiff~fastDiff `fastDiff()`} when detecting\n * such a scenario. The return formats of both functions are identical.\n *\n * @param {Array|String} a Input array or string.\n * @param {Array|String} b Output array or string.\n * @param {Function} [cmp] Optional function used to compare array values, by default === is used.\n * @returns {Array} Array of changes.\n */\n\nexport default function diff(a, b, cmp) {\n  // Set the comparator function.\n  cmp = cmp || function (a, b) {\n    return a === b;\n  };\n\n  var aLength = a.length;\n  var bLength = b.length; // Perform `fastDiff` for longer strings/arrays (see #269).\n\n  if (aLength > 200 || bLength > 200 || aLength + bLength > 300) {\n    return diff.fastDiff(a, b, cmp, true);\n  } // Temporary action type statics.\n\n\n  var _insert, _delete; // Swapped the arrays to use the shorter one as the first one.\n\n\n  if (bLength < aLength) {\n    var tmp = a;\n    a = b;\n    b = tmp; // We swap the action types as well.\n\n    _insert = 'delete';\n    _delete = 'insert';\n  } else {\n    _insert = 'insert';\n    _delete = 'delete';\n  }\n\n  var m = a.length;\n  var n = b.length;\n  var delta = n - m; // Edit scripts, for each diagonal.\n\n  var es = {}; // Furthest points, the furthest y we can get on each diagonal.\n\n  var fp = {};\n\n  function snake(k) {\n    // We use -1 as an alternative below to handle initial values ( instead of filling the fp with -1 first ).\n    // Furthest points (y) on the diagonal below k.\n    var y1 = (fp[k - 1] !== undefined ? fp[k - 1] : -1) + 1; // Furthest points (y) on the diagonal above k.\n\n    var y2 = fp[k + 1] !== undefined ? fp[k + 1] : -1; // The way we should go to get further.\n\n    var dir = y1 > y2 ? -1 : 1; // Clone previous changes array (if any).\n\n    if (es[k + dir]) {\n      es[k] = es[k + dir].slice(0);\n    } // Create changes array.\n\n\n    if (!es[k]) {\n      es[k] = [];\n    } // Push the action.\n\n\n    es[k].push(y1 > y2 ? _insert : _delete); // Set the beginning coordinates.\n\n    var y = Math.max(y1, y2);\n    var x = y - k; // Traverse the diagonal as long as the values match.\n\n    while (x < m && y < n && cmp(a[x], b[y])) {\n      x++;\n      y++; // Push no change action.\n\n      es[k].push('equal');\n    }\n\n    return y;\n  }\n\n  var p = 0;\n  var k; // Traverse the graph until we reach the end of the longer string.\n\n  do {\n    // Updates furthest points and edit scripts for diagonals below delta.\n    for (k = -p; k < delta; k++) {\n      fp[k] = snake(k);\n    } // Updates furthest points and edit scripts for diagonals above delta.\n\n\n    for (k = delta + p; k > delta; k--) {\n      fp[k] = snake(k);\n    } // Updates furthest point and edit script for the delta diagonal.\n    // note that the delta diagonal is the one which goes through the sink (m, n).\n\n\n    fp[delta] = snake(delta);\n    p++;\n  } while (fp[delta] !== n); // Return the final list of edit changes.\n  // We remove the first item that represents the action for the injected nulls.\n\n\n  return es[delta].slice(1);\n} // Store the API in static property to easily overwrite it in tests.\n// Too bad dependency injection does not work in Webpack + ES 6 (const) + Babel.\n\ndiff.fastDiff = fastDiff;","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/insertat\n */\n\n/**\n * Inserts node to the parent at given index.\n *\n * @param {Element} parentElement Parent element.\n * @param {Number} index Insertions index.\n * @param {Node} nodeToInsert Node to insert.\n */\nexport default function insertAt(parentElement, index, nodeToInsert) {\n  parentElement.insertBefore(nodeToInsert, parentElement.childNodes[index] || null);\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/remove\n */\n\n/**\n * Removes given node from parent.\n *\n * @param {Node} node Node to remove.\n */\nexport default function remove(node) {\n  var parent = node.parentNode;\n\n  if (parent) {\n    parent.removeChild(node);\n  }\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/isnode\n */\n\n/**\n * Checks if the object is a native DOM Node.\n *\n * @param {*} obj\n * @returns {Boolean}\n */\nexport default function isNode(obj) {\n  if (obj) {\n    if (obj.defaultView) {\n      return obj instanceof obj.defaultView.Document;\n    } else if (obj.ownerDocument && obj.ownerDocument.defaultView) {\n      return obj instanceof obj.ownerDocument.defaultView.Node;\n    }\n  }\n\n  return false;\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/indexof\n */\n\n/**\n * Returns index of the node in the parent element.\n *\n * @param {Node} node Node which index is tested.\n * @returns {Number} Index of the node in the parent element. Returns 0 if node has no parent.\n */\nexport default function indexOf(node) {\n  var index = 0;\n\n  while (node.previousSibling) {\n    node = node.previousSibling;\n    index++;\n  }\n\n  return index;\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals Node */\n\n/**\n * @module utils/dom/getancestors\n */\n\n/**\n * Returns all ancestors of given DOM node, starting from the top-most (root). Includes the given node itself. If the\n * node is a part of `DocumentFragment` that `DocumentFragment` will be returned. In contrary, if the node is\n * appended to a `Document`, that `Document` will not be returned (algorithms operating on DOM tree care for `Document#documentElement`\n * at most, which will be returned).\n *\n * @param {Node} node DOM node.\n * @returns {Array.<Node|DocumentFragment>} Array of given `node` parents.\n */\nexport default function getAncestors(node) {\n  var nodes = []; // We are interested in `Node`s `DocumentFragment`s only.\n\n  while (node && node.nodeType != Node.DOCUMENT_NODE) {\n    nodes.unshift(node);\n    node = node.parentNode;\n  }\n\n  return nodes;\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/getcommonancestor\n */\nimport getAncestors from \"./getancestors\";\n/**\n * Searches and returns the lowest common ancestor of two given nodes.\n *\n * @param {Node} nodeA First node.\n * @param {Node} nodeB Second node.\n * @returns {Node|DocumentFragment|Document|null} Lowest common ancestor of both nodes or `null` if nodes do not have a common ancestor.\n */\n\nexport default function getCommonAncestor(nodeA, nodeB) {\n  var ancestorsA = getAncestors(nodeA);\n  var ancestorsB = getAncestors(nodeB);\n  var i = 0; // It does not matter which array is shorter.\n\n  while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n    i++;\n  }\n\n  return i === 0 ? null : ancestorsA[i - 1];\n}","import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"regenerator-runtime/runtime\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.weak-map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, Text */\nimport ViewText from \"./text\";\nimport ViewElement from \"./element\";\nimport ViewPosition from \"./position\";\nimport ViewRange from \"./range\";\nimport ViewSelection from \"./selection\";\nimport ViewDocumentFragment from \"./documentfragment\";\nimport ViewTreeWalker from \"./treewalker\";\nimport { BR_FILLER, INLINE_FILLER_LENGTH, isBlockFiller, isInlineFiller, startsWithFiller, getDataWithoutFiller } from \"./filler\";\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport getCommonAncestor from '@ckeditor/ckeditor5-utils/src/dom/getcommonancestor';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport { isElement } from 'lodash-es';\n/**\n * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.\n *\n * The instance of DOMConverter is available in {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a\n * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).\n *\n * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will\n * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\n\nvar DomConverter =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates DOM converter.\n   *\n   * @param {Object} options Object with configuration options.\n   * @param {Function} [options.blockFiller=module:engine/view/filler~BR_FILLER] Block filler creator.\n   */\n  function DomConverter() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, DomConverter);\n\n    // Using WeakMap prevent memory leaks: when the converter will be destroyed all referenced between View and DOM\n    // will be removed. Also because it is a *Weak*Map when both view and DOM elements will be removed referenced\n    // will be also removed, isn't it brilliant?\n    //\n    // Yes, PJ. It is.\n    //\n    // You guys so smart.\n    //\n    // I've been here. Seen stuff. Afraid of code now.\n\n    /**\n     * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the\n     * view to DOM conversion and to recognize block fillers during the DOM to view conversion.\n     *\n     * @readonly\n     * @member {Function} module:engine/view/domconverter~DomConverter#blockFiller\n     */\n    this.blockFiller = options.blockFiller || BR_FILLER;\n    /**\n     * Tag names of DOM `Element`s which are considered pre-formatted elements.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n     */\n\n    this.preElements = ['pre'];\n    /**\n     * Tag names of DOM `Element`s which are considered block elements.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n     */\n\n    this.blockElements = ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n    /**\n     * DOM to View mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n     */\n\n    this._domToViewMapping = new WeakMap();\n    /**\n     * View to DOM mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n     */\n\n    this._viewToDomMapping = new WeakMap();\n    /**\n     * Holds mapping between fake selection containers and corresponding view selections.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n     */\n\n    this._fakeSelectionMapping = new WeakMap();\n  }\n  /**\n   * Binds given DOM element that represents fake selection to {@link module:engine/view/documentselection~DocumentSelection\n   * document selection}. Document selection copy is stored and can be retrieved by\n   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n   *\n   * @param {HTMLElement} domElement\n   * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n   */\n\n\n  _createClass(DomConverter, [{\n    key: \"bindFakeSelection\",\n    value: function bindFakeSelection(domElement, viewDocumentSelection) {\n      this._fakeSelectionMapping.set(domElement, new ViewSelection(viewDocumentSelection));\n    }\n    /**\n     * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to\n     * given DOM element that represents fake selection. Returns `undefined` if binding to given DOM element does not exists.\n     *\n     * @param {HTMLElement} domElement\n     * @returns {module:engine/view/selection~Selection|undefined}\n     */\n\n  }, {\n    key: \"fakeSelectionToView\",\n    value: function fakeSelectionToView(domElement) {\n      return this._fakeSelectionMapping.get(domElement);\n    }\n    /**\n     * Binds DOM and View elements, so it will be possible to get corresponding elements using\n     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n     *\n     * @param {HTMLElement} domElement DOM element to bind.\n     * @param {module:engine/view/element~Element} viewElement View element to bind.\n     */\n\n  }, {\n    key: \"bindElements\",\n    value: function bindElements(domElement, viewElement) {\n      this._domToViewMapping.set(domElement, viewElement);\n\n      this._viewToDomMapping.set(viewElement, domElement);\n    }\n    /**\n     * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of\n     * `domElement` will be unbound too.\n     *\n     * @param {HTMLElement} domElement DOM element to unbind.\n     */\n\n  }, {\n    key: \"unbindDomElement\",\n    value: function unbindDomElement(domElement) {\n      var viewElement = this._domToViewMapping.get(domElement);\n\n      if (viewElement) {\n        this._domToViewMapping.delete(domElement);\n\n        this._viewToDomMapping.delete(viewElement); // Use Array.from because of MS Edge (#923).\n\n\n        for (var _i = 0, _Array$from = Array.from(domElement.childNodes); _i < _Array$from.length; _i++) {\n          var child = _Array$from[_i];\n          this.unbindDomElement(child);\n        }\n      }\n    }\n    /**\n     * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using\n     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n     *\n     * @param {DocumentFragment} domFragment DOM document fragment to bind.\n     * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.\n     */\n\n  }, {\n    key: \"bindDocumentFragments\",\n    value: function bindDocumentFragments(domFragment, viewFragment) {\n      this._domToViewMapping.set(domFragment, viewFragment);\n\n      this._viewToDomMapping.set(viewFragment, domFragment);\n    }\n    /**\n     * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will\n     * be created. For bound elements and document fragments function will return corresponding items.\n     *\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n     * View node or document fragment to transform.\n     * @param {Document} domDocument Document which will be used to create DOM nodes.\n     * @param {Object} [options] Conversion options.\n     * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n     * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n     * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n     */\n\n  }, {\n    key: \"viewToDom\",\n    value: function viewToDom(viewNode, domDocument) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (viewNode.is('text')) {\n        var textData = this._processDataFromViewText(viewNode);\n\n        return domDocument.createTextNode(textData);\n      } else {\n        if (this.mapViewToDom(viewNode)) {\n          return this.mapViewToDom(viewNode);\n        }\n\n        var domElement;\n\n        if (viewNode.is('documentFragment')) {\n          // Create DOM document fragment.\n          domElement = domDocument.createDocumentFragment();\n\n          if (options.bind) {\n            this.bindDocumentFragments(domElement, viewNode);\n          }\n        } else if (viewNode.is('uiElement')) {\n          // UIElement has its own render() method (see #799).\n          domElement = viewNode.render(domDocument);\n\n          if (options.bind) {\n            this.bindElements(domElement, viewNode);\n          }\n\n          return domElement;\n        } else {\n          // Create DOM element.\n          domElement = domDocument.createElement(viewNode.name);\n\n          if (options.bind) {\n            this.bindElements(domElement, viewNode);\n          } // Copy element's attributes.\n\n\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = viewNode.getAttributeKeys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var key = _step.value;\n              domElement.setAttribute(key, viewNode.getAttribute(key));\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        if (options.withChildren || options.withChildren === undefined) {\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = this.viewChildrenToDom(viewNode, domDocument, options)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var child = _step2.value;\n              domElement.appendChild(child);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n\n        return domElement;\n      }\n    }\n    /**\n     * Converts children of the view element to DOM using the\n     * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n     * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n     * @param {Document} domDocument Document which will be used to create DOM nodes.\n     * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n     * @returns {Iterable.<Node>} DOM nodes.\n     */\n\n  }, {\n    key: \"viewChildrenToDom\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function viewChildrenToDom(viewElement, domDocument) {\n      var options,\n          fillerPositionOffset,\n          offset,\n          _iteratorNormalCompletion3,\n          _didIteratorError3,\n          _iteratorError3,\n          _iterator3,\n          _step3,\n          childView,\n          _args = arguments;\n\n      return regeneratorRuntime.wrap(function viewChildrenToDom$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n              fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n              offset = 0;\n              _iteratorNormalCompletion3 = true;\n              _didIteratorError3 = false;\n              _iteratorError3 = undefined;\n              _context.prev = 6;\n              _iterator3 = viewElement.getChildren()[Symbol.iterator]();\n\n            case 8:\n              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                _context.next = 19;\n                break;\n              }\n\n              childView = _step3.value;\n\n              if (!(fillerPositionOffset === offset)) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 13;\n              return this.blockFiller(domDocument);\n\n            case 13:\n              _context.next = 15;\n              return this.viewToDom(childView, domDocument, options);\n\n            case 15:\n              offset++;\n\n            case 16:\n              _iteratorNormalCompletion3 = true;\n              _context.next = 8;\n              break;\n\n            case 19:\n              _context.next = 25;\n              break;\n\n            case 21:\n              _context.prev = 21;\n              _context.t0 = _context[\"catch\"](6);\n              _didIteratorError3 = true;\n              _iteratorError3 = _context.t0;\n\n            case 25:\n              _context.prev = 25;\n              _context.prev = 26;\n\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n\n            case 28:\n              _context.prev = 28;\n\n              if (!_didIteratorError3) {\n                _context.next = 31;\n                break;\n              }\n\n              throw _iteratorError3;\n\n            case 31:\n              return _context.finish(28);\n\n            case 32:\n              return _context.finish(25);\n\n            case 33:\n              if (!(fillerPositionOffset === offset)) {\n                _context.next = 36;\n                break;\n              }\n\n              _context.next = 36;\n              return this.blockFiller(domDocument);\n\n            case 36:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, viewChildrenToDom, this, [[6, 21, 25, 33], [26,, 28, 32]]);\n    })\n    /**\n     * Converts view {@link module:engine/view/range~Range} to DOM range.\n     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n     *\n     * @param {module:engine/view/range~Range} viewRange View range.\n     * @returns {Range} DOM range.\n     */\n\n  }, {\n    key: \"viewRangeToDom\",\n    value: function viewRangeToDom(viewRange) {\n      var domStart = this.viewPositionToDom(viewRange.start);\n      var domEnd = this.viewPositionToDom(viewRange.end);\n      var domRange = document.createRange();\n      domRange.setStart(domStart.parent, domStart.offset);\n      domRange.setEnd(domEnd.parent, domEnd.offset);\n      return domRange;\n    }\n    /**\n     * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n     *\n     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n     * If the converted position is directly before inline filler it is moved inside the filler.\n     *\n     * @param {module:engine/view/position~Position} viewPosition View position.\n     * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n     * @returns {Node} position.parent DOM position parent.\n     * @returns {Number} position.offset DOM position offset.\n     */\n\n  }, {\n    key: \"viewPositionToDom\",\n    value: function viewPositionToDom(viewPosition) {\n      var viewParent = viewPosition.parent;\n\n      if (viewParent.is('text')) {\n        var domParent = this.findCorrespondingDomText(viewParent);\n\n        if (!domParent) {\n          // Position is in a view text node that has not been rendered to DOM yet.\n          return null;\n        }\n\n        var offset = viewPosition.offset;\n\n        if (startsWithFiller(domParent)) {\n          offset += INLINE_FILLER_LENGTH;\n        }\n\n        return {\n          parent: domParent,\n          offset: offset\n        };\n      } else {\n        // viewParent is instance of ViewElement.\n        var _domParent, domBefore, domAfter;\n\n        if (viewPosition.offset === 0) {\n          _domParent = this.mapViewToDom(viewParent);\n\n          if (!_domParent) {\n            // Position is in a view element that has not been rendered to DOM yet.\n            return null;\n          }\n\n          domAfter = _domParent.childNodes[0];\n        } else {\n          var nodeBefore = viewPosition.nodeBefore;\n          domBefore = nodeBefore.is('text') ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(viewPosition.nodeBefore);\n\n          if (!domBefore) {\n            // Position is after a view element that has not been rendered to DOM yet.\n            return null;\n          }\n\n          _domParent = domBefore.parentNode;\n          domAfter = domBefore.nextSibling;\n        } // If there is an inline filler at position return position inside the filler. We should never return\n        // the position before the inline filler.\n\n\n        if (isText(domAfter) && startsWithFiller(domAfter)) {\n          return {\n            parent: domAfter,\n            offset: INLINE_FILLER_LENGTH\n          };\n        }\n\n        var _offset = domBefore ? indexOf(domBefore) + 1 : 0;\n\n        return {\n          parent: _domParent,\n          offset: _offset\n        };\n      }\n    }\n    /**\n     * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n     * be created. For bound elements and document fragments function will return corresponding items. For\n     * {@link module:engine/view/filler fillers} `null` will be returned.\n     * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n     *\n     * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n     * @param {Object} [options] Conversion options.\n     * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n     * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n     * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.\n     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n     * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n     */\n\n  }, {\n    key: \"domToView\",\n    value: function domToView(domNode) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (isBlockFiller(domNode, this.blockFiller)) {\n        return null;\n      } // When node is inside UIElement return that UIElement as it's view representation.\n\n\n      var uiElement = this.getParentUIElement(domNode, this._domToViewMapping);\n\n      if (uiElement) {\n        return uiElement;\n      }\n\n      if (isText(domNode)) {\n        if (isInlineFiller(domNode)) {\n          return null;\n        } else {\n          var textData = this._processDataFromDomText(domNode);\n\n          return textData === '' ? null : new ViewText(textData);\n        }\n      } else if (this.isComment(domNode)) {\n        return null;\n      } else {\n        if (this.mapDomToView(domNode)) {\n          return this.mapDomToView(domNode);\n        }\n\n        var viewElement;\n\n        if (this.isDocumentFragment(domNode)) {\n          // Create view document fragment.\n          viewElement = new ViewDocumentFragment();\n\n          if (options.bind) {\n            this.bindDocumentFragments(domNode, viewElement);\n          }\n        } else {\n          // Create view element.\n          var viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();\n          viewElement = new ViewElement(viewName);\n\n          if (options.bind) {\n            this.bindElements(domNode, viewElement);\n          } // Copy element's attributes.\n\n\n          var attrs = domNode.attributes;\n\n          for (var i = attrs.length - 1; i >= 0; i--) {\n            viewElement._setAttribute(attrs[i].name, attrs[i].value);\n          }\n        }\n\n        if (options.withChildren || options.withChildren === undefined) {\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = this.domChildrenToView(domNode, options)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var child = _step4.value;\n\n              viewElement._appendChild(child);\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n\n        return viewElement;\n      }\n    }\n    /**\n     * Converts children of the DOM element to view nodes using\n     * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n     * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n     *\n     * @param {HTMLElement} domElement Parent DOM element.\n     * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n     * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n     */\n\n  }, {\n    key: \"domChildrenToView\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function domChildrenToView(domElement) {\n      var options,\n          i,\n          domChild,\n          viewChild,\n          _args2 = arguments;\n      return regeneratorRuntime.wrap(function domChildrenToView$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              i = 0;\n\n            case 2:\n              if (!(i < domElement.childNodes.length)) {\n                _context2.next = 11;\n                break;\n              }\n\n              domChild = domElement.childNodes[i];\n              viewChild = this.domToView(domChild, options);\n\n              if (!(viewChild !== null)) {\n                _context2.next = 8;\n                break;\n              }\n\n              _context2.next = 8;\n              return viewChild;\n\n            case 8:\n              i++;\n              _context2.next = 2;\n              break;\n\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, domChildrenToView, this);\n    })\n    /**\n     * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n     * Ranges which cannot be converted will be omitted.\n     *\n     * @param {Selection} domSelection DOM selection.\n     * @returns {module:engine/view/selection~Selection} View selection.\n     */\n\n  }, {\n    key: \"domSelectionToView\",\n    value: function domSelectionToView(domSelection) {\n      // DOM selection might be placed in fake selection container.\n      // If container contains fake selection - return corresponding view selection.\n      if (domSelection.rangeCount === 1) {\n        var container = domSelection.getRangeAt(0).startContainer; // The DOM selection might be moved to the text node inside the fake selection container.\n\n        if (isText(container)) {\n          container = container.parentNode;\n        }\n\n        var viewSelection = this.fakeSelectionToView(container);\n\n        if (viewSelection) {\n          return viewSelection;\n        }\n      }\n\n      var isBackward = this.isDomSelectionBackward(domSelection);\n      var viewRanges = [];\n\n      for (var i = 0; i < domSelection.rangeCount; i++) {\n        // DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n        var domRange = domSelection.getRangeAt(i);\n        var viewRange = this.domRangeToView(domRange);\n\n        if (viewRange) {\n          viewRanges.push(viewRange);\n        }\n      }\n\n      return new ViewSelection(viewRanges, {\n        backward: isBackward\n      });\n    }\n    /**\n     * Converts DOM Range to view {@link module:engine/view/range~Range}.\n     * If the start or end position can not be converted `null` is returned.\n     *\n     * @param {Range} domRange DOM range.\n     * @returns {module:engine/view/range~Range|null} View range.\n     */\n\n  }, {\n    key: \"domRangeToView\",\n    value: function domRangeToView(domRange) {\n      var viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);\n      var viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);\n\n      if (viewStart && viewEnd) {\n        return new ViewRange(viewStart, viewEnd);\n      }\n\n      return null;\n    }\n    /**\n     * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n     *\n     * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n     * position of the filler will be converted and returned.\n     *\n     * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n     * that position will be converted to view position before that UIElement.\n     *\n     * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n     *\n     * @param {Node} domParent DOM position parent.\n     * @param {Number} domOffset DOM position offset.\n     * @returns {module:engine/view/position~Position} viewPosition View position.\n     */\n\n  }, {\n    key: \"domPositionToView\",\n    value: function domPositionToView(domParent, domOffset) {\n      if (isBlockFiller(domParent, this.blockFiller)) {\n        return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n      } // If position is somewhere inside UIElement - return position before that element.\n\n\n      var viewElement = this.mapDomToView(domParent);\n\n      if (viewElement && viewElement.is('uiElement')) {\n        return ViewPosition._createBefore(viewElement);\n      }\n\n      if (isText(domParent)) {\n        if (isInlineFiller(domParent)) {\n          return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n        }\n\n        var viewParent = this.findCorrespondingViewText(domParent);\n        var offset = domOffset;\n\n        if (!viewParent) {\n          return null;\n        }\n\n        if (startsWithFiller(domParent)) {\n          offset -= INLINE_FILLER_LENGTH;\n          offset = offset < 0 ? 0 : offset;\n        }\n\n        return new ViewPosition(viewParent, offset);\n      } // domParent instanceof HTMLElement.\n      else {\n          if (domOffset === 0) {\n            var _viewParent = this.mapDomToView(domParent);\n\n            if (_viewParent) {\n              return new ViewPosition(_viewParent, 0);\n            }\n          } else {\n            var domBefore = domParent.childNodes[domOffset - 1];\n            var viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore); // TODO #663\n\n            if (viewBefore && viewBefore.parent) {\n              return new ViewPosition(viewBefore.parent, viewBefore.index + 1);\n            }\n          }\n\n          return null;\n        }\n    }\n    /**\n     * Returns corresponding view {@link module:engine/view/element~Element Element} or\n     * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n     * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n     * to the given DOM - `undefined` is returned.\n     * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n     *\n     * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n     * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n     * Corresponding view element, document fragment or `undefined` if no element was bound.\n     */\n\n  }, {\n    key: \"mapDomToView\",\n    value: function mapDomToView(domElementOrDocumentFragment) {\n      return this.getParentUIElement(domElementOrDocumentFragment) || this._domToViewMapping.get(domElementOrDocumentFragment);\n    }\n    /**\n     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n     * corresponding text node is returned based on the sibling or parent.\n     *\n     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n     * to find the corresponding text node.\n     *\n     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n     * element, it is used to find the corresponding text node.\n     *\n     * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n     *\n     * Otherwise `null` is returned.\n     *\n     * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n     *\n     * @param {Text} domText DOM text node.\n     * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n     * corresponding node.\n     */\n\n  }, {\n    key: \"findCorrespondingViewText\",\n    value: function findCorrespondingViewText(domText) {\n      if (isInlineFiller(domText)) {\n        return null;\n      } // If DOM text was rendered by UIElement - return that element.\n\n\n      var uiElement = this.getParentUIElement(domText);\n\n      if (uiElement) {\n        return uiElement;\n      }\n\n      var previousSibling = domText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n      if (previousSibling) {\n        if (!this.isElement(previousSibling)) {\n          // The previous is text or comment.\n          return null;\n        }\n\n        var viewElement = this.mapDomToView(previousSibling);\n\n        if (viewElement) {\n          var nextSibling = viewElement.nextSibling; // It might be filler which has no corresponding view node.\n\n          if (nextSibling instanceof ViewText) {\n            return viewElement.nextSibling;\n          } else {\n            return null;\n          }\n        }\n      } // Try to use parent to find the corresponding text node.\n      else {\n          var _viewElement = this.mapDomToView(domText.parentNode);\n\n          if (_viewElement) {\n            var firstChild = _viewElement.getChild(0); // It might be filler which has no corresponding view node.\n\n\n            if (firstChild instanceof ViewText) {\n              return firstChild;\n            } else {\n              return null;\n            }\n          }\n        }\n\n      return null;\n    }\n    /**\n     * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n     * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n     * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n     * use {@link #findCorrespondingDomText}.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n     * View element or document fragment.\n     * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n     */\n\n  }, {\n    key: \"mapViewToDom\",\n    value: function mapViewToDom(documentFragmentOrElement) {\n      return this._viewToDomMapping.get(documentFragmentOrElement);\n    }\n    /**\n     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n     * corresponding text node is returned based on the sibling or parent.\n     *\n     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n     * to find the corresponding text node.\n     *\n     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n     * element, it is used to find the corresponding text node.\n     *\n     * Otherwise `null` is returned.\n     *\n     * @param {module:engine/view/text~Text} viewText View text node.\n     * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n     */\n\n  }, {\n    key: \"findCorrespondingDomText\",\n    value: function findCorrespondingDomText(viewText) {\n      var previousSibling = viewText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n      if (previousSibling && this.mapViewToDom(previousSibling)) {\n        return this.mapViewToDom(previousSibling).nextSibling;\n      } // If this is a first node, try to use parent to find the corresponding text node.\n\n\n      if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {\n        return this.mapViewToDom(viewText.parent).childNodes[0];\n      }\n\n      return null;\n    }\n    /**\n     * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n     *\n     * @param {module:engine/view/editableelement~EditableElement} viewEditable\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus(viewEditable) {\n      var domEditable = this.mapViewToDom(viewEditable);\n\n      if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {\n        // Save the scrollX and scrollY positions before the focus.\n        var _global$window = global.window,\n            scrollX = _global$window.scrollX,\n            scrollY = _global$window.scrollY;\n        var scrollPositions = []; // Save all scrollLeft and scrollTop values starting from domEditable up to\n        // document#documentElement.\n\n        forEachDomNodeAncestor(domEditable, function (node) {\n          var scrollLeft = node.scrollLeft,\n              scrollTop = node.scrollTop;\n          scrollPositions.push([scrollLeft, scrollTop]);\n        });\n        domEditable.focus(); // Restore scrollLeft and scrollTop values starting from domEditable up to\n        // document#documentElement.\n        // https://github.com/ckeditor/ckeditor5-engine/issues/951\n        // https://github.com/ckeditor/ckeditor5-engine/issues/957\n\n        forEachDomNodeAncestor(domEditable, function (node) {\n          var _scrollPositions$shif = scrollPositions.shift(),\n              _scrollPositions$shif2 = _slicedToArray(_scrollPositions$shif, 2),\n              scrollLeft = _scrollPositions$shif2[0],\n              scrollTop = _scrollPositions$shif2[1];\n\n          node.scrollLeft = scrollLeft;\n          node.scrollTop = scrollTop;\n        }); // Restore the scrollX and scrollY positions after the focus.\n        // https://github.com/ckeditor/ckeditor5-engine/issues/951\n\n        global.window.scrollTo(scrollX, scrollY);\n      }\n    }\n    /**\n     * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n     *\n     * @param {Node} node Node to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isElement\",\n    value: function isElement(node) {\n      return node && node.nodeType == Node.ELEMENT_NODE;\n    }\n    /**\n     * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n     *\n     * @param {Node} node Node to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isDocumentFragment\",\n    value: function isDocumentFragment(node) {\n      return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n    }\n    /**\n     * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n     *\n     * @param {Node} node Node to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isComment\",\n    value: function isComment(node) {\n      return node && node.nodeType == Node.COMMENT_NODE;\n    }\n    /**\n     * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n     *\n     * @param {Selection} DOM Selection instance to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isDomSelectionBackward\",\n    value: function isDomSelectionBackward(selection) {\n      if (selection.isCollapsed) {\n        return false;\n      } // Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n      // we will use the fact that range will collapse if it's end is before it's start.\n\n\n      var range = document.createRange();\n      range.setStart(selection.anchorNode, selection.anchorOffset);\n      range.setEnd(selection.focusNode, selection.focusOffset);\n      var backward = range.collapsed;\n      range.detach();\n      return backward;\n    }\n    /**\n     * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no\n     * parent UIElement.\n     *\n     * @param {Node} domNode\n     * @returns {module:engine/view/uielement~UIElement|null}\n     */\n\n  }, {\n    key: \"getParentUIElement\",\n    value: function getParentUIElement(domNode) {\n      var ancestors = getAncestors(domNode); // Remove domNode from the list.\n\n      ancestors.pop();\n\n      while (ancestors.length) {\n        var _domNode = ancestors.pop();\n\n        var viewNode = this._domToViewMapping.get(_domNode);\n\n        if (viewNode && viewNode.is('uiElement')) {\n          return viewNode;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Checks if given selection's boundaries are at correct places.\n     *\n     * The following places are considered as incorrect for selection boundaries:\n     * * before or in the middle of the inline filler sequence,\n     * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.\n     *\n     * @param {Selection} domSelection DOM Selection object to be checked.\n     * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n     */\n\n  }, {\n    key: \"isDomSelectionCorrect\",\n    value: function isDomSelectionCorrect(domSelection) {\n      return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);\n    }\n    /**\n     * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n     *\n     * @private\n     * @param {Element} domParent Position parent.\n     * @param {Number} offset Position offset.\n     * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n     */\n\n  }, {\n    key: \"_isDomSelectionPositionCorrect\",\n    value: function _isDomSelectionPositionCorrect(domParent, offset) {\n      // If selection is before or in the middle of inline filler string, it is incorrect.\n      if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {\n        // Selection in a text node, at wrong position (before or in the middle of filler).\n        return false;\n      }\n\n      if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {\n        // Selection in an element node, before filler text node.\n        return false;\n      }\n\n      var viewParent = this.mapDomToView(domParent); // If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`\n      // also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).\n\n      if (viewParent && viewParent.is('uiElement')) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n     * it is correctly displayed in the DOM.\n     *\n     * Following changes are done:\n     *\n     * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n     * element or if a previous text node ends with a space character,\n     * * space at the end of the text node is changed to `&nbsp;` if this is the last text node in its container,\n     * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n     *\n     * Content of {@link #preElements} is not processed.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} node View text node to process.\n     * @returns {String} Processed text data.\n     */\n\n  }, {\n    key: \"_processDataFromViewText\",\n    value: function _processDataFromViewText(node) {\n      var _this = this;\n\n      var data = node.data; // If any of node ancestors has a name which is in `preElements` array, then currently processed\n      // view text node is (will be) in preformatted element. We should not change whitespaces then.\n\n      if (node.getAncestors().some(function (parent) {\n        return _this.preElements.includes(parent.name);\n      })) {\n        return data;\n      } // 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n      // (container element boundary).\n\n\n      if (data.charAt(0) == ' ') {\n        var prevNode = this._getTouchingViewTextNode(node, false);\n\n        var prevEndsWithSpace = prevNode && this._nodeEndsWithSpace(prevNode);\n\n        if (prevEndsWithSpace || !prevNode) {\n          data = \"\\xA0\" + data.substr(1);\n        }\n      } // 2. Replace the last space with a nbsp if this is the last text node (container element boundary).\n\n\n      if (data.charAt(data.length - 1) == ' ') {\n        var nextNode = this._getTouchingViewTextNode(node, true);\n\n        if (!nextNode) {\n          data = data.substr(0, data.length - 1) + \"\\xA0\";\n        }\n      }\n\n      return data.replace(/ {2}/g, \" \\xA0\");\n    }\n    /**\n     * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} node Node to check.\n     * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n     */\n\n  }, {\n    key: \"_nodeEndsWithSpace\",\n    value: function _nodeEndsWithSpace(node) {\n      var _this2 = this;\n\n      if (node.getAncestors().some(function (parent) {\n        return _this2.preElements.includes(parent.name);\n      })) {\n        return false;\n      }\n\n      var data = this._processDataFromViewText(node);\n\n      return data.charAt(data.length - 1) == ' ';\n    }\n    /**\n     * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n     *\n     * Following changes are done:\n     *\n     * * multiple whitespaces are replaced to a single space,\n     * * space at the beginning of a text node is removed if it is the first text node in its container\n     * element or if the previous text node ends with a space character,\n     * * space at the end of the text node is removed, if it is the last text node in its container.\n     *\n     * @param {Node} node DOM text node to process.\n     * @returns {String} Processed data.\n     * @private\n     */\n\n  }, {\n    key: \"_processDataFromDomText\",\n    value: function _processDataFromDomText(node) {\n      var data = node.data;\n\n      if (_hasDomParentOfType(node, this.preElements)) {\n        return getDataWithoutFiller(node);\n      } // Change all consecutive whitespace characters (from the [ \\n\\t\\r] set \n      // see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n      // That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n      // We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\n\n      data = data.replace(/[ \\n\\t\\r]{1,}/g, ' ');\n\n      var prevNode = this._getTouchingInlineDomNode(node, false);\n\n      var nextNode = this._getTouchingInlineDomNode(node, true);\n\n      var shouldLeftTrim = this._checkShouldLeftTrimDomText(prevNode);\n\n      var shouldRightTrim = this._checkShouldRightTrimDomText(node, nextNode); // If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n      // of this text node. Such space character is treated as a whitespace.\n\n\n      if (shouldLeftTrim) {\n        data = data.replace(/^ /, '');\n      } // If the next text node does not exist remove space character from the end of this text node.\n\n\n      if (shouldRightTrim) {\n        data = data.replace(/ $/, '');\n      } // At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n      // This means that the text node starts/end with normal space instead of non-breaking space.\n      // This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n      // the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\n\n      data = getDataWithoutFiller(new Text(data)); // At this point we should have removed all whitespaces from DOM text data.\n      // Now we have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n      // First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view as\n      // ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them\n      // to `  ` which is what we expect to have in model/view.\n\n      data = data.replace(/ \\u00A0/g, '  '); // Then, change &nbsp; character that is at the beginning of the text node to space character.\n      // As above, that &nbsp; was created for rendering reasons but it's real meaning is just a space character.\n      // We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\n      if (shouldLeftTrim) {\n        data = data.replace(/^\\u00A0/, ' ');\n      } // Since input text data could be: `x_ _`, we would not replace the first &nbsp; after `x` character.\n      // We have to fix it. Since we already change all ` &nbsp;`, we will have something like this at the end of text data:\n      // `x_ _ _` -> `x_    `. Find &nbsp; at the end of string (can be followed only by spaces).\n      // We do that replacement only if this is the last node or the next node starts with &nbsp; or is a <br>.\n\n\n      if (isText(nextNode) ? nextNode.data.charAt(0) == \"\\xA0\" : true) {\n        data = data.replace(/\\u00A0( *)$/, ' $1');\n      } // At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n      // changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\n\n      return data;\n    }\n    /**\n     * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n     * be trimmed from the left side.\n     *\n     * @param {Node} prevNode\n     */\n\n  }, {\n    key: \"_checkShouldLeftTrimDomText\",\n    value: function _checkShouldLeftTrimDomText(prevNode) {\n      if (!prevNode) {\n        return true;\n      }\n\n      if (isElement(prevNode)) {\n        return true;\n      }\n\n      return /[^\\S\\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1));\n    }\n    /**\n     * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n     * be trimmed from the right side.\n     *\n     * @param {Node} node\n     * @param {Node} prevNode\n     */\n\n  }, {\n    key: \"_checkShouldRightTrimDomText\",\n    value: function _checkShouldRightTrimDomText(node, nextNode) {\n      if (nextNode) {\n        return false;\n      }\n\n      return !startsWithFiller(node);\n    }\n    /**\n     * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n     * that is contained in the same container element. If there is no such sibling, `null` is returned.\n     *\n     * @param {module:engine/view/text~Text} node Reference node.\n     * @param {Boolean} getNext\n     * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.\n     */\n\n  }, {\n    key: \"_getTouchingViewTextNode\",\n    value: function _getTouchingViewTextNode(node, getNext) {\n      var treeWalker = new ViewTreeWalker({\n        startPosition: getNext ? ViewPosition._createAfter(node) : ViewPosition._createBefore(node),\n        direction: getNext ? 'forward' : 'backward'\n      });\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = treeWalker[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var value = _step5.value;\n\n          // ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n          // text node in its container element.\n          if (value.item.is('containerElement')) {\n            return null;\n          } // <br> found  it works like a block boundary, so do not scan further.\n          else if (value.item.is('br')) {\n              return null;\n            } // Found a text node in the same container element.\n            else if (value.item.is('textProxy')) {\n                return value.item;\n              }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Helper function. For the given text node, it finds the closest touching node which is either\n     * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node\n     * wasn't found so far, `null` is returned.\n     *\n     * In the following DOM structure:\n     *\n     *\t\t<p>foo<b>bar</b><br>bom</p>\n     *\n     * * `foo` doesn't have its previous touching inline node (`null` is returned),\n     * * `foo`'s next touching inline node is `bar`\n     * * `bar`'s next touching inline node is `<br>`\n     *\n     * This method returns text nodes and `<br>` elements because these types of nodes affect how\n     * spaces in the given text node need to be converted.\n     *\n     * @private\n     * @param {Text} node\n     * @param {Boolean} getNext\n     * @returns {Text|Element|null}\n     */\n\n  }, {\n    key: \"_getTouchingInlineDomNode\",\n    value: function _getTouchingInlineDomNode(node, getNext) {\n      if (!node.parentNode) {\n        return null;\n      }\n\n      var direction = getNext ? 'nextNode' : 'previousNode';\n      var document = node.ownerDocument;\n      var topmostParent = getAncestors(node)[0];\n      var treeWalker = document.createTreeWalker(topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n        acceptNode: function acceptNode(node) {\n          if (isText(node)) {\n            return NodeFilter.FILTER_ACCEPT;\n          }\n\n          if (node.tagName == 'BR') {\n            return NodeFilter.FILTER_ACCEPT;\n          }\n\n          return NodeFilter.FILTER_SKIP;\n        }\n      });\n      treeWalker.currentNode = node;\n      var touchingNode = treeWalker[direction]();\n\n      if (touchingNode !== null) {\n        var lca = getCommonAncestor(node, touchingNode); // If there is common ancestor between the text node and next/prev text node,\n        // and there are no block elements on a way from the text node to that ancestor,\n        // and there are no block elements on a way from next/prev text node to that ancestor...\n\n        if (lca && !_hasDomParentOfType(node, this.blockElements, lca) && !_hasDomParentOfType(touchingNode, this.blockElements, lca)) {\n          // Then they are in the same container element.\n          return touchingNode;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return DomConverter;\n}(); // Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\n\n\nexport { DomConverter as default };\n\nfunction _hasDomParentOfType(node, types, boundaryParent) {\n  var parents = getAncestors(node);\n\n  if (boundaryParent) {\n    parents = parents.slice(parents.indexOf(boundaryParent) + 1);\n  }\n\n  return parents.some(function (parent) {\n    return parent.tagName && types.includes(parent.tagName.toLowerCase());\n  });\n} // A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\n\n\nfunction forEachDomNodeAncestor(node, callback) {\n  while (node && node != global.document) {\n    callback(node);\n    node = node.parentNode;\n  }\n}","import \"core-js/modules/es6.regexp.to-string\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/iswindow\n */\n\n/**\n * Checks if the object is a native DOM Window.\n *\n * @param {*} obj\n * @returns {Boolean}\n */\nexport default function isWindow(obj) {\n  var stringifiedObject = Object.prototype.toString.apply(obj); // Returns `true` for the `window` object in browser environments.\n\n  if (stringifiedObject == '[object Window]') {\n    return true;\n  } // Returns `true` for the `window` object in the Electron environment.\n\n\n  if (stringifiedObject == '[object global]') {\n    return true;\n  }\n\n  return false;\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/emittermixin\n */\nimport { default as EmitterMixin, _getEmitterListenedTo, _setEmitterId } from \"../emittermixin\";\nimport uid from \"../uid\";\nimport isNode from \"./isnode\";\nimport isWindow from \"./iswindow\";\nimport { extend } from 'lodash-es';\n/**\n * Mixin that injects the DOM events API into its host. It provides the API\n * compatible with {@link module:utils/emittermixin~EmitterMixin}.\n *\n * DOM emitter mixin is by default available in the {@link module:ui/view~View} class,\n * but it can also be mixed into any other class:\n *\n *\t\timport mix from '../utils/mix.js';\n *\t\timport DomEmitterMixin from '../utils/dom/emittermixin.js';\n *\n *\t\tclass SomeView {}\n *\t\tmix( SomeView, DomEmitterMixin );\n *\n *\t\tconst view = new SomeView();\n *\t\tview.listenTo( domElement, ( evt, domEvt ) => {\n *\t\t\tconsole.log( evt, domEvt );\n *\t\t} );\n *\n * @mixin EmitterMixin\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/dom/emittermixin~Emitter\n */\n\nvar DomEmitterMixin = extend({}, EmitterMixin, {\n  /**\n   * Registers a callback function to be executed when an event is fired in a specific Emitter or DOM Node.\n   * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.\n   *\n   * @param {module:utils/emittermixin~Emitter|Node} emitter The object that fires the event.\n   * @param {String} event The name of the event.\n   * @param {Function} callback The function to be called on event.\n   * @param {Object} [options={}] Additional options.\n   * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n   * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n   * order they were added.\n   * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered\n   * listener before being dispatched to any EventTarget beneath it in the DOM tree.\n   */\n  listenTo: function listenTo(emitter) {\n    var _EmitterMixin$listenT;\n\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    // Check if emitter is an instance of DOM Node. If so, replace the argument with\n    // corresponding ProxyEmitter (or create one if not existing).\n    if (isNode(emitter) || isWindow(emitter)) {\n      var proxy = this._getProxyEmitter(emitter) || new ProxyEmitter(emitter);\n      proxy.attach.apply(proxy, rest);\n      emitter = proxy;\n    } // Execute parent class method with Emitter (or ProxyEmitter) instance.\n\n\n    (_EmitterMixin$listenT = EmitterMixin.listenTo).call.apply(_EmitterMixin$listenT, [this, emitter].concat(rest));\n  },\n\n  /**\n   * Stops listening for events. It can be used at different levels:\n   * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.\n   *\n   * * To stop listening to a specific callback.\n   * * To stop listening to a specific event.\n   * * To stop listening to all events fired by a specific object.\n   * * To stop listening to all events fired by all object.\n   *\n   * @param {module:utils/emittermixin~Emitter|Node} [emitter] The object to stop listening to. If omitted, stops it for all objects.\n   * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it\n   * for all events from `emitter`.\n   * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given\n   * `event`.\n   */\n  stopListening: function stopListening(emitter, event, callback) {\n    // Check if emitter is an instance of DOM Node. If so, replace the argument with corresponding ProxyEmitter.\n    if (isNode(emitter) || isWindow(emitter)) {\n      var proxy = this._getProxyEmitter(emitter); // Element has no listeners.\n\n\n      if (!proxy) {\n        return;\n      }\n\n      emitter = proxy;\n    } // Execute parent class method with Emitter (or ProxyEmitter) instance.\n\n\n    EmitterMixin.stopListening.call(this, emitter, event, callback);\n\n    if (emitter instanceof ProxyEmitter) {\n      emitter.detach(event);\n    }\n  },\n\n  /**\n   * Retrieves ProxyEmitter instance for given DOM Node residing in this Host.\n   *\n   * @pivate\n   * @param {Node} node DOM Node of the ProxyEmitter.\n   * @returns {module:utils/dom/emittermixin~ProxyEmitter} ProxyEmitter instance or null.\n   */\n  _getProxyEmitter: function _getProxyEmitter(node) {\n    return _getEmitterListenedTo(this, getNodeUID(node));\n  }\n});\nexport default DomEmitterMixin;\n/**\n * Creates a ProxyEmitter instance. Such an instance is a bridge between a DOM Node firing events\n * and any Host listening to them. It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#on}.\n *\n *                                  listenTo( click, ... )\n *                    +-----------------------------------------+\n *                    |              stopListening( ... )       |\n *     +----------------------------+                           |             addEventListener( click, ... )\n *     | Host                       |                           |   +---------------------------------------------+\n *     +----------------------------+                           |   |       removeEventListener( click, ... )     |\n *     | _listeningTo: {            |                +----------v-------------+                                   |\n *     |   UID: {                   |                | ProxyEmitter           |                                   |\n *     |     emitter: ProxyEmitter, |                +------------------------+                      +------------v----------+\n *     |     callbacks: {           |                | events: {              |                      | Node (HTMLElement)    |\n *     |       click: [ callbacks ] |                |   click: [ callbacks ] |                      +-----------------------+\n *     |     }                      |                | },                     |                      | data-ck-expando: UID  |\n *     |   }                        |                | _domNode: Node,        |                      +-----------------------+\n *     | }                          |                | _domListeners: {},     |                                   |\n *     | +------------------------+ |                | _emitterId: UID        |                                   |\n *     | | DomEmitterMixin        | |                +--------------^---------+                                   |\n *     | +------------------------+ |                           |   |                                             |\n *     +--------------^-------------+                           |   +---------------------------------------------+\n *                    |                                         |                  click (DOM Event)\n *                    +-----------------------------------------+\n *                                fire( click, DOM Event )\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/dom/emittermixin~Emitter\n * @private\n */\n\nvar ProxyEmitter =\n/**\n * @param {Node} node DOM Node that fires events.\n * @returns {Object} ProxyEmitter instance bound to the DOM Node.\n */\nfunction ProxyEmitter(node) {\n  _classCallCheck(this, ProxyEmitter);\n\n  // Set emitter ID to match DOM Node \"expando\" property.\n  _setEmitterId(this, getNodeUID(node)); // Remember the DOM Node this ProxyEmitter is bound to.\n\n\n  this._domNode = node;\n};\n\nextend(ProxyEmitter.prototype, EmitterMixin, {\n  /**\n   * Collection of native DOM listeners.\n   *\n   * @private\n   * @member {Object} module:utils/dom/emittermixin~ProxyEmitter#_domListeners\n   */\n\n  /**\n   * Registers a callback function to be executed when an event is fired.\n   *\n   * It attaches a native DOM listener to the DOM Node. When fired,\n   * a corresponding Emitter event will also fire with DOM Event object as an argument.\n   *\n   * @method module:utils/dom/emittermixin~ProxyEmitter#attach\n   * @param {String} event The name of the event.\n   * @param {Function} callback The function to be called on event.\n   * @param {Object} [options={}] Additional options.\n   * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered\n   * listener before being dispatched to any EventTarget beneath it in the DOM tree.\n   */\n  attach: function attach(event, callback) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    // If the DOM Listener for given event already exist it is pointless\n    // to attach another one.\n    if (this._domListeners && this._domListeners[event]) {\n      return;\n    }\n\n    var domListener = this._createDomListener(event, !!options.useCapture); // Attach the native DOM listener to DOM Node.\n\n\n    this._domNode.addEventListener(event, domListener, !!options.useCapture);\n\n    if (!this._domListeners) {\n      this._domListeners = {};\n    } // Store the native DOM listener in this ProxyEmitter. It will be helpful\n    // when stopping listening to the event.\n\n\n    this._domListeners[event] = domListener;\n  },\n\n  /**\n   * Stops executing the callback on the given event.\n   *\n   * @method module:utils/dom/emittermixin~ProxyEmitter#detach\n   * @param {String} event The name of the event.\n   */\n  detach: function detach(event) {\n    var events; // Remove native DOM listeners which are orphans. If no callbacks\n    // are awaiting given event, detach native DOM listener from DOM Node.\n    // See: {@link attach}.\n\n    if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {\n      this._domListeners[event].removeListener();\n    }\n  },\n\n  /**\n   * Creates a native DOM listener callback. When the native DOM event\n   * is fired it will fire corresponding event on this ProxyEmitter.\n   * Note: A native DOM Event is passed as an argument.\n   *\n   * @private\n   * @method module:utils/dom/emittermixin~ProxyEmitter#_createDomListener\n   * @param {String} event The name of the event.\n   * @param {Boolean} useCapture Indicates whether the listener was created for capturing event.\n   * @returns {Function} The DOM listener callback.\n   */\n  _createDomListener: function _createDomListener(event, useCapture) {\n    var _this = this;\n\n    var domListener = function domListener(domEvt) {\n      _this.fire(event, domEvt);\n    }; // Supply the DOM listener callback with a function that will help\n    // detach it from the DOM Node, when it is no longer necessary.\n    // See: {@link detach}.\n\n\n    domListener.removeListener = function () {\n      _this._domNode.removeEventListener(event, domListener, useCapture);\n\n      delete _this._domListeners[event];\n    };\n\n    return domListener;\n  }\n}); // Gets an unique DOM Node identifier. The identifier will be set if not defined.\n//\n// @private\n// @param {Node} node\n// @returns {String} UID for given DOM Node.\n\nfunction getNodeUID(node) {\n  return node['data-ck-expando'] || (node['data-ck-expando'] = uid());\n}\n/**\n * Interface representing classes which mix in {@link module:utils/dom/emittermixin~EmitterMixin}.\n *\n * @interface Emitter\n */","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/fakeselectionobserver\n */\nimport Observer from \"./observer\";\nimport ViewSelection from \"../selection\";\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport { debounce } from 'lodash-es';\n/**\n * Fake selection observer class. If view selection is fake it is placed in dummy DOM container. This observer listens\n * on {@link module:engine/view/document~Document#event:keydown keydown} events and handles moving fake view selection to the correct place\n * if arrow keys are pressed.\n * Fires {@link module:engine/view/document~Document#event:selectionChange selectionChange event} simulating natural behaviour of\n * {@link module:engine/view/observer/selectionobserver~SelectionObserver SelectionObserver}.\n *\n * @extends module:engine/view/observer/observer~Observer.Observer\n */\n\nvar FakeSelectionObserver =\n/*#__PURE__*/\nfunction (_Observer) {\n  _inherits(FakeSelectionObserver, _Observer);\n\n  /**\n   * Creates new FakeSelectionObserver instance.\n   *\n   * @param {module:engine/view/view~View} view\n   */\n  function FakeSelectionObserver(view) {\n    var _this;\n\n    _classCallCheck(this, FakeSelectionObserver);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FakeSelectionObserver).call(this, view));\n    /**\n     * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n     *\n     * @private\n     * @param {Object} data Selection change data.\n     * @method #_fireSelectionChangeDoneDebounced\n     */\n\n    _this._fireSelectionChangeDoneDebounced = debounce(function (data) {\n      return _this.document.fire('selectionChangeDone', data);\n    }, 200);\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(FakeSelectionObserver, [{\n    key: \"observe\",\n    value: function observe() {\n      var _this2 = this;\n\n      var document = this.document;\n      document.on('keydown', function (eventInfo, data) {\n        var selection = document.selection;\n\n        if (selection.isFake && _isArrowKeyCode(data.keyCode) && _this2.isEnabled) {\n          // Prevents default key down handling - no selection change will occur.\n          data.preventDefault();\n\n          _this2._handleSelectionMove(data.keyCode);\n        }\n      }, {\n        priority: 'lowest'\n      });\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(FakeSelectionObserver.prototype), \"destroy\", this).call(this);\n\n      this._fireSelectionChangeDoneDebounced.cancel();\n    }\n    /**\n     * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be\n     * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.\n     *\n     * This method fires {@link module:engine/view/document~Document#event:selectionChange} and\n     * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of\n     * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n     *\n     * @private\n     * @param {Number} keyCode\n     * @fires module:engine/view/document~Document#event:selectionChange\n     * @fires module:engine/view/document~Document#event:selectionChangeDone\n     */\n\n  }, {\n    key: \"_handleSelectionMove\",\n    value: function _handleSelectionMove(keyCode) {\n      var selection = this.document.selection;\n      var newSelection = new ViewSelection(selection.getRanges(), {\n        backward: selection.isBackward,\n        fake: false\n      }); // Left or up arrow pressed - move selection to start.\n\n      if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {\n        newSelection.setTo(newSelection.getFirstPosition());\n      } // Right or down arrow pressed - move selection to end.\n\n\n      if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {\n        newSelection.setTo(newSelection.getLastPosition());\n      }\n\n      var data = {\n        oldSelection: selection,\n        newSelection: newSelection,\n        domSelection: null\n      }; // Fire dummy selection change event.\n\n      this.document.fire('selectionChange', data); // Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n      // This function is debounced what means that `selectionChangeDone` event will be fired only when\n      // defined int the function time will elapse since the last time the function was called.\n      // So `selectionChangeDone` will be fired when selection will stop changing.\n\n      this._fireSelectionChangeDoneDebounced(data);\n    }\n  }]);\n\n  return FakeSelectionObserver;\n}(Observer); // Checks if one of the arrow keys is pressed.\n//\n// @private\n// @param {Number} keyCode\n// @returns {Boolean}\n\n\nexport { FakeSelectionObserver as default };\n\nfunction _isArrowKeyCode(keyCode) {\n  return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;\n}","import \"core-js/modules/es6.regexp.to-string\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/isrange\n */\n\n/**\n * Checks if the object is a native DOM Range.\n *\n * @param {*} obj\n * @returns {Boolean}\n */\nexport default function isRange(obj) {\n  return Object.prototype.toString.apply(obj) == '[object Range]';\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/getborderwidths\n */\n\n/**\n * Returns an object containing CSS border widths of a specified HTML element.\n *\n * @param {HTMLElement} element An element which has CSS borders.\n * @returns {Object} An object containing `top`, `left`, `right` and `bottom` properties\n * with numerical values of the `border-[top,left,right,bottom]-width` CSS styles.\n */\nexport default function getBorderWidths(element) {\n  // Call getComputedStyle on the window the element document belongs to.\n  var style = element.ownerDocument.defaultView.getComputedStyle(element);\n  return {\n    top: parseInt(style.borderTopWidth, 10),\n    right: parseInt(style.borderRightWidth, 10),\n    bottom: parseInt(style.borderBottomWidth, 10),\n    left: parseInt(style.borderLeftWidth, 10)\n  };\n}","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/rect\n */\nimport isRange from \"./isrange\";\nimport isWindow from \"./iswindow\";\nimport getBorderWidths from \"./getborderwidths\";\nimport log from \"../log\";\nimport isText from \"./istext\";\nimport { isElement } from 'lodash-es';\nvar rectProperties = ['top', 'right', 'bottom', 'left', 'width', 'height'];\n/**\n * A helper class representing a `ClientRect` object, e.g. value returned by\n * the native `object.getBoundingClientRect()` method. Provides a set of methods\n * to manipulate the rect and compare it against other rect instances.\n */\n\nvar Rect =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of rect.\n   *\n   *\t\t// Rect of an HTMLElement.\n   *\t\tconst rectA = new Rect( document.body );\n   *\n   *\t\t// Rect of a DOM Range.\n   *\t\tconst rectB = new Rect( document.getSelection().getRangeAt( 0 ) );\n   *\n   *\t\t// Rect of a window (web browser viewport).\n   *\t\tconst rectC = new Rect( window );\n   *\n   *\t\t// Rect out of an object.\n   *\t\tconst rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );\n   *\n   *\t\t// Rect out of another Rect instance.\n   *\t\tconst rectE = new Rect( rectD );\n   *\n   *\t\t// Rect out of a ClientRect.\n   *\t\tconst rectF = new Rect( document.body.getClientRects().item( 0 ) );\n   *\n   * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)\n   * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}\n   * to get the inner part of the rect.\n   *\n   * @param {HTMLElement|Range|Window|ClientRect|module:utils/dom/rect~Rect|Object} source A source object to create the rect.\n   */\n  function Rect(source) {\n    _classCallCheck(this, Rect);\n\n    var isSourceRange = isRange(source);\n    /**\n     * The object this rect is for.\n     *\n     * @protected\n     * @readonly\n     * @member {HTMLElement|Range|ClientRect|module:utils/dom/rect~Rect|Object} #_source\n     */\n\n    Object.defineProperty(this, '_source', {\n      // If the source is a Rect instance, copy it's #_source.\n      value: source._source || source,\n      writable: true,\n      enumerable: false\n    });\n\n    if (isElement(source) || isSourceRange) {\n      var sourceNode = isSourceRange ? source.startContainer : source;\n\n      if (!sourceNode.ownerDocument || !sourceNode.ownerDocument.body.contains(sourceNode)) {\n        /**\n         * The `Rect` class depends on `getBoundingClientRect` and `getClientRects` DOM methods.\n         * If the {@link #constructor source} of a rect in an HTML element or a DOM range but it does\n         * not belong to any rendered DOM tree, these methods will fail to obtain the geometry and\n         * the rect instance makes little sense to the features using it.\n         *\n         * To get rid of this warning make sure the source passed to the constructor\n         * is a descendant of `window.document.body`.\n         *\n         * @error rect-source-not-in-dom\n         * @param {String} source The source of the Rect instance.\n         */\n        log.warn('rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.', {\n          source: source\n        });\n      }\n\n      if (isSourceRange) {\n        copyRectProperties(this, Rect.getDomRangeRects(source)[0]);\n      } else {\n        copyRectProperties(this, source.getBoundingClientRect());\n      }\n    } else if (isWindow(source)) {\n      var innerWidth = source.innerWidth,\n          innerHeight = source.innerHeight;\n      copyRectProperties(this, {\n        top: 0,\n        right: innerWidth,\n        bottom: innerHeight,\n        left: 0,\n        width: innerWidth,\n        height: innerHeight\n      });\n    } else {\n      copyRectProperties(this, source);\n    }\n    /**\n     * The \"top\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #top\n     */\n\n    /**\n     * The \"right\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #right\n     */\n\n    /**\n     * The \"bottom\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #bottom\n     */\n\n    /**\n     * The \"left\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #left\n     */\n\n    /**\n     * The \"width\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #width\n     */\n\n    /**\n     * The \"height\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #height\n     */\n\n  }\n  /**\n   * Returns a clone of the rect.\n   *\n   * @returns {module:utils/dom/rect~Rect} A cloned rect.\n   */\n\n\n  _createClass(Rect, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Rect(this);\n    }\n    /**\n     * Moves the rect so that its upperleft corner lands in desired `[ x, y ]` location.\n     *\n     * @param {Number} x Desired horizontal location.\n     * @param {Number} y Desired vertical location.\n     * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n     */\n\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(x, y) {\n      this.top = y;\n      this.right = x + this.width;\n      this.bottom = y + this.height;\n      this.left = x;\n      return this;\n    }\n    /**\n     * Moves the rect inplace by a dedicated offset.\n     *\n     * @param {Number} x A horizontal offset.\n     * @param {Number} y A vertical offset\n     * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n     */\n\n  }, {\n    key: \"moveBy\",\n    value: function moveBy(x, y) {\n      this.top += y;\n      this.right += x;\n      this.left += x;\n      this.bottom += y;\n      return this;\n    }\n    /**\n     * Returns a new rect a a result of intersection with another rect.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect\n     * @returns {module:utils/dom/rect~Rect}\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(anotherRect) {\n      var rect = {\n        top: Math.max(this.top, anotherRect.top),\n        right: Math.min(this.right, anotherRect.right),\n        bottom: Math.min(this.bottom, anotherRect.bottom),\n        left: Math.max(this.left, anotherRect.left)\n      };\n      rect.width = rect.right - rect.left;\n      rect.height = rect.bottom - rect.top;\n\n      if (rect.width < 0 || rect.height < 0) {\n        return null;\n      } else {\n        return new Rect(rect);\n      }\n    }\n    /**\n     * Returns the area of intersection with another rect.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect [description]\n     * @returns {Number} Area of intersection.\n     */\n\n  }, {\n    key: \"getIntersectionArea\",\n    value: function getIntersectionArea(anotherRect) {\n      var rect = this.getIntersection(anotherRect);\n\n      if (rect) {\n        return rect.getArea();\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * Returns the area of the rect.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getArea\",\n    value: function getArea() {\n      return this.width * this.height;\n    }\n    /**\n     * Returns a new rect, a part of the original rect, which is actually visible to the user,\n     * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS\n     * other than `\"visible\"`.\n     *\n     * If there's no such visible rect, which is when the rect is limited by one or many of\n     * the ancestors, `null` is returned.\n     *\n     * @returns {module:utils/dom/rect~Rect|null} A visible rect instance or `null`, if there's none.\n     */\n\n  }, {\n    key: \"getVisible\",\n    value: function getVisible() {\n      var source = this._source;\n      var visibleRect = this.clone(); // There's no ancestor to crop <body> with the overflow.\n\n      if (!isBody(source)) {\n        var parent = source.parentNode || source.commonAncestorContainer; // Check the ancestors all the way up to the <body>.\n\n        while (parent && !isBody(parent)) {\n          var parentRect = new Rect(parent);\n          var intersectionRect = visibleRect.getIntersection(parentRect);\n\n          if (intersectionRect) {\n            if (intersectionRect.getArea() < visibleRect.getArea()) {\n              // Reduce the visible rect to the intersection.\n              visibleRect = intersectionRect;\n            }\n          } else {\n            // There's no intersection, the rect is completely invisible.\n            return null;\n          }\n\n          parent = parent.parentNode;\n        }\n      }\n\n      return visibleRect;\n    }\n    /**\n     * Checks if all property values ({@link #top}, {@link #left}, {@link #right},\n     * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect\n     * instances.\n     *\n     * @param {module:utils/dom/rect~Rect} rect A rect instance to compare with.\n     * @returns {Boolean} `true` when Rects are equal. `false` otherwise.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(anotherRect) {\n      for (var _i = 0, _rectProperties = rectProperties; _i < _rectProperties.length; _i++) {\n        var prop = _rectProperties[_i];\n\n        if (this[prop] !== anotherRect[prop]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Checks whether a rect fully contains another rect instance.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect\n     * @returns {Boolean} `true` if contains, `false` otherwise.\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(anotherRect) {\n      var intersectRect = this.getIntersection(anotherRect);\n      return !!(intersectRect && intersectRect.isEqual(anotherRect));\n    }\n    /**\n     * Excludes scrollbars and CSS borders from the rect.\n     *\n     * * Borders are removed when {@link #_source} is an HTML element.\n     * * Scrollbars are excluded from HTML elements and the `window`.\n     *\n     * @returns {module:utils/dom/rect~Rect} A rect which has been updated.\n     */\n\n  }, {\n    key: \"excludeScrollbarsAndBorders\",\n    value: function excludeScrollbarsAndBorders() {\n      var source = this._source;\n      var scrollBarWidth, scrollBarHeight;\n\n      if (isWindow(source)) {\n        scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;\n        scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;\n      } else {\n        var borderWidths = getBorderWidths(this._source);\n        scrollBarWidth = source.offsetWidth - source.clientWidth;\n        scrollBarHeight = source.offsetHeight - source.clientHeight;\n        this.moveBy(borderWidths.left, borderWidths.top);\n      } // Assuming LTR scrollbars. TODO: RTL.\n\n\n      this.width -= scrollBarWidth;\n      this.right -= scrollBarWidth;\n      this.height -= scrollBarHeight;\n      this.bottom -= scrollBarHeight;\n      return this;\n    }\n    /**\n     * Returns an array of rects of the given native DOM Range.\n     *\n     * @param {Range} range A native DOM range.\n     * @returns {Array.<module:utils/dom/rect~Rect>} DOM Range rects.\n     */\n\n  }], [{\n    key: \"getDomRangeRects\",\n    value: function getDomRangeRects(range) {\n      var rects = []; // Safari does not iterate over ClientRectList using for...of loop.\n\n      var clientRects = Array.from(range.getClientRects());\n\n      if (clientRects.length) {\n        for (var _i2 = 0, _clientRects = clientRects; _i2 < _clientRects.length; _i2++) {\n          var rect = _clientRects[_i2];\n          rects.push(new Rect(rect));\n        }\n      } // If there's no client rects for the Range, use parent container's bounding rect\n      // instead and adjust rect's width to simulate the actual geometry of such range.\n      // https://github.com/ckeditor/ckeditor5-utils/issues/153\n      // https://github.com/ckeditor/ckeditor5-ui/issues/317\n      else {\n          var startContainer = range.startContainer;\n\n          if (isText(startContainer)) {\n            startContainer = startContainer.parentNode;\n          }\n\n          var _rect = new Rect(startContainer.getBoundingClientRect());\n\n          _rect.right = _rect.left;\n          _rect.width = 0;\n          rects.push(_rect);\n        }\n\n      return rects;\n    }\n  }]);\n\n  return Rect;\n}(); // Acquires all the rect properties from the passed source.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} rect\n// @param {ClientRect|module:utils/dom/rect~Rect|Object} source\n\n\nexport { Rect as default };\n\nfunction copyRectProperties(rect, source) {\n  for (var _i3 = 0, _rectProperties2 = rectProperties; _i3 < _rectProperties2.length; _i3++) {\n    var p = _rectProperties2[_i3];\n    rect[p] = source[p];\n  }\n} // Checks if provided object is a <body> HTML element.\n//\n// @private\n// @param {HTMLElement|Range} elementOrRange\n// @returns {Boolean}\n\n\nfunction isBody(elementOrRange) {\n  if (!isElement(elementOrRange)) {\n    return false;\n  }\n\n  return elementOrRange === elementOrRange.ownerDocument.body;\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/scroll\n */\nimport isRange from \"./isrange\";\nimport Rect from \"./rect\";\nimport isText from \"./istext\";\nvar utils = {};\n/**\n * Makes any page `HTMLElement` or `Range` (`target`) visible inside the browser viewport.\n * This helper will scroll all `target` ancestors and the web browser viewport to reveal the target to\n * the user. If the `target` is already visible, nothing will happen.\n *\n * @param {HTMLElement|Range} options.target A target, which supposed to become visible to the user.\n * @param {Number} [options.viewportOffset] An offset from the edge of the viewport (in pixels)\n * the `target` will be moved by when the viewport is scrolled. It enhances the user experience\n * by keeping the `target` some distance from the edge of the viewport and thus making it easier to\n * read or edit by the user.\n */\n\nexport function scrollViewportToShowTarget(_ref) {\n  var target = _ref.target,\n      _ref$viewportOffset = _ref.viewportOffset,\n      viewportOffset = _ref$viewportOffset === void 0 ? 0 : _ref$viewportOffset;\n  var targetWindow = getWindow(target);\n  var currentWindow = targetWindow;\n  var currentFrame = null; // Iterate over all windows, starting from target's parent window up to window#top.\n\n  while (currentWindow) {\n    var firstAncestorToScroll = void 0; // Let's scroll target's ancestors first to reveal it. Then, once the ancestor scrolls\n    // settled down, the algorithm can eventually scroll the viewport of the current window.\n    //\n    // Note: If the current window is target's **original** window (e.g. the first one),\n    // start scrolling the closest parent of the target. If not, scroll the closest parent\n    // of an iframe that resides in the current window.\n\n    if (currentWindow == targetWindow) {\n      firstAncestorToScroll = getParentElement(target);\n    } else {\n      firstAncestorToScroll = getParentElement(currentFrame);\n    } // Scroll the target's ancestors first. Once done, scrolling the viewport is easy.\n\n\n    scrollAncestorsToShowRect(firstAncestorToScroll, function () {\n      // Note: If the target does not belong to the current window **directly**,\n      // i.e. it resides in an iframe belonging to the window, obtain the target's rect\n      // in the coordinates of the current window. By default, a Rect returns geometry\n      // relative to the current window's viewport. To make it work in a parent window,\n      // it must be shifted.\n      return getRectRelativeToWindow(target, currentWindow);\n    }); // Obtain the rect of the target after it has been scrolled within its ancestors.\n    // It's time to scroll the viewport.\n\n    var targetRect = getRectRelativeToWindow(target, currentWindow);\n    scrollWindowToShowRect(currentWindow, targetRect, viewportOffset);\n\n    if (currentWindow.parent != currentWindow) {\n      // Keep the reference to the <iframe> element the \"previous current window\" was\n      // rendered within. It will be useful to recalculate the rect of the target\n      // in the parent window's relative geometry. The target's rect must be shifted\n      // by it's iframe's position.\n      currentFrame = currentWindow.frameElement;\n      currentWindow = currentWindow.parent; // If the current window has some parent but frameElement is inaccessible, then they have\n      // different domains/ports and, due to security reasons, accessing and scrolling\n      // the parent window won't be possible.\n      // See https://github.com/ckeditor/ckeditor5/issues/930.\n\n      if (!currentFrame) {\n        return;\n      }\n    } else {\n      currentWindow = null;\n    }\n  }\n}\n/**\n * Makes any page `HTMLElement` or `Range` (target) visible within its scrollable ancestors,\n * e.g. if they have `overflow: scroll` CSS style.\n *\n * @param {HTMLElement|Range} target A target, which supposed to become visible to the user.\n */\n\nexport function scrollAncestorsToShowTarget(target) {\n  var targetParent = getParentElement(target);\n  scrollAncestorsToShowRect(targetParent, function () {\n    return new Rect(target);\n  });\n} // TODO: Using a property value shorthand in the top of the file\n// causes JSDoc to throw errors. See https://github.com/cksource/docs-builder/issues/75.\n\nObject.assign(utils, {\n  scrollViewportToShowTarget: scrollViewportToShowTarget,\n  scrollAncestorsToShowTarget: scrollAncestorsToShowTarget\n}); // Makes a given rect visible within its parent window.\n//\n// Note: Avoid the situation where the caret is still in the viewport, but totally\n// at the edge of it. In such situation, if it moved beyond the viewport in the next\n// action e.g. after paste, the scrolling would move it to the viewportOffset level\n// and it all would look like the caret visually moved up/down:\n//\n// 1.\n//\t\t| foo[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// 2. *paste*\n// 3.\n//\t\t|\n//\t\t|\n//\t\t+-foo-----------------------------...\n//\t\t  bar[]                              <--- caret below viewport, scrolling...\n//\n// 4. *scrolling*\n// 5.\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]                              <--- caret precisely at the edge\n//\t\t+---------------------------------...\n//\n// To prevent this, this method checks the rects moved by the viewportOffset to cover\n// the upper/lower edge of the viewport. It makes sure if the action repeats, there's\n// no twitching  it's a purely visual improvement:\n//\n// 5. (after fix)\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// @private\n// @param {Window} window A window which is scrolled to reveal the rect.\n// @param {module:utils/dom/rect~Rect} rect A rect which is to be revealed.\n// @param {Number} viewportOffset See scrollViewportToShowTarget.\n\nfunction scrollWindowToShowRect(window, rect, viewportOffset) {\n  var targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset);\n  var targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset);\n  var viewportRect = new Rect(window).excludeScrollbarsAndBorders();\n  var rects = [targetShiftedUpRect, targetShiftedDownRect];\n\n  if (!rects.every(function (rect) {\n    return viewportRect.contains(rect);\n  })) {\n    var scrollX = window.scrollX,\n        scrollY = window.scrollY;\n\n    if (isAbove(targetShiftedUpRect, viewportRect)) {\n      scrollY -= viewportRect.top - rect.top + viewportOffset;\n    } else if (isBelow(targetShiftedDownRect, viewportRect)) {\n      scrollY += rect.bottom - viewportRect.bottom + viewportOffset;\n    } // TODO: Web browsers scroll natively to place the target in the middle\n    // of the viewport. It's not a very popular case, though.\n\n\n    if (isLeftOf(rect, viewportRect)) {\n      scrollX -= viewportRect.left - rect.left + viewportOffset;\n    } else if (isRightOf(rect, viewportRect)) {\n      scrollX += rect.right - viewportRect.right + viewportOffset;\n    }\n\n    window.scrollTo(scrollX, scrollY);\n  }\n} // Recursively scrolls element ancestors to visually reveal a rect.\n//\n// @private\n// @param {HTMLElement} A parent The first ancestors to start scrolling.\n// @param {Function} getRect A function which returns the Rect, which is to be revealed.\n\n\nfunction scrollAncestorsToShowRect(parent, getRect) {\n  var parentWindow = getWindow(parent);\n  var parentRect, targetRect;\n\n  while (parent != parentWindow.document.body) {\n    targetRect = getRect();\n    parentRect = new Rect(parent).excludeScrollbarsAndBorders();\n\n    if (!parentRect.contains(targetRect)) {\n      if (isAbove(targetRect, parentRect)) {\n        parent.scrollTop -= parentRect.top - targetRect.top;\n      } else if (isBelow(targetRect, parentRect)) {\n        parent.scrollTop += targetRect.bottom - parentRect.bottom;\n      }\n\n      if (isLeftOf(targetRect, parentRect)) {\n        parent.scrollLeft -= parentRect.left - targetRect.left;\n      } else if (isRightOf(targetRect, parentRect)) {\n        parent.scrollLeft += targetRect.right - parentRect.right;\n      }\n    }\n\n    parent = parent.parentNode;\n  }\n} // Determines if a given `Rect` extends beyond the bottom edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n\n\nfunction isBelow(firstRect, secondRect) {\n  return firstRect.bottom > secondRect.bottom;\n} // Determines if a given `Rect` extends beyond the top edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n\n\nfunction isAbove(firstRect, secondRect) {\n  return firstRect.top < secondRect.top;\n} // Determines if a given `Rect` extends beyond the left edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n\n\nfunction isLeftOf(firstRect, secondRect) {\n  return firstRect.left < secondRect.left;\n} // Determines if a given `Rect` extends beyond the right edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\n\n\nfunction isRightOf(firstRect, secondRect) {\n  return firstRect.right > secondRect.right;\n} // Returns the closest window of an element or range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {Window}\n\n\nfunction getWindow(elementOrRange) {\n  if (isRange(elementOrRange)) {\n    return elementOrRange.startContainer.ownerDocument.defaultView;\n  } else {\n    return elementOrRange.ownerDocument.defaultView;\n  }\n} // Returns the closest parent of an element or DOM range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {HTMLelement}\n\n\nfunction getParentElement(elementOrRange) {\n  if (isRange(elementOrRange)) {\n    var parent = elementOrRange.commonAncestorContainer; // If a Range is attached to the Text, use the closest element ancestor.\n\n    if (isText(parent)) {\n      parent = parent.parentNode;\n    }\n\n    return parent;\n  } else {\n    return elementOrRange.parentNode;\n  }\n} // Returns the rect of an element or range residing in an iframe.\n// The result rect is relative to the geometry of the passed window instance.\n//\n// @private\n// @param {HTMLElement|Range} target Element or range which rect should be returned.\n// @param {Window} relativeWindow A window the rect should be relative to.\n// @returns {module:utils/dom/rect~Rect}\n\n\nfunction getRectRelativeToWindow(target, relativeWindow) {\n  var targetWindow = getWindow(target);\n  var rect = new Rect(target);\n\n  if (targetWindow === relativeWindow) {\n    return rect;\n  } else {\n    var currentWindow = targetWindow;\n\n    while (currentWindow != relativeWindow) {\n      var frame = currentWindow.frameElement;\n      var frameRect = new Rect(frame).excludeScrollbarsAndBorders();\n      rect.moveBy(frameRect.left, frameRect.top);\n      currentWindow = currentWindow.parent;\n    }\n  }\n\n  return rect;\n}","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/tomap\n */\nimport objectToMap from \"./objecttomap\";\nimport { isPlainObject } from 'lodash-es';\n/**\n * Transforms object or iterable to map. Iterable needs to be in the format acceptable by the `Map` constructor.\n *\n *\t\tmap = toMap( { 'foo': 1, 'bar': 2 } );\n *\t\tmap = toMap( [ [ 'foo', 1 ], [ 'bar', 2 ] ] );\n *\t\tmap = toMap( anotherMap );\n *\n * @param {Object|Iterable} data Object or iterable to transform.\n * @returns {Map} Map created from data.\n */\n\nexport default function toMap(data) {\n  if (isPlainObject(data)) {\n    return objectToMap(data);\n  } else {\n    return new Map(data);\n  }\n}","import _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.weak-map\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/view\n */\nimport Document from \"./document\";\nimport DowncastWriter from \"./downcastwriter\";\nimport Renderer from \"./renderer\";\nimport DomConverter from \"./domconverter\";\nimport Position from \"./position\";\nimport Range from \"./range\";\nimport Selection from \"./selection\";\nimport MutationObserver from \"./observer/mutationobserver\";\nimport KeyObserver from \"./observer/keyobserver\";\nimport FakeSelectionObserver from \"./observer/fakeselectionobserver\";\nimport SelectionObserver from \"./observer/selectionobserver\";\nimport FocusObserver from \"./observer/focusobserver\";\nimport CompositionObserver from \"./observer/compositionobserver\";\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { scrollViewportToShowTarget } from '@ckeditor/ckeditor5-utils/src/dom/scroll';\nimport { injectUiElementHandling } from \"./uielement\";\nimport { injectQuirksHandling } from \"./filler\";\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Editor's view controller class. Its main responsibility is DOM - View management for editing purposes, to provide\n * abstraction over the DOM structure and events and hide all browsers quirks.\n *\n * View controller renders view document to DOM whenever view structure changes. To determine when view can be rendered,\n * all changes need to be done using the {@link module:engine/view/view~View#change} method, using\n * {@link module:engine/view/downcastwriter~DowncastWriter}:\n *\n *\t\tview.change( writer => {\n *\t\t\twriter.insert( position, writer.createText( 'foo' ) );\n *\t\t} );\n *\n * View controller also register {@link module:engine/view/observer/observer~Observer observers} which observes changes\n * on DOM and fire events on the {@link module:engine/view/document~Document Document}.\n * Note that the following observers are added by the class constructor and are always available:\n *\n * * {@link module:engine/view/observer/mutationobserver~MutationObserver},\n * * {@link module:engine/view/observer/selectionobserver~SelectionObserver},\n * * {@link module:engine/view/observer/focusobserver~FocusObserver},\n * * {@link module:engine/view/observer/keyobserver~KeyObserver},\n * * {@link module:engine/view/observer/fakeselectionobserver~FakeSelectionObserver}.\n * * {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n *\n * This class also {@link module:engine/view/view~View#attachDomRoot binds the DOM and the view elements}.\n *\n * If you do not need full a DOM - view management, and only want to transform a tree of view elements to a tree of DOM\n * elements you do not need this controller. You can use the {@link module:engine/view/domconverter~DomConverter DomConverter} instead.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar View =\n/*#__PURE__*/\nfunction () {\n  function View() {\n    var _this = this;\n\n    _classCallCheck(this, View);\n\n    /**\n     * Instance of the {@link module:engine/view/document~Document} associated with this view controller.\n     *\n     * @readonly\n     * @type {module:engine/view/document~Document}\n     */\n    this.document = new Document();\n    /**\n     * Instance of the {@link module:engine/view/domconverter~DomConverter domConverter} used by\n     * {@link module:engine/view/view~View#_renderer renderer}\n     * and {@link module:engine/view/observer/observer~Observer observers}.\n     *\n     * @readonly\n     * @type {module:engine/view/domconverter~DomConverter}\n     */\n\n    this.domConverter = new DomConverter();\n    /**\n     * Roots of the DOM tree. Map on the `HTMLElement`s with roots names as keys.\n     *\n     * @readonly\n     * @type {Map.<String, HTMLElement>}\n     */\n\n    this.domRoots = new Map();\n    /**\n     * Used to prevent calling {@link #forceRender} and {@link #change} during rendering view to the DOM.\n     *\n     * @readonly\n     * @member {Boolean} #isRenderingInProgress\n     */\n\n    this.set('isRenderingInProgress', false);\n    /**\n     * Instance of the {@link module:engine/view/renderer~Renderer renderer}.\n     *\n     * @protected\n     * @type {module:engine/view/renderer~Renderer}\n     */\n\n    this._renderer = new Renderer(this.domConverter, this.document.selection);\n\n    this._renderer.bind('isFocused').to(this.document);\n    /**\n     * A DOM root attributes cache. It saves the initial values of DOM root attributes before the DOM element\n     * is {@link module:engine/view/view~View#attachDomRoot attached} to the view so later on, when\n     * the view is destroyed ({@link module:engine/view/view~View#detachDomRoot}), they can be easily restored.\n     * This way, the DOM element can go back to the (clean) state as if the editing view never used it.\n     *\n     * @private\n     * @member {WeakMap.<HTMLElement,Object>}\n     */\n\n\n    this._initialDomRootAttributes = new WeakMap();\n    /**\n     * Map of registered {@link module:engine/view/observer/observer~Observer observers}.\n     *\n     * @private\n     * @type {Map.<Function, module:engine/view/observer/observer~Observer>}\n     */\n\n    this._observers = new Map();\n    /**\n     * Is set to `true` when {@link #change view changes} are currently in progress.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    this._ongoingChange = false;\n    /**\n     * Used to prevent calling {@link #forceRender} and {@link #change} during rendering view to the DOM.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    this._postFixersInProgress = false;\n    /**\n     * Internal flag to temporary disable rendering. See the usage in the {@link #_disableRendering}.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    this._renderingDisabled = false;\n    /**\n     * Internal flag that disables rendering when there are no changes since the last rendering.\n     * It stores information about changed selection and changed elements from attached document roots.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    this._hasChangedSinceTheLastRendering = false;\n    /**\n     * DowncastWriter instance used in {@link #change change method} callbacks.\n     *\n     * @private\n     * @type {module:engine/view/downcastwriter~DowncastWriter}\n     */\n\n    this._writer = new DowncastWriter(this.document); // Add default observers.\n\n    this.addObserver(MutationObserver);\n    this.addObserver(SelectionObserver);\n    this.addObserver(FocusObserver);\n    this.addObserver(KeyObserver);\n    this.addObserver(FakeSelectionObserver);\n    this.addObserver(CompositionObserver); // Inject quirks handlers.\n\n    injectQuirksHandling(this);\n    injectUiElementHandling(this); // Use 'normal' priority so that rendering is performed as first when using that priority.\n\n    this.on('render', function () {\n      _this._render(); // Informs that layout has changed after render.\n\n\n      _this.document.fire('layoutChanged'); // Reset the `_hasChangedSinceTheLastRendering` flag after rendering.\n\n\n      _this._hasChangedSinceTheLastRendering = false;\n    }); // Listen to the document selection changes directly.\n\n    this.listenTo(this.document.selection, 'change', function () {\n      _this._hasChangedSinceTheLastRendering = true;\n    });\n  }\n  /**\n   * Attaches a DOM root element to the view element and enable all observers on that element.\n   * Also {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized\n   * with the view what means that all child nodes will be removed and replaced with content of the view root.\n   *\n   * This method also will change view element name as the same as tag name of given dom root.\n   * Name is always transformed to lower case.\n   *\n   * **Note:** Use {@link #detachDomRoot `detachDomRoot()`} to revert this action.\n   *\n   * @param {Element} domRoot DOM root element.\n   * @param {String} [name='main'] Name of the root.\n   */\n\n\n  _createClass(View, [{\n    key: \"attachDomRoot\",\n    value: function attachDomRoot(domRoot) {\n      var _this2 = this;\n\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'main';\n      var viewRoot = this.document.getRoot(name); // Set view root name the same as DOM root tag name.\n\n      viewRoot._name = domRoot.tagName.toLowerCase();\n      var initialDomRootAttributes = {}; // 1. Copy and cache the attributes to remember the state of the element before attaching.\n      //    The cached attributes will be restored in detachDomRoot() so the element goes to the\n      //    clean state as if the editing view never used it.\n      // 2. Apply the attributes using the view writer, so they all go under the control of the engine.\n      //    The editing view takes over the attribute management completely because various\n      //    features (e.g. addPlaceholder()) require dynamic changes of those attributes and they\n      //    cannot be managed by the engine and the UI library at the same time.\n\n      for (var _i = 0, _Array$from = Array.from(domRoot.attributes); _i < _Array$from.length; _i++) {\n        var _Array$from$_i = _Array$from[_i],\n            _name = _Array$from$_i.name,\n            value = _Array$from$_i.value;\n        initialDomRootAttributes[_name] = value; // Do not use writer.setAttribute() for the class attribute. The EditableUIView class\n        // and its descendants could have already set some using the writer.addClass() on the view\n        // document root. They haven't been rendered yet so they are not present in the DOM root.\n        // Using writer.setAttribute( 'class', ... ) would override them completely.\n\n        if (_name === 'class') {\n          this._writer.addClass(value.split(' '), viewRoot);\n        } else {\n          this._writer.setAttribute(_name, value, viewRoot);\n        }\n      }\n\n      this._initialDomRootAttributes.set(domRoot, initialDomRootAttributes);\n\n      var updateContenteditableAttribute = function updateContenteditableAttribute() {\n        _this2._writer.setAttribute('contenteditable', !viewRoot.isReadOnly, viewRoot);\n\n        if (viewRoot.isReadOnly) {\n          _this2._writer.addClass('ck-read-only', viewRoot);\n        } else {\n          _this2._writer.removeClass('ck-read-only', viewRoot);\n        }\n      }; // Set initial value.\n\n\n      updateContenteditableAttribute();\n      this.domRoots.set(name, domRoot);\n      this.domConverter.bindElements(domRoot, viewRoot);\n\n      this._renderer.markToSync('children', viewRoot);\n\n      this._renderer.markToSync('attributes', viewRoot);\n\n      this._renderer.domDocuments.add(domRoot.ownerDocument);\n\n      viewRoot.on('change:children', function (evt, node) {\n        return _this2._renderer.markToSync('children', node);\n      });\n      viewRoot.on('change:attributes', function (evt, node) {\n        return _this2._renderer.markToSync('attributes', node);\n      });\n      viewRoot.on('change:text', function (evt, node) {\n        return _this2._renderer.markToSync('text', node);\n      });\n      viewRoot.on('change:isReadOnly', function () {\n        return _this2.change(updateContenteditableAttribute);\n      });\n      viewRoot.on('change', function () {\n        _this2._hasChangedSinceTheLastRendering = true;\n      });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._observers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var observer = _step.value;\n          observer.observe(domRoot, name);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Detaches a DOM root element from the view element and restores its attributes to the state before\n     * {@link #attachDomRoot `attachDomRoot()`}.\n     *\n     * @param {String} name Name of the root to detach.\n     */\n\n  }, {\n    key: \"detachDomRoot\",\n    value: function detachDomRoot(name) {\n      var domRoot = this.domRoots.get(name); // Remove all root attributes so the DOM element is \"bare\".\n\n      Array.from(domRoot.attributes).forEach(function (_ref) {\n        var name = _ref.name;\n        return domRoot.removeAttribute(name);\n      });\n\n      var initialDomRootAttributes = this._initialDomRootAttributes.get(domRoot); // Revert all view root attributes back to the state before attachDomRoot was called.\n\n\n      for (var attribute in initialDomRootAttributes) {\n        domRoot.setAttribute(attribute, initialDomRootAttributes[attribute]);\n      }\n\n      this.domRoots.delete(name);\n      this.domConverter.unbindDomElement(domRoot);\n    }\n    /**\n     * Gets DOM root element.\n     *\n     * @param {String} [name='main']  Name of the root.\n     * @returns {Element} DOM root element instance.\n     */\n\n  }, {\n    key: \"getDomRoot\",\n    value: function getDomRoot() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n      return this.domRoots.get(name);\n    }\n    /**\n     * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it\n     * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future\n     * {@link #domRoots DOM roots}.\n     *\n     * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only\n     * when registered for the first time. This means that features and other components can register a single observer\n     * multiple times without caring whether it has been already added or not.\n     *\n     * @param {Function} Observer The constructor of an observer to add.\n     * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.\n     * @returns {module:engine/view/observer/observer~Observer} Added observer instance.\n     */\n\n  }, {\n    key: \"addObserver\",\n    value: function addObserver(Observer) {\n      var observer = this._observers.get(Observer);\n\n      if (observer) {\n        return observer;\n      }\n\n      observer = new Observer(this);\n\n      this._observers.set(Observer, observer);\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.domRoots[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              name = _step2$value[0],\n              domElement = _step2$value[1];\n\n          observer.observe(domElement, name);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      observer.enable();\n      return observer;\n    }\n    /**\n     * Returns observer of the given type or `undefined` if such observer has not been added yet.\n     *\n     * @param {Function} Observer The constructor of an observer to get.\n     * @returns {module:engine/view/observer/observer~Observer|undefined} Observer instance or undefined.\n     */\n\n  }, {\n    key: \"getObserver\",\n    value: function getObserver(Observer) {\n      return this._observers.get(Observer);\n    }\n    /**\n     * Disables all added observers.\n     */\n\n  }, {\n    key: \"disableObservers\",\n    value: function disableObservers() {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this._observers.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var observer = _step3.value;\n          observer.disable();\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n    /**\n     * Enables all added observers.\n     */\n\n  }, {\n    key: \"enableObservers\",\n    value: function enableObservers() {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this._observers.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var observer = _step4.value;\n          observer.enable();\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n    /**\n     * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the\n     * caret, if not already visible to the user.\n     */\n\n  }, {\n    key: \"scrollToTheSelection\",\n    value: function scrollToTheSelection() {\n      var range = this.document.selection.getFirstRange();\n\n      if (range) {\n        scrollViewportToShowTarget({\n          target: this.domConverter.viewRangeToDom(range),\n          viewportOffset: 20\n        });\n      }\n    }\n    /**\n     * It will focus DOM element representing {@link module:engine/view/editableelement~EditableElement EditableElement}\n     * that is currently having selection inside.\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (!this.document.isFocused) {\n        var editable = this.document.selection.editableElement;\n\n        if (editable) {\n          this.domConverter.focus(editable);\n          this.forceRender();\n        } else {\n          /**\n           * Before focusing view document, selection should be placed inside one of the view's editables.\n           * Normally its selection will be converted from model document (which have default selection), but\n           * when using view document on its own, we need to manually place selection before focusing it.\n           *\n           * @error view-focus-no-selection\n           */\n          log.warn('view-focus-no-selection: There is no selection in any editable to focus.');\n        }\n      }\n    }\n    /**\n     * The `change()` method is the primary way of changing the view. You should use it to modify any node in the view tree.\n     * It makes sure that after all changes are made the view is rendered to the DOM (assuming that the view will be changed\n     * inside the callback). It prevents situations when the DOM is updated when the view state is not yet correct. It allows\n     * to nest calls one inside another and still performs a single rendering after all those changes are made.\n     * It also returns the return value of its callback.\n     *\n     *\t\tconst text = view.change( writer => {\n     *\t\t\tconst newText = writer.createText( 'foo' );\n     *\t\t\twriter.insert( position1, newText );\n     *\n     *\t\t\tview.change( writer => {\n     *\t\t\t\twriter.insert( position2, writer.createText( 'bar' ) );\n     *\t\t\t} );\n     *\n     * \t\t\twriter.remove( range );\n     *\n     * \t\t\treturn newText;\n     *\t\t} );\n     *\n     * When the outermost change block is done and rendering to the DOM is over the\n     * {@link module:engine/view/view~View#event:render `View#render`} event is fired.\n     *\n     * This method throws a `applying-view-changes-on-rendering` error when\n     * the change block is used after rendering to the DOM has started.\n     *\n     * @param {Function} callback Callback function which may modify the view.\n     * @returns {*} Value returned by the callback.\n     */\n\n  }, {\n    key: \"change\",\n    value: function change(callback) {\n      if (this.isRenderingInProgress || this._postFixersInProgress) {\n        /**\n         * Thrown when there is an attempt to make changes to the view tree when it is in incorrect state. This may\n         * cause some unexpected behaviour and inconsistency between the DOM and the view.\n         * This may be caused by:\n         *\n         * * calling {@link #change} or {@link #forceRender} during rendering process,\n         * * calling {@link #change} or {@link #forceRender} inside of\n         *   {@link module:engine/view/document~Document#registerPostFixer post-fixer function}.\n         *\n         * @error cannot-change-view-tree\n         */\n        throw new CKEditorError('cannot-change-view-tree: ' + 'Attempting to make changes to the view when it is in an incorrect state: rendering or post-fixers are in progress. ' + 'This may cause some unexpected behavior and inconsistency between the DOM and the view.');\n      } // Recursive call to view.change() method - execute listener immediately.\n\n\n      if (this._ongoingChange) {\n        return callback(this._writer);\n      } // This lock will assure that all recursive calls to view.change() will end up in same block - one \"render\"\n      // event for all nested calls.\n\n\n      this._ongoingChange = true;\n      var callbackResult = callback(this._writer);\n      this._ongoingChange = false; // This lock is used by editing controller to render changes from outer most model.change() once. As plugins might call\n      // view.change() inside model.change() block - this will ensures that postfixers and rendering are called once after all changes.\n      // Also, we don't need to render anything if there're no changes since last rendering.\n\n      if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {\n        this._postFixersInProgress = true;\n\n        this.document._callPostFixers(this._writer);\n\n        this._postFixersInProgress = false;\n        this.fire('render');\n      }\n\n      return callbackResult;\n    }\n    /**\n     * Forces rendering {@link module:engine/view/document~Document view document} to DOM. If any view changes are\n     * currently in progress, rendering will start after all {@link #change change blocks} are processed.\n     *\n     * Note that this method is dedicated for special cases. All view changes should be wrapped in the {@link #change}\n     * block and the view will automatically check whether it needs to render DOM or not.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when\n     * trying to re-render when rendering to DOM has already started.\n     */\n\n  }, {\n    key: \"forceRender\",\n    value: function forceRender() {\n      this._hasChangedSinceTheLastRendering = true;\n      this.change(function () {});\n    }\n    /**\n     * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this._observers.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var observer = _step5.value;\n          observer.destroy();\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      this.document.destroy();\n      this.stopListening();\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/view/position~Position position},\n     * * parent element and offset (offset defaults to `0`),\n     * * parent element and `'end'` (sets position at the end of that element),\n     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n     *\n     * This method is a shortcut to other constructors such as:\n     *\n     * * {@link #createPositionBefore},\n     * * {@link #createPositionAfter},\n     *\n     * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     */\n\n  }, {\n    key: \"createPositionAt\",\n    value: function createPositionAt(itemOrPosition, offset) {\n      return Position._createAt(itemOrPosition, offset);\n    }\n    /**\n     * Creates a new position after given view item.\n     *\n     * @param {module:engine/view/item~Item} item View item after which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAfter\",\n    value: function createPositionAfter(item) {\n      return Position._createAfter(item);\n    }\n    /**\n     * Creates a new position before given view item.\n     *\n     * @param {module:engine/view/item~Item} item View item before which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"createPositionBefore\",\n    value: function createPositionBefore(item) {\n      return Position._createBefore(item);\n    }\n    /**\n     * Creates a range spanning from `start` position to `end` position.\n     *\n     * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n     *\n     * @param {module:engine/view/position~Position} start Start position.\n     * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"createRange\",\n    value: function createRange(start, end) {\n      return new Range(start, end);\n    }\n    /**\n     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n     *\n     * @param {module:engine/view/item~Item} item\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"createRangeOn\",\n    value: function createRangeOn(item) {\n      return Range._createOn(item);\n    }\n    /**\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"createRangeIn\",\n    value: function createRangeIn(element) {\n      return Range._createIn(element);\n    }\n    /**\n     Creates new {@link module:engine/view/selection~Selection} instance.\n     *\n     * \t\t// Creates empty selection without ranges.\n     *\t\tconst selection = view.createSelection();\n     *\n     *\t\t// Creates selection at the given range.\n     *\t\tconst range = view.createRange( start, end );\n     *\t\tconst selection = view.createSelection( range );\n     *\n     *\t\t// Creates selection at the given ranges\n     * \t\tconst ranges = [ view.createRange( start1, end2 ), view.createRange( star2, end2 ) ];\n     *\t\tconst selection = view.createSelection( ranges );\n     *\n     *\t\t// Creates selection from the other selection.\n     *\t\tconst otherSelection = view.createSelection();\n     *\t\tconst selection = view.createSelection( otherSelection );\n     *\n     *\t\t// Creates selection from the document selection.\n     *\t\tconst selection = view.createSelection( editor.editing.view.document.selection );\n     *\n     * \t\t// Creates selection at the given position.\n     *\t\tconst position = view.createPositionFromPath( root, path );\n     *\t\tconst selection = view.createSelection( position );\n     *\n     *\t\t// Creates collapsed selection at the position of given item and offset.\n     *\t\tconst paragraph = view.createContainerElement( 'paragraph' );\n     *\t\tconst selection = view.createSelection( paragraph, offset );\n     *\n     *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n     *\t\t// first child of that element and ends after the last child of that element.\n     *\t\tconst selection = view.createSelection( paragraph, 'in' );\n     *\n     *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n     *\t\t// just after the item.\n     *\t\tconst selection = view.createSelection( paragraph, 'on' );\n     *\n     * `Selection`'s factory method allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n     *\n     *\t\t// Creates backward selection.\n     *\t\tconst selection = view.createSelection( range, { backward: true } );\n     *\n     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n     * represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n     * (and be  properly handled by screen readers).\n     *\n     *\t\t// Creates fake selection with label.\n     *\t\tconst selection = view.createSelection( range, { fake: true, label: 'foo' } );\n     *\n     * @param {module:engine/view/selection~Selectable} [selectable=null]\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n     * @param {String} [options.label] Label for the fake selection.\n     * @returns {module:engine/view/selection~Selection}\n     */\n\n  }, {\n    key: \"createSelection\",\n    value: function createSelection(selectable, placeOrOffset, options) {\n      return new Selection(selectable, placeOrOffset, options);\n    }\n    /**\n     * Disables or enables rendering. If the flag is set to `true` then the rendering will be disabled.\n     * If the flag is set to `false` and if there was some change in the meantime, then the rendering action will be performed.\n     *\n     * @protected\n     * @param {Boolean} flag A flag indicates whether the rendering should be disabled.\n     */\n\n  }, {\n    key: \"_disableRendering\",\n    value: function _disableRendering(flag) {\n      this._renderingDisabled = flag;\n\n      if (flag == false) {\n        // Render when you stop blocking rendering.\n        this.change(function () {});\n      }\n    }\n    /**\n     * Renders all changes. In order to avoid triggering the observers (e.g. mutations) all observers are disabled\n     * before rendering and re-enabled after that.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      this.isRenderingInProgress = true;\n      this.disableObservers();\n\n      this._renderer.render();\n\n      this.enableObservers();\n      this.isRenderingInProgress = false;\n    }\n    /**\n     * Fired after a topmost {@link module:engine/view/view~View#change change block} and all\n     * {@link module:engine/view/document~Document#registerPostFixer post-fixers} are executed.\n     *\n     * Actual rendering is performed as a first listener on 'normal' priority.\n     *\n     *\t\tview.on( 'render', () => {\n     *\t\t\t// Rendering to the DOM is complete.\n     *\t\t} );\n     *\n     * This event is useful when you want to update interface elements after the rendering, e.g. position of the\n     * balloon panel. If you wants to change view structure use\n     * {@link module:engine/view/document~Document#registerPostFixer post-fixers}.\n     *\n     * @event module:engine/view/view~View#event:render\n     */\n\n  }]);\n\n  return View;\n}();\n\nexport { View as default };\nmix(View, ObservableMixin);","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/element\n */\nimport Node from \"./node\";\nimport NodeList from \"./nodelist\";\nimport Text from \"./text\";\nimport TextProxy from \"./textproxy\";\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n/**\n * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and\n * {@link module:engine/model/element~Element#getChildren child nodes}.\n *\n * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.\n *\n * @extends {module:engine/model/node~Node}\n */\n\nvar Element =\n/*#__PURE__*/\nfunction (_Node) {\n  _inherits(Element, _Node);\n\n  /**\n   * Creates a model element.\n   *\n   * **Note:** Constructor of this class shouldn't be used directly in the code.\n   * Use the {@link module:engine/model/writer~Writer#createElement} method instead.\n   *\n   * @protected\n   * @param {String} name Element's name.\n   * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n   * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n   * One or more nodes to be inserted as children of created element.\n   */\n  function Element(name, attrs, children) {\n    var _this;\n\n    _classCallCheck(this, Element);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this, attrs));\n    /**\n     * Element name.\n     *\n     * @readonly\n     * @member {String} module:engine/model/element~Element#name\n     */\n\n    _this.name = name;\n    /**\n     * List of children nodes.\n     *\n     * @private\n     * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children\n     */\n\n    _this._children = new NodeList();\n\n    if (children) {\n      _this._insertChild(0, children);\n    }\n\n    return _this;\n  }\n  /**\n   * Number of this element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  _createClass(Element, [{\n    key: \"is\",\n\n    /**\n     * Checks whether this model object is of the given type.\n     *\n     *\t\tobj.name; // 'listItem'\n     *\t\tobj instanceof Element; // true\n     *\n     *\t\tobj.is( 'element' ); // true\n     *\t\tobj.is( 'listItem' ); // true\n     *\t\tobj.is( 'element', 'listItem' ); // true\n     *\t\tobj.is( 'text' ); // false\n     *\t\tobj.is( 'element', 'image' ); // false\n     *\n     * Read more in {@link module:engine/model/node~Node#is `Node#is()`}.\n     *\n     * @param {String} type Type to check when `name` parameter is present.\n     * Otherwise, it acts like the `name` parameter.\n     * @param {String} [name] Element name.\n     * @returns {Boolean}\n     */\n    value: function is(type) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!name) {\n        return type == 'element' || type == this.name || _get(_getPrototypeOf(Element.prototype), \"is\", this).call(this, type);\n      } else {\n        return type == 'element' && name == this.name;\n      }\n    }\n    /**\n     * Gets the child at the given index.\n     *\n     * @param {Number} index Index of child.\n     * @returns {module:engine/model/node~Node} Child node.\n     */\n\n  }, {\n    key: \"getChild\",\n    value: function getChild(index) {\n      return this._children.getNode(index);\n    }\n    /**\n     * Returns an iterator that iterates over all of this element's children.\n     *\n     * @returns {Iterable.<module:engine/model/node~Node>}\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this._children[Symbol.iterator]();\n    }\n    /**\n     * Returns an index of the given child node. Returns `null` if given node is not a child of this element.\n     *\n     * @param {module:engine/model/node~Node} node Child node to look for.\n     * @returns {Number} Child node's index in this element.\n     */\n\n  }, {\n    key: \"getChildIndex\",\n    value: function getChildIndex(node) {\n      return this._children.getNodeIndex(node);\n    }\n    /**\n     * Returns the starting offset of given child. Starting offset is equal to the sum of\n     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n     * given node is not a child of this element.\n     *\n     * @param {module:engine/model/node~Node} node Child node to look for.\n     * @returns {Number} Child node's starting offset.\n     */\n\n  }, {\n    key: \"getChildStartOffset\",\n    value: function getChildStartOffset(node) {\n      return this._children.getNodeStartOffset(node);\n    }\n    /**\n     * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n     * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.\n     *\n     *\t\tconst textNode = new Text( 'foo' );\n     *\t\tconst pElement = new Element( 'p' );\n     *\t\tconst divElement = new Element( [ textNode, pElement ] );\n     *\t\tdivElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n     *\t\tdivElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n     *\t\tdivElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n     *\t\tdivElement.offsetToIndex( 2 ); // Returns 0.\n     *\t\tdivElement.offsetToIndex( 3 ); // Returns 1.\n     *\t\tdivElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n     *\n     * @param {Number} offset Offset to look for.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"offsetToIndex\",\n    value: function offsetToIndex(offset) {\n      return this._children.offsetToIndex(offset);\n    }\n    /**\n     * Returns a descendant node by its path relative to this element.\n     *\n     *\t\t// <this>a<b>c</b></this>\n     *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n     *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n     *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n     *\n     * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n     * @returns {module:engine/model/node~Node}\n     */\n\n  }, {\n    key: \"getNodeByPath\",\n    value: function getNodeByPath(relativePath) {\n      var node = this; // eslint-disable-line consistent-this\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = relativePath[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var index = _step.value;\n          node = node.getChild(node.offsetToIndex(index));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return node;\n    }\n    /**\n     * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.\n     *\n     * @returns {Object} `Element` instance converted to plain object.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(Element.prototype), \"toJSON\", this).call(this);\n\n      json.name = this.name;\n\n      if (this._children.length > 0) {\n        json.children = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this._children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var node = _step2.value;\n            json.children.push(node.toJSON());\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      return json;\n    }\n    /**\n     * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.\n     * If clone is deep, the original element's children are also cloned. If not, then empty element is removed.\n     *\n     * @protected\n     * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n     * element will be cloned without any child.\n     */\n\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var children = deep ? Array.from(this._children).map(function (node) {\n        return node._clone(true);\n      }) : null;\n      return new Element(this.name, this.getAttributes(), children);\n    }\n    /**\n     * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.\n     *\n     * @see module:engine/model/writer~Writer#append\n     * @protected\n     * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} nodes Nodes to be inserted.\n     */\n\n  }, {\n    key: \"_appendChild\",\n    value: function _appendChild(nodes) {\n      this._insertChild(this.childCount, nodes);\n    }\n    /**\n     * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n     * to this element.\n     *\n     * @see module:engine/model/writer~Writer#insert\n     * @protected\n     * @param {Number} index Index at which nodes should be inserted.\n     * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n     */\n\n  }, {\n    key: \"_insertChild\",\n    value: function _insertChild(index, items) {\n      var nodes = normalize(items);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var node = _step3.value;\n\n          // If node that is being added to this element is already inside another element, first remove it from the old parent.\n          if (node.parent !== null) {\n            node._remove();\n          }\n\n          node.parent = this;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      this._children._insertNodes(index, nodes);\n    }\n    /**\n     * Removes one or more nodes starting at the given index and sets\n     * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n     *\n     * @see module:engine/model/writer~Writer#remove\n     * @protected\n     * @param {Number} index Index of the first node to remove.\n     * @param {Number} [howMany=1] Number of nodes to remove.\n     * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n     */\n\n  }, {\n    key: \"_removeChildren\",\n    value: function _removeChildren(index) {\n      var howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var nodes = this._children._removeNodes(index, howMany);\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = nodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var node = _step4.value;\n          node.parent = null;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return nodes;\n    }\n    /**\n     * Creates an `Element` instance from given plain object (i.e. parsed JSON string).\n     * Converts `Element` children to proper nodes.\n     *\n     * @param {Object} json Plain object to be converted to `Element`.\n     * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.\n     */\n\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this._children.length;\n    }\n    /**\n     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n  }, {\n    key: \"maxOffset\",\n    get: function get() {\n      return this._children.maxOffset;\n    }\n    /**\n     * Is `true` if there are no nodes inside this element, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.childCount === 0;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var children = null;\n\n      if (json.children) {\n        children = [];\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = json.children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var child = _step5.value;\n\n            if (child.name) {\n              // If child has name property, it is an Element.\n              children.push(Element.fromJSON(child));\n            } else {\n              // Otherwise, it is a Text node.\n              children.push(Text.fromJSON(child));\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n\n      return new Element(json.name, json.attributes, children);\n    }\n  }]);\n\n  return Element;\n}(Node); // Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\n\n\nexport { Element as default };\n\nfunction normalize(nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(nodes)];\n  }\n\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  } // Array.from to enable .map() on non-arrays.\n\n\n  return Array.from(nodes).map(function (node) {\n    if (typeof node == 'string') {\n      return new Text(node);\n    }\n\n    if (node instanceof TextProxy) {\n      return new Text(node.data, node.getAttributes());\n    }\n\n    return node;\n  });\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/treewalker\n */\nimport Text from \"./text\";\nimport TextProxy from \"./textproxy\";\nimport Element from \"./element\";\nimport Position from \"./position\";\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\n\nvar TreeWalker =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n   *\n   * @constructor\n   * @param {Object} [options={}] Object with configuration.\n   * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n   * @param {module:engine/model/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n   * @param {module:engine/model/position~Position} [options.startPosition] Starting position.\n   * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes\n   * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one\n   * {@link module:engine/model/textproxy~TextProxy} (`false`).\n   * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n   * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n   * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n   * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n   * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned\n   * twice: for `'elementStart'` and `'elementEnd'`.\n   */\n  function TreeWalker() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TreeWalker);\n\n    if (!options.boundaries && !options.startPosition) {\n      /**\n       * Neither boundaries nor starting position of a `TreeWalker` have been defined.\n       *\n       * @error model-tree-walker-no-start-position\n       */\n      throw new CKEditorError('model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.');\n    }\n\n    var direction = options.direction || 'forward';\n\n    if (direction != 'forward' && direction != 'backward') {\n      throw new CKEditorError('model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.', {\n        direction: direction\n      });\n    }\n    /**\n     * Walking direction. Defaults `'forward'`.\n     *\n     * @readonly\n     * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction\n     */\n\n\n    this.direction = direction;\n    /**\n     * Iterator boundaries.\n     *\n     * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n     * on the start of boundary, then `{ done: true }` is returned.\n     *\n     * If boundaries are not defined they are set before first and after last child of the root node.\n     *\n     * @readonly\n     * @member {module:engine/model/range~Range} module:engine/model/treewalker~TreeWalker#boundaries\n     */\n\n    this.boundaries = options.boundaries || null;\n    /**\n     * Iterator position. This is always static position, even if the initial position was a\n     * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends\n     * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction\n     * is `'backward'` position starts from the end.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position\n     */\n\n    if (options.startPosition) {\n      this.position = options.startPosition.clone();\n    } else {\n      this.position = Position._createAt(this.boundaries[this.direction == 'backward' ? 'end' : 'start']);\n    } // Reset position stickiness in case it was set to other value, as the stickiness is kept after cloning.\n\n\n    this.position.stickiness = 'toNone';\n    /**\n     * Flag indicating whether all consecutive characters with the same attributes should be\n     * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).\n     *\n     * @readonly\n     * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters\n     */\n\n    this.singleCharacters = !!options.singleCharacters;\n    /**\n     * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n     * iterated node will not be returned along with `elementEnd` tag.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow\n     */\n\n    this.shallow = !!options.shallow;\n    /**\n     * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not\n     * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will\n     * be returned once, while if the option is `false` they might be returned twice:\n     * for `'elementStart'` and `'elementEnd'`.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd\n     */\n\n    this.ignoreElementEnd = !!options.ignoreElementEnd;\n    /**\n     * Start boundary cached for optimization purposes.\n     *\n     * @private\n     * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent\n     */\n\n    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n    /**\n     * End boundary cached for optimization purposes.\n     *\n     * @private\n     * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent\n     */\n\n    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n    /**\n     * Parent of the most recently visited node. Cached for optimization purposes.\n     *\n     * @private\n     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     * module:engine/model/treewalker~TreeWalker#_visitedParent\n     */\n\n    this._visitedParent = this.position.parent;\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n   */\n\n\n  _createClass(TreeWalker, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this;\n    }\n    /**\n     * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n     *\n     * For example:\n     *\n     * \t\twalker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n     * \t\twalker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]\n     * \t\twalker.skip( () => false ); // Do not move the position.\n     *\n     * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n     * return `true` if the value should be skipped or `false` if not.\n     */\n\n  }, {\n    key: \"skip\",\n    value: function skip(_skip) {\n      var done, value, prevPosition, prevVisitedParent;\n\n      do {\n        prevPosition = this.position;\n        prevVisitedParent = this._visitedParent;\n\n        var _this$next = this.next();\n\n        done = _this$next.done;\n        value = _this$next.value;\n      } while (!done && _skip(value));\n\n      if (!done) {\n        this.position = prevPosition;\n        this._visitedParent = prevVisitedParent;\n      }\n    }\n    /**\n     * Gets the next tree walker's value.\n     *\n     * @returns {module:engine/model/treewalker~TreeWalkerValue} Next tree walker's value.\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.direction == 'forward') {\n        return this._next();\n      } else {\n        return this._previous();\n      }\n    }\n    /**\n     * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.\n     *\n     * @private\n     * @returns {Object}\n     * @returns {Boolean} return.done True if iterator is done.\n     * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n     */\n\n  }, {\n    key: \"_next\",\n    value: function _next() {\n      var previousPosition = this.position;\n      var position = this.position.clone();\n      var parent = this._visitedParent; // We are at the end of the root.\n\n      if (parent.parent === null && position.offset === parent.maxOffset) {\n        return {\n          done: true\n        };\n      } // We reached the walker boundary.\n\n\n      if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {\n        return {\n          done: true\n        };\n      }\n\n      var node = position.textNode ? position.textNode : position.nodeAfter;\n\n      if (node instanceof Element) {\n        if (!this.shallow) {\n          // Manual operations on path internals for optimization purposes. Here and in the rest of the method.\n          position.path.push(0);\n          this._visitedParent = node;\n        } else {\n          position.offset++;\n        }\n\n        this.position = position;\n        return formatReturnValue('elementStart', node, previousPosition, position, 1);\n      } else if (node instanceof Text) {\n        var charactersCount;\n\n        if (this.singleCharacters) {\n          charactersCount = 1;\n        } else {\n          var offset = node.endOffset;\n\n          if (this._boundaryEndParent == parent && this.boundaries.end.offset < offset) {\n            offset = this.boundaries.end.offset;\n          }\n\n          charactersCount = offset - position.offset;\n        }\n\n        var offsetInTextNode = position.offset - node.startOffset;\n        var item = new TextProxy(node, offsetInTextNode, charactersCount);\n        position.offset += charactersCount;\n        this.position = position;\n        return formatReturnValue('text', item, previousPosition, position, charactersCount);\n      } else {\n        // `node` is not set, we reached the end of current `parent`.\n        position.path.pop();\n        position.offset++;\n        this.position = position;\n        this._visitedParent = parent.parent;\n\n        if (this.ignoreElementEnd) {\n          return this._next();\n        } else {\n          return formatReturnValue('elementEnd', parent, previousPosition, position);\n        }\n      }\n    }\n    /**\n     * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.\n     *\n     * @private\n     * @returns {Object}\n     * @returns {Boolean} return.done True if iterator is done.\n     * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n     */\n\n  }, {\n    key: \"_previous\",\n    value: function _previous() {\n      var previousPosition = this.position;\n      var position = this.position.clone();\n      var parent = this._visitedParent; // We are at the beginning of the root.\n\n      if (parent.parent === null && position.offset === 0) {\n        return {\n          done: true\n        };\n      } // We reached the walker boundary.\n\n\n      if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {\n        return {\n          done: true\n        };\n      } // Get node just before current position\n\n\n      var node = position.textNode ? position.textNode : position.nodeBefore;\n\n      if (node instanceof Element) {\n        position.offset--;\n\n        if (!this.shallow) {\n          position.path.push(node.maxOffset);\n          this.position = position;\n          this._visitedParent = node;\n\n          if (this.ignoreElementEnd) {\n            return this._previous();\n          } else {\n            return formatReturnValue('elementEnd', node, previousPosition, position);\n          }\n        } else {\n          this.position = position;\n          return formatReturnValue('elementStart', node, previousPosition, position, 1);\n        }\n      } else if (node instanceof Text) {\n        var charactersCount;\n\n        if (this.singleCharacters) {\n          charactersCount = 1;\n        } else {\n          var offset = node.startOffset;\n\n          if (this._boundaryStartParent == parent && this.boundaries.start.offset > offset) {\n            offset = this.boundaries.start.offset;\n          }\n\n          charactersCount = position.offset - offset;\n        }\n\n        var offsetInTextNode = position.offset - node.startOffset;\n        var item = new TextProxy(node, offsetInTextNode - charactersCount, charactersCount);\n        position.offset -= charactersCount;\n        this.position = position;\n        return formatReturnValue('text', item, previousPosition, position, charactersCount);\n      } else {\n        // `node` is not set, we reached the beginning of current `parent`.\n        position.path.pop();\n        this.position = position;\n        this._visitedParent = parent.parent;\n        return formatReturnValue('elementStart', parent, previousPosition, position, 1);\n      }\n    }\n  }]);\n\n  return TreeWalker;\n}();\n\nexport { TreeWalker as default };\n\nfunction formatReturnValue(type, item, previousPosition, nextPosition, length) {\n  return {\n    done: false,\n    value: {\n      type: type,\n      item: item,\n      previousPosition: previousPosition,\n      nextPosition: nextPosition,\n      length: length\n    }\n  };\n}\n/**\n * Type of the step made by {@link module:engine/model/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end of node,\n * `'character'` if walker traversed over a character, or `'text'` if walker traversed over multiple characters (available in\n * character merging mode, see {@link module:engine/model/treewalker~TreeWalker#constructor}).\n *\n * @typedef {'elementStart'|'elementEnd'|'character'|'text'} module:engine/model/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/model/treewalker~TreeWalker} when traversing tree model.\n *\n * @typedef {Object} module:engine/model/treewalker~TreeWalkerValue\n * @property {module:engine/model/treewalker~TreeWalkerValueType} type\n * @property {module:engine/model/item~Item} item Item between old and new positions of {@link module:engine/model/treewalker~TreeWalker}.\n * @property {module:engine/model/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * @property {module:engine/model/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * @property {Number} [length] Length of the item. For `'elementStart'` and `'character'` it is 1. For `'text'` it is\n * the length of the text. For `'elementEnd'` it is `undefined`.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection\n */","import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.set\";\nimport \"core-js/modules/es6.map\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.weak-map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/mapper\n */\nimport ModelPosition from \"../model/position\";\nimport ModelRange from \"../model/range\";\nimport ViewPosition from \"../view/position\";\nimport ViewRange from \"../view/range\";\nimport ViewText from \"../view/text\";\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Maps elements, positions and markers between {@link module:engine/view/document~Document the view} and\n * {@link module:engine/model/model the model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map complex model to/from view relations, you may provide custom callbacks for\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n */\n\nvar Mapper =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the mapper.\n   */\n  function Mapper() {\n    var _this = this;\n\n    _classCallCheck(this, Mapper);\n\n    /**\n     * Model element to view element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n    this._modelToViewMapping = new WeakMap();\n    /**\n     * View element to model element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n\n    this._viewToModelMapping = new WeakMap();\n    /**\n     * A map containing callbacks between view element names and functions evaluating length of view elements\n     * in model.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._viewToModelLengthCallbacks = new Map();\n    /**\n     * Model marker name to view elements mapping.\n     *\n     * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n     * One marker (name) can be mapped to multiple elements.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._markerNameToElements = new Map(); // Default mapper algorithm for mapping model position to view position.\n\n    this.on('modelToViewPosition', function (evt, data) {\n      if (data.viewPosition) {\n        return;\n      }\n\n      var viewContainer = _this._modelToViewMapping.get(data.modelPosition.parent);\n\n      data.viewPosition = _this._findPositionIn(viewContainer, data.modelPosition.offset);\n    }, {\n      priority: 'low'\n    }); // Default mapper algorithm for mapping view position to model position.\n\n    this.on('viewToModelPosition', function (evt, data) {\n      if (data.modelPosition) {\n        return;\n      }\n\n      var viewBlock = _this.findMappedViewAncestor(data.viewPosition);\n\n      var modelParent = _this._viewToModelMapping.get(viewBlock);\n\n      var modelOffset = _this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);\n\n      data.modelPosition = ModelPosition._createAt(modelParent, modelOffset);\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n   * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n   * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n   * The information that elements are bound is also used to translate positions.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element.\n   * @param {module:engine/view/element~Element} viewElement View element.\n   */\n\n\n  _createClass(Mapper, [{\n    key: \"bindElements\",\n    value: function bindElements(modelElement, viewElement) {\n      this._modelToViewMapping.set(modelElement, viewElement);\n\n      this._viewToModelMapping.set(viewElement, modelElement);\n    }\n    /**\n     * Unbinds given {@link module:engine/view/element~Element view element} from the map.\n     *\n     * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n     * will be removed only if model element is still bound to passed `viewElement`.\n     *\n     * This behavior lets for re-binding model element to another view element without fear of losing the new binding\n     * when the previously bound view element is unbound.\n     *\n     * @param {module:engine/view/element~Element} viewElement View element to unbind.\n     */\n\n  }, {\n    key: \"unbindViewElement\",\n    value: function unbindViewElement(viewElement) {\n      var modelElement = this.toModelElement(viewElement);\n\n      this._viewToModelMapping.delete(viewElement);\n\n      if (this._modelToViewMapping.get(modelElement) == viewElement) {\n        this._modelToViewMapping.delete(modelElement);\n      }\n    }\n    /**\n     * Unbinds given {@link module:engine/model/element~Element model element} from the map.\n     *\n     * **Note:** model-to-view binding will be removed, if it existed. However, corresponding view-to-model binding\n     * will be removed only if view element is still bound to passed `modelElement`.\n     *\n     * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n     * when the previously bound model element is unbound.\n     *\n     * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n     */\n\n  }, {\n    key: \"unbindModelElement\",\n    value: function unbindModelElement(modelElement) {\n      var viewElement = this.toViewElement(modelElement);\n\n      this._modelToViewMapping.delete(modelElement);\n\n      if (this._viewToModelMapping.get(viewElement) == modelElement) {\n        this._viewToModelMapping.delete(viewElement);\n      }\n    }\n    /**\n     * Binds given marker name with given {@link module:engine/view/element~Element view element}. The element\n     * will be added to the current set of elements bound with given marker name.\n     *\n     * @param {module:engine/view/element~Element} element Element to bind.\n     * @param {String} name Marker name.\n     */\n\n  }, {\n    key: \"bindElementToMarker\",\n    value: function bindElementToMarker(element, name) {\n      var elements = this._markerNameToElements.get(name) || new Set();\n      elements.add(element);\n\n      this._markerNameToElements.set(name, elements);\n    }\n    /**\n     * Unbinds all elements from given marker name.\n     *\n     * @param {String} name Marker name.\n     */\n\n  }, {\n    key: \"unbindElementsFromMarkerName\",\n    value: function unbindElementsFromMarkerName(name) {\n      this._markerNameToElements.delete(name);\n    }\n    /**\n     * Removes all model to view and view to model bindings.\n     */\n\n  }, {\n    key: \"clearBindings\",\n    value: function clearBindings() {\n      this._modelToViewMapping = new WeakMap();\n      this._viewToModelMapping = new WeakMap();\n      this._markerNameToElements = new Map();\n    }\n    /**\n     * Gets the corresponding model element.\n     *\n     * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n     *\n     * @param {module:engine/view/element~Element} viewElement View element.\n     * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n     */\n\n  }, {\n    key: \"toModelElement\",\n    value: function toModelElement(viewElement) {\n      return this._viewToModelMapping.get(viewElement);\n    }\n    /**\n     * Gets the corresponding view element.\n     *\n     * @param {module:engine/model/element~Element} modelElement Model element.\n     * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n     */\n\n  }, {\n    key: \"toViewElement\",\n    value: function toViewElement(modelElement) {\n      return this._modelToViewMapping.get(modelElement);\n    }\n    /**\n     * Gets the corresponding model range.\n     *\n     * @param {module:engine/view/range~Range} viewRange View range.\n     * @returns {module:engine/model/range~Range} Corresponding model range.\n     */\n\n  }, {\n    key: \"toModelRange\",\n    value: function toModelRange(viewRange) {\n      return new ModelRange(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));\n    }\n    /**\n     * Gets the corresponding view range.\n     *\n     * @param {module:engine/model/range~Range} modelRange Model range.\n     * @returns {module:engine/view/range~Range} Corresponding view range.\n     */\n\n  }, {\n    key: \"toViewRange\",\n    value: function toViewRange(modelRange) {\n      return new ViewRange(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));\n    }\n    /**\n     * Gets the corresponding model position.\n     *\n     * @fires viewToModelPosition\n     * @param {module:engine/view/position~Position} viewPosition View position.\n     * @returns {module:engine/model/position~Position} Corresponding model position.\n     */\n\n  }, {\n    key: \"toModelPosition\",\n    value: function toModelPosition(viewPosition) {\n      var data = {\n        viewPosition: viewPosition,\n        mapper: this\n      };\n      this.fire('viewToModelPosition', data);\n      return data.modelPosition;\n    }\n    /**\n     * Gets the corresponding view position.\n     *\n     * @fires modelToViewPosition\n     * @param {module:engine/model/position~Position} modelPosition Model position.\n     * @param {Object} [options] Additional options for position mapping process.\n     * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n     * in model tree which no longer exists. For example, it could be an end of a removed model range.\n     * @returns {module:engine/view/position~Position} Corresponding view position.\n     */\n\n  }, {\n    key: \"toViewPosition\",\n    value: function toViewPosition(modelPosition) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        isPhantom: false\n      };\n      var data = {\n        modelPosition: modelPosition,\n        mapper: this,\n        isPhantom: options.isPhantom\n      };\n      this.fire('modelToViewPosition', data);\n      return data.viewPosition;\n    }\n    /**\n     * Gets all view elements bound to the given marker name.\n     *\n     * @param {String} name Marker name.\n     * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with given marker name or `null`\n     * if no elements are bound to given marker name.\n     */\n\n  }, {\n    key: \"markerNameToElements\",\n    value: function markerNameToElements(name) {\n      var boundElements = this._markerNameToElements.get(name);\n\n      if (!boundElements) {\n        return null;\n      }\n\n      var elements = new Set();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = boundElements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var element = _step.value;\n\n          if (element.is('attributeElement')) {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = element.getElementsWithSameId()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var clone = _step2.value;\n                elements.add(clone);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          } else {\n            elements.add(element);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return elements;\n    }\n    /**\n     * Registers a callback that evaluates the length in the model of a view element with given name.\n     *\n     * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n     * a number representing the length of view element in model.\n     *\n     *\t\t// List item in view may contain nested list, which have other list items. In model though,\n     *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n     *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n     *\n     *\t\tfunction getViewListItemLength( element ) {\n     *\t\t\tlet length = 1;\n     *\n     *\t\t\tfor ( let child of element.getChildren() ) {\n     *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n     *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n     *\t\t\t\t\t\tlength += getViewListItemLength( item );\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\n     *\t\t\treturn length;\n     *\t\t}\n     *\n     *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n     *\n     * @param {String} viewElementName Name of view element for which callback is registered.\n     * @param {Function} lengthCallback Function return a length of view element instance in model.\n     */\n\n  }, {\n    key: \"registerViewToModelLength\",\n    value: function registerViewToModelLength(viewElementName, lengthCallback) {\n      this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);\n    }\n    /**\n     * For given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n     * the model.\n     *\n     * @param {module:engine/view/position~Position} viewPosition Position for which mapped ancestor should be found.\n     * @returns {module:engine/view/element~Element}\n     */\n\n  }, {\n    key: \"findMappedViewAncestor\",\n    value: function findMappedViewAncestor(viewPosition) {\n      var parent = viewPosition.parent;\n\n      while (!this._viewToModelMapping.has(parent)) {\n        parent = parent.parent;\n      }\n\n      return parent;\n    }\n    /**\n     * Calculates model offset based on the view position and the block element.\n     *\n     * Example:\n     *\n     *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n     *\n     * Is a sum of:\n     *\n     *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n     *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n     *\n     * @private\n     * @param {module:engine/view/element~Element} viewParent Position parent.\n     * @param {Number} viewOffset Position offset.\n     * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n     * @returns {Number} Offset in the model.\n     */\n\n  }, {\n    key: \"_toModelOffset\",\n    value: function _toModelOffset(viewParent, viewOffset, viewBlock) {\n      if (viewBlock != viewParent) {\n        // See example.\n        var offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);\n\n        var offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);\n\n        return offsetToParentStart + offsetInParent;\n      } // viewBlock == viewParent, so we need to calculate the offset in the parent element.\n      // If the position is a text it is simple (\"ba|r\" -> 2).\n\n\n      if (viewParent.is('text')) {\n        return viewOffset;\n      } // If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\n\n      var modelOffset = 0;\n\n      for (var i = 0; i < viewOffset; i++) {\n        modelOffset += this.getModelLength(viewParent.getChild(i));\n      }\n\n      return modelOffset;\n    }\n    /**\n     * Gets the length of the view element in the model.\n     *\n     * The length is calculated as follows:\n     * * if {@link #registerViewToModelLength length mapping callback} is provided for given `viewNode` it is used to\n     * evaluate model length (`viewNode` is used as first and only parameter passed to the callback),\n     * * length of a {@link module:engine/view/text~Text text node} is equal to the length of it's\n     * {@link module:engine/view/text~Text#data data},\n     * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n     * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n     * * length of a not-mapped {@link module:engine/view/element~Element element} is equal to the length of it's children.\n     *\n     * Examples:\n     *\n     *\t\tfoo                          -> 3 // Text length is equal to it's data length.\n     *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n     *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n     *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n     *\n     * @param {module:engine/view/element~Element} viewNode View node.\n     * @returns {Number} Length of the node in the tree model.\n     */\n\n  }, {\n    key: \"getModelLength\",\n    value: function getModelLength(viewNode) {\n      if (this._viewToModelLengthCallbacks.get(viewNode.name)) {\n        var callback = this._viewToModelLengthCallbacks.get(viewNode.name);\n\n        return callback(viewNode);\n      } else if (this._viewToModelMapping.has(viewNode)) {\n        return 1;\n      } else if (viewNode.is('text')) {\n        return viewNode.data.length;\n      } else if (viewNode.is('uiElement')) {\n        return 0;\n      } else {\n        var len = 0;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = viewNode.getChildren()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var child = _step3.value;\n            len += this.getModelLength(child);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return len;\n      }\n    }\n    /**\n     * Finds the position in the view node (or its children) with the expected model offset.\n     *\n     * Example:\n     *\n     *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n     *\n     *\t\t_findPositionIn( p, 4 ):\n     *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n     *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n     *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n     *\n     *\t\t_findPositionIn( b, 4 - ( 5 - 3 ) ):\n     *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n     *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n     *\n     *\t\t_findPositionIn( bar, 2 - ( 3 - 3 ) ):\n     *\t\tWe are in the text node so we can simple find the offset.\n     *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n     *\n     * @private\n     * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n     * @param {Number} expectedOffset Expected offset.\n     * @returns {module:engine/view/position~Position} Found position.\n     */\n\n  }, {\n    key: \"_findPositionIn\",\n    value: function _findPositionIn(viewParent, expectedOffset) {\n      // Last scanned view node.\n      var viewNode; // Length of the last scanned view node.\n\n      var lastLength = 0;\n      var modelOffset = 0;\n      var viewOffset = 0; // In the text node it is simple: offset in the model equals offset in the text.\n\n      if (viewParent.is('text')) {\n        return new ViewPosition(viewParent, expectedOffset);\n      } // In other cases we add lengths of child nodes to find the proper offset.\n      // If it is smaller we add the length.\n\n\n      while (modelOffset < expectedOffset) {\n        viewNode = viewParent.getChild(viewOffset);\n        lastLength = this.getModelLength(viewNode);\n        modelOffset += lastLength;\n        viewOffset++;\n      } // If it equals we found the position.\n\n\n      if (modelOffset == expectedOffset) {\n        return this._moveViewPositionToTextNode(new ViewPosition(viewParent, viewOffset));\n      } // If it is higher we need to enter last child.\n      else {\n          // ( modelOffset - lastLength ) is the offset to the child we enter,\n          // so we subtract it from the expected offset to fine the offset in the child.\n          return this._findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));\n        }\n    }\n    /**\n     * Because we prefer positions in text nodes over positions next to text node moves view position to the text node\n     * if it was next to it.\n     *\n     *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n     *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n     *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n     *\n     * @private\n     * @param {module:engine/view/position~Position} viewPosition Position potentially next to text node.\n     * @returns {module:engine/view/position~Position} Position in text node if possible.\n     */\n\n  }, {\n    key: \"_moveViewPositionToTextNode\",\n    value: function _moveViewPositionToTextNode(viewPosition) {\n      // If the position is just after text node, put it at the end of that text node.\n      // If the position is just before text node, put it at the beginning of that text node.\n      var nodeBefore = viewPosition.nodeBefore;\n      var nodeAfter = viewPosition.nodeAfter;\n\n      if (nodeBefore instanceof ViewText) {\n        return new ViewPosition(nodeBefore, nodeBefore.data.length);\n      } else if (nodeAfter instanceof ViewText) {\n        return new ViewPosition(nodeAfter, 0);\n      } // Otherwise, just return the given position.\n\n\n      return viewPosition;\n    }\n    /**\n     * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n     * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n     * calculate {@link module:engine/view/position~Position view position}. Calculated view position should be added as `viewPosition`\n     * value in `data` object that is passed as one of parameters to the event callback.\n     *\n     * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n     * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n     * \t\t// <span> element.\n     *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n     *\t\t\tconst positionParent = modelPosition.parent;\n     *\n     *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n     *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n     *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n     *\n     *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n     *\n     *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n     *\t\t\t\tevt.stop();\n     *\t\t\t}\n     *\t\t} );\n     *\n     * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. \"Phantom\" model position is\n     * a position that points to a non-existing place in model. Such position might still be valid for conversion, though\n     * (it would point to a correct place in view when converted). One example of such situation is when a range is\n     * removed from model, there may be a need to map the range's end (which is no longer valid model position). To\n     * handle such situation, check `data.isPhantom` flag:\n     *\n     * \t\t// Assume that there is \"customElement\" model element and whenever position is before it, we want to move it\n     * \t\t// to the inside of the view element bound to \"customElement\".\n     *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n     *\t\t\tif ( data.isPhantom ) {\n     *\t\t\t\treturn;\n     *\t\t\t}\n     *\n     *\t\t\t// Below line might crash for phantom position that does not exist in model.\n     *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n     *\n     *\t\t\t// Check if this is the element we are interested in.\n     *\t\t\tif ( !sibling.is( 'customElement' ) ) {\n     *\t\t\t\treturn;\n     *\t\t\t}\n     *\n     *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n     *\n     *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n     *\n     *\t\t\tevt.stop();\n     *\t\t} );\n     *\n     * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n     * attach a custom callback after default callback and also use `data.viewPosition` calculated by default callback\n     * (for example to fix it).\n     *\n     * **Note:** default mapping callback will not fire if `data.viewPosition` is already set.\n     *\n     * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n     * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n     * the condition that checks if special case scenario happened should be as simple as possible.\n     *\n     * @event modelToViewPosition\n     * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n     * `viewPosition` value to that object with calculated {@link module:engine/view/position~Position view position}.\n     * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n     */\n\n    /**\n     * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n     *\n     * \t\t// See example in `modelToViewPosition` event description.\n     * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n     *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n     *\t\t\tconst positionParent = viewPosition.parent;\n     *\n     *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n     *\t\t\t\tconst viewImg = positionParent.previousSibling;\n     *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n     *\n     *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n     *\t\t\t\tevt.stop();\n     *\t\t\t}\n     *\t\t} );\n     *\n     * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n     * attach a custom callback after default callback and also use `data.modelPosition` calculated by default callback\n     * (for example to fix it).\n     *\n     * **Note:** default mapping callback will not fire if `data.modelPosition` is already set.\n     *\n     * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n     * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n     * the condition that checks if special case scenario happened should be as simple as possible.\n     *\n     * @event viewToModelPosition\n     * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n     * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n     * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n     */\n\n  }]);\n\n  return Mapper;\n}();\n\nexport { Mapper as default };\nmix(Mapper, EmitterMixin);","import \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/modelconsumable\n */\nimport TextProxy from \"../model/textproxy\";\n/**\n * Manages a list of consumable values for {@link module:engine/model/item~Item model items}.\n *\n * Consumables are various aspects of the model. A model item can be broken down into singular properties that might be\n * taken into consideration when converting that item.\n *\n * `ModelConsumable` is used by {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} while analyzing changed\n * parts of {@link module:engine/model/document~Document the document}. The added / changed / removed model items are broken down\n * into singular properties (the item itself and it's attributes). All those parts are saved in `ModelConsumable`. Then,\n * during conversion, when given part of model item is converted (i.e. the view element has been inserted into the view,\n * but without attributes), consumable value is removed from `ModelConsumable`.\n *\n * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addattribute:<attributeKey>`,\n * `changeattributes:<attributeKey>`, `removeattributes:<attributeKey>`.\n *\n * In most cases, it is enough to let {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * gather consumable values, so there is no need to use\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#add add method} directly.\n * However, it is important to understand how consumable values can be\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n * See {@link module:engine/conversion/downcasthelpers default downcast converters} for more information.\n *\n * Keep in mind, that one conversion event may have multiple callbacks (converters) attached to it. Each of those is\n * able to convert one or more parts of the model. However, when one of those callbacks actually converts\n * something, other should not, because they would duplicate the results. Using `ModelConsumable` helps avoiding\n * this situation, because callbacks should only convert those values, which were not yet consumed from `ModelConsumable`.\n *\n * Consuming multiple values in a single callback:\n *\n *\t\t// Converter for custom `image` element that might have a `caption` element inside which changes\n *\t\t// how the image is displayed in the view:\n *\t\t//\n *\t\t// Model:\n *\t\t//\n *\t\t// [image]\n *\t\t//    [caption]\n *\t\t//        foo\n *\t\t//\n *\t\t// View:\n *\t\t//\n *\t\t// <figure>\n *\t\t//    <img />\n *\t\t//    <caption>\n *\t\t//        foo\n *\t\tmodelConversionDispatcher.on( 'insert:image', ( evt, data, conversionApi ) => {\n *\t\t\t// First, consume the `image` element.\n *\t\t\tconversionApi.consumable.consume( data.item, 'insert' );\n *\n *\t\t\t// Just create normal image element for the view.\n *\t\t\t// Maybe it will be \"decorated\" later.\n *\t\t\tconst viewImage = new ViewElement( 'img' );\n *\t\t\tconst insertPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\t\t\tconst viewWriter = conversionApi.writer;\n *\n *\t\t\t// Check if the `image` element has children.\n *\t\t\tif ( data.item.childCount > 0 ) {\n *\t\t\t\tconst modelCaption = data.item.getChild( 0 );\n *\n *\t\t\t\t// `modelCaption` insertion change is consumed from consumable values.\n *\t\t\t\t// It will not be converted by other converters, but it's children (probably some text) will be.\n *\t\t\t\t// Through mapping, converters for text will know where to insert contents of `modelCaption`.\n *\t\t\t\tif ( conversionApi.consumable.consume( modelCaption, 'insert' ) ) {\n *\t\t\t\t\tconst viewCaption = new ViewElement( 'figcaption' );\n *\n *\t\t\t\t\tconst viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );\n *\n *\t\t\t\t\tconversionApi.mapper.bindElements( modelCaption, viewCaption );\n *\t\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImageHolder );\n *\t\t\t\t\tviewWriter.insert( insertPosition, viewImageHolder );\n *\t\t\t\t}\n *\t\t\t} else {\n *\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImage );\n *\t\t\t\tviewWriter.insert( insertPosition, viewImage );\n *\t\t\t}\n *\n *\t\t\tevt.stop();\n *\t\t} );\n */\n\nvar ModelConsumable =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an empty consumables list.\n   */\n  function ModelConsumable() {\n    _classCallCheck(this, ModelConsumable);\n\n    /**\n     * Contains list of consumable values.\n     *\n     * @private\n     * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_consumable\n     */\n    this._consumable = new Map();\n    /**\n     * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds parent\n     * of that `TextProxy` and start and end indices of that `TextProxy`. This allows identification of `TextProxy`\n     * instances that points to the same part of the model but are different instances. Each distinct `TextProxy`\n     * is given unique `Symbol` which is then registered as consumable. This process is transparent for `ModelConsumable`\n     * API user because whenever `TextProxy` is added, tested, consumed or reverted, internal mechanisms of\n     * `ModelConsumable` translates `TextProxy` to that unique `Symbol`.\n     *\n     * @private\n     * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_textProxyRegistry\n     */\n\n    this._textProxyRegistry = new Map();\n  }\n  /**\n   * Adds a consumable value to the consumables list and links it with given model item.\n   *\n   *\t\tmodelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.\n   *\t\tmodelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.\n   *\t\tmodelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.\n   *\t\tmodelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.\n   *\t\tmodelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n   * Model item, range or selection that has the consumable.\n   * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n   * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n   */\n\n\n  _createClass(ModelConsumable, [{\n    key: \"add\",\n    value: function add(item, type) {\n      type = _normalizeConsumableType(type);\n\n      if (item instanceof TextProxy) {\n        item = this._getSymbolForTextProxy(item);\n      }\n\n      if (!this._consumable.has(item)) {\n        this._consumable.set(item, new Map());\n      }\n\n      this._consumable.get(item).set(type, true);\n    }\n    /**\n     * Removes given consumable value from given model item.\n     *\n     *\t\tmodelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.\n     *\t\tmodelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.\n     *\t\tmodelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.\n     *\t\tmodelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.\n     *\t\tmodelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n     * Model item, range or selection from which consumable will be consumed.\n     * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n     * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n     * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.\n     */\n\n  }, {\n    key: \"consume\",\n    value: function consume(item, type) {\n      type = _normalizeConsumableType(type);\n\n      if (item instanceof TextProxy) {\n        item = this._getSymbolForTextProxy(item);\n      }\n\n      if (this.test(item, type)) {\n        this._consumable.get(item).set(type, false);\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Tests whether there is a consumable value of given type connected with given model item.\n     *\n     *\t\tmodelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.\n     *\t\tmodelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.\n     *\t\tmodelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.\n     *\t\tmodelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.\n     *\t\tmodelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n     * Model item, range or selection to be tested.\n     * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n     * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n     * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was\n     * already consumed or `true` if it was added and not consumed yet.\n     */\n\n  }, {\n    key: \"test\",\n    value: function test(item, type) {\n      type = _normalizeConsumableType(type);\n\n      if (item instanceof TextProxy) {\n        item = this._getSymbolForTextProxy(item);\n      }\n\n      var itemConsumables = this._consumable.get(item);\n\n      if (itemConsumables === undefined) {\n        return null;\n      }\n\n      var value = itemConsumables.get(type);\n\n      if (value === undefined) {\n        return null;\n      }\n\n      return value;\n    }\n    /**\n     * Reverts consuming of consumable value.\n     *\n     *\t\tmodelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.\n     *\t\tmodelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.\n     *\t\tmodelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.\n     *\t\tmodelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.\n     *\t\tmodelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n     * Model item, range or selection to be reverted.\n     * @param {String} type Consumable type.\n     * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has\n     * never been added.\n     */\n\n  }, {\n    key: \"revert\",\n    value: function revert(item, type) {\n      type = _normalizeConsumableType(type);\n\n      if (item instanceof TextProxy) {\n        item = this._getSymbolForTextProxy(item);\n      }\n\n      var test = this.test(item, type);\n\n      if (test === false) {\n        this._consumable.get(item).set(type, true);\n\n        return true;\n      } else if (test === true) {\n        return false;\n      }\n\n      return null;\n    }\n    /**\n     * Gets a unique symbol for passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that\n     * have same parent, same start index and same end index will get the same symbol.\n     *\n     * Used internally to correctly consume `TextProxy` instances.\n     *\n     * @private\n     * @param {module:engine/model/textproxy~TextProxy} textProxy `TextProxy` instance to get a symbol for.\n     * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.\n     */\n\n  }, {\n    key: \"_getSymbolForTextProxy\",\n    value: function _getSymbolForTextProxy(textProxy) {\n      var symbol = null;\n\n      var startMap = this._textProxyRegistry.get(textProxy.startOffset);\n\n      if (startMap) {\n        var endMap = startMap.get(textProxy.endOffset);\n\n        if (endMap) {\n          symbol = endMap.get(textProxy.parent);\n        }\n      }\n\n      if (!symbol) {\n        symbol = this._addSymbolForTextProxy(textProxy.startOffset, textProxy.endOffset, textProxy.parent);\n      }\n\n      return symbol;\n    }\n    /**\n     * Adds a symbol for given properties that characterizes a {@link module:engine/model/textproxy~TextProxy} instance.\n     *\n     * Used internally to correctly consume `TextProxy` instances.\n     *\n     * @private\n     * @param {Number} startIndex Text proxy start index in it's parent.\n     * @param {Number} endIndex Text proxy end index in it's parent.\n     * @param {module:engine/model/element~Element} parent Text proxy parent.\n     * @returns {Symbol} Symbol generated for given properties.\n     */\n\n  }, {\n    key: \"_addSymbolForTextProxy\",\n    value: function _addSymbolForTextProxy(start, end, parent) {\n      var symbol = Symbol('textProxySymbol');\n      var startMap, endMap;\n      startMap = this._textProxyRegistry.get(start);\n\n      if (!startMap) {\n        startMap = new Map();\n\n        this._textProxyRegistry.set(start, startMap);\n      }\n\n      endMap = startMap.get(end);\n\n      if (!endMap) {\n        endMap = new Map();\n        startMap.set(end, endMap);\n      }\n\n      endMap.set(parent, symbol);\n      return symbol;\n    }\n  }]);\n\n  return ModelConsumable;\n}(); // Returns a normalized consumable type name from given string. A normalized consumable type name is a string that has\n// at most one colon, for example: `insert` or `addMarker:highlight`. If string to normalize has more \"parts\" (more colons),\n// the other parts are dropped, for example: `addattribute:bold:$text` -> `addattributes:bold`.\n//\n// @param {String} type Consumable type.\n// @returns {String} Normalized consumable type.\n\n\nexport { ModelConsumable as default };\n\nfunction _normalizeConsumableType(type) {\n  var parts = type.split(':');\n  return parts.length > 1 ? parts[0] + ':' + parts[1] : parts[0];\n}","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/downcastdispatcher\n */\nimport Consumable from \"./modelconsumable\";\nimport Range from \"../model/range\";\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { extend } from 'lodash-es';\n/**\n * `DowncastDispatcher` is a central point of downcasting (conversion from model to view), which is a process of reacting to changes\n * in the model and firing a set of events. Callbacks listening to those events are called converters. Those\n * converters role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During conversion process, `DowncastDispatcher` fires events, basing on state of the model and prepares\n * data for those events. It is important to understand that those events are connected with changes done on model,\n * for example: \"node has been inserted\" or \"attribute has changed\". This is in a contrary to upcasting (view to model conversion),\n * where we convert view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to `DowncastDispatcher` as a diff between old model state and new model state.\n *\n * Note, that because changes are converted there is a need to have a mapping between model structure and view structure.\n * To map positions and elements during downcast (model to view conversion) use {@link module:engine/conversion/mapper~Mapper}.\n *\n * `DowncastDispatcher` fires following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}\n * if a range of nodes has been inserted to the model tree,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove remove}\n * if a range of nodes has been removed from the model tree,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute}\n * if attribute has been added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute},\n * `DowncastDispatcher` generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have a control over which changes has been already consumed. It is useful when some converters\n * overwrite other or converts multiple changes (for example converts insertion of an element and also converts that\n * element's attributes during insertion).\n *\n * Additionally, `DowncastDispatcher` fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} if a marker has been added,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} if a marker has been removed.\n *\n * Note, that changing a marker is done through removing the marker from the old range, and adding on the new range,\n * so both those events are fired.\n *\n * Finally, `DowncastDispatcher` also handles firing events for {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection}\n * which converts selection from model to view,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute}\n * which is fired for every selection attribute,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}\n * which is fired for every marker which contains selection.\n *\n * Unlike model tree and markers, events for selection are not fired for changes but for selection state.\n *\n * When providing custom listeners for `DowncastDispatcher` remember to check whether given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for `DowncastDispatcher` keep in mind that any callback that had\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} a value from a consumable and\n * converted the change should also stop the event (for efficiency purposes).\n *\n * When providing custom listeners for `DowncastDispatcher` remember to use provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * Example of a custom converter for `DowncastDispatcher`:\n *\n *\t\t// We will convert inserting \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate position in model to position in view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create <p> element that will be inserted in view at `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to model element so positions will map accordingly in future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\n *\t\t\t// Remember to stop the event propagation.\n *\t\t\tevt.stop();\n *\t\t} );\n */\n\nvar DowncastDispatcher =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a `DowncastDispatcher` instance.\n   *\n   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n   * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired\n   * by `DowncastDispatcher`.\n   */\n  function DowncastDispatcher() {\n    var conversionApi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, DowncastDispatcher);\n\n    /**\n     * Interface passed by dispatcher to the events callbacks.\n     *\n     * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n     */\n    this.conversionApi = extend({\n      dispatcher: this\n    }, conversionApi);\n  }\n  /**\n   * Takes {@link module:engine/model/differ~Differ model differ} object with buffered changes and fires conversion basing on it.\n   *\n   * @param {module:engine/model/differ~Differ} differ Differ object with buffered changes.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  _createClass(DowncastDispatcher, [{\n    key: \"convertChanges\",\n    value: function convertChanges(differ, writer) {\n      // Before the view is updated, remove markers which have changed.\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = differ.getMarkersToRemove()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var change = _step.value;\n          this.convertMarkerRemove(change.name, change.range, writer);\n        } // Convert changes that happened on model tree.\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = differ.getChanges()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var entry = _step2.value;\n\n          if (entry.type == 'insert') {\n            this.convertInsert(Range._createFromPositionAndShift(entry.position, entry.length), writer);\n          } else if (entry.type == 'remove') {\n            this.convertRemove(entry.position, entry.length, entry.name, writer);\n          } else {\n            // entry.type == 'attribute'.\n            this.convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, writer);\n          }\n        } // After the view is updated, convert markers which have changed.\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = differ.getMarkersToAdd()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _change = _step3.value;\n          this.convertMarkerAdd(_change.name, _change.range, writer);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n    /**\n     * Starts conversion of a range insertion.\n     *\n     * For each node in the range, {@link #event:insert insert event is fired}. For each attribute on each node,\n     * {@link #event:attribute attribute event is fired}.\n     *\n     * @fires insert\n     * @fires attribute\n     * @param {module:engine/model/range~Range} range Inserted range.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n     */\n\n  }, {\n    key: \"convertInsert\",\n    value: function convertInsert(range, writer) {\n      this.conversionApi.writer = writer; // Create a list of things that can be consumed, consisting of nodes and their attributes.\n\n      this.conversionApi.consumable = this._createInsertConsumable(range); // Fire a separate insert event for each node and text fragment contained in the range.\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = range[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var value = _step4.value;\n          var item = value.item;\n\n          var itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n\n          var data = {\n            item: item,\n            range: itemRange\n          };\n\n          this._testAndFire('insert', data); // Fire a separate addAttribute event for each attribute that was set on inserted items.\n          // This is important because most attributes converters will listen only to add/change/removeAttribute events.\n          // If we would not add this part, attributes on inserted nodes would not be converted.\n\n\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = item.getAttributeKeys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var key = _step5.value;\n              data.attributeKey = key;\n              data.attributeOldValue = null;\n              data.attributeNewValue = item.getAttribute(key);\n\n              this._testAndFire(\"attribute:\".concat(key), data);\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      this._clearConversionApi();\n    }\n    /**\n     * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n     *\n     * @param {module:engine/model/position~Position} position Position from which node was removed.\n     * @param {Number} length Offset size of removed node.\n     * @param {String} name Name of removed node.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n     */\n\n  }, {\n    key: \"convertRemove\",\n    value: function convertRemove(position, length, name, writer) {\n      this.conversionApi.writer = writer;\n      this.fire('remove:' + name, {\n        position: position,\n        length: length\n      }, this.conversionApi);\n\n      this._clearConversionApi();\n    }\n    /**\n     * Starts conversion of attribute change on given `range`.\n     *\n     * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n     *\n     * @fires attribute\n     * @param {module:engine/model/range~Range} range Changed range.\n     * @param {String} key Key of the attribute that has changed.\n     * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n     * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n     */\n\n  }, {\n    key: \"convertAttribute\",\n    value: function convertAttribute(range, key, oldValue, newValue, writer) {\n      this.conversionApi.writer = writer; // Create a list with attributes to consume.\n\n      this.conversionApi.consumable = this._createConsumableForRange(range, \"attribute:\".concat(key)); // Create a separate attribute event for each node in the range.\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = range[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var value = _step6.value;\n          var item = value.item;\n\n          var itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n\n          var data = {\n            item: item,\n            range: itemRange,\n            attributeKey: key,\n            attributeOldValue: oldValue,\n            attributeNewValue: newValue\n          };\n\n          this._testAndFire(\"attribute:\".concat(key), data);\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      this._clearConversionApi();\n    }\n    /**\n     * Starts model selection conversion.\n     *\n     * Fires events for given {@link module:engine/model/selection~Selection selection} to start selection conversion.\n     *\n     * @fires selection\n     * @fires addMarker\n     * @fires attribute\n     * @param {module:engine/model/selection~Selection} selection Selection to convert.\n     * @param {Array.<module:engine/model/markercollection~Marker>} markers Array of markers containing model markers.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n     */\n\n  }, {\n    key: \"convertSelection\",\n    value: function convertSelection(selection, markers, writer) {\n      var markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));\n      this.conversionApi.writer = writer;\n      this.conversionApi.consumable = this._createSelectionConsumable(selection, markersAtSelection);\n      this.fire('selection', {\n        selection: selection\n      }, this.conversionApi);\n\n      if (!selection.isCollapsed) {\n        return;\n      }\n\n      for (var _i = 0, _markersAtSelection = markersAtSelection; _i < _markersAtSelection.length; _i++) {\n        var marker = _markersAtSelection[_i];\n        var markerRange = marker.getRange();\n\n        if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, this.conversionApi.mapper)) {\n          continue;\n        }\n\n        var data = {\n          item: selection,\n          markerName: marker.name,\n          markerRange: markerRange\n        };\n\n        if (this.conversionApi.consumable.test(selection, 'addMarker:' + marker.name)) {\n          this.fire('addMarker:' + marker.name, data, this.conversionApi);\n        }\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = selection.getAttributeKeys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var key = _step7.value;\n          var _data = {\n            item: selection,\n            range: selection.getFirstRange(),\n            attributeKey: key,\n            attributeOldValue: null,\n            attributeNewValue: selection.getAttribute(key)\n          }; // Do not fire event if the attribute has been consumed.\n\n          if (this.conversionApi.consumable.test(selection, 'attribute:' + _data.attributeKey)) {\n            this.fire('attribute:' + _data.attributeKey + ':$text', _data, this.conversionApi);\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      this._clearConversionApi();\n    }\n    /**\n     * Converts added marker. Fires {@link #event:addMarker addMarker} event for each item\n     * in marker's range. If range is collapsed single event is dispatched. See event description for more details.\n     *\n     * @fires addMarker\n     * @param {String} markerName Marker name.\n     * @param {module:engine/model/range~Range} markerRange Marker range.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n     */\n\n  }, {\n    key: \"convertMarkerAdd\",\n    value: function convertMarkerAdd(markerName, markerRange, writer) {\n      // Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).\n      if (!markerRange.root.document || markerRange.root.rootName == '$graveyard') {\n        return;\n      }\n\n      this.conversionApi.writer = writer; // In markers' case, event name == consumable name.\n\n      var eventName = 'addMarker:' + markerName; //\n      // First, fire an event for the whole marker.\n      //\n\n      var consumable = new Consumable();\n      consumable.add(markerRange, eventName);\n      this.conversionApi.consumable = consumable;\n      this.fire(eventName, {\n        markerName: markerName,\n        markerRange: markerRange\n      }, this.conversionApi); //\n      // Do not fire events for each item inside the range if the range got consumed.\n      //\n\n      if (!consumable.test(markerRange, eventName)) {\n        return;\n      } //\n      // Then, fire an event for each item inside the marker range.\n      //\n\n\n      this.conversionApi.consumable = this._createConsumableForRange(markerRange, eventName);\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = markerRange.getItems()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var item = _step8.value;\n\n          // Do not fire event for already consumed items.\n          if (!this.conversionApi.consumable.test(item, eventName)) {\n            continue;\n          }\n\n          var data = {\n            item: item,\n            range: Range._createOn(item),\n            markerName: markerName,\n            markerRange: markerRange\n          };\n          this.fire(eventName, data, this.conversionApi);\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      this._clearConversionApi();\n    }\n    /**\n     * Fires conversion of marker removal. Fires {@link #event:removeMarker removeMarker} event with provided data.\n     *\n     * @fires removeMarker\n     * @param {String} markerName Marker name.\n     * @param {module:engine/model/range~Range} markerRange Marker range.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n     */\n\n  }, {\n    key: \"convertMarkerRemove\",\n    value: function convertMarkerRemove(markerName, markerRange, writer) {\n      // Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).\n      if (!markerRange.root.document || markerRange.root.rootName == '$graveyard') {\n        return;\n      }\n\n      this.conversionApi.writer = writer;\n      this.fire('removeMarker:' + markerName, {\n        markerName: markerName,\n        markerRange: markerRange\n      }, this.conversionApi);\n\n      this._clearConversionApi();\n    }\n    /**\n     * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from given range,\n     * assuming that the range has just been inserted to the model.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range Inserted range.\n     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n     */\n\n  }, {\n    key: \"_createInsertConsumable\",\n    value: function _createInsertConsumable(range) {\n      var consumable = new Consumable();\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = range[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var value = _step9.value;\n          var item = value.item;\n          consumable.add(item, 'insert');\n          var _iteratorNormalCompletion10 = true;\n          var _didIteratorError10 = false;\n          var _iteratorError10 = undefined;\n\n          try {\n            for (var _iterator10 = item.getAttributeKeys()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n              var key = _step10.value;\n              consumable.add(item, 'attribute:' + key);\n            }\n          } catch (err) {\n            _didIteratorError10 = true;\n            _iteratorError10 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n                _iterator10.return();\n              }\n            } finally {\n              if (_didIteratorError10) {\n                throw _iteratorError10;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      return consumable;\n    }\n    /**\n     * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for given range.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range Affected range.\n     * @param {String} type Consumable type.\n     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n     */\n\n  }, {\n    key: \"_createConsumableForRange\",\n    value: function _createConsumableForRange(range, type) {\n      var consumable = new Consumable();\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = range.getItems()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var item = _step11.value;\n          consumable.add(item, type);\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n            _iterator11.return();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n\n      return consumable;\n    }\n    /**\n     * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n     *\n     * @private\n     * @param {module:engine/model/selection~Selection} selection Selection to create consumable from.\n     * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers which contains selection.\n     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n     */\n\n  }, {\n    key: \"_createSelectionConsumable\",\n    value: function _createSelectionConsumable(selection, markers) {\n      var consumable = new Consumable();\n      consumable.add(selection, 'selection');\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = markers[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var marker = _step12.value;\n          consumable.add(selection, 'addMarker:' + marker.name);\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion13 = true;\n      var _didIteratorError13 = false;\n      var _iteratorError13 = undefined;\n\n      try {\n        for (var _iterator13 = selection.getAttributeKeys()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n          var key = _step13.value;\n          consumable.add(selection, 'attribute:' + key);\n        }\n      } catch (err) {\n        _didIteratorError13 = true;\n        _iteratorError13 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n            _iterator13.return();\n          }\n        } finally {\n          if (_didIteratorError13) {\n            throw _iteratorError13;\n          }\n        }\n      }\n\n      return consumable;\n    }\n    /**\n     * Tests passed `consumable` to check whether given event can be fired and if so, fires it.\n     *\n     * @private\n     * @fires insert\n     * @fires attribute\n     * @param {String} type Event type.\n     * @param {Object} data Event data.\n     */\n\n  }, {\n    key: \"_testAndFire\",\n    value: function _testAndFire(type, data) {\n      if (!this.conversionApi.consumable.test(data.item, type)) {\n        // Do not fire event if the item was consumed.\n        return;\n      }\n\n      var name = data.item.name || '$text';\n      this.fire(type + ':' + name, data, this.conversionApi);\n    }\n    /**\n     * Clears conversion API object.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_clearConversionApi\",\n    value: function _clearConversionApi() {\n      delete this.conversionApi.writer;\n      delete this.conversionApi.consumable;\n    }\n    /**\n     * Fired for inserted nodes.\n     *\n     * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,\n     * or {@link module:engine/model/element~Element#name name} of inserted element.\n     *\n     * This way listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).\n     *\n     * @event insert\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/item~Item} data.item Inserted item.\n     * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired for removed nodes.\n     *\n     * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `remove:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been removed,\n     * or the {@link module:engine/model/element~Element#name name} of removed element.\n     *\n     * This way listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).\n     *\n     * @event remove\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/position~Position} data.position Position from which the node has been removed.\n     * @param {Number} data.length Offset size of the removed node.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired in the following cases:\n     *\n     * * when an attribute has been added, changed, or removed from a node,\n     * * when a node with an attribute is inserted,\n     * * when collapsed model selection attribute is converted.\n     *\n     * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.\n     * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},\n     * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.\n     *\n     * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:image`).\n     *\n     * @event attribute\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n     * or converted selection.\n     * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n     * @param {String} data.attributeKey Attribute key.\n     * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n     * @param {*} data.attributeNewValue New attribute value.\n     * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired for {@link module:engine/model/selection~Selection selection} changes.\n     *\n     * @event selection\n     * @param {module:engine/model/selection~Selection} selection Selection that is converted.\n     * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired when a new marker is added to the model. Also fired when collapsed model selection that is inside marker is converted.\n     *\n     * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n     * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and\n     * `addMarker:foo:bar` events.\n     *\n     * If the marker range is not collapsed:\n     *\n     * * the event is fired for each item in the marker range one by one,\n     * * consumables object includes each item of the marker range and the consumable value is same as event name.\n     *\n     * If the marker range is collapsed:\n     *\n     * * there is only one event,\n     * * consumables object includes marker range with event name.\n     *\n     * If selection inside a marker is converted:\n     *\n     * * there is only one event,\n     * * consumables object includes selection instance with event name.\n     *\n     * @event addMarker\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or\n     * the selection that is being converted.\n     * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if\n     * the marker range was not collapsed.\n     * @param {module:engine/model/range~Range} data.markerRange Marker range.\n     * @param {String} data.markerName Marker name.\n     * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired when marker is removed from the model.\n     *\n     * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n     * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and\n     * `removeMarker:foo:bar` events.\n     *\n     * @event removeMarker\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/range~Range} data.markerRange Marker range.\n     * @param {String} data.markerName Marker name.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n  }]);\n\n  return DowncastDispatcher;\n}();\n\nexport { DowncastDispatcher as default };\nmix(DowncastDispatcher, EmitterMixin); // Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\n\nfunction shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {\n  var range = marker.getRange();\n  var ancestors = Array.from(modelPosition.getAncestors());\n  ancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n\n  ancestors.reverse();\n  var hasCustomHandling = ancestors.some(function (element) {\n    if (range.containsItem(element)) {\n      var viewElement = mapper.toViewElement(element);\n      return !!viewElement.getCustomProperty('addHighlight');\n    }\n  });\n  return !hasCustomHandling;\n}\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher dispatcher}\n * fires it's events.\n *\n * @interface module:engine/conversion/downcastdispatcher~DowncastConversionApi\n */\n\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n\n/**\n * Stores information about what parts of processed model item are still waiting to be handled. After a piece of model item\n * was converted, appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/liverange\n */\nimport Range from \"./range\";\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * `LiveRange` is a type of {@link module:engine/model/range~Range Range}\n * that updates itself as {@link module:engine/model/document~Document document}\n * is changed through operations. It may be used as a bookmark.\n *\n * **Note:** Be very careful when dealing with `LiveRange`. Each `LiveRange` instance bind events that might\n * have to be unbound. Use {@link module:engine/model/liverange~LiveRange#detach detach} whenever you don't need `LiveRange` anymore.\n */\n\nvar LiveRange =\n/*#__PURE__*/\nfunction (_Range) {\n  _inherits(LiveRange, _Range);\n\n  /**\n   * Creates a live range.\n   *\n   * @see module:engine/model/range~Range\n   */\n  function LiveRange(start, end) {\n    var _this;\n\n    _classCallCheck(this, LiveRange);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LiveRange).call(this, start, end));\n    bindWithDocument.call(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance\n   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was\n   * referring to it).\n   */\n\n\n  _createClass(LiveRange, [{\n    key: \"detach\",\n    value: function detach() {\n      this.stopListening();\n    }\n    /**\n     * Creates a {@link module:engine/model/range~Range range instance} that is equal to this live range.\n     *\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"toRange\",\n    value: function toRange() {\n      return new Range(this.start, this.end);\n    }\n    /**\n     * Creates a `LiveRange` instance that is equal to the given range.\n     *\n     * @param {module:engine/model/range~Range} range\n     * @returns {module:engine/model/liverange~LiveRange}\n     */\n\n  }], [{\n    key: \"fromRange\",\n    value: function fromRange(range) {\n      return new LiveRange(range.start, range.end);\n    }\n    /**\n     * @see module:engine/model/range~Range._createIn\n     * @static\n     * @protected\n     * @method module:engine/model/liverange~LiveRange._createIn\n     * @param {module:engine/model/element~Element} element\n     * @returns {module:engine/model/liverange~LiveRange}\n     */\n\n    /**\n     * @see module:engine/model/range~Range._createOn\n     * @static\n     * @protected\n     * @method module:engine/model/liverange~LiveRange._createOn\n     * @param {module:engine/model/element~Element} element\n     * @returns {module:engine/model/liverange~LiveRange}\n     */\n\n    /**\n     * @see module:engine/model/range~Range._createFromPositionAndShift\n     * @static\n     * @protected\n     * @method module:engine/model/liverange~LiveRange._createFromPositionAndShift\n     * @param {module:engine/model/position~Position} position\n     * @param {Number} shift\n     * @returns {module:engine/model/liverange~LiveRange}\n     */\n\n    /**\n     * Fired when `LiveRange` instance boundaries have changed due to changes in the\n     * {@link module:engine/model/document~Document document}.\n     *\n     * @event change:range\n     * @param {module:engine/model/range~Range} oldRange Range with start and end position equal to start and end position of this live\n     * range before it got changed.\n     * @param {Object} data Object with additional information about the change.\n     * @param {module:engine/model/position~Position|null} data.deletionPosition Source position for remove and merge changes.\n     * Available if the range was moved to the graveyard root, `null` otherwise.\n     */\n\n    /**\n     * Fired when `LiveRange` instance boundaries have not changed after a change in {@link module:engine/model/document~Document document}\n     * but the change took place inside the range, effectively changing its content.\n     *\n     * @event change:content\n     * @param {module:engine/model/range~Range} range Range with start and end position equal to start and end position of\n     * change range.\n     * @param {Object} data Object with additional information about the change.\n     * @param {null} data.deletionPosition Due to the nature of this event, this property is always set to `null`. It is passed\n     * for compatibility with the {@link module:engine/model/liverange~LiveRange#event:change:range} event.\n     */\n\n  }]);\n\n  return LiveRange;\n}(Range); // Binds this `LiveRange` to the {@link module:engine/model/document~Document document}\n// that owns this range's {@link module:engine/model/range~Range#root root}.\n//\n// @private\n\n\nexport { LiveRange as default };\n\nfunction bindWithDocument() {\n  var _this2 = this;\n\n  this.listenTo(this.root.document.model, 'applyOperation', function (event, args) {\n    var operation = args[0];\n\n    if (!operation.isDocumentOperation) {\n      return;\n    }\n\n    transform.call(_this2, operation);\n  }, {\n    priority: 'low'\n  });\n} // Updates this range accordingly to the updates applied to the model. Bases on change events.\n//\n// @private\n// @param {module:engine/model/operation/operation~Operation} operation Executed operation.\n\n\nfunction transform(operation) {\n  // Transform the range by the operation. Join the result ranges if needed.\n  var ranges = this.getTransformedByOperation(operation);\n\n  var result = Range._createFromRanges(ranges);\n\n  var boundariesChanged = !result.isEqual(this);\n  var contentChanged = doesOperationChangeRangeContent(this, operation);\n  var deletionPosition = null;\n\n  if (boundariesChanged) {\n    // If range boundaries have changed, fire `change:range` event.\n    //\n    if (result.root.rootName == '$graveyard') {\n      // If the range was moved to the graveyard root, set `deletionPosition`.\n      if (operation.type == 'remove') {\n        deletionPosition = operation.sourcePosition;\n      } else {\n        // Merge operation.\n        deletionPosition = operation.deletionPosition;\n      }\n    }\n\n    var oldRange = this.toRange();\n    this.start = result.start;\n    this.end = result.end;\n    this.fire('change:range', oldRange, {\n      deletionPosition: deletionPosition\n    });\n  } else if (contentChanged) {\n    // If range boundaries have not changed, but there was change inside the range, fire `change:content` event.\n    this.fire('change:content', this.toRange(), {\n      deletionPosition: deletionPosition\n    });\n  }\n} // Checks whether given operation changes something inside the range (even if it does not change boundaries).\n//\n// @private\n// @param {module:engine/model/range~Range} range Range to check.\n// @param {module:engine/model/operation/operation~Operation} operation Executed operation.\n// @returns {Boolean}\n\n\nfunction doesOperationChangeRangeContent(range, operation) {\n  switch (operation.type) {\n    case 'insert':\n      return range.containsPosition(operation.position);\n\n    case 'move':\n    case 'remove':\n    case 'reinsert':\n    case 'merge':\n      return range.containsPosition(operation.sourcePosition) || range.start.isEqual(operation.sourcePosition) || range.containsPosition(operation.targetPosition);\n\n    case 'split':\n      return range.containsPosition(operation.splitPosition) || range.containsPosition(operation.insertionPosition);\n  }\n\n  return false;\n}\n\nmix(LiveRange, EmitterMixin);","import _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.array.from\";\nimport \"regenerator-runtime/runtime\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.set\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\nimport \"core-js/modules/es6.string.starts-with\";\nimport \"core-js/modules/es6.string.anchor\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/documentselection\n */\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport Selection from \"./selection\";\nimport LiveRange from \"./liverange\";\nimport Text from \"./text\";\nimport TextProxy from \"./textproxy\";\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\nvar storePrefix = 'selection:';\n/**\n * `DocumentSelection` is a special selection which is used as the\n * {@link module:engine/model/document~Document#selection document's selection}.\n * There can be only one instance of `DocumentSelection` per document.\n *\n * Document selection can only be changed by using the {@link module:engine/model/writer~Writer} instance\n * inside the {@link module:engine/model/model~Model#change `change()`} block, as it provides a secure way to modify model.\n *\n * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n *\n * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:\n * * there is always a range in `DocumentSelection` - even if no ranges were added there is a \"default range\"\n * present in the selection,\n * * ranges added to this selection updates automatically when the document changes,\n * * attributes of `DocumentSelection` are updated automatically according to selection ranges.\n *\n * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}\n * and is updated when {@link module:engine/model/document~Document document}\n * changes, it cannot be set on {@link module:engine/model/node~Node nodes}\n * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n * If you need to represent a selection in document fragment,\n * use {@link module:engine/model/selection~Selection Selection class} instead.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar DocumentSelection =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an empty live selection for given {@link module:engine/model/document~Document}.\n   *\n   * @param {module:engine/model/document~Document} doc Document which owns this selection.\n   */\n  function DocumentSelection(doc) {\n    _classCallCheck(this, DocumentSelection);\n\n    /**\n     * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).\n     *\n     * @protected\n     */\n    this._selection = new LiveSelection(doc);\n\n    this._selection.delegate('change:range').to(this);\n\n    this._selection.delegate('change:attribute').to(this);\n  }\n  /**\n   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n   * collapsed.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  _createClass(DocumentSelection, [{\n    key: \"getRanges\",\n\n    /**\n     * Returns an iterable that iterates over copies of selection ranges.\n     *\n     * @returns {Iterable.<module:engine/model/range~Range>}\n     */\n    value: function getRanges() {\n      return this._selection.getRanges();\n    }\n    /**\n     * Returns the first position in the selection.\n     * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n     * any other position in the selection.\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/position~Position|null}\n     */\n\n  }, {\n    key: \"getFirstPosition\",\n    value: function getFirstPosition() {\n      return this._selection.getFirstPosition();\n    }\n    /**\n     * Returns the last position in the selection.\n     * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n     * any other position in the selection.\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/position~Position|null}\n     */\n\n  }, {\n    key: \"getLastPosition\",\n    value: function getLastPosition() {\n      return this._selection.getLastPosition();\n    }\n    /**\n     * Returns a copy of the first range in the selection.\n     * First range is the one which {@link module:engine/model/range~Range#start start} position\n     * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n     * (not to confuse with the first range added to the selection).\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n\n  }, {\n    key: \"getFirstRange\",\n    value: function getFirstRange() {\n      return this._selection.getFirstRange();\n    }\n    /**\n     * Returns a copy of the last range in the selection.\n     * Last range is the one which {@link module:engine/model/range~Range#end end} position\n     * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n     * recently added to the selection).\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n\n  }, {\n    key: \"getLastRange\",\n    value: function getLastRange() {\n      return this._selection.getLastRange();\n    }\n    /**\n     * Gets elements of type \"block\" touched by the selection.\n     *\n     * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n     *\n     * **Note:** `getSelectedBlocks()` always returns the deepest block.\n     *\n     * In this case the function will return exactly all 3 paragraphs:\n     *\n     *\t\t<paragraph>[a</paragraph>\n     *\t\t<quote>\n     *\t\t\t<paragraph>b</paragraph>\n     *\t\t</quote>\n     *\t\t<paragraph>c]d</paragraph>\n     *\n     * In this case the paragraph will also be returned, despite the collapsed selection:\n     *\n     *\t\t<paragraph>[]a</paragraph>\n     *\n     * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n     * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n     *\n     *\t\t<paragraph>[a</paragraph>\n     *\t\t<paragraph>b</paragraph>\n     *\t\t<paragraph>]c</paragraph> // this block will not be returned\n     *\n     * @returns {Iterable.<module:engine/model/element~Element>}\n     */\n\n  }, {\n    key: \"getSelectedBlocks\",\n    value: function getSelectedBlocks() {\n      return this._selection.getSelectedBlocks();\n    }\n    /**\n     * Returns blocks that aren't nested in other selected blocks.\n     *\n     * In this case the method will return blocks A, B and E because C & D are children of block B:\n     *\n     *\t\t[<blockA></blockA>\n     *\t\t<blockB>\n     *\t\t\t<blockC></blockC>\n     *\t\t\t<blockD></blockD>\n     *\t\t</blockB>\n     *\t\t<blockE></blockE>]\n     *\n     * **Note:** To get all selected blocks use {@link #getSelectedBlocks `getSelectedBlocks()`}.\n     *\n     * @returns {Iterable.<module:engine/model/element~Element>}\n     */\n\n  }, {\n    key: \"getTopMostBlocks\",\n    value: function getTopMostBlocks() {\n      return this._selection.getTopMostBlocks();\n    }\n    /**\n     * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n     * one range in the selection, and that range contains exactly one element.\n     * Returns `null` if there is no selected element.\n     *\n     * @returns {module:engine/model/element~Element|null}\n     */\n\n  }, {\n    key: \"getSelectedElement\",\n    value: function getSelectedElement() {\n      return this._selection.getSelectedElement();\n    }\n    /**\n     * Checks whether the selection contains the entire content of the given element. This means that selection must start\n     * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n     * touching the element's end.\n     *\n     * By default, this method will check whether the entire content of the selection's current root is selected.\n     * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n     *\n     * @param {module:engine/model/element~Element} [element=this.anchor.root]\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"containsEntireContent\",\n    value: function containsEntireContent(element) {\n      return this._selection.containsEntireContent(element);\n    }\n    /**\n     * Unbinds all events previously bound by document selection.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._selection.destroy();\n    }\n    /**\n     * Returns iterable that iterates over this selection's attribute keys.\n     *\n     * @returns {Iterable.<String>}\n     */\n\n  }, {\n    key: \"getAttributeKeys\",\n    value: function getAttributeKeys() {\n      return this._selection.getAttributeKeys();\n    }\n    /**\n     * Returns iterable that iterates over this selection's attributes.\n     *\n     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n     *\n     * @returns {Iterable.<*>}\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this._selection.getAttributes();\n    }\n    /**\n     * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n     *\n     * @param {String} key Key of attribute to look for.\n     * @returns {*} Attribute value or `undefined`.\n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return this._selection.getAttribute(key);\n    }\n    /**\n     * Checks if the selection has an attribute for given key.\n     *\n     * @param {String} key Key of attribute to check.\n     * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n     */\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return this._selection.hasAttribute(key);\n    }\n    /**\n     * Refreshes selection attributes and markers according to the current position in the model.\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this._selection._updateMarkers();\n\n      this._selection._updateAttributes(false);\n    }\n    /**\n     * Checks whether object is of given type following the convention set by\n     * {@link module:engine/model/node~Node#is `Node#is()`}.\n     *\n     *\t\tconst selection = new DocumentSelection( ... );\n     *\n     *\t\tselection.is( 'selection' ); // true\n     *\t\tselection.is( 'documentSelection' ); // true\n     *\t\tselection.is( 'node' ); // false\n     *\t\tselection.is( 'element' ); // false\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type == 'selection' || type == 'documentSelection';\n    }\n    /**\n     * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n     * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.\n     *\n     * The location can be specified in the same form as\n     * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n     *\n     * @see module:engine/model/writer~Writer#setSelectionFocus\n     * @protected\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"_setFocus\",\n    value: function _setFocus(itemOrPosition, offset) {\n      this._selection.setFocus(itemOrPosition, offset);\n    }\n    /**\n     * Sets this selection's ranges and direction to the specified location based on the given\n     * {@link module:engine/model/selection~Selectable selectable}.\n     * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.\n     *\n     * @see module:engine/model/writer~Writer#setSelection\n     * @protected\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     */\n\n  }, {\n    key: \"_setTo\",\n    value: function _setTo(selectable, placeOrOffset, options) {\n      this._selection.setTo(selectable, placeOrOffset, options);\n    }\n    /**\n     * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n     * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.\n     *\n     * @see module:engine/model/writer~Writer#setSelectionAttribute\n     * @protected\n     * @param {String} key Key of the attribute to set.\n     * @param {*} value Attribute value.\n     */\n\n  }, {\n    key: \"_setAttribute\",\n    value: function _setAttribute(key, value) {\n      this._selection.setAttribute(key, value);\n    }\n    /**\n     * Removes an attribute with given key from the selection.\n     * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}\n     * event with removed attribute key.\n     * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.\n     *\n     * @see module:engine/model/writer~Writer#removeSelectionAttribute\n     * @protected\n     * @param {String} key Key of the attribute to remove.\n     */\n\n  }, {\n    key: \"_removeAttribute\",\n    value: function _removeAttribute(key) {\n      this._selection.removeAttribute(key);\n    }\n    /**\n     * Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n     *\n     * @protected\n     * @returns {Iterable.<*>}\n     */\n\n  }, {\n    key: \"_getStoredAttributes\",\n    value: function _getStoredAttributes() {\n      return this._selection._getStoredAttributes();\n    }\n    /**\n     * Temporarily changes the gravity of the selection from the left to the right.\n     *\n     * The gravity defines from which direction the selection inherits its attributes. If it's the default left\n     * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.\n     * This method allows to temporarily override this behavior by forcing the gravity to the right.\n     *\n     * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n     * of the process.\n     *\n     * @see module:engine/model/writer~Writer#overrideSelectionGravity\n     * @protected\n     * @returns {String} The unique id which allows restoring the gravity.\n     */\n\n  }, {\n    key: \"_overrideGravity\",\n    value: function _overrideGravity() {\n      return this._selection.overrideGravity();\n    }\n    /**\n     * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.\n     *\n     * Restoring the gravity is only possible using the unique identifier returned by\n     * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored\n     * the same number of times it was overridden.\n     *\n     * @see module:engine/model/writer~Writer#restoreSelectionGravity\n     * @protected\n     * @param {String} uid The unique id returned by {@link #_overrideGravity}.\n     */\n\n  }, {\n    key: \"_restoreGravity\",\n    value: function _restoreGravity(uid) {\n      this._selection.restoreGravity(uid);\n    }\n    /**\n     * Generates and returns an attribute key for selection attributes store, basing on original attribute key.\n     *\n     * @protected\n     * @param {String} key Attribute key to convert.\n     * @returns {String} Converted attribute key, applicable for selection store.\n     */\n\n  }, {\n    key: \"isCollapsed\",\n    get: function get() {\n      return this._selection.isCollapsed;\n    }\n    /**\n     * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.\n     * Together with {@link #focus} they define the direction of selection, which is important\n     * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or\n     * {@link module:engine/model/range~Range#end end} position of the most recently added range.\n     *\n     * Is set to `null` if there are no ranges in selection.\n     *\n     * @see #focus\n     * @readonly\n     * @type {module:engine/model/position~Position|null}\n     */\n\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      return this._selection.anchor;\n    }\n    /**\n     * Selection focus. Focus is a position where the selection ends.\n     *\n     * Is set to `null` if there are no ranges in selection.\n     *\n     * @see #anchor\n     * @readonly\n     * @type {module:engine/model/position~Position|null}\n     */\n\n  }, {\n    key: \"focus\",\n    get: function get() {\n      return this._selection.focus;\n    }\n    /**\n     * Returns number of ranges in selection.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n  }, {\n    key: \"rangeCount\",\n    get: function get() {\n      return this._selection.rangeCount;\n    }\n    /**\n     * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to\n     * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"hasOwnRange\",\n    get: function get() {\n      return this._selection.hasOwnRange;\n    }\n    /**\n     * Specifies whether the {@link #focus}\n     * precedes {@link #anchor}.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isBackward\",\n    get: function get() {\n      return this._selection.isBackward;\n    }\n    /**\n     * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.\n     *\n     * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.\n     *\n     * @readonly\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isGravityOverridden\",\n    get: function get() {\n      return this._selection.isGravityOverridden;\n    }\n    /**\n     * A collection of selection markers.\n     * Marker is a selection marker when selection range is inside the marker range.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection.<module:engine/model/markercollection~Marker>}\n     */\n\n  }, {\n    key: \"markers\",\n    get: function get() {\n      return this._selection.markers;\n    }\n    /**\n     * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_ranges\",\n    get: function get() {\n      return this._selection._ranges;\n    }\n  }], [{\n    key: \"_getStoreAttributeKey\",\n    value: function _getStoreAttributeKey(key) {\n      return storePrefix + key;\n    }\n    /**\n     * Checks whether the given attribute key is an attribute stored on an element.\n     *\n     * @protected\n     * @param {String} key\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isStoreAttributeKey\",\n    value: function _isStoreAttributeKey(key) {\n      return key.startsWith(storePrefix);\n    }\n  }]);\n\n  return DocumentSelection;\n}();\n\nexport { DocumentSelection as default };\nmix(DocumentSelection, EmitterMixin);\n/**\n * Fired when selection range(s) changed.\n *\n * @event change:range\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed because the structure of the model has been changed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n */\n\n/**\n * Fired when selection attribute changed.\n *\n * @event change:attribute\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed in the model and its attributes were refreshed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n */\n// `LiveSelection` is used internally by {@link module:engine/model/documentselection~DocumentSelection} and shouldn't be used directly.\n//\n// LiveSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n// to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n//\n// Differences between {@link module:engine/model/selection~Selection} and `LiveSelection` are:\n// * there is always a range in `LiveSelection` - even if no ranges were added there is a \"default range\"\n// present in the selection,\n// * ranges added to this selection updates automatically when the document changes,\n// * attributes of `LiveSelection` are updated automatically according to selection ranges.\n//\n// @extends module:engine/model/selection~Selection\n//\n\nvar LiveSelection =\n/*#__PURE__*/\nfunction (_Selection) {\n  _inherits(LiveSelection, _Selection);\n\n  // Creates an empty live selection for given {@link module:engine/model/document~Document}.\n  // @param {module:engine/model/document~Document} doc Document which owns this selection.\n  function LiveSelection(doc) {\n    var _this;\n\n    _classCallCheck(this, LiveSelection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LiveSelection).call(this)); // List of selection markers.\n    // Marker is a selection marker when selection range is inside the marker range.\n    //\n    // @type {module:utils/collection~Collection}\n\n    _this.markers = new Collection({\n      idProperty: 'name'\n    }); // Document which owns this selection.\n    //\n    // @protected\n    // @member {module:engine/model/model~Model}\n\n    _this._model = doc.model; // Document which owns this selection.\n    //\n    // @protected\n    // @member {module:engine/model/document~Document}\n\n    _this._document = doc; // Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)\n    // last time. Possible values of priority are: `'low'` and `'normal'`.\n    //\n    // Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`\n    // attributes API are set with `'normal'` priority.\n    //\n    // @private\n    // @member {Map} module:engine/model/liveselection~LiveSelection#_attributePriority\n\n    _this._attributePriority = new Map(); // Contains data required to fix ranges which have been moved to the graveyard.\n    // @private\n    // @member {Array} module:engine/model/liveselection~LiveSelection#_fixGraveyardRangesData\n\n    _this._fixGraveyardRangesData = []; // Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.\n    // @private\n    // @member {Array} module:engine/model/liveselection~LiveSelection#_hasChangedRange\n\n    _this._hasChangedRange = false; // Each overriding gravity adds an UID to the set and each removal removes it.\n    // Gravity is overridden when there's at least one UID in the set.\n    // Gravity is restored when the set is empty.\n    // This is to prevent conflicts when gravity is overridden by more than one feature at the same time.\n    // @private\n    // @type {Set}\n\n    _this._overriddenGravityRegister = new Set(); // Ensure selection is correct after each operation.\n\n    _this.listenTo(_this._model, 'applyOperation', function (evt, args) {\n      var operation = args[0];\n\n      if (!operation.isDocumentOperation || operation.type == 'marker' || operation.type == 'rename' || operation.type == 'noop') {\n        return;\n      }\n\n      while (_this._fixGraveyardRangesData.length) {\n        var _this$_fixGraveyardRa = _this._fixGraveyardRangesData.shift(),\n            liveRange = _this$_fixGraveyardRa.liveRange,\n            sourcePosition = _this$_fixGraveyardRa.sourcePosition;\n\n        _this._fixGraveyardSelection(liveRange, sourcePosition);\n      }\n\n      if (_this._hasChangedRange) {\n        _this._hasChangedRange = false;\n\n        _this.fire('change:range', {\n          directChange: false\n        });\n      }\n    }, {\n      priority: 'lowest'\n    }); // Ensure selection is correct and up to date after each range change.\n\n\n    _this.on('change:range', function () {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _this.getRanges()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var range = _step.value;\n\n          if (!_this._document._validateSelectionRange(range)) {\n            /**\n             * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}\n             * starts or ends at incorrect position.\n             *\n             * @error document-selection-wrong-position\n             * @param {module:engine/model/range~Range} range\n             */\n            throw new CKEditorError('document-selection-wrong-position: Range from document selection starts or ends at incorrect position.', {\n              range: range\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }); // Update markers data stored by the selection after each marker change.\n\n\n    _this.listenTo(_this._model.markers, 'update', function () {\n      return _this._updateMarkers();\n    }); // Ensure selection is up to date after each change block.\n\n\n    _this.listenTo(_this._document, 'change', function (evt, batch) {\n      clearAttributesStoredInElement(_this._model, batch);\n    });\n\n    return _this;\n  }\n\n  _createClass(LiveSelection, [{\n    key: \"destroy\",\n    // Unbinds all events previously bound by live selection.\n    value: function destroy() {\n      for (var i = 0; i < this._ranges.length; i++) {\n        this._ranges[i].detach();\n      }\n\n      this.stopListening();\n    }\n  }, {\n    key: \"getRanges\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function getRanges() {\n      return regeneratorRuntime.wrap(function getRanges$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!this._ranges.length) {\n                _context.next = 4;\n                break;\n              }\n\n              return _context.delegateYield(_get(_getPrototypeOf(LiveSelection.prototype), \"getRanges\", this).call(this), \"t0\", 2);\n\n            case 2:\n              _context.next = 6;\n              break;\n\n            case 4:\n              _context.next = 6;\n              return this._document._getDefaultRange();\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, getRanges, this);\n    })\n  }, {\n    key: \"getFirstRange\",\n    value: function getFirstRange() {\n      return _get(_getPrototypeOf(LiveSelection.prototype), \"getFirstRange\", this).call(this) || this._document._getDefaultRange();\n    }\n  }, {\n    key: \"getLastRange\",\n    value: function getLastRange() {\n      return _get(_getPrototypeOf(LiveSelection.prototype), \"getLastRange\", this).call(this) || this._document._getDefaultRange();\n    }\n  }, {\n    key: \"setTo\",\n    value: function setTo(selectable, optionsOrPlaceOrOffset, options) {\n      _get(_getPrototypeOf(LiveSelection.prototype), \"setTo\", this).call(this, selectable, optionsOrPlaceOrOffset, options);\n\n      this._updateAttributes(true);\n    }\n  }, {\n    key: \"setFocus\",\n    value: function setFocus(itemOrPosition, offset) {\n      _get(_getPrototypeOf(LiveSelection.prototype), \"setFocus\", this).call(this, itemOrPosition, offset);\n\n      this._updateAttributes(true);\n    }\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value) {\n      if (this._setAttribute(key, value)) {\n        // Fire event with exact data.\n        var attributeKeys = [key];\n        this.fire('change:attribute', {\n          attributeKeys: attributeKeys,\n          directChange: true\n        });\n      }\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key) {\n      if (this._removeAttribute(key)) {\n        // Fire event with exact data.\n        var attributeKeys = [key];\n        this.fire('change:attribute', {\n          attributeKeys: attributeKeys,\n          directChange: true\n        });\n      }\n    }\n  }, {\n    key: \"overrideGravity\",\n    value: function overrideGravity() {\n      var overrideUid = uid(); // Remember that another overriding has been requested. It will need to be removed\n      // before the gravity is to be restored.\n\n      this._overriddenGravityRegister.add(overrideUid);\n\n      if (this._overriddenGravityRegister.size === 1) {\n        this._updateAttributes(true);\n      }\n\n      return overrideUid;\n    }\n  }, {\n    key: \"restoreGravity\",\n    value: function restoreGravity(uid) {\n      if (!this._overriddenGravityRegister.has(uid)) {\n        /**\n         * Restoring gravity for an unknown UID is not possible. Make sure you are using a correct\n         * UID obtained from the {@link module:engine/model/writer~Writer#overrideSelectionGravity} to restore.\n         *\n         * @error document-selection-gravity-wrong-restore\n         * @param {String} uid The unique identifier returned by\n         * {@link module:engine/model/documentselection~DocumentSelection#_overrideGravity}.\n         */\n        throw new CKEditorError('document-selection-gravity-wrong-restore: Attempting to restore the selection gravity for an unknown UID.', {\n          uid: uid\n        });\n      }\n\n      this._overriddenGravityRegister.delete(uid); // Restore gravity only when all overriding have been restored.\n\n\n      if (!this.isGravityOverridden) {\n        this._updateAttributes(true);\n      }\n    }\n  }, {\n    key: \"_popRange\",\n    value: function _popRange() {\n      this._ranges.pop().detach();\n    }\n  }, {\n    key: \"_pushRange\",\n    value: function _pushRange(range) {\n      var liveRange = this._prepareRange(range); // `undefined` is returned when given `range` is in graveyard root.\n\n\n      if (liveRange) {\n        this._ranges.push(liveRange);\n      }\n    } // Prepares given range to be added to selection. Checks if it is correct,\n    // converts it to {@link module:engine/model/liverange~LiveRange LiveRange}\n    // and sets listeners listening to the range's change event.\n    //\n    // @private\n    // @param {module:engine/model/range~Range} range\n\n  }, {\n    key: \"_prepareRange\",\n    value: function _prepareRange(range) {\n      var _this2 = this;\n\n      this._checkRange(range);\n\n      if (range.root == this._document.graveyard) {\n        /**\n         * Trying to add a Range that is in the graveyard root. Range rejected.\n         *\n         * @warning model-selection-range-in-graveyard\n         */\n        log.warn('model-selection-range-in-graveyard: Trying to add a Range that is in the graveyard root. Range rejected.');\n        return;\n      }\n\n      var liveRange = LiveRange.fromRange(range);\n      liveRange.on('change:range', function (evt, oldRange, data) {\n        _this2._hasChangedRange = true; // If `LiveRange` is in whole moved to the graveyard, save necessary data. It will be fixed on `Model#applyOperation` event.\n\n        if (liveRange.root == _this2._document.graveyard) {\n          _this2._fixGraveyardRangesData.push({\n            liveRange: liveRange,\n            sourcePosition: data.deletionPosition\n          });\n        }\n      });\n      return liveRange;\n    }\n  }, {\n    key: \"_updateMarkers\",\n    value: function _updateMarkers() {\n      var markers = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._model.markers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var marker = _step2.value;\n          var markerRange = marker.getRange();\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = this.getRanges()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var selectionRange = _step3.value;\n\n              if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {\n                markers.push(marker);\n              }\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      for (var _i = 0, _markers = markers; _i < _markers.length; _i++) {\n        var _marker = _markers[_i];\n\n        if (!this.markers.has(_marker)) {\n          this.markers.add(_marker);\n        }\n      }\n\n      for (var _i2 = 0, _Array$from = Array.from(this.markers); _i2 < _Array$from.length; _i2++) {\n        var _marker2 = _Array$from[_i2];\n\n        if (!markers.includes(_marker2)) {\n          this.markers.remove(_marker2);\n        }\n      }\n    } // Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.\n    //\n    // @protected\n    // @param {Boolean} clearAll\n    // @fires change:attribute\n\n  }, {\n    key: \"_updateAttributes\",\n    value: function _updateAttributes(clearAll) {\n      var newAttributes = toMap(this._getSurroundingAttributes());\n      var oldAttributes = toMap(this.getAttributes());\n\n      if (clearAll) {\n        // If `clearAll` remove all attributes and reset priorities.\n        this._attributePriority = new Map();\n        this._attrs = new Map();\n      } else {\n        // If not, remove only attributes added with `low` priority.\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this._attributePriority[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n                key = _step4$value[0],\n                priority = _step4$value[1];\n\n            if (priority == 'low') {\n              this._attrs.delete(key);\n\n              this._attributePriority.delete(key);\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      this._setAttributesTo(newAttributes); // Let's evaluate which attributes really changed.\n\n\n      var changed = []; // First, loop through all attributes that are set on selection right now.\n      // Check which of them are different than old attributes.\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this.getAttributes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              newKey = _step5$value[0],\n              newValue = _step5$value[1];\n\n          if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {\n            changed.push(newKey);\n          }\n        } // Then, check which of old attributes got removed.\n\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = oldAttributes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _step6$value = _slicedToArray(_step6.value, 1),\n              oldKey = _step6$value[0];\n\n          if (!this.hasAttribute(oldKey)) {\n            changed.push(oldKey);\n          }\n        } // Fire event with exact data (fire only if anything changed).\n\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (changed.length > 0) {\n        this.fire('change:attribute', {\n          attributeKeys: changed,\n          directChange: false\n        });\n      }\n    } // Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n    // parameter).\n    //\n    // @private\n    // @param {String} key Attribute key.\n    // @param {*} value Attribute value.\n    // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n    // is caused by `Batch` API.\n    // @returns {Boolean} Whether value has changed.\n\n  }, {\n    key: \"_setAttribute\",\n    value: function _setAttribute(key, value) {\n      var directChange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var priority = directChange ? 'normal' : 'low';\n\n      if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n        // Priority too low.\n        return false;\n      }\n\n      var oldValue = _get(_getPrototypeOf(LiveSelection.prototype), \"getAttribute\", this).call(this, key); // Don't do anything if value has not changed.\n\n\n      if (oldValue === value) {\n        return false;\n      }\n\n      this._attrs.set(key, value); // Update priorities map.\n\n\n      this._attributePriority.set(key, priority);\n\n      return true;\n    } // Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n    // parameter).\n    //\n    // NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will\n    // be changed according to `directChange` parameter.\n    //\n    // @private\n    // @param {String} key Attribute key.\n    // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n    // is caused by `Batch` API.\n    // @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the\n    // existing attribute had higher priority.\n\n  }, {\n    key: \"_removeAttribute\",\n    value: function _removeAttribute(key) {\n      var directChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var priority = directChange ? 'normal' : 'low';\n\n      if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n        // Priority too low.\n        return false;\n      } // Update priorities map.\n\n\n      this._attributePriority.set(key, priority); // Don't do anything if value has not changed.\n\n\n      if (!_get(_getPrototypeOf(LiveSelection.prototype), \"hasAttribute\", this).call(this, key)) {\n        return false;\n      }\n\n      this._attrs.delete(key);\n\n      return true;\n    } // Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through\n    // `directChange` parameter).\n    //\n    // @private\n    // @param {Map.<String,*>} attrs Iterable object containing attributes to be set.\n    // @returns {Set.<String>} Changed attribute keys.\n\n  }, {\n    key: \"_setAttributesTo\",\n    value: function _setAttributesTo(attrs) {\n      var changed = new Set();\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this.getAttributes()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              oldKey = _step7$value[0],\n              oldValue = _step7$value[1];\n\n          // Do not remove attribute if attribute with same key and value is about to be set.\n          if (attrs.get(oldKey) === oldValue) {\n            continue;\n          } // All rest attributes will be removed so changed attributes won't change .\n\n\n          this._removeAttribute(oldKey, false);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = attrs[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var _step8$value = _slicedToArray(_step8.value, 2),\n              key = _step8$value[0],\n              value = _step8$value[1];\n\n          // Attribute may not be set because of attributes or because same key/value is already added.\n          var gotAdded = this._setAttribute(key, value, false);\n\n          if (gotAdded) {\n            changed.add(key);\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      return changed;\n    } // Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n    //\n    // @protected\n    // @returns {Iterable.<*>}\n\n  }, {\n    key: \"_getStoredAttributes\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _getStoredAttributes() {\n      var selectionParent, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, key, realKey;\n\n      return regeneratorRuntime.wrap(function _getStoredAttributes$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              selectionParent = this.getFirstPosition().parent;\n\n              if (!(this.isCollapsed && selectionParent.isEmpty)) {\n                _context2.next = 30;\n                break;\n              }\n\n              _iteratorNormalCompletion9 = true;\n              _didIteratorError9 = false;\n              _iteratorError9 = undefined;\n              _context2.prev = 5;\n              _iterator9 = selectionParent.getAttributeKeys()[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {\n                _context2.next = 16;\n                break;\n              }\n\n              key = _step9.value;\n\n              if (!key.startsWith(storePrefix)) {\n                _context2.next = 13;\n                break;\n              }\n\n              realKey = key.substr(storePrefix.length);\n              _context2.next = 13;\n              return [realKey, selectionParent.getAttribute(key)];\n\n            case 13:\n              _iteratorNormalCompletion9 = true;\n              _context2.next = 7;\n              break;\n\n            case 16:\n              _context2.next = 22;\n              break;\n\n            case 18:\n              _context2.prev = 18;\n              _context2.t0 = _context2[\"catch\"](5);\n              _didIteratorError9 = true;\n              _iteratorError9 = _context2.t0;\n\n            case 22:\n              _context2.prev = 22;\n              _context2.prev = 23;\n\n              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                _iterator9.return();\n              }\n\n            case 25:\n              _context2.prev = 25;\n\n              if (!_didIteratorError9) {\n                _context2.next = 28;\n                break;\n              }\n\n              throw _iteratorError9;\n\n            case 28:\n              return _context2.finish(25);\n\n            case 29:\n              return _context2.finish(22);\n\n            case 30:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _getStoredAttributes, this, [[5, 18, 22, 30], [23,, 25, 29]]);\n    }) // Checks model text nodes that are closest to the selection's first position and returns attributes of first\n    // found element. If there are no text nodes in selection's first position parent, it returns selection\n    // attributes stored in that parent.\n    //\n    // @private\n    // @returns {Iterable.<*>} Collection of attributes.\n\n  }, {\n    key: \"_getSurroundingAttributes\",\n    value: function _getSurroundingAttributes() {\n      var position = this.getFirstPosition();\n      var schema = this._model.schema;\n      var attrs = null;\n\n      if (!this.isCollapsed) {\n        // 1. If selection is a range...\n        var range = this.getFirstRange(); // ...look for a first character node in that range and take attributes from it.\n\n        var _iteratorNormalCompletion10 = true;\n        var _didIteratorError10 = false;\n        var _iteratorError10 = undefined;\n\n        try {\n          for (var _iterator10 = range[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n            var value = _step10.value;\n\n            // If the item is an object, we don't want to get attributes from its children.\n            if (value.item.is('element') && schema.isObject(value.item)) {\n              break;\n            }\n\n            if (value.type == 'text') {\n              attrs = value.item.getAttributes();\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError10 = true;\n          _iteratorError10 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n              _iterator10.return();\n            }\n          } finally {\n            if (_didIteratorError10) {\n              throw _iteratorError10;\n            }\n          }\n        }\n      } else {\n        // 2. If the selection is a caret or the range does not contain a character node...\n        var nodeBefore = position.textNode ? position.textNode : position.nodeBefore;\n        var nodeAfter = position.textNode ? position.textNode : position.nodeAfter; // When gravity is overridden then don't take node before into consideration.\n\n        if (!this.isGravityOverridden) {\n          // ...look at the node before caret and take attributes from it if it is a character node.\n          attrs = getAttrsIfCharacter(nodeBefore);\n        } // 3. If not, look at the node after caret...\n\n\n        if (!attrs) {\n          attrs = getAttrsIfCharacter(nodeAfter);\n        } // 4. If not, try to find the first character on the left, that is in the same node.\n        // When gravity is overridden then don't take node before into consideration.\n\n\n        if (!this.isGravityOverridden && !attrs) {\n          var node = nodeBefore;\n\n          while (node && !attrs) {\n            node = node.previousSibling;\n            attrs = getAttrsIfCharacter(node);\n          }\n        } // 5. If not found, try to find the first character on the right, that is in the same node.\n\n\n        if (!attrs) {\n          var _node = nodeAfter;\n\n          while (_node && !attrs) {\n            _node = _node.nextSibling;\n            attrs = getAttrsIfCharacter(_node);\n          }\n        } // 6. If not found, selection should retrieve attributes from parent.\n\n\n        if (!attrs) {\n          attrs = this._getStoredAttributes();\n        }\n      }\n\n      return attrs;\n    } // Fixes a selection range after it ends up in graveyard root.\n    //\n    // @private\n    // @param {module:engine/model/liverange~LiveRange} liveRange The range from selection, that ended up in the graveyard root.\n    // @param {module:engine/model/position~Position} removedRangeStart Start position of a range which was removed.\n\n  }, {\n    key: \"_fixGraveyardSelection\",\n    value: function _fixGraveyardSelection(liveRange, removedRangeStart) {\n      // The start of the removed range is the closest position to the `liveRange` - the original selection range.\n      // This is a good candidate for a fixed selection range.\n      var positionCandidate = removedRangeStart.clone(); // Find a range that is a correct selection range and is closest to the start of removed range.\n\n      var selectionRange = this._model.schema.getNearestSelectionRange(positionCandidate); // Remove the old selection range before preparing and adding new selection range. This order is important,\n      // because new range, in some cases, may intersect with old range (it depends on `getNearestSelectionRange()` result).\n\n\n      var index = this._ranges.indexOf(liveRange);\n\n      this._ranges.splice(index, 1);\n\n      liveRange.detach(); // If nearest valid selection range has been found - add it in the place of old range.\n\n      if (selectionRange) {\n        // Check the range, convert it to live range, bind events, etc.\n        var newRange = this._prepareRange(selectionRange); // Add new range in the place of old range.\n\n\n        this._ranges.splice(index, 0, newRange);\n      } // If nearest valid selection range cannot be found - just removing the old range is fine.\n\n    }\n  }, {\n    key: \"isCollapsed\",\n    get: function get() {\n      var length = this._ranges.length;\n      return length === 0 ? this._document._getDefaultRange().isCollapsed : _get(_getPrototypeOf(LiveSelection.prototype), \"isCollapsed\", this);\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      return _get(_getPrototypeOf(LiveSelection.prototype), \"anchor\", this) || this._document._getDefaultRange().start;\n    }\n  }, {\n    key: \"focus\",\n    get: function get() {\n      return _get(_getPrototypeOf(LiveSelection.prototype), \"focus\", this) || this._document._getDefaultRange().end;\n    }\n  }, {\n    key: \"rangeCount\",\n    get: function get() {\n      return this._ranges.length ? this._ranges.length : 1;\n    } // Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to\n    // {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n    //\n    // @readonly\n    // @type {Boolean}\n\n  }, {\n    key: \"hasOwnRange\",\n    get: function get() {\n      return this._ranges.length > 0;\n    } // When set to `true` then selection attributes on node before the caret won't be taken\n    // into consideration while updating selection attributes.\n    //\n    // @protected\n    // @type {Boolean}\n\n  }, {\n    key: \"isGravityOverridden\",\n    get: function get() {\n      return !!this._overriddenGravityRegister.size;\n    }\n  }]);\n\n  return LiveSelection;\n}(Selection); // Helper function for {@link module:engine/model/liveselection~LiveSelection#_updateAttributes}.\n//\n// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.\n//\n// @param {module:engine/model/item~Item|null}  node\n// @returns {Boolean}\n\n\nfunction getAttrsIfCharacter(node) {\n  if (node instanceof TextProxy || node instanceof Text) {\n    return node.getAttributes();\n  }\n\n  return null;\n} // Removes selection attributes from element which is not empty anymore.\n//\n// @private\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/model/batch~Batch} batch\n\n\nfunction clearAttributesStoredInElement(model, batch) {\n  var differ = model.document.differ;\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var entry = _step11.value;\n\n      if (entry.type != 'insert') {\n        return \"continue\";\n      }\n\n      var changeParent = entry.position.parent;\n      var isNoLongerEmpty = entry.length === changeParent.maxOffset;\n\n      if (isNoLongerEmpty) {\n        model.enqueueChange(batch, function (writer) {\n          var storedAttributes = Array.from(changeParent.getAttributeKeys()).filter(function (key) {\n            return key.startsWith(storePrefix);\n          });\n          var _iteratorNormalCompletion12 = true;\n          var _didIteratorError12 = false;\n          var _iteratorError12 = undefined;\n\n          try {\n            for (var _iterator12 = storedAttributes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n              var key = _step12.value;\n              writer.removeAttribute(key, changeParent);\n            }\n          } catch (err) {\n            _didIteratorError12 = true;\n            _iteratorError12 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n                _iterator12.return();\n              }\n            } finally {\n              if (_didIteratorError12) {\n                throw _iteratorError12;\n              }\n            }\n          }\n        });\n      }\n    };\n\n    for (var _iterator11 = differ.getChanges()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/conversionhelpers\n */\n\n/**\n * Base class for conversion helpers.\n */\nvar ConversionHelpers =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a conversion helpers instance.\n   *\n   * @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n   * module:engine/conversion/upcastdispatcher~UpcastDispatcher>} dispatchers\n   */\n  function ConversionHelpers(dispatchers) {\n    _classCallCheck(this, ConversionHelpers);\n\n    this._dispatchers = dispatchers;\n  }\n  /**\n   * Registers a conversion helper.\n   *\n   * **Note**: See full usage example in the `{@link module:engine/conversion/conversion~Conversion#for conversion.for()}`\n   * method description.\n   *\n   * @param {Function} conversionHelper The function to be called on event.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers|module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n\n\n  _createClass(ConversionHelpers, [{\n    key: \"add\",\n    value: function add(conversionHelper) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._dispatchers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var dispatcher = _step.value;\n          conversionHelper(dispatcher);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return ConversionHelpers;\n}();\n\nexport { ConversionHelpers as default };","import _typeof from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/typeof\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport ModelRange from \"../model/range\";\nimport ModelSelection from \"../model/selection\";\nimport ModelElement from \"../model/element\";\nimport ViewAttributeElement from \"../view/attributeelement\";\nimport DocumentSelection from \"../model/documentselection\";\nimport ConversionHelpers from \"./conversionhelpers\";\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport { cloneDeep } from 'lodash-es';\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\n\n/**\n * Downcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\n\nvar DowncastHelpers =\n/*#__PURE__*/\nfunction (_ConversionHelpers) {\n  _inherits(DowncastHelpers, _ConversionHelpers);\n\n  function DowncastHelpers() {\n    _classCallCheck(this, DowncastHelpers);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DowncastHelpers).apply(this, arguments));\n  }\n\n  _createClass(DowncastHelpers, [{\n    key: \"elementToElement\",\n\n    /**\n     * Model element to view element conversion helper.\n     *\n     * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tview: 'p'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tview: 'div',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'fancyParagraph',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'p',\n     *\t\t\t\tclasses: 'fancy'\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'heading',\n     *\t\t\tview: ( modelElement, viewWriter ) => {\n     *\t\t\t\treturn viewWriter.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) )\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #elementToElement\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.model The name of the model element to convert.\n     * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n     * that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n     * as parameters and returns a view container element.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n    value: function elementToElement(config) {\n      return this.add(downcastElementToElement(config));\n    }\n    /**\n     * Model attribute to view element conversion helper.\n     *\n     * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n     * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: 'strong'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: 'b',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'invert',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'fontSize',\n     *\t\t\t\tvalues: [ 'big', 'small' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tbig: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '1.2em'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tsmall: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '0.8em'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: ( modelAttributeValue, viewWriter ) => {\n     *\t\t\t\treturn viewWriter.createAttributeElement( 'span', {\n     *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'color',\n     *\t\t\t\tname: '$text'\n     *\t\t\t},\n     *\t\t\tview: ( modelAttributeValue, viewWriter ) => {\n     *\t\t\t\treturn viewWriter.createAttributeElement( 'span', {\n     *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #attributeToElement\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n     * of `String`s with possible values if the model attribute is an enumerable.\n     * @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n     * that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n     * as parameters and returns a view attribute element. If `config.model.values` is\n     * given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"attributeToElement\",\n    value: function attributeToElement(config) {\n      return this.add(downcastAttributeToElement(config));\n    }\n    /**\n     * Model attribute to view attribute conversion helper.\n     *\n     * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n     * `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>`.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'source',\n     *\t\t\tview: 'src'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'source',\n     *\t\t\tview: 'href',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'image',\n     *\t\t\t\tkey: 'source'\n     *\t\t\t},\n     *\t\t\tview: 'src'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'styled',\n     *\t\t\t\tvalues: [ 'dark', 'light' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tdark: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n     *\t\t\t\t},\n     *\t\t\t\tlight: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'styled',\n     *\t\t\tview: modelAttributeValue => ( { key: 'class', value: 'styled-' + modelAttributeValue } )\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #attributeToAttribute\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n     * the attribute key, possible values and, optionally, an element name to convert from.\n     * @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n     * the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n     * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n     * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n     * `{ key, value }` objects or a functions.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"attributeToAttribute\",\n    value: function attributeToAttribute(config) {\n      return this.add(downcastAttributeToAttribute(config));\n    }\n    /**\n     * Model marker to view element conversion helper.\n     *\n     * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n     * is collapsed, only one element is created. For example, model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n     * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: 'marker-search'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: 'search-result',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tattributes: {\n     *\t\t\t\t\t'data-marker': 'search'\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: ( markerData, viewWriter ) => {\n     *\t\t\t\treturn viewWriter.createUIElement( 'span', {\n     *\t\t\t\t\t'data-marker': 'search',\n     *\t\t\t\t\t'data-start': markerData.isOpening\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n     * receives the `data` object as a parameter and should return an instance of the\n     * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n     * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n     * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` to\n     * the marker end boundary element.\n     *\n     * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #markerToElement\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.model The name of the model marker (or model marker group) to convert.\n     * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n     * that takes the model marker data as a parameter and returns a view UI element.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"markerToElement\",\n    value: function markerToElement(config) {\n      return this.add(downcastMarkerToElement(config));\n    }\n    /**\n     * Model marker to highlight conversion helper.\n     *\n     * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n     * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n     *\n     * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n     * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n     * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n     *\n     * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n     * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n     * For example, a model marker set like this: `[<image src=\"foo.jpg\"></image>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>`\n     * in the view.\n     *\n     * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n     * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n     * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n     *\t\t\tmodel: 'comment',\n     *\t\t\tview: { classes: 'new-comment' },\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n     *\t\t\tmodel: 'comment',\n     *\t\t\tview: data => {\n     *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType.\n     *\t\t\t\tconst commentType = data.markerName.split( ':' )[ 1 ];\n     *\n     *\t\t\t\treturn {\n     *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ]\n     *\t\t\t\t};\n     *\t\t\t}\n     *\t\t} );\n     *\n     * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n     * receives the `data` object as a parameter and should return a\n     * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n     * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #markerToHighlight\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.model The name of the model marker (or model marker group) to convert.\n     * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n     * that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"markerToHighlight\",\n    value: function markerToHighlight(config) {\n      return this.add(downcastMarkerToHighlight(config));\n    }\n  }]);\n\n  return DowncastHelpers;\n}(ConversionHelpers);\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\n\n\nexport { DowncastHelpers as default };\nexport function insertText() {\n  return function (evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, 'insert')) {\n      return;\n    }\n\n    var viewWriter = conversionApi.writer;\n    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    var viewText = viewWriter.createText(data.item.data);\n    viewWriter.insert(viewPosition, viewText);\n  };\n}\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\n\nexport function remove() {\n  return function (evt, data, conversionApi) {\n    // Find view range start position by mapping model position at which the remove happened.\n    var viewStart = conversionApi.mapper.toViewPosition(data.position);\n    var modelEnd = data.position.getShiftedBy(data.length);\n    var viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {\n      isPhantom: true\n    });\n    var viewRange = conversionApi.writer.createRange(viewStart, viewEnd); // Trim the range to remove in case some UI elements are on the view range boundaries.\n\n    var removed = conversionApi.writer.remove(viewRange.getTrimmed()); // After the range is removed, unbind all view elements from the model.\n    // Range inside view document fragment is used to unbind deeply.\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = conversionApi.writer.createRangeIn(removed).getItems()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var child = _step.value;\n        conversionApi.mapper.unbindViewElement(child);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If a priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\n\nexport function createViewElementFromHighlightDescriptor(descriptor) {\n  var viewElement = new ViewAttributeElement('span', descriptor.attributes);\n\n  if (descriptor.classes) {\n    viewElement._addClass(descriptor.classes);\n  }\n\n  if (descriptor.priority) {\n    viewElement._priority = descriptor.priority;\n  }\n\n  viewElement._id = descriptor.id;\n  return viewElement;\n}\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\n\nexport function convertRangeSelection() {\n  return function (evt, data, conversionApi) {\n    var selection = data.selection;\n\n    if (selection.isCollapsed) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n\n    var viewRanges = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = selection.getRanges()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var range = _step2.value;\n        var viewRange = conversionApi.mapper.toViewRange(range);\n        viewRanges.push(viewRange);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    conversionApi.writer.setSelection(viewRanges, {\n      backward: selection.isBackward\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\n\nexport function convertCollapsedSelection() {\n  return function (evt, data, conversionApi) {\n    var selection = data.selection;\n\n    if (!selection.isCollapsed) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n\n    var viewWriter = conversionApi.writer;\n    var modelPosition = selection.getFirstPosition();\n    var viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n    var brokenPosition = viewWriter.breakAttributes(viewPosition);\n    viewWriter.setSelection(brokenPosition);\n  };\n}\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\n\nexport function clearAttributes() {\n  return function (evt, data, conversionApi) {\n    var viewWriter = conversionApi.writer;\n    var viewSelection = viewWriter.document.selection;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = viewSelection.getRanges()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var range = _step3.value;\n\n        // Not collapsed selection should not have artifacts.\n        if (range.isCollapsed) {\n          // Position might be in the node removed by the view writer.\n          if (range.end.parent.document) {\n            conversionApi.writer.mergeAttributes(range.start);\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    viewWriter.setSelection(null);\n  };\n}\n/**\n * Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, viewWriter ) => {\n *\t\t\treturn viewWriter.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\n\nexport function wrap(elementCreator) {\n  return function (evt, data, conversionApi) {\n    // Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n    // or the attribute was removed.\n    var oldViewElement = elementCreator(data.attributeOldValue, conversionApi.writer); // Create node to wrap with.\n\n    var newViewElement = elementCreator(data.attributeNewValue, conversionApi.writer);\n\n    if (!oldViewElement && !newViewElement) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    var viewWriter = conversionApi.writer;\n    var viewSelection = viewWriter.document.selection;\n\n    if (data.item instanceof ModelSelection || data.item instanceof DocumentSelection) {\n      // Selection attribute conversion.\n      viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);\n    } else {\n      // Node attribute conversion.\n      var viewRange = conversionApi.mapper.toViewRange(data.range); // First, unwrap the range from current wrapper.\n\n      if (data.attributeOldValue !== null && oldViewElement) {\n        viewRange = viewWriter.unwrap(viewRange, oldViewElement);\n      }\n\n      if (data.attributeNewValue !== null && newViewElement) {\n        viewWriter.wrap(viewRange, newViewElement);\n      }\n    }\n  };\n}\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list, stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}) and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, viewWriter ) => {\n *\t\t\t\tconst text = viewWriter.createText( 'myText' );\n *\t\t\t\tconst myElem = viewWriter.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @returns {Function} Insert element event converter.\n */\n\nexport function insertElement(elementCreator) {\n  return function (evt, data, conversionApi) {\n    var viewElement = elementCreator(data.item, conversionApi.writer);\n\n    if (!viewElement) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, 'insert')) {\n      return;\n    }\n\n    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(data.item, viewElement);\n    conversionApi.writer.insert(viewPosition, viewElement);\n  };\n}\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\n\nexport function insertUIElement(elementCreator) {\n  return function (evt, data, conversionApi) {\n    // Create two view elements. One will be inserted at the beginning of marker, one at the end.\n    // If marker is collapsed, only \"opening\" element will be inserted.\n    data.isOpening = true;\n    var viewStartElement = elementCreator(data, conversionApi.writer);\n    data.isOpening = false;\n    var viewEndElement = elementCreator(data, conversionApi.writer);\n\n    if (!viewStartElement || !viewEndElement) {\n      return;\n    }\n\n    var markerRange = data.markerRange; // Marker that is collapsed has consumable build differently that non-collapsed one.\n    // For more information see `addMarker` event description.\n    // If marker's range is collapsed - check if it can be consumed.\n\n    if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {\n      return;\n    } // If marker's range is not collapsed - consume all items inside.\n\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = markerRange[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var value = _step4.value;\n\n        if (!conversionApi.consumable.consume(value.item, evt.name)) {\n          return;\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    var mapper = conversionApi.mapper;\n    var viewWriter = conversionApi.writer; // Add \"opening\" element.\n\n    viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);\n    conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName); // Add \"closing\" element only if range is not collapsed.\n\n    if (!markerRange.isCollapsed) {\n      viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);\n      conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);\n    }\n\n    evt.stop();\n  };\n} // Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// basing on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\n\nfunction removeUIElement() {\n  return function (evt, data, conversionApi) {\n    var elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    conversionApi.mapper.unbindElementsFromMarkerName(data.markerName);\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = elements[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var element = _step5.value;\n        conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n} // Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\n\n\nfunction changeAttribute(attributeCreator) {\n  return function (evt, data, conversionApi) {\n    var oldAttribute = attributeCreator(data.attributeOldValue, data);\n    var newAttribute = attributeCreator(data.attributeNewValue, data);\n\n    if (!oldAttribute && !newAttribute) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    var viewElement = conversionApi.mapper.toViewElement(data.item);\n    var viewWriter = conversionApi.writer; // If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n    // Only elements can have attributes in a view so do not proceed for anything else (#1587).\n\n    if (!viewElement) {\n      /**\n       * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n       * by {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n       * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n       *\t\t\tmodel: 'attribute-name',\n       *\t\t\tview: 'attribute-name'\n       *\t\t} ) );\n       *\n       * and given attribute is used on text node, for example:\n       *\n       *\t\tmodel.change( writer => {\n       *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n       *\t\t} );\n       *\n       * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n       * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n       * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n       * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n       *\t\t\tmodel: {\n       *\t\t\t\tkey: 'attribute-name',\n       *\t\t\t\tname: '$text'\n       *\t\t\t},\n       *\t\t\tview: ( value, writer ) => {\n       *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n       *\t\t\t},\n       *\t\t\tconverterPriority: 'high'\n       *\t\t} ) );\n       *\n       * @error conversion-attribute-to-attribute-on-text\n       */\n      log.warn('conversion-attribute-to-attribute-on-text: ' + 'Trying to convert text node\\'s attribute with attribute-to-attribute converter.');\n      return;\n    } // First remove the old attribute if there was one.\n\n\n    if (data.attributeOldValue !== null && oldAttribute) {\n      if (oldAttribute.key == 'class') {\n        var classes = Array.isArray(oldAttribute.value) ? oldAttribute.value : [oldAttribute.value];\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = classes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var className = _step6.value;\n            viewWriter.removeClass(className, viewElement);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n      } else if (oldAttribute.key == 'style') {\n        var keys = Object.keys(oldAttribute.value);\n\n        for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n          var key = _keys[_i];\n          viewWriter.removeStyle(key, viewElement);\n        }\n      } else {\n        viewWriter.removeAttribute(oldAttribute.key, viewElement);\n      }\n    } // Then set the new attribute.\n\n\n    if (data.attributeNewValue !== null && newAttribute) {\n      if (newAttribute.key == 'class') {\n        var _classes = Array.isArray(newAttribute.value) ? newAttribute.value : [newAttribute.value];\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = _classes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var _className = _step7.value;\n            viewWriter.addClass(_className, viewElement);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      } else if (newAttribute.key == 'style') {\n        var _keys2 = Object.keys(newAttribute.value);\n\n        for (var _i2 = 0, _keys3 = _keys2; _i2 < _keys3.length; _i2++) {\n          var _key = _keys3[_i2];\n          viewWriter.setStyle(_key, newAttribute.value[_key], viewElement);\n        }\n      } else {\n        viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);\n      }\n    }\n  };\n} // Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction highlightText(highlightDescriptor) {\n  return function (evt, data, conversionApi) {\n    if (!data.item) {\n      return;\n    }\n\n    if (!(data.item instanceof ModelSelection || data.item instanceof DocumentSelection) && !data.item.is('textProxy')) {\n      return;\n    }\n\n    var descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    var viewElement = createViewElementFromHighlightDescriptor(descriptor);\n    var viewWriter = conversionApi.writer;\n    var viewSelection = viewWriter.document.selection;\n\n    if (data.item instanceof ModelSelection || data.item instanceof DocumentSelection) {\n      viewWriter.wrap(viewSelection.getFirstRange(), viewElement, viewSelection);\n    } else {\n      var viewRange = conversionApi.mapper.toViewRange(data.range);\n      var rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = rangeAfterWrap.getItems()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var element = _step8.value;\n\n          if (element.is('attributeElement') && element.isSimilar(viewElement)) {\n            conversionApi.mapper.bindElementToMarker(element, data.markerName); // One attribute element is enough, because all of them are bound together by the view writer.\n            // Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n  };\n} // Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction highlightElement(highlightDescriptor) {\n  return function (evt, data, conversionApi) {\n    if (!data.item) {\n      return;\n    }\n\n    if (!(data.item instanceof ModelElement)) {\n      return;\n    }\n\n    var descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    }\n\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    }\n\n    var viewElement = conversionApi.mapper.toViewElement(data.item);\n\n    if (viewElement && viewElement.getCustomProperty('addHighlight')) {\n      // Consume element itself.\n      conversionApi.consumable.consume(data.item, evt.name); // Consume all children nodes.\n\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = ModelRange._createIn(data.item)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var value = _step9.value;\n          conversionApi.consumable.consume(value.item, evt.name);\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      viewElement.getCustomProperty('addHighlight')(viewElement, descriptor, conversionApi.writer);\n      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n    }\n  };\n} // Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction removeHighlight(highlightDescriptor) {\n  return function (evt, data, conversionApi) {\n    // This conversion makes sense only for non-collapsed range.\n    if (data.markerRange.isCollapsed) {\n      return;\n    }\n\n    var descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    } // View element that will be used to unwrap `AttributeElement`s.\n\n\n    var viewHighlightElement = createViewElementFromHighlightDescriptor(descriptor); // Get all elements bound with given marker name.\n\n    var elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    conversionApi.mapper.unbindElementsFromMarkerName(data.markerName);\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n      for (var _iterator10 = elements[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var element = _step10.value;\n\n        if (element.is('attributeElement')) {\n          conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);\n        } else {\n          // if element.is( 'containerElement' ).\n          element.getCustomProperty('removeHighlight')(element, descriptor.id, conversionApi.writer);\n        }\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n} // Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model element to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n// as parameters and returns a view container element.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastElementToElement(config) {\n  config = cloneDeep(config);\n  config.view = normalizeToElementConfig(config.view, 'container');\n  return function (dispatcher) {\n    dispatcher.on('insert:' + config.model, insertElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n// that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n// as parameters and returns a view attribute element. If `config.model.values` is\n// given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastAttributeToElement(config) {\n  config = cloneDeep(config);\n  var modelKey = config.model.key ? config.model.key : config.model;\n  var eventName = 'attribute:' + modelKey;\n\n  if (config.model.name) {\n    eventName += ':' + config.model.name;\n  }\n\n  if (config.model.values) {\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n      for (var _iterator11 = config.model.values[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        var modelValue = _step11.value;\n        config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], 'attribute');\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n          _iterator11.return();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  } else {\n    config.view = normalizeToElementConfig(config.view, 'attribute');\n  }\n\n  var elementCreator = getFromAttributeCreator(config);\n  return function (dispatcher) {\n    dispatcher.on(eventName, wrap(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n// the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n// array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastAttributeToAttribute(config) {\n  config = cloneDeep(config);\n  var modelKey = config.model.key ? config.model.key : config.model;\n  var eventName = 'attribute:' + modelKey;\n\n  if (config.model.name) {\n    eventName += ':' + config.model.name;\n  }\n\n  if (config.model.values) {\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n\n    try {\n      for (var _iterator12 = config.model.values[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n        var modelValue = _step12.value;\n        config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);\n      }\n    } catch (err) {\n      _didIteratorError12 = true;\n      _iteratorError12 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n          _iterator12.return();\n        }\n      } finally {\n        if (_didIteratorError12) {\n          throw _iteratorError12;\n        }\n      }\n    }\n  } else {\n    config.view = normalizeToAttributeConfig(config.view);\n  }\n\n  var elementCreator = getFromAttributeCreator(config);\n  return function (dispatcher) {\n    dispatcher.on(eventName, changeAttribute(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToElement(config) {\n  config = cloneDeep(config);\n  config.view = normalizeToElementConfig(config.view, 'ui');\n  return function (dispatcher) {\n    dispatcher.on('addMarker:' + config.model, insertUIElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + config.model, removeUIElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToHighlight(config) {\n  return function (dispatcher) {\n    dispatcher.on('addMarker:' + config.model, highlightText(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('addMarker:' + config.model, highlightElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + config.model, removeHighlight(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\n\n\nfunction normalizeToElementConfig(view, viewElementType) {\n  if (typeof view == 'function') {\n    // If `view` is already a function, don't do anything.\n    return view;\n  }\n\n  return function (modelData, viewWriter) {\n    return createViewElementFromDefinition(view, viewWriter, viewElementType);\n  };\n} // Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\n\n\nfunction createViewElementFromDefinition(viewElementDefinition, viewWriter, viewElementType) {\n  if (typeof viewElementDefinition == 'string') {\n    // If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n    viewElementDefinition = {\n      name: viewElementDefinition\n    };\n  }\n\n  var element;\n  var attributes = Object.assign({}, viewElementDefinition.attributes);\n\n  if (viewElementType == 'container') {\n    element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);\n  } else if (viewElementType == 'attribute') {\n    var options = {\n      priority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n    };\n    element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);\n  } else {\n    // 'ui'.\n    element = viewWriter.createUIElement(viewElementDefinition.name, attributes);\n  }\n\n  if (viewElementDefinition.styles) {\n    var keys = Object.keys(viewElementDefinition.styles);\n\n    for (var _i3 = 0, _keys4 = keys; _i3 < _keys4.length; _i3++) {\n      var key = _keys4[_i3];\n      viewWriter.setStyle(key, viewElementDefinition.styles[key], element);\n    }\n  }\n\n  if (viewElementDefinition.classes) {\n    var classes = viewElementDefinition.classes;\n\n    if (typeof classes == 'string') {\n      viewWriter.addClass(classes, element);\n    } else {\n      var _iteratorNormalCompletion13 = true;\n      var _didIteratorError13 = false;\n      var _iteratorError13 = undefined;\n\n      try {\n        for (var _iterator13 = classes[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n          var className = _step13.value;\n          viewWriter.addClass(className, element);\n        }\n      } catch (err) {\n        _didIteratorError13 = true;\n        _iteratorError13 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n            _iterator13.return();\n          }\n        } finally {\n          if (_didIteratorError13) {\n            throw _iteratorError13;\n          }\n        }\n      }\n    }\n  }\n\n  return element;\n}\n\nfunction getFromAttributeCreator(config) {\n  if (config.model.values) {\n    return function (modelAttributeValue, viewWriter) {\n      var view = config.view[modelAttributeValue];\n\n      if (view) {\n        return view(modelAttributeValue, viewWriter);\n      }\n\n      return null;\n    };\n  } else {\n    return config.view;\n  }\n} // Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\n\n\nfunction normalizeToAttributeConfig(view) {\n  if (typeof view == 'string') {\n    return function (modelAttributeValue) {\n      return {\n        key: view,\n        value: modelAttributeValue\n      };\n    };\n  } else if (_typeof(view) == 'object') {\n    // { key, value, ... }\n    if (view.value) {\n      return function () {\n        return view;\n      };\n    } // { key, ... }\n    else {\n        return function (modelAttributeValue) {\n          return {\n            key: view.key,\n            value: modelAttributeValue\n          };\n        };\n      }\n  } else {\n    // function.\n    return view;\n  }\n} // Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\n\n\nfunction prepareDescriptor(highlightDescriptor, data, conversionApi) {\n  // If passed descriptor is a creator function, call it. If not, just use passed value.\n  var descriptor = typeof highlightDescriptor == 'function' ? highlightDescriptor(data, conversionApi) : highlightDescriptor;\n\n  if (!descriptor) {\n    return null;\n  } // Apply default descriptor priority.\n\n\n  if (!descriptor.priority) {\n    descriptor.priority = 10;\n  } // Default descriptor id is marker name.\n\n\n  if (!descriptor.id) {\n    descriptor.id = data.markerName;\n  }\n\n  return descriptor;\n}\n/**\n * An object describing how the marker highlight should be represented in the view.\n *\n * Each text node contained in a highlighted range will be wrapped in a `<span>`\n * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority\n * described by this object.\n *\n * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight\n * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:\n *\n *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to\n *  the element.\n *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the\n *  given ID from the element.\n *\n * @typedef {Object} module:engine/conversion/downcasthelpers~HighlightDescriptor\n *\n * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to\n * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set\n * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n *\n * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.\n *\n * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's\n * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,\n * the priority will be used to determine which descriptor is more important.\n *\n * @property {Object} [attributes] Attributes to set. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that\n * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n */","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport _defineProperty from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.function.name\";\nimport _typeof from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/typeof\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Matcher from \"../view/matcher\";\nimport ModelRange from \"../model/range\";\nimport ConversionHelpers from \"./conversionhelpers\";\nimport { cloneDeep } from 'lodash-es';\nimport ModelSelection from \"../model/selection\";\n/**\n * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcasthelpers\n */\n\n/**\n * Upcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\n\nvar UpcastHelpers =\n/*#__PURE__*/\nfunction (_ConversionHelpers) {\n  _inherits(UpcastHelpers, _ConversionHelpers);\n\n  function UpcastHelpers() {\n    _classCallCheck(this, UpcastHelpers);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UpcastHelpers).apply(this, arguments));\n  }\n\n  _createClass(UpcastHelpers, [{\n    key: \"elementToElement\",\n\n    /**\n     * View element to model element conversion helper.\n     *\n     * This conversion results in creating a model element. For example,\n     * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n     *\n     * Keep in mind that the element will be inserted only if it is allowed\n     * by {@link module:engine/model/schema~Schema schema} configuration.\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n     *\t\t\tview: 'p',\n     *\t\t\tmodel: 'paragraph'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n     *\t\t\tview: 'p',\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'p',\n     *\t\t\t\tclasses: 'fancy'\n     *\t\t\t},\n     *\t\t\tmodel: 'fancyParagraph'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n     * \t\t\tview: {\n     *\t\t\t\tname: 'p',\n     *\t\t\t\tclasses: 'heading'\n     * \t\t\t},\n     * \t\t\tmodel: ( viewElement, modelWriter ) => {\n     * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n     * \t\t\t}\n     * \t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #elementToElement\n     * @param {Object} config Conversion configuration.\n     * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n     * set, the converter will fire for every view element.\n     * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n     * instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n    value: function elementToElement(config) {\n      return this.add(upcastElementToElement(config));\n    }\n    /**\n     * View element to model attribute conversion helper.\n     *\n     * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n     * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n     *\n     * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n     *\n     *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n     *\n     * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n     * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n     * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.\n     *\n     * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: 'strong',\n     *\t\t\tmodel: 'bold'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: 'strong',\n     *\t\t\tmodel: 'bold',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tclasses: 'bold'\n     *\t\t\t},\n     *\t\t\tmodel: 'bold'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n     *\t\t\t},\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'styled',\n     *\t\t\t\tvalue: 'dark'\n     *\t\t\t}\n     *\t\t} );\n     *\n     * \t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tstyles: {\n     *\t\t\t\t\t'font-size': /[\\s\\S]+/\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'fontSize',\n     *\t\t\t\tvalue: viewElement => {\n     *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n     *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n     *\n     *\t\t\t\t\tif ( value <= 10 ) {\n     *\t\t\t\t\t\treturn 'small';\n     *\t\t\t\t\t} else if ( value > 12 ) {\n     *\t\t\t\t\t\treturn 'big';\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #elementToAttribute\n     * @param {Object} config Conversion configuration.\n     * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n     * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n     * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n     * If `String` is given, the model attribute value will be set to `true`.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n\n  }, {\n    key: \"elementToAttribute\",\n    value: function elementToAttribute(config) {\n      return this.add(upcastElementToAttribute(config));\n    }\n    /**\n     * View attribute to model attribute conversion helper.\n     *\n     * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n     * `<image source=\"foo.jpg\"></image>` in the model.\n     *\n     * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n     * is set only on the corresponding model node:\n     *\n     *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n     *\n     * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n     * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for\n     * all the children in the model:\n     *\n     *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n     *\n     * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n     * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n     *\n     * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: 'src',\n     *\t\t\tmodel: 'source'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: { key: 'src' },\n     *\t\t\tmodel: 'source'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: { key: 'src' },\n     *\t\t\tmodel: 'source',\n     *\t\t\tconverterPriority: 'normal'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tkey: 'data-style',\n     *\t\t\t\tvalue: /[\\s\\S]+/\n     *\t\t\t},\n     *\t\t\tmodel: 'styled'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'img',\n     *\t\t\t\tkey: 'class',\n     *\t\t\t\tvalue: 'styled-dark'\n     *\t\t\t},\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'styled',\n     *\t\t\t\tvalue: 'dark'\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tkey: 'class',\n     *\t\t\t\tvalue: /styled-[\\S]+/\n     *\t\t\t},\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'styled'\n     *\t\t\t\tvalue: viewElement => {\n     *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n     *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n     *\n     *\t\t\t\t\treturn match[ 1 ];\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #attributeToAttribute\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n     * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n     * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n     * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n     * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n     * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n     * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n     * If `String` is given, the model attribute value will be same as view attribute value.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n\n  }, {\n    key: \"attributeToAttribute\",\n    value: function attributeToAttribute(config) {\n      return this.add(upcastAttributeToAttribute(config));\n    }\n    /**\n     * View element to model marker conversion helper.\n     *\n     * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n     * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n     * after the conversion is done, the marker will be available in\n     * {@link module:engine/model/model~Model#markers model document markers}.\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n     *\t\t\tview: 'marker-search',\n     *\t\t\tmodel: 'search'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n     *\t\t\tview: 'marker-search',\n     *\t\t\tmodel: 'search',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n     *\t\t\tview: 'marker-search',\n     *\t\t\tmodel: viewElement => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tattributes: {\n     *\t\t\t\t\t'data-marker': 'search'\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tmodel: 'search'\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #elementToMarker\n     * @param {Object} config Conversion configuration.\n     * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n     * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n     * a model marker name.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n\n  }, {\n    key: \"elementToMarker\",\n    value: function elementToMarker(config) {\n      return this.add(upcastElementToMarker(config));\n    }\n  }]);\n\n  return UpcastHelpers;\n}(ConversionHelpers);\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\n\n\nexport { UpcastHelpers as default };\nexport function convertToModelFragment() {\n  return function (evt, data, conversionApi) {\n    // Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n    if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, {\n      name: true\n    })) {\n      var _conversionApi$conver = conversionApi.convertChildren(data.viewItem, data.modelCursor),\n          modelRange = _conversionApi$conver.modelRange,\n          modelCursor = _conversionApi$conver.modelCursor;\n\n      data.modelRange = modelRange;\n      data.modelCursor = modelCursor;\n    }\n  };\n}\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\n\nexport function convertText() {\n  return function (evt, data, conversionApi) {\n    if (conversionApi.schema.checkChild(data.modelCursor, '$text')) {\n      if (conversionApi.consumable.consume(data.viewItem)) {\n        var text = conversionApi.writer.createText(data.viewItem.data);\n        conversionApi.writer.insert(text, data.modelCursor);\n        data.modelRange = ModelRange._createFromPositionAndShift(data.modelCursor, text.offsetSize);\n        data.modelCursor = data.modelRange.end;\n      }\n    }\n  };\n}\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\n\nexport function convertSelectionChange(model, mapper) {\n  return function (evt, data) {\n    var viewSelection = data.newSelection;\n    var modelSelection = new ModelSelection();\n    var ranges = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = viewSelection.getRanges()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var viewRange = _step.value;\n        ranges.push(mapper.toModelRange(viewRange));\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    modelSelection.setTo(ranges, {\n      backward: viewSelection.isBackward\n    });\n\n    if (!modelSelection.isEqual(model.document.selection)) {\n      model.change(function (writer) {\n        writer.setSelection(modelSelection);\n      });\n    }\n  };\n} // View element to model element conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n// set, the converter will fire for every view element.\n// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\nfunction upcastElementToElement(config) {\n  config = cloneDeep(config);\n  var converter = prepareToElementConverter(config);\n  var elementName = getViewElementNameFromConfig(config);\n  var eventName = elementName ? 'element:' + elementName : 'element';\n  return function (dispatcher) {\n    dispatcher.on(eventName, converter, {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // View element to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be set to `true`.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastElementToAttribute(config) {\n  config = cloneDeep(config);\n  normalizeModelAttributeConfig(config);\n  var converter = prepareToAttributeConverter(config, false);\n  var elementName = getViewElementNameFromConfig(config);\n  var eventName = elementName ? 'element:' + elementName : 'element';\n  return function (dispatcher) {\n    dispatcher.on(eventName, converter, {\n      priority: config.converterPriority || 'low'\n    });\n  };\n} // View attribute to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be same as view attribute value.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastAttributeToAttribute(config) {\n  config = cloneDeep(config);\n  var viewKey = null;\n\n  if (typeof config.view == 'string' || config.view.key) {\n    viewKey = normalizeViewAttributeKeyValueConfig(config);\n  }\n\n  normalizeModelAttributeConfig(config, viewKey);\n  var converter = prepareToAttributeConverter(config, true);\n  return function (dispatcher) {\n    dispatcher.on('element', converter, {\n      priority: config.converterPriority || 'low'\n    });\n  };\n} // View element to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n// a model marker name.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastElementToMarker(config) {\n  config = cloneDeep(config);\n  normalizeToMarkerConfig(config);\n  return upcastElementToElement(config);\n} // Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion config.\n// @returns {String|null} View element name or `null` if name is not directly set.\n\n\nfunction getViewElementNameFromConfig(config) {\n  if (typeof config.view == 'string') {\n    return config.view;\n  }\n\n  if (_typeof(config.view) == 'object' && typeof config.view.name == 'string') {\n    return config.view.name;\n  }\n\n  return null;\n} // Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\n\n\nfunction prepareToElementConverter(config) {\n  var matcher = config.view ? new Matcher(config.view) : null;\n  return function (evt, data, conversionApi) {\n    var match = {}; // If `config.view` has not been passed do not try matching. In this case, the converter should fire for all elements.\n\n    if (matcher) {\n      // This will be usually just one pattern but we support matchers with many patterns too.\n      var matcherResult = matcher.match(data.viewItem); // If there is no match, this callback should not do anything.\n\n      if (!matcherResult) {\n        return;\n      }\n\n      match = matcherResult.match;\n    } // Force consuming element's name.\n\n\n    match.name = true; // Create model element basing on config.\n\n    var modelElement = getModelElement(config.model, data.viewItem, conversionApi.writer); // Do not convert if element building function returned falsy value.\n\n    if (!modelElement) {\n      return;\n    } // When element was already consumed then skip it.\n\n\n    if (!conversionApi.consumable.test(data.viewItem, match)) {\n      return;\n    } // Find allowed parent for element that we are going to insert.\n    // If current parent does not allow to insert element but one of the ancestors does\n    // then split nodes to allowed parent.\n\n\n    var splitResult = conversionApi.splitToAllowedParent(modelElement, data.modelCursor); // When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\n    if (!splitResult) {\n      return;\n    } // Insert element on allowed position.\n\n\n    conversionApi.writer.insert(modelElement, splitResult.position); // Convert children and insert to element.\n\n    conversionApi.convertChildren(data.viewItem, conversionApi.writer.createPositionAt(modelElement, 0)); // Consume appropriate value from consumable values list.\n\n    conversionApi.consumable.consume(data.viewItem, match);\n    var parts = conversionApi.getSplitParts(modelElement); // Set conversion result range.\n\n    data.modelRange = new ModelRange(conversionApi.writer.createPositionBefore(modelElement), conversionApi.writer.createPositionAfter(parts[parts.length - 1])); // Now we need to check where the `modelCursor` should be.\n\n    if (splitResult.cursorParent) {\n      // If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n      //\n      // before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n      // after:  <allowed><notAllowed>foo</notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>\n      data.modelCursor = conversionApi.writer.createPositionAt(splitResult.cursorParent, 0);\n    } else {\n      // Otherwise just continue after inserted element.\n      data.modelCursor = data.modelRange.end;\n    }\n  };\n} // Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/model/writer~Writer} writer A writer instance to use to create the model element.\n\n\nfunction getModelElement(model, input, writer) {\n  if (model instanceof Function) {\n    return model(input, writer);\n  } else {\n    return writer.createElement(model);\n  }\n} // Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\n\n\nfunction normalizeViewAttributeKeyValueConfig(config) {\n  if (typeof config.view == 'string') {\n    config.view = {\n      key: config.view\n    };\n  }\n\n  var key = config.view.key;\n  var normalized;\n\n  if (key == 'class' || key == 'style') {\n    var keyName = key == 'class' ? 'classes' : 'styles';\n    normalized = _defineProperty({}, keyName, config.view.value);\n  } else {\n    var value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n    normalized = {\n      attributes: _defineProperty({}, key, value)\n    };\n  }\n\n  if (config.view.name) {\n    normalized.name = config.view.name;\n  }\n\n  config.view = normalized;\n  return key;\n} // Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\n\n\nfunction normalizeModelAttributeConfig(config) {\n  var viewAttributeKeyToCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var defaultModelValue = viewAttributeKeyToCopy === null ? true : function (viewElement) {\n    return viewElement.getAttribute(viewAttributeKeyToCopy);\n  };\n  var key = _typeof(config.model) != 'object' ? config.model : config.model.key;\n  var value = _typeof(config.model) != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n  config.model = {\n    key: key,\n    value: value\n  };\n} // Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n\n\nfunction prepareToAttributeConverter(config, shallow) {\n  var matcher = new Matcher(config.view);\n  return function (evt, data, conversionApi) {\n    var match = matcher.match(data.viewItem); // If there is no match, this callback should not do anything.\n\n    if (!match) {\n      return;\n    }\n\n    var modelKey = config.model.key;\n    var modelValue = typeof config.model.value == 'function' ? config.model.value(data.viewItem) : config.model.value; // Do not convert if attribute building function returned falsy value.\n\n    if (modelValue === null) {\n      return;\n    }\n\n    if (onlyViewNameIsDefined(config)) {\n      match.match.name = true;\n    } else {\n      // Do not test or consume `name` consumable.\n      delete match.match.name;\n    } // Try to consume appropriate values from consumable values list.\n\n\n    if (!conversionApi.consumable.test(data.viewItem, match.match)) {\n      return;\n    } // Since we are converting to attribute we need an range on which we will set the attribute.\n    // If the range is not created yet, we will create it.\n\n\n    if (!data.modelRange) {\n      // Convert children and set conversion result as a current data.\n      data = Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));\n    } // Set attribute on current `output`. `Schema` is checked inside this helper function.\n\n\n    var attributeWasSet = setAttributeOn(data.modelRange, {\n      key: modelKey,\n      value: modelValue\n    }, shallow, conversionApi);\n\n    if (attributeWasSet) {\n      conversionApi.consumable.consume(data.viewItem, match.match);\n    }\n  };\n} // Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion config.\n// @returns {Boolean}\n\n\nfunction onlyViewNameIsDefined(config) {\n  if (_typeof(config.view) == 'object' && !getViewElementNameFromConfig(config)) {\n    return false;\n  }\n\n  return !config.view.classes && !config.view.attributes && !config.view.styles;\n} // Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\n\n\nfunction setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {\n  var result = false; // Set attribute on each item in range according to Schema.\n\n  for (var _i = 0, _Array$from = Array.from(modelRange.getItems({\n    shallow: shallow\n  })); _i < _Array$from.length; _i++) {\n    var node = _Array$from[_i];\n\n    if (conversionApi.schema.checkAttribute(node, modelAttribute.key)) {\n      conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node);\n      result = true;\n    }\n  }\n\n  return result;\n} // Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `_upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\n\n\nfunction normalizeToMarkerConfig(config) {\n  var oldModel = config.model;\n\n  config.model = function (viewElement, modelWriter) {\n    var markerName = typeof oldModel == 'string' ? oldModel : oldModel(viewElement);\n    return modelWriter.createElement('$marker', {\n      'data-name': markerName\n    });\n  };\n}","import \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/editingcontroller\n */\nimport RootEditableElement from \"../view/rooteditableelement\";\nimport View from \"../view/view\";\nimport Mapper from \"../conversion/mapper\";\nimport DowncastDispatcher from \"../conversion/downcastdispatcher\";\nimport { clearAttributes, convertCollapsedSelection, convertRangeSelection, insertText, remove } from \"../conversion/downcasthelpers\";\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { convertSelectionChange } from \"../conversion/upcasthelpers\";\n/**\n * Controller for the editing pipeline. The editing pipeline controls {@link ~EditingController#model model} rendering,\n * including selection handling. It also creates the {@link ~EditingController#view view} which builds a\n * browser-independent virtualization over the DOM elements. The editing controller also attaches default converters.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar EditingController =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an editing controller instance.\n   *\n   * @param {module:engine/model/model~Model} model Editing model.\n   */\n  function EditingController(model) {\n    var _this = this;\n\n    _classCallCheck(this, EditingController);\n\n    /**\n     * Editor model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * Editing view controller.\n     *\n     * @readonly\n     * @member {module:engine/view/view~View}\n     */\n\n    this.view = new View();\n    /**\n     * Mapper which describes the model-view binding.\n     *\n     * @readonly\n     * @member {module:engine/conversion/mapper~Mapper}\n     */\n\n    this.mapper = new Mapper();\n    /**\n     * Downcast dispatcher that converts changes from the model to {@link #view the editing view}.\n     *\n     * @readonly\n     * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #downcastDispatcher\n     */\n\n    this.downcastDispatcher = new DowncastDispatcher({\n      mapper: this.mapper\n    });\n    var doc = this.model.document;\n    var selection = doc.selection;\n    var markers = this.model.markers; // When plugins listen on model changes (on selection change, post fixers, etc) and change the view as a result of\n    // model's change, they might trigger view rendering before the conversion is completed (e.g. before the selection\n    // is converted). We disable rendering for the length of the outermost model change() block to prevent that.\n    //\n    // See  https://github.com/ckeditor/ckeditor5-engine/issues/1528\n\n    this.listenTo(this.model, '_beforeChanges', function () {\n      _this.view._disableRendering(true);\n    }, {\n      priority: 'highest'\n    });\n    this.listenTo(this.model, '_afterChanges', function () {\n      _this.view._disableRendering(false);\n    }, {\n      priority: 'lowest'\n    }); // Whenever model document is changed, convert those changes to the view (using model.Document#differ).\n    // Do it on 'low' priority, so changes are converted after other listeners did their job.\n    // Also convert model selection.\n\n    this.listenTo(doc, 'change', function () {\n      _this.view.change(function (writer) {\n        _this.downcastDispatcher.convertChanges(doc.differ, writer);\n\n        _this.downcastDispatcher.convertSelection(selection, markers, writer);\n      });\n    }, {\n      priority: 'low'\n    }); // Convert selection from the view to the model when it changes in the view.\n\n    this.listenTo(this.view.document, 'selectionChange', convertSelectionChange(this.model, this.mapper)); // Attach default model converters.\n\n    this.downcastDispatcher.on('insert:$text', insertText(), {\n      priority: 'lowest'\n    });\n    this.downcastDispatcher.on('remove', remove(), {\n      priority: 'low'\n    }); // Attach default model selection converters.\n\n    this.downcastDispatcher.on('selection', clearAttributes(), {\n      priority: 'low'\n    });\n    this.downcastDispatcher.on('selection', convertRangeSelection(), {\n      priority: 'low'\n    });\n    this.downcastDispatcher.on('selection', convertCollapsedSelection(), {\n      priority: 'low'\n    }); // Binds {@link module:engine/view/document~Document#roots view roots collection} to\n    // {@link module:engine/model/document~Document#roots model roots collection} so creating\n    // model root automatically creates corresponding view root.\n\n    this.view.document.roots.bindTo(this.model.document.roots).using(function (root) {\n      // $graveyard is a special root that has no reflection in the view.\n      if (root.rootName == '$graveyard') {\n        return null;\n      }\n\n      var viewRoot = new RootEditableElement(root.name);\n      viewRoot.rootName = root.rootName;\n      viewRoot._document = _this.view.document;\n\n      _this.mapper.bindElements(root, viewRoot);\n\n      return viewRoot;\n    });\n  }\n  /**\n   * Removes all event listeners attached to the `EditingController`. Destroys all objects created\n   * by `EditingController` that need to be destroyed.\n   */\n\n\n  _createClass(EditingController, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.view.destroy();\n      this.stopListening();\n    }\n  }]);\n\n  return EditingController;\n}();\n\nexport { EditingController as default };\nmix(EditingController, ObservableMixin);","import _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.set\";\nimport \"core-js/modules/es6.function.name\";\nimport \"regenerator-runtime/runtime\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar PluginCollection =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the PluginCollection class.\n   * Allows loading and initializing plugins and their dependencies.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n   * when {@link module:core/plugincollection~PluginCollection#init} is used with plugin names (strings, instead of constructors).\n   * Usually, the editor will pass its built-in plugins to the collection so they can later be\n   * used in `config.plugins` or `config.removePlugins` by names.\n   */\n  function PluginCollection(editor) {\n    var availablePlugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, PluginCollection);\n\n    /**\n     * @protected\n     * @member {module:core/editor/editor~Editor} module:core/plugin~PluginCollection#_editor\n     */\n    this._editor = editor;\n    /**\n     * Map of plugin constructors which can be retrieved by their names.\n     *\n     * @protected\n     * @member {Map.<String|Function,Function>} module:core/plugin~PluginCollection#_availablePlugins\n     */\n\n    this._availablePlugins = new Map();\n    /**\n     * @protected\n     * @member {Map} module:core/plugin~PluginCollection#_plugins\n     */\n\n    this._plugins = new Map();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = availablePlugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var PluginConstructor = _step.value;\n\n        this._availablePlugins.set(PluginConstructor, PluginConstructor);\n\n        if (PluginConstructor.pluginName) {\n          this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n  /**\n   * Iterable interface.\n   *\n   * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n   *\n   * @returns {Iterable.<Array>}\n   */\n\n\n  _createClass(PluginCollection, [{\n    key: Symbol.iterator,\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function value() {\n      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, entry;\n\n      return regeneratorRuntime.wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 3;\n              _iterator2 = this._plugins[Symbol.iterator]();\n\n            case 5:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 13;\n                break;\n              }\n\n              entry = _step2.value;\n\n              if (!(typeof entry[0] == 'function')) {\n                _context.next = 10;\n                break;\n              }\n\n              _context.next = 10;\n              return entry;\n\n            case 10:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 5;\n              break;\n\n            case 13:\n              _context.next = 19;\n              break;\n\n            case 15:\n              _context.prev = 15;\n              _context.t0 = _context[\"catch\"](3);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t0;\n\n            case 19:\n              _context.prev = 19;\n              _context.prev = 20;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n\n            case 22:\n              _context.prev = 22;\n\n              if (!_didIteratorError2) {\n                _context.next = 25;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 25:\n              return _context.finish(22);\n\n            case 26:\n              return _context.finish(19);\n\n            case 27:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, value, this, [[3, 15, 19, 27], [20,, 22, 26]]);\n    })\n    /**\n     * Gets the plugin instance by its constructor or name.\n     *\n     *\t\t// Check if 'Clipboard' plugin was loaded.\n     *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n     *\t\t\t// Get clipboard plugin instance\n     *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n     *\n     *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n     *\t\t\t\t// Do something on clipboard input.\n     *\t\t\t} );\n     *\t\t}\n     *\n     * **Note**: This method will throw error if plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n     * to check if plugin is available.\n     *\n     * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n     * @returns {module:core/plugin~PluginInterface}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var plugin = this._plugins.get(key);\n\n      if (!plugin) {\n        /**\n         * The plugin is not loaded and could not be obtained.\n         *\n         * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n         * the plugin collection.\n         * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n         * property.\n         *\n         * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n         * to check if plugin was loaded.\n         *\n         * @error plugincollection-plugin-not-loaded\n         * @param {String} plugin The name of the plugin which is not loaded.\n         */\n        var errorMsg = 'plugincollection-plugin-not-loaded: The requested plugin is not loaded.';\n        var pluginName = key;\n\n        if (typeof key == 'function') {\n          pluginName = key.pluginName || key.name;\n        }\n\n        throw new CKEditorError(errorMsg, {\n          plugin: pluginName\n        });\n      }\n\n      return plugin;\n    }\n    /**\n     * Checks if plugin is loaded.\n     *\n     *\t\t// Check if 'Clipboard' plugin was loaded.\n     *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n     *\t\t\t// Now use clipboard plugin instance:\n     *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n     *\n     *\t\t\t// ...\n     *\t\t}\n     *\n     * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this._plugins.has(key);\n    }\n    /**\n     * Initializes a set of plugins and adds them to the collection.\n     *\n     * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n     * or {@link module:core/plugin~PluginInterface.pluginName plugin names}. The second option (names) works only if\n     * `availablePlugins` were passed to the {@link #constructor}.\n     * @param {Array.<String|Function>} [removePlugins] Names of plugins or plugin constructors\n     * that should not be loaded (despite being specified in the `plugins` array).\n     * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n     * and available in the collection.\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(plugins) {\n      var removePlugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var that = this;\n      var editor = this._editor;\n      var loading = new Set();\n      var loaded = [];\n      var pluginConstructors = mapToAvailableConstructors(plugins);\n      var removePluginConstructors = mapToAvailableConstructors(removePlugins);\n      var missingPlugins = getMissingPluginNames(plugins);\n\n      if (missingPlugins) {\n        /**\n         * Some plugins are not available and could not be loaded.\n         *\n         * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n         * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n         * property.\n         *\n         * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**, it means\n         * that you try to enable a plugin which was not included in that build. This may be due to a typo\n         * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n         * read more about {@glink builds/guides/development/custom-builds custom builds}.\n         *\n         * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n         * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n         * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n         * provide each plugin through reference (as a constructor function). Check out the examples in\n         * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source \"Building from source\"}.\n         *\n         * @error plugincollection-plugin-not-found\n         * @param {Array.<String>} plugins The name of the plugins which could not be loaded.\n         */\n        var errorMsg = 'plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.'; // Log the error so it's more visible on the console. Hopefully, for better DX.\n\n        log.error(errorMsg, {\n          plugins: missingPlugins\n        });\n        return Promise.reject(new CKEditorError(errorMsg, {\n          plugins: missingPlugins\n        }));\n      }\n\n      return Promise.all(pluginConstructors.map(loadPlugin)).then(function () {\n        return initPlugins(loaded, 'init');\n      }).then(function () {\n        return initPlugins(loaded, 'afterInit');\n      }).then(function () {\n        return loaded;\n      });\n\n      function loadPlugin(PluginConstructor) {\n        if (removePluginConstructors.includes(PluginConstructor)) {\n          return;\n        } // The plugin is already loaded or being loaded - do nothing.\n\n\n        if (that._plugins.has(PluginConstructor) || loading.has(PluginConstructor)) {\n          return;\n        }\n\n        return instantiatePlugin(PluginConstructor).catch(function (err) {\n          /**\n           * It was not possible to load the plugin.\n           *\n           * This is a generic error logged to the console when a JavaSript error is thrown during the initialization\n           * of one of the plugins.\n           *\n           * If you correctly handled the promise returned by the editor's `create()` method (like shown below)\n           * you will find the original error logged to the console, too:\n           *\n           *\t\tClassicEditor.create( document.getElementById( 'editor' ) )\n           *\t\t\t.then( editor => {\n           *\t\t\t\t// ...\n           * \t\t\t} )\n           *\t\t\t.catch( error => {\n           *\t\t\t\tconsole.error( error );\n           *\t\t\t} );\n           *\n           * @error plugincollection-load\n           * @param {String} plugin The name of the plugin that could not be loaded.\n           */\n          log.error('plugincollection-load: It was not possible to load the plugin.', {\n            plugin: PluginConstructor\n          });\n          throw err;\n        });\n      }\n\n      function initPlugins(loadedPlugins, method) {\n        return loadedPlugins.reduce(function (promise, plugin) {\n          if (!plugin[method]) {\n            return promise;\n          }\n\n          return promise.then(plugin[method].bind(plugin));\n        }, Promise.resolve());\n      }\n\n      function instantiatePlugin(PluginConstructor) {\n        return new Promise(function (resolve) {\n          loading.add(PluginConstructor);\n\n          if (PluginConstructor.requires) {\n            PluginConstructor.requires.forEach(function (RequiredPluginConstructorOrName) {\n              var RequiredPluginConstructor = getPluginConstructor(RequiredPluginConstructorOrName);\n\n              if (removePlugins.includes(RequiredPluginConstructor)) {\n                /**\n                 * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n                 *\n                 * @error plugincollection-required\n                 * @param {Function} plugin The required plugin.\n                 * @param {Function} requiredBy The parent plugin.\n                 */\n                throw new CKEditorError('plugincollection-required: Cannot load a plugin because one of its dependencies is listed in' + 'the `removePlugins` option.', {\n                  plugin: RequiredPluginConstructor,\n                  requiredBy: PluginConstructor\n                });\n              }\n\n              loadPlugin(RequiredPluginConstructor);\n            });\n          }\n\n          var plugin = new PluginConstructor(editor);\n\n          that._add(PluginConstructor, plugin);\n\n          loaded.push(plugin);\n          resolve();\n        });\n      }\n\n      function getPluginConstructor(PluginConstructorOrName) {\n        if (typeof PluginConstructorOrName == 'function') {\n          return PluginConstructorOrName;\n        }\n\n        return that._availablePlugins.get(PluginConstructorOrName);\n      }\n\n      function getMissingPluginNames(plugins) {\n        var missingPlugins = [];\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = plugins[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var pluginNameOrConstructor = _step3.value;\n\n            if (!getPluginConstructor(pluginNameOrConstructor)) {\n              missingPlugins.push(pluginNameOrConstructor);\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return missingPlugins.length ? missingPlugins : null;\n      }\n\n      function mapToAvailableConstructors(plugins) {\n        return plugins.map(function (pluginNameOrConstructor) {\n          return getPluginConstructor(pluginNameOrConstructor);\n        }).filter(function (PluginConstructor) {\n          return !!PluginConstructor;\n        });\n      }\n    }\n    /**\n     * Destroys all loaded plugins.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var promises = Array.from(this).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            pluginInstance = _ref2[1];\n\n        return pluginInstance;\n      }).filter(function (pluginInstance) {\n        return typeof pluginInstance.destroy == 'function';\n      }).map(function (pluginInstance) {\n        return pluginInstance.destroy();\n      });\n      return Promise.all(promises);\n    }\n    /**\n     * Adds the plugin to the collection. Exposed mainly for testing purposes.\n     *\n     * @protected\n     * @param {Function} PluginConstructor The plugin constructor.\n     * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n     */\n\n  }, {\n    key: \"_add\",\n    value: function _add(PluginConstructor, plugin) {\n      this._plugins.set(PluginConstructor, plugin);\n\n      var pluginName = PluginConstructor.pluginName;\n\n      if (!pluginName) {\n        return;\n      }\n\n      if (this._plugins.has(pluginName)) {\n        /**\n         * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n         * This will lead to runtime conflicts between these plugins.\n         *\n         * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n         * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n         * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n         *\n         * Check your import paths and the list of plugins passed to\n         * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n         * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n         *\n         * The second option is that your `node_modules/` directory contains duplicated versions of the same\n         * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n         * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n         * of packages, their dependencies may need to be installed in more than one version which may lead to this\n         * warning.\n         *\n         * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n         * dependencies of this plugin are being duplicated.\n         * They are already built into that editor build and now get added for the second time as dependencies\n         * of the plugin you are installing.\n         *\n         * Read more about {@glink builds/guides/integration/installing-plugins installing plugins}.\n         *\n         * @error plugincollection-plugin-name-conflict\n         * @param {String} pluginName The duplicated plugin name.\n         * @param {Function} plugin1 The first plugin constructor.\n         * @param {Function} plugin2 The second plugin constructor.\n         */\n        log.warn('plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.', {\n          pluginName: pluginName,\n          plugin1: this._plugins.get(pluginName).constructor,\n          plugin2: PluginConstructor\n        });\n      } else {\n        this._plugins.set(pluginName, plugin);\n      }\n    }\n  }]);\n\n  return PluginCollection;\n}();\n\nexport { PluginCollection as default };\nmix(PluginCollection, EmitterMixin);","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"regenerator-runtime/runtime\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/commandcollection\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Collection of commands. Its instance is available in {@link module:core/editor/editor~Editor#commands `editor.commands`}.\n */\n\nvar CommandCollection =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates collection instance.\n   */\n  function CommandCollection() {\n    _classCallCheck(this, CommandCollection);\n\n    /**\n     * Command map.\n     *\n     * @private\n     * @member {Map}\n     */\n    this._commands = new Map();\n  }\n  /**\n   * Registers a new command.\n   *\n   * @param {String} commandName The name of the command.\n   * @param {module:core/command~Command} command\n   */\n\n\n  _createClass(CommandCollection, [{\n    key: \"add\",\n    value: function add(commandName, command) {\n      this._commands.set(commandName, command);\n    }\n    /**\n     * Retrieves a command from the collection.\n     *\n     * @param {String} commandName The name of the command.\n     * @returns {module:core/command~Command}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(commandName) {\n      return this._commands.get(commandName);\n    }\n    /**\n     * Executes a command.\n     *\n     * @param {String} commandName The name of the command.\n     * @param {*} [...commandParams] Command parameters.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(commandName) {\n      var command = this.get(commandName);\n\n      if (!command) {\n        /**\n         * Command does not exist.\n         *\n         * @error commandcollection-command-not-found\n         * @param {String} commandName Name of the command.\n         */\n        throw new CKEditorError('commandcollection-command-not-found: Command does not exist.', {\n          commandName: commandName\n        });\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      command.execute.apply(command, args);\n    }\n    /**\n     * Returns iterator of command names.\n     *\n     * @returns {Iterable.<String>}\n     */\n\n  }, {\n    key: \"names\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function names() {\n      return regeneratorRuntime.wrap(function names$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this._commands.keys(), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, names, this);\n    })\n    /**\n     * Returns iterator of command instances.\n     *\n     * @returns {Iterable.<module:core/command~Command>}\n     */\n\n  }, {\n    key: \"commands\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function commands() {\n      return regeneratorRuntime.wrap(function commands$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.delegateYield(this._commands.values(), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, commands, this);\n    })\n    /**\n     * Iterable interface.\n     *\n     * Returns `[ commandName, commandInstance ]` pairs.\n     *\n     * @returns {Iterable.<Array>}\n     */\n\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this._commands[Symbol.iterator]();\n    }\n    /**\n     * Destroys all collection commands.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.commands()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var command = _step.value;\n          command.destroy();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return CommandCollection;\n}();\n\nexport { CommandCollection as default };","import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals window */\n\n/**\n * @module utils/translation-service\n */\n\n/* istanbul ignore else */\nif (!window.CKEDITOR_TRANSLATIONS) {\n  window.CKEDITOR_TRANSLATIONS = {};\n}\n/**\n * Adds translations to existing ones.\n * These translations will later be available for the {@link module:utils/translation-service~translate `translate()`} function.\n *\n *\t\tadd( 'pl', {\n *\t\t\t'OK': 'OK',\n *\t\t\t'Cancel [context: reject]': 'Anuluj'\n *\t\t} );\n *\n * If you cannot import this function from this module (e.g. because you use a CKEditor 5 build), then you can\n * still add translations by extending the global `window.CKEDITOR_TRANSLATIONS` object by using a function like\n * the one below:\n *\n *\t\tfunction addTranslations( language, translations ) {\n *\t\t\tif ( !window.CKEDITOR_TRANSLATIONS ) {\n *\t\t\t\twindow.CKEDITOR_TRANSLATIONS = {};\n *\t\t\t}\n *\n *\t\t\tconst dictionary = window.CKEDITOR_TRANSLATIONS[ language ] || ( window.CKEDITOR_TRANSLATIONS[ language ] = {} );\n *\n *\t\t\t// Extend the dictionary for the given language.\n *\t\t\tObject.assign( dictionary, translations );\n *\t\t}\n *\n * @param {String} language Target language.\n * @param {Object.<String, String>} translations Translations which will be added to the dictionary.\n */\n\n\nexport function add(language, translations) {\n  var dictionary = window.CKEDITOR_TRANSLATIONS[language] || (window.CKEDITOR_TRANSLATIONS[language] = {});\n  Object.assign(dictionary, translations);\n}\n/**\n * Translates string if the translation of the string was previously added to the dictionary.\n * See {@link module:utils/translation-service Translation Service}.\n * This happens in a multi-language mode were translation modules are created by the bundler.\n *\n * When no translation is defined in the dictionary or the dictionary doesn't exist this function returns\n * the original string without the `'[context: ]'` (happens in development and single-language modes).\n *\n * In a single-language mode (when values passed to `t()` were replaced with target language strings) the dictionary\n * is left empty, so this function will return the original strings always.\n *\n *\t\ttranslate( 'pl', 'Cancel [context: reject]' );\n *\n * @param {String} language Target language.\n * @param {String} translationKey String that will be translated.\n * @returns {String} Translated sentence.\n */\n\nexport function translate(language, translationKey) {\n  var numberOfLanguages = getNumberOfLanguages();\n\n  if (numberOfLanguages === 1) {\n    // Override the language to the only supported one.\n    // This can't be done in the `Locale` class, because the translations comes after the `Locale` class initialization.\n    language = Object.keys(window.CKEDITOR_TRANSLATIONS)[0];\n  }\n\n  if (numberOfLanguages === 0 || !hasTranslation(language, translationKey)) {\n    return translationKey.replace(/ \\[context: [^\\]]+\\]$/, '');\n  }\n\n  var dictionary = window.CKEDITOR_TRANSLATIONS[language]; // In case of missing translations we still need to cut off the `[context: ]` parts.\n\n  return dictionary[translationKey].replace(/ \\[context: [^\\]]+\\]$/, '');\n}\n/**\n * Clears dictionaries for test purposes.\n *\n * @protected\n */\n\nexport function _clear() {\n  window.CKEDITOR_TRANSLATIONS = {};\n} // Checks whether the dictionary exists and translation in that dictionary exists.\n\nfunction hasTranslation(language, translationKey) {\n  return language in window.CKEDITOR_TRANSLATIONS && translationKey in window.CKEDITOR_TRANSLATIONS[language];\n}\n\nfunction getNumberOfLanguages() {\n  return Object.keys(window.CKEDITOR_TRANSLATIONS).length;\n}","import \"core-js/modules/es6.set\";\nimport \"core-js/modules/es6.string.starts-with\";\nimport \"core-js/modules/es6.string.ends-with\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"regenerator-runtime/runtime\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\nvar _marked =\n/*#__PURE__*/\nregeneratorRuntime.mark(combineWalkers),\n    _marked2 =\n/*#__PURE__*/\nregeneratorRuntime.mark(convertToMinimalFlatRanges);\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/schema\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport Range from \"./range\";\nimport Position from \"./position\";\nimport Element from \"./element\";\nimport Text from \"./text\";\nimport TreeWalker from \"./treewalker\";\n/**\n * The model's schema. It defines allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by features and based on them the editing framework and features\n * make decisions how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * {@glink framework/guides/architecture/editing-engine#schema \"Schema\"} section of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the \"Editing engine architecture\"}.\n * * {@glink framework/guides/deep-dive/schema \"Schema\" deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Schema =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates schema instance.\n   */\n  function Schema() {\n    var _this = this;\n\n    _classCallCheck(this, Schema);\n\n    this._sourceDefinitions = {};\n    /**\n     * A dictionary containing attribute properties.\n     *\n     * @private\n     * @member {Object.<String,String>}\n     */\n\n    this._attributeProperties = {};\n    this.decorate('checkChild');\n    this.decorate('checkAttribute');\n    this.on('checkAttribute', function (evt, args) {\n      args[0] = new SchemaContext(args[0]);\n    }, {\n      priority: 'highest'\n    });\n    this.on('checkChild', function (evt, args) {\n      args[0] = new SchemaContext(args[0]);\n      args[1] = _this.getDefinition(args[1]);\n    }, {\n      priority: 'highest'\n    });\n  }\n  /**\n   * Registers schema item. Can only be called once for every item name.\n   *\n   *\t\tschema.register( 'paragraph', {\n   *\t\t\tinheritAllFrom: '$block'\n   *\t\t} );\n   *\n   * @param {String} itemName\n   * @param {module:engine/model/schema~SchemaItemDefinition} definition\n   */\n\n\n  _createClass(Schema, [{\n    key: \"register\",\n    value: function register(itemName, definition) {\n      if (this._sourceDefinitions[itemName]) {\n        /**\n         * A single item cannot be registered twice in the schema.\n         *\n         * This situation may happen when:\n         *\n         * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n         * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n         * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n         * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n         * and usually means one or more of the following issues:\n         *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n         *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n         *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n         *\n         * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n         *\n         * @param itemName The name of the model element that is being registered twice.\n         * @error schema-cannot-register-item-twice\n         */\n        throw new CKEditorError('schema-cannot-register-item-twice: A single item cannot be registered twice in the schema.', {\n          itemName: itemName\n        });\n      }\n\n      this._sourceDefinitions[itemName] = [Object.assign({}, definition)];\n\n      this._clearCache();\n    }\n    /**\n     * Extends a {@link #register registered} item's definition.\n     *\n     * Extending properties such as `allowIn` will add more items to the existing properties,\n     * while redefining properties such as `isBlock` will override the previously defined ones.\n     *\n     *\t\tschema.register( 'foo', {\n     *\t\t\tallowIn: '$root',\n     *\t\t\tisBlock: true;\n     *\t\t} );\n     *\t\tschema.extend( 'foo', {\n     *\t\t\tallowIn: 'blockQuote',\n     *\t\t\tisBlock: false\n     *\t\t} );\n     *\n     *\t\tschema.getDefinition( 'foo' );\n     *\t\t//\t{\n     *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n     *\t\t// \t\tisBlock: false\n     *\t\t//\t}\n     *\n     * @param {String} itemName\n     * @param {module:engine/model/schema~SchemaItemDefinition} definition\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend(itemName, definition) {\n      if (!this._sourceDefinitions[itemName]) {\n        /**\n         * Cannot extend an item which was not registered yet.\n         *\n         * This error happens when a plugin tries to extend the schema definition of an item which was not\n         * {@link #register registered} yet.\n         *\n         * @param itemName The name of the model element which is being extended.\n         * @error schema-cannot-register-item-twice\n         */\n        throw new CKEditorError('schema-cannot-extend-missing-item: Cannot extend an item which was not registered yet.', {\n          itemName: itemName\n        });\n      }\n\n      this._sourceDefinitions[itemName].push(Object.assign({}, definition));\n\n      this._clearCache();\n    }\n    /**\n     * Returns all registered items.\n     *\n     * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n     */\n\n  }, {\n    key: \"getDefinitions\",\n    value: function getDefinitions() {\n      if (!this._compiledDefinitions) {\n        this._compile();\n      }\n\n      return this._compiledDefinitions;\n    }\n    /**\n     * Returns a definition of the given item or `undefined` if item is not registered.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n     */\n\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(item) {\n      var itemName;\n\n      if (typeof item == 'string') {\n        itemName = item;\n      } else if (item.is && (item.is('text') || item.is('textProxy'))) {\n        itemName = '$text';\n      } // Element or module:engine/model/schema~SchemaContextItem.\n      else {\n          itemName = item.name;\n        }\n\n      return this.getDefinitions()[itemName];\n    }\n    /**\n     * Returns `true` if the given item is registered in the schema.\n     *\n     *\t\tschema.isRegistered( 'paragraph' ); // -> true\n     *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n     *\t\tschema.isRegistered( 'foo' ); // -> false\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     */\n\n  }, {\n    key: \"isRegistered\",\n    value: function isRegistered(item) {\n      return !!this.getDefinition(item);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * a block by {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n     *\n     *\t\tschema.isBlock( 'paragraph' ); // -> true\n     *\t\tschema.isBlock( '$root' ); // -> false\n     *\n     *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n     *\t\tschema.isBlock( paragraphElement ); // -> true\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     */\n\n  }, {\n    key: \"isBlock\",\n    value: function isBlock(item) {\n      var def = this.getDefinition(item);\n      return !!(def && def.isBlock);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * a limit element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isLimit` or `isObject` property\n     * (all objects are also limits).\n     *\n     *\t\tschema.isLimit( 'paragraph' ); // -> false\n     *\t\tschema.isLimit( '$root' ); // -> true\n     *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n     *\t\tschema.isLimit( 'image' ); // -> true\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     */\n\n  }, {\n    key: \"isLimit\",\n    value: function isLimit(item) {\n      var def = this.getDefinition(item);\n\n      if (!def) {\n        return false;\n      }\n\n      return !!(def.isLimit || def.isObject);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * an object element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isObject` property.\n     *\n     *\t\tschema.isObject( 'paragraph' ); // -> false\n     *\t\tschema.isObject( 'image' ); // -> true\n     *\n     *\t\tconst imageElement = writer.createElement( 'image' );\n     *\t\tschema.isObject( imageElement ); // -> true\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     */\n\n  }, {\n    key: \"isObject\",\n    value: function isObject(item) {\n      var def = this.getDefinition(item);\n      return !!(def && def.isObject);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * an inline element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n     *\n     *\t\tschema.isInline( 'paragraph' ); // -> false\n     *\t\tschema.isInline( 'softBreak' ); // -> true\n     *\n     *\t\tconst text = writer.createText('foo' );\n     *\t\tschema.isInline( text ); // -> true\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     */\n\n  }, {\n    key: \"isInline\",\n    value: function isInline(item) {\n      var def = this.getDefinition(item);\n      return !!(def && def.isInline);\n    }\n    /**\n     * Checks whether the given node (`child`) can be a child of the given context.\n     *\n     *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n     *\n     *\t\tschema.register( 'paragraph', {\n     *\t\t\tallowIn: '$root'\n     *\t\t} );\n     *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n     *\n     * Note: When verifying whether the given node can be a child of the given context, the\n     * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n     * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n     * It happens if one of the context's elements does not allow its child.\n     *\n     * @fires checkChild\n     * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n     * @param {module:engine/model/node~Node|String} def The child to check.\n     */\n\n  }, {\n    key: \"checkChild\",\n    value: function checkChild(context, def) {\n      // Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n      if (!def) {\n        return false;\n      }\n\n      return this._checkContextMatch(def, context);\n    }\n    /**\n     * Checks whether the given attribute can be applied in the given context (on the last\n     * item of the context).\n     *\n     *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n     *\n     *\t\tschema.extend( '$text', {\n     *\t\t\tallowAttributes: 'bold'\n     *\t\t} );\n     *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n     *\n     * @fires checkAttribute\n     * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n     * @param {String} attributeName\n     */\n\n  }, {\n    key: \"checkAttribute\",\n    value: function checkAttribute(context, attributeName) {\n      var def = this.getDefinition(context.last);\n\n      if (!def) {\n        return false;\n      }\n\n      return def.allowAttributes.includes(attributeName);\n    }\n    /**\n     * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n     *\n     * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n     *\n     * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n     * will be valid.\n     *\n     * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n     * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n     *\n     * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n     * element to which the `elementToMerge` will be merged.\n     * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"checkMerge\",\n    value: function checkMerge(positionOrBaseElement) {\n      var elementToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (positionOrBaseElement instanceof Position) {\n        var nodeBefore = positionOrBaseElement.nodeBefore;\n        var nodeAfter = positionOrBaseElement.nodeAfter;\n\n        if (!(nodeBefore instanceof Element)) {\n          /**\n           * The node before the merge position must be an element.\n           *\n           * @error schema-check-merge-no-element-before\n           */\n          throw new CKEditorError('schema-check-merge-no-element-before: The node before the merge position must be an element.');\n        }\n\n        if (!(nodeAfter instanceof Element)) {\n          /**\n           * The node after the merge position must be an element.\n           *\n           * @error schema-check-merge-no-element-after\n           */\n          throw new CKEditorError('schema-check-merge-no-element-after: The node after the merge position must be an element.');\n        }\n\n        return this.checkMerge(nodeBefore, nodeAfter);\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = elementToMerge.getChildren()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n\n          if (!this.checkChild(positionOrBaseElement, child)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Allows registering a callback to the {@link #checkChild} method calls.\n     *\n     * Callbacks allow you to implement rules which are not otherwise possible to achieve\n     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n     * For example, by using this method you can disallow elements in specific contexts.\n     *\n     * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n     * you can use that event instead.\n     *\n     * Example:\n     *\n     *\t\t// Disallow heading1 directly inside a blockQuote.\n     *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n     *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n     *\t\t\t\treturn false;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Which translates to:\n     *\n     *\t\tschema.on( 'checkChild', ( evt, args ) => {\n     *\t\t\tconst context = args[ 0 ];\n     *\t\t\tconst childDefinition = args[ 1 ];\n     *\n     *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n     *\t\t\t\t// Prevent next listeners from being called.\n     *\t\t\t\tevt.stop();\n     *\t\t\t\t// Set the checkChild()'s return value.\n     *\t\t\t\tevt.return = false;\n     *\t\t\t}\n     *\t\t}, { priority: 'high' } );\n     *\n     * @param {Function} callback The callback to be called. It is called with two parameters:\n     * {@link module:engine/model/schema~SchemaContext} (context) instance and\n     * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n     * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n     * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n     */\n\n  }, {\n    key: \"addChildCheck\",\n    value: function addChildCheck(callback) {\n      this.on('checkChild', function (evt, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            ctx = _ref2[0],\n            childDef = _ref2[1];\n\n        // checkChild() was called with a non-registered child.\n        // In 99% cases such check should return false, so not to overcomplicate all callbacks\n        // don't even execute them.\n        if (!childDef) {\n          return;\n        }\n\n        var retValue = callback(ctx, childDef);\n\n        if (typeof retValue == 'boolean') {\n          evt.stop();\n          evt.return = retValue;\n        }\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * Allows registering a callback to the {@link #checkAttribute} method calls.\n     *\n     * Callbacks allow you to implement rules which are not otherwise possible to achieve\n     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n     * For example, by using this method you can disallow attribute if node to which it is applied\n     * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n     *\n     * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n     * you can use that event instead.\n     *\n     * Example:\n     *\n     *\t\t// Disallow bold on $text inside heading1.\n     *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n     *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n     *\t\t\t\treturn false;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Which translates to:\n     *\n     *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n     *\t\t\tconst context = args[ 0 ];\n     *\t\t\tconst attributeName = args[ 1 ];\n     *\n     *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n     *\t\t\t\t// Prevent next listeners from being called.\n     *\t\t\t\tevt.stop();\n     *\t\t\t\t// Set the checkAttribute()'s return value.\n     *\t\t\t\tevt.return = false;\n     *\t\t\t}\n     *\t\t}, { priority: 'high' } );\n     *\n     * @param {Function} callback The callback to be called. It is called with two parameters:\n     * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n     * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n     * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n     */\n\n  }, {\n    key: \"addAttributeCheck\",\n    value: function addAttributeCheck(callback) {\n      this.on('checkAttribute', function (evt, _ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            ctx = _ref4[0],\n            attributeName = _ref4[1];\n\n        var retValue = callback(ctx, attributeName);\n\n        if (typeof retValue == 'boolean') {\n          evt.stop();\n          evt.return = retValue;\n        }\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * This method allows assigning additional metadata to the model attributes. For example,\n     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n     * used to mark formatting attributes (like `bold` or `italic`).\n     *\n     *\t\t// Mark bold as a formatting attribute.\n     *\t\tschema.setAttributeProperties( 'bold', {\n     *\t\t\tisFormatting: true\n     *\t\t} );\n     *\n     *\t\t// Override code not to be considered a formatting markup.\n     *\t\tschema.setAttributeProperties( 'code', {\n     *\t\t\tisFormatting: false\n     *\t\t} );\n     *\n     * Properties are not limited to members defined in the\n     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n     *\n     *\t\tschema.setAttributeProperties( 'blockQuote', {\n     *\t\t\tcustomProperty: 'value'\n     *\t\t} );\n     *\n     * Subsequent calls with the same attribute will extend its custom properties:\n     *\n     *\t\tschema.setAttributeProperties( 'blockQuote', {\n     *\t\t\tone: 1\n     *\t\t} );\n     *\n     *\t\tschema.setAttributeProperties( 'blockQuote', {\n     *\t\t\ttwo: 2\n     *\t\t} );\n     *\n     *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n     *\t\t// Logs: { one: 1, two: 2 }\n     *\n     * @param {String} attributeName A name of the attribute to receive the properties.\n     * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n     */\n\n  }, {\n    key: \"setAttributeProperties\",\n    value: function setAttributeProperties(attributeName, properties) {\n      this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);\n    }\n    /**\n     * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n     *\n     * @param {String} attributeName A name of the attribute.\n     * @returns {module:engine/model/schema~AttributeProperties}\n     */\n\n  }, {\n    key: \"getAttributeProperties\",\n    value: function getAttributeProperties(attributeName) {\n      return this._attributeProperties[attributeName] || {};\n    }\n    /**\n     * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n     * selection/range/position or the root otherwise.\n     *\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n     * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n     * The selection/range/position to check.\n     * @returns {module:engine/model/element~Element} The lowest limit element containing\n     * the entire `selectionOrRangeOrPosition`.\n     */\n\n  }, {\n    key: \"getLimitElement\",\n    value: function getLimitElement(selectionOrRangeOrPosition) {\n      var element;\n\n      if (selectionOrRangeOrPosition instanceof Position) {\n        element = selectionOrRangeOrPosition.parent;\n      } else {\n        var ranges = selectionOrRangeOrPosition instanceof Range ? [selectionOrRangeOrPosition] : Array.from(selectionOrRangeOrPosition.getRanges()); // Find the common ancestor for all selection's ranges.\n\n        element = ranges.reduce(function (element, range) {\n          var rangeCommonAncestor = range.getCommonAncestor();\n\n          if (!element) {\n            return rangeCommonAncestor;\n          }\n\n          return element.getCommonAncestor(rangeCommonAncestor, {\n            includeSelf: true\n          });\n        }, null);\n      }\n\n      while (!this.isLimit(element)) {\n        if (element.parent) {\n          element = element.parent;\n        } else {\n          break;\n        }\n      }\n\n      return element;\n    }\n    /**\n     * Checks whether the attribute is allowed in selection:\n     *\n     * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n     * * if the selection is collapsed, then checks if on the selection position there's a text with the\n     * specified attribute allowed.\n     *\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * Selection which will be checked.\n     * @param {String} attribute The name of the attribute to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"checkAttributeInSelection\",\n    value: function checkAttributeInSelection(selection, attribute) {\n      if (selection.isCollapsed) {\n        var firstPosition = selection.getFirstPosition();\n        var context = [].concat(_toConsumableArray(firstPosition.getAncestors()), [new Text('', selection.getAttributes())]); // Check whether schema allows for a text with the attribute in the selection.\n\n        return this.checkAttribute(context, attribute);\n      } else {\n        var ranges = selection.getRanges(); // For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var range = _step2.value;\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n              for (var _iterator3 = range[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var value = _step3.value;\n\n                if (this.checkAttribute(value.item, attribute)) {\n                  // If we found a node that is allowed to have the attribute, return true.\n                  return true;\n                }\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                  _iterator3.return();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } // If we haven't found such node, return false.\n\n\n      return false;\n    }\n    /**\n     * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n     *\n     * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n     * @param {String} attribute The name of the attribute to check.\n     * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n     */\n\n  }, {\n    key: \"getValidRanges\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function getValidRanges(ranges, attribute) {\n      var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, range;\n\n      return regeneratorRuntime.wrap(function getValidRanges$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              ranges = convertToMinimalFlatRanges(ranges);\n              _iteratorNormalCompletion4 = true;\n              _didIteratorError4 = false;\n              _iteratorError4 = undefined;\n              _context.prev = 4;\n              _iterator4 = ranges[Symbol.iterator]();\n\n            case 6:\n              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n                _context.next = 12;\n                break;\n              }\n\n              range = _step4.value;\n              return _context.delegateYield(this._getValidRangesForRange(range, attribute), \"t0\", 9);\n\n            case 9:\n              _iteratorNormalCompletion4 = true;\n              _context.next = 6;\n              break;\n\n            case 12:\n              _context.next = 18;\n              break;\n\n            case 14:\n              _context.prev = 14;\n              _context.t1 = _context[\"catch\"](4);\n              _didIteratorError4 = true;\n              _iteratorError4 = _context.t1;\n\n            case 18:\n              _context.prev = 18;\n              _context.prev = 19;\n\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n\n            case 21:\n              _context.prev = 21;\n\n              if (!_didIteratorError4) {\n                _context.next = 24;\n                break;\n              }\n\n              throw _iteratorError4;\n\n            case 24:\n              return _context.finish(21);\n\n            case 25:\n              return _context.finish(18);\n\n            case 26:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, getValidRanges, this, [[4, 14, 18, 26], [19,, 21, 25]]);\n    })\n    /**\n     * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n     * nearest to that `position` and is a correct range for selection.\n     *\n     * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n     * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n     * the {@link module:engine/model/schema~Schema schema}.\n     *\n     * Direction of searching for the nearest correct selection range can be specified as:\n     *\n     * * `both` - searching will be performed in both ways,\n     * * `forward` - searching will be performed only forward,\n     * * `backward` - searching will be performed only backward.\n     *\n     * When valid selection range cannot be found, `null` is returned.\n     *\n     * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n     * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n     * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n     */\n\n  }, {\n    key: \"getNearestSelectionRange\",\n    value: function getNearestSelectionRange(position) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'both';\n\n      // Return collapsed range if provided position is valid.\n      if (this.checkChild(position, '$text')) {\n        return new Range(position);\n      }\n\n      var backwardWalker, forwardWalker;\n\n      if (direction == 'both' || direction == 'backward') {\n        backwardWalker = new TreeWalker({\n          startPosition: position,\n          direction: 'backward'\n        });\n      }\n\n      if (direction == 'both' || direction == 'forward') {\n        forwardWalker = new TreeWalker({\n          startPosition: position\n        });\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = combineWalkers(backwardWalker, forwardWalker)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var data = _step5.value;\n          var type = data.walker == backwardWalker ? 'elementEnd' : 'elementStart';\n          var value = data.value;\n\n          if (value.type == type && this.isObject(value.item)) {\n            return Range._createOn(value.item);\n          }\n\n          if (this.checkChild(value.nextPosition, '$text')) {\n            return new Range(value.nextPosition);\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Tries to find position ancestors that allows to insert given node.\n     * It starts searching from the given position and goes node by node to the top of the model tree\n     * as long as {@link module:engine/model/schema~Schema#isLimit limit element},\n     * {@link module:engine/model/schema~Schema#isObject object element} or top-most ancestor won't be reached.\n     *\n     * @params {module:engine/model/position~Position} position Position from searching will start.\n     * @params {module:engine/model/node~Node|String} node Node for which allowed parent should be found or its name.\n     * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n     */\n\n  }, {\n    key: \"findAllowedParent\",\n    value: function findAllowedParent(position, node) {\n      var parent = position.parent;\n\n      while (parent) {\n        if (this.checkChild(parent, node)) {\n          return parent;\n        } // Do not split limit elements.\n\n\n        if (this.isLimit(parent)) {\n          return null;\n        }\n\n        parent = parent.parent;\n      }\n\n      return null;\n    }\n    /**\n     * Removes attributes disallowed by the schema.\n     *\n     * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n     * @param {module:engine/model/writer~Writer} writer\n     */\n\n  }, {\n    key: \"removeDisallowedAttributes\",\n    value: function removeDisallowedAttributes(nodes, writer) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = nodes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var node = _step6.value;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = node.getAttributeKeys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var attribute = _step7.value;\n\n              if (!this.checkAttribute(node, attribute)) {\n                writer.removeAttribute(attribute, node);\n              }\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n\n          if (node.is('element')) {\n            this.removeDisallowedAttributes(node.getChildren(), writer);\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n    /**\n     * Creates an instance of the schema context.\n     *\n     * @param {module:engine/model/schema~SchemaContextDefinition} context\n     * @returns {module:engine/model/schema~SchemaContext}\n     */\n\n  }, {\n    key: \"createContext\",\n    value: function createContext(context) {\n      return new SchemaContext(context);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_clearCache\",\n    value: function _clearCache() {\n      this._compiledDefinitions = null;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_compile\",\n    value: function _compile() {\n      var compiledDefinitions = {};\n      var sourceRules = this._sourceDefinitions;\n      var itemNames = Object.keys(sourceRules);\n\n      for (var _i = 0, _itemNames = itemNames; _i < _itemNames.length; _i++) {\n        var itemName = _itemNames[_i];\n        compiledDefinitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);\n      }\n\n      for (var _i2 = 0, _itemNames2 = itemNames; _i2 < _itemNames2.length; _i2++) {\n        var _itemName = _itemNames2[_i2];\n        compileAllowContentOf(compiledDefinitions, _itemName);\n      }\n\n      for (var _i3 = 0, _itemNames3 = itemNames; _i3 < _itemNames3.length; _i3++) {\n        var _itemName2 = _itemNames3[_i3];\n        compileAllowWhere(compiledDefinitions, _itemName2);\n      }\n\n      for (var _i4 = 0, _itemNames4 = itemNames; _i4 < _itemNames4.length; _i4++) {\n        var _itemName3 = _itemNames4[_i4];\n        compileAllowAttributesOf(compiledDefinitions, _itemName3);\n        compileInheritPropertiesFrom(compiledDefinitions, _itemName3);\n      }\n\n      for (var _i5 = 0, _itemNames5 = itemNames; _i5 < _itemNames5.length; _i5++) {\n        var _itemName4 = _itemNames5[_i5];\n        cleanUpAllowIn(compiledDefinitions, _itemName4);\n        cleanUpAllowAttributes(compiledDefinitions, _itemName4);\n      }\n\n      this._compiledDefinitions = compiledDefinitions;\n    }\n    /**\n     * @private\n     * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n     * @param {module:engine/model/schema~SchemaContext} context\n     * @param {Number} contextItemIndex\n     */\n\n  }, {\n    key: \"_checkContextMatch\",\n    value: function _checkContextMatch(def, context) {\n      var contextItemIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context.length - 1;\n      var contextItem = context.getItem(contextItemIndex);\n\n      if (def.allowIn.includes(contextItem.name)) {\n        if (contextItemIndex == 0) {\n          return true;\n        } else {\n          var parentRule = this.getDefinition(contextItem);\n          return this._checkContextMatch(parentRule, context, contextItemIndex - 1);\n        }\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n     * inside the given range on which the attribute can be applied.\n     *\n     * This is a helper function for {@link ~Schema#getValidRanges}.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range Range to process.\n     * @param {String} attribute The name of the attribute to check.\n     * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n     */\n\n  }, {\n    key: \"_getValidRangesForRange\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _getValidRangesForRange(range, attribute) {\n      var start, end, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, item;\n\n      return regeneratorRuntime.wrap(function _getValidRangesForRange$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              start = range.start;\n              end = range.start;\n              _iteratorNormalCompletion8 = true;\n              _didIteratorError8 = false;\n              _iteratorError8 = undefined;\n              _context2.prev = 5;\n              _iterator8 = range.getItems({\n                shallow: true\n              })[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {\n                _context2.next = 20;\n                break;\n              }\n\n              item = _step8.value;\n\n              if (!item.is('element')) {\n                _context2.next = 11;\n                break;\n              }\n\n              return _context2.delegateYield(this._getValidRangesForRange(Range._createIn(item), attribute), \"t0\", 11);\n\n            case 11:\n              if (this.checkAttribute(item, attribute)) {\n                _context2.next = 16;\n                break;\n              }\n\n              if (start.isEqual(end)) {\n                _context2.next = 15;\n                break;\n              }\n\n              _context2.next = 15;\n              return new Range(start, end);\n\n            case 15:\n              start = Position._createAfter(item);\n\n            case 16:\n              end = Position._createAfter(item);\n\n            case 17:\n              _iteratorNormalCompletion8 = true;\n              _context2.next = 7;\n              break;\n\n            case 20:\n              _context2.next = 26;\n              break;\n\n            case 22:\n              _context2.prev = 22;\n              _context2.t1 = _context2[\"catch\"](5);\n              _didIteratorError8 = true;\n              _iteratorError8 = _context2.t1;\n\n            case 26:\n              _context2.prev = 26;\n              _context2.prev = 27;\n\n              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                _iterator8.return();\n              }\n\n            case 29:\n              _context2.prev = 29;\n\n              if (!_didIteratorError8) {\n                _context2.next = 32;\n                break;\n              }\n\n              throw _iteratorError8;\n\n            case 32:\n              return _context2.finish(29);\n\n            case 33:\n              return _context2.finish(26);\n\n            case 34:\n              if (start.isEqual(end)) {\n                _context2.next = 37;\n                break;\n              }\n\n              _context2.next = 37;\n              return new Range(start, end);\n\n            case 37:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _getValidRangesForRange, this, [[5, 22, 26, 34], [27,, 29, 33]]);\n    })\n  }]);\n\n  return Schema;\n}();\n\nexport { Schema as default };\nmix(Schema, ObservableMixin);\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior  e.g. implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in a various way, but the most important use case is overriding standard behaviour of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you don't have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\" you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it's normally handled by\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition} but if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior  e.g. implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it's\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in a various way, but the most important use case is overriding standard behaviour of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you don't have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1` you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst atributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it's normally handled by\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition} but if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst atributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * `allowIn` &ndash; A string or an array of strings. Defines in which other items this item will be allowed.\n * * `allowAttributes` &ndash; A string or an array of strings. Defines allowed attributes of the given item.\n * * `allowContentOf` &ndash; A string or an array of strings. Inherits \"allowed children\" from other items.\n * * `allowWhere` &ndash; A string or an array of strings. Inherits \"allowed in\" from other items.\n * * `allowAttributesOf` &ndash; A string or an array of strings. Inherits attributes from other items.\n * * `inheritTypesFrom` &ndash; A string or an array of strings. Inherits `is*` properties of other items.\n * * `inheritAllFrom` &ndash; A string. A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n * * Additionally, you can define the following `is*` properties: `isBlock`, `isLimit`, `isObject`, `isInline`. Read about them below.\n *\n * # The is* properties\n *\n * There are 3 commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * `isBlock` &ndash; Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n * * `isLimit` &ndash; It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content. **Note:** All objects (`isObject`) are treated as limit elements, too.\n * * `isObject` &ndash; Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `image`, `table`, `video`, etc. **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n * * `isInline` &ndash; Whether an item is \"text-like\" and should be treated as an inline node. Examples of inline elements:\n * `$text`, `softBreak` (`<br>`), etc.\n *\n * # Generic items\n *\n * There are three basic generic items: `$root`, `$block` and `$text`.\n * They are defined as follows:\n *\n *\t\tthis.schema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\t\tthis.schema.register( '$block', {\n *\t\t\tallowIn: '$root',\n *\t\t\tisBlock: true\n *\t\t} );\n *\t\tthis.schema.register( '$text', {\n *\t\t\tallowIn: '$block',\n *\t\t\tisInline: true\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@linkTODO Defining schema} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Make `image` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'image', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n * Make `caption` allowed in `image` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'image',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about definining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\n\nexport var SchemaContext =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the context.\n   *\n   * @param {module:engine/model/schema~SchemaContextDefinition} context\n   */\n  function SchemaContext(context) {\n    _classCallCheck(this, SchemaContext);\n\n    if (context instanceof SchemaContext) {\n      return context;\n    }\n\n    if (typeof context == 'string') {\n      context = [context];\n    } else if (!Array.isArray(context)) {\n      // `context` is item or position.\n      // Position#getAncestors() doesn't accept any parameters but it works just fine here.\n      context = context.getAncestors({\n        includeSelf: true\n      });\n    }\n\n    if (context[0] && typeof context[0] != 'string' && context[0].is('documentFragment')) {\n      context.shift();\n    }\n\n    this._items = context.map(mapContextItem);\n  }\n  /**\n   * The number of items.\n   *\n   * @type {Number}\n   */\n\n\n  _createClass(SchemaContext, [{\n    key: Symbol.iterator,\n\n    /**\n     * Iterable interface.\n     *\n     * Iterates over all context items.\n     *\n     * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n     */\n    value: function value() {\n      return this._items[Symbol.iterator]();\n    }\n    /**\n     * Returns a new schema context instance with an additional item.\n     *\n     * Item can be added as:\n     *\n     * \t\tconst context = new SchemaContext( [ '$root' ] );\n     *\n     * \t\t// An element.\n     * \t\tconst fooElement = writer.createElement( 'fooElement' );\n     * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n     *\n     * \t\t// A text node.\n     * \t\tconst text = writer.createText( 'foobar' );\n     * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n     *\n     * \t\t// A string (element name).\n     * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n     *\n     * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n     * (without ancestors).\n     *\n     * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n     * to the current context.\n     * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(item) {\n      var ctx = new SchemaContext([item]);\n      ctx._items = [].concat(_toConsumableArray(this._items), _toConsumableArray(ctx._items));\n      return ctx;\n    }\n    /**\n     * Gets an item on the given index.\n     *\n     * @returns {module:engine/model/schema~SchemaContextItem}\n     */\n\n  }, {\n    key: \"getItem\",\n    value: function getItem(index) {\n      return this._items[index];\n    }\n    /**\n     * Returns the names of items.\n     *\n     * @returns {Iterable.<String>}\n     */\n\n  }, {\n    key: \"getNames\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function getNames() {\n      return regeneratorRuntime.wrap(function getNames$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.delegateYield(this._items.map(function (item) {\n                return item.name;\n              }), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, getNames, this);\n    })\n    /**\n     * Checks whether the context ends with the given nodes.\n     *\n     *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n     *\n     *\t\tctx.endsWith( '$text' ); // -> true\n     *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n     *\t\tctx.endsWith( '$root' ); // -> false\n     *\t\tctx.endsWith( 'paragraph' ); // -> false\n     *\n     * @param {String} query\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"endsWith\",\n    value: function endsWith(query) {\n      return Array.from(this.getNames()).join(' ').endsWith(query);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._items.length;\n    }\n    /**\n     * The last item (the lowest node).\n     *\n     * @type {module:engine/model/schema~SchemaContextItem}\n     */\n\n  }, {\n    key: \"last\",\n    get: function get() {\n      return this._items[this._items.length - 1];\n    }\n  }]);\n\n  return SchemaContext;\n}();\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node**  in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document  in this case all its ancestors will be used.\n * * By defining an **array of nodes**  in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes)  The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mising an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name`  the name of this item,\n * * `* getAttributeKeys()`  a generator of keys of item attributes,\n * * `getAttribute( keyName )`  a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\n/**\n * A structure containing additional metadata describing the attribute.\n *\n * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.\n *\n * @typedef {Object} module:engine/model/schema~AttributeProperties\n * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or\n * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the \"Remove format\" feature.\n */\n\nfunction compileBaseItemRule(sourceItemRules, itemName) {\n  var itemRule = {\n    name: itemName,\n    allowIn: [],\n    allowContentOf: [],\n    allowWhere: [],\n    allowAttributes: [],\n    allowAttributesOf: [],\n    inheritTypesFrom: []\n  };\n  copyTypes(sourceItemRules, itemRule);\n  copyProperty(sourceItemRules, itemRule, 'allowIn');\n  copyProperty(sourceItemRules, itemRule, 'allowContentOf');\n  copyProperty(sourceItemRules, itemRule, 'allowWhere');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributes');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributesOf');\n  copyProperty(sourceItemRules, itemRule, 'inheritTypesFrom');\n  makeInheritAllWork(sourceItemRules, itemRule);\n  return itemRule;\n}\n\nfunction compileAllowContentOf(compiledDefinitions, itemName) {\n  var _iteratorNormalCompletion9 = true;\n  var _didIteratorError9 = false;\n  var _iteratorError9 = undefined;\n\n  try {\n    for (var _iterator9 = compiledDefinitions[itemName].allowContentOf[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n      var allowContentOfItemName = _step9.value;\n\n      // The allowContentOf property may point to an unregistered element.\n      if (compiledDefinitions[allowContentOfItemName]) {\n        var allowedChildren = getAllowedChildren(compiledDefinitions, allowContentOfItemName);\n        allowedChildren.forEach(function (allowedItem) {\n          allowedItem.allowIn.push(itemName);\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError9 = true;\n    _iteratorError9 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n        _iterator9.return();\n      }\n    } finally {\n      if (_didIteratorError9) {\n        throw _iteratorError9;\n      }\n    }\n  }\n\n  delete compiledDefinitions[itemName].allowContentOf;\n}\n\nfunction compileAllowWhere(compiledDefinitions, itemName) {\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = compiledDefinitions[itemName].allowWhere[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var allowWhereItemName = _step10.value;\n      var inheritFrom = compiledDefinitions[allowWhereItemName]; // The allowWhere property may point to an unregistered element.\n\n      if (inheritFrom) {\n        var _compiledDefinitions$;\n\n        var allowedIn = inheritFrom.allowIn;\n\n        (_compiledDefinitions$ = compiledDefinitions[itemName].allowIn).push.apply(_compiledDefinitions$, _toConsumableArray(allowedIn));\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n\n  delete compiledDefinitions[itemName].allowWhere;\n}\n\nfunction compileAllowAttributesOf(compiledDefinitions, itemName) {\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = compiledDefinitions[itemName].allowAttributesOf[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var allowAttributeOfItem = _step11.value;\n      var inheritFrom = compiledDefinitions[allowAttributeOfItem];\n\n      if (inheritFrom) {\n        var _compiledDefinitions$2;\n\n        var inheritAttributes = inheritFrom.allowAttributes;\n\n        (_compiledDefinitions$2 = compiledDefinitions[itemName].allowAttributes).push.apply(_compiledDefinitions$2, _toConsumableArray(inheritAttributes));\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n\n  delete compiledDefinitions[itemName].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom(compiledDefinitions, itemName) {\n  var item = compiledDefinitions[itemName];\n  var _iteratorNormalCompletion12 = true;\n  var _didIteratorError12 = false;\n  var _iteratorError12 = undefined;\n\n  try {\n    for (var _iterator12 = item.inheritTypesFrom[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n      var inheritPropertiesOfItem = _step12.value;\n      var inheritFrom = compiledDefinitions[inheritPropertiesOfItem];\n\n      if (inheritFrom) {\n        var typeNames = Object.keys(inheritFrom).filter(function (name) {\n          return name.startsWith('is');\n        });\n        var _iteratorNormalCompletion13 = true;\n        var _didIteratorError13 = false;\n        var _iteratorError13 = undefined;\n\n        try {\n          for (var _iterator13 = typeNames[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n            var name = _step13.value;\n\n            if (!(name in item)) {\n              item[name] = inheritFrom[name];\n            }\n          }\n        } catch (err) {\n          _didIteratorError13 = true;\n          _iteratorError13 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n              _iterator13.return();\n            }\n          } finally {\n            if (_didIteratorError13) {\n              throw _iteratorError13;\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError12 = true;\n    _iteratorError12 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n        _iterator12.return();\n      }\n    } finally {\n      if (_didIteratorError12) {\n        throw _iteratorError12;\n      }\n    }\n  }\n\n  delete item.inheritTypesFrom;\n} // Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\n\n\nfunction cleanUpAllowIn(compiledDefinitions, itemName) {\n  var itemRule = compiledDefinitions[itemName];\n  var existingItems = itemRule.allowIn.filter(function (itemToCheck) {\n    return compiledDefinitions[itemToCheck];\n  });\n  itemRule.allowIn = Array.from(new Set(existingItems));\n}\n\nfunction cleanUpAllowAttributes(compiledDefinitions, itemName) {\n  var itemRule = compiledDefinitions[itemName];\n  itemRule.allowAttributes = Array.from(new Set(itemRule.allowAttributes));\n}\n\nfunction copyTypes(sourceItemRules, itemRule) {\n  var _iteratorNormalCompletion14 = true;\n  var _didIteratorError14 = false;\n  var _iteratorError14 = undefined;\n\n  try {\n    for (var _iterator14 = sourceItemRules[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n      var sourceItemRule = _step14.value;\n      var typeNames = Object.keys(sourceItemRule).filter(function (name) {\n        return name.startsWith('is');\n      });\n      var _iteratorNormalCompletion15 = true;\n      var _didIteratorError15 = false;\n      var _iteratorError15 = undefined;\n\n      try {\n        for (var _iterator15 = typeNames[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n          var name = _step15.value;\n          itemRule[name] = sourceItemRule[name];\n        }\n      } catch (err) {\n        _didIteratorError15 = true;\n        _iteratorError15 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n            _iterator15.return();\n          }\n        } finally {\n          if (_didIteratorError15) {\n            throw _iteratorError15;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError14 = true;\n    _iteratorError14 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n        _iterator14.return();\n      }\n    } finally {\n      if (_didIteratorError14) {\n        throw _iteratorError14;\n      }\n    }\n  }\n}\n\nfunction copyProperty(sourceItemRules, itemRule, propertyName) {\n  var _iteratorNormalCompletion16 = true;\n  var _didIteratorError16 = false;\n  var _iteratorError16 = undefined;\n\n  try {\n    for (var _iterator16 = sourceItemRules[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n      var sourceItemRule = _step16.value;\n\n      if (typeof sourceItemRule[propertyName] == 'string') {\n        itemRule[propertyName].push(sourceItemRule[propertyName]);\n      } else if (Array.isArray(sourceItemRule[propertyName])) {\n        var _itemRule$propertyNam;\n\n        (_itemRule$propertyNam = itemRule[propertyName]).push.apply(_itemRule$propertyNam, _toConsumableArray(sourceItemRule[propertyName]));\n      }\n    }\n  } catch (err) {\n    _didIteratorError16 = true;\n    _iteratorError16 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n        _iterator16.return();\n      }\n    } finally {\n      if (_didIteratorError16) {\n        throw _iteratorError16;\n      }\n    }\n  }\n}\n\nfunction makeInheritAllWork(sourceItemRules, itemRule) {\n  var _iteratorNormalCompletion17 = true;\n  var _didIteratorError17 = false;\n  var _iteratorError17 = undefined;\n\n  try {\n    for (var _iterator17 = sourceItemRules[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n      var sourceItemRule = _step17.value;\n      var inheritFrom = sourceItemRule.inheritAllFrom;\n\n      if (inheritFrom) {\n        itemRule.allowContentOf.push(inheritFrom);\n        itemRule.allowWhere.push(inheritFrom);\n        itemRule.allowAttributesOf.push(inheritFrom);\n        itemRule.inheritTypesFrom.push(inheritFrom);\n      }\n    }\n  } catch (err) {\n    _didIteratorError17 = true;\n    _iteratorError17 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n        _iterator17.return();\n      }\n    } finally {\n      if (_didIteratorError17) {\n        throw _iteratorError17;\n      }\n    }\n  }\n}\n\nfunction getAllowedChildren(compiledDefinitions, itemName) {\n  var itemRule = compiledDefinitions[itemName];\n  return getValues(compiledDefinitions).filter(function (def) {\n    return def.allowIn.includes(itemRule.name);\n  });\n}\n\nfunction getValues(obj) {\n  return Object.keys(obj).map(function (key) {\n    return obj[key];\n  });\n}\n\nfunction mapContextItem(ctxItem) {\n  if (typeof ctxItem == 'string') {\n    return {\n      name: ctxItem,\n      getAttributeKeys:\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function getAttributeKeys() {\n        return regeneratorRuntime.wrap(function getAttributeKeys$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, getAttributeKeys);\n      }),\n      getAttribute: function getAttribute() {}\n    };\n  } else {\n    return {\n      // '$text' means text nodes and text proxies.\n      name: ctxItem.is('element') ? ctxItem.name : '$text',\n      getAttributeKeys:\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function getAttributeKeys() {\n        return regeneratorRuntime.wrap(function getAttributeKeys$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.delegateYield(ctxItem.getAttributeKeys(), \"t0\", 1);\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, getAttributeKeys);\n      }),\n      getAttribute: function getAttribute(key) {\n        return ctxItem.getAttribute(key);\n      }\n    };\n  }\n} // Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\n\n\nfunction combineWalkers(backward, forward) {\n  var done, step, _step18;\n\n  return regeneratorRuntime.wrap(function combineWalkers$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          done = false;\n\n        case 1:\n          if (done) {\n            _context6.next = 17;\n            break;\n          }\n\n          done = true;\n\n          if (!backward) {\n            _context6.next = 9;\n            break;\n          }\n\n          step = backward.next();\n\n          if (step.done) {\n            _context6.next = 9;\n            break;\n          }\n\n          done = false;\n          _context6.next = 9;\n          return {\n            walker: backward,\n            value: step.value\n          };\n\n        case 9:\n          if (!forward) {\n            _context6.next = 15;\n            break;\n          }\n\n          _step18 = forward.next();\n\n          if (_step18.done) {\n            _context6.next = 15;\n            break;\n          }\n\n          done = false;\n          _context6.next = 15;\n          return {\n            walker: forward,\n            value: _step18.value\n          };\n\n        case 15:\n          _context6.next = 1;\n          break;\n\n        case 17:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, _marked);\n} // Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\n\n\nfunction convertToMinimalFlatRanges(ranges) {\n  var _iteratorNormalCompletion18, _didIteratorError18, _iteratorError18, _iterator18, _step19, range;\n\n  return regeneratorRuntime.wrap(function convertToMinimalFlatRanges$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          _iteratorNormalCompletion18 = true;\n          _didIteratorError18 = false;\n          _iteratorError18 = undefined;\n          _context7.prev = 3;\n          _iterator18 = ranges[Symbol.iterator]();\n\n        case 5:\n          if (_iteratorNormalCompletion18 = (_step19 = _iterator18.next()).done) {\n            _context7.next = 11;\n            break;\n          }\n\n          range = _step19.value;\n          return _context7.delegateYield(range.getMinimalFlatRanges(), \"t0\", 8);\n\n        case 8:\n          _iteratorNormalCompletion18 = true;\n          _context7.next = 5;\n          break;\n\n        case 11:\n          _context7.next = 17;\n          break;\n\n        case 13:\n          _context7.prev = 13;\n          _context7.t1 = _context7[\"catch\"](3);\n          _didIteratorError18 = true;\n          _iteratorError18 = _context7.t1;\n\n        case 17:\n          _context7.prev = 17;\n          _context7.prev = 18;\n\n          if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n            _iterator18.return();\n          }\n\n        case 20:\n          _context7.prev = 20;\n\n          if (!_didIteratorError18) {\n            _context7.next = 23;\n            break;\n          }\n\n          throw _iteratorError18;\n\n        case 23:\n          return _context7.finish(20);\n\n        case 24:\n          return _context7.finish(17);\n\n        case 25:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, _marked2, null, [[3, 13, 17, 25], [18,, 20, 24]]);\n}","import \"core-js/modules/es6.set\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/upcastdispatcher\n */\nimport ViewConsumable from \"./viewconsumable\";\nimport ModelRange from \"../model/range\";\nimport ModelPosition from \"../model/position\";\nimport { SchemaContext } from \"../model/schema\";\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * `UpcastDispatcher` is a central point of {@link module:engine/view/view view} conversion, which is a process of\n * converting given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element} into another structure.\n * In default application, {@link module:engine/view/view view} is converted to {@link module:engine/model/model}.\n *\n * During conversion process, for all {@link module:engine/view/node~Node view nodes} from the converted view document fragment,\n * `UpcastDispatcher` fires corresponding events. Special callbacks called \"converters\" should listen to\n * `UpcastDispatcher` for those events.\n *\n * Each callback, as the second argument, is passed a special object `data` that has `viewItem`, `modelCursor` and\n * `modelRange` properties. `viewItem` property contains {@link module:engine/view/node~Node view node} or\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback. `modelRange` property should be used to save the result\n * of conversion and is always a {@link module:engine/model/range~Range} when conversion result is correct.\n * `modelCursor` property is a {@link module:engine/model/position~Position position} on which conversion result will be inserted\n * and is a context according to {@link module:engine/model/schema~Schema schema} will be checked before the conversion.\n * See also {@link ~UpcastDispatcher#convert}. It is also shared by reference by all callbacks listening to given event.\n *\n * The third parameter passed to a callback is an instance of {@link ~UpcastDispatcher}\n * which provides additional tools for converters.\n *\n * Examples of providing callbacks for `UpcastDispatcher`:\n *\n *\t\t// Converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why we need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert all elements which have no custom converter into paragraph (autoparagraphing).\n *  \teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *  \t \t// When element is already consumed by higher priority converters then do nothing.\n *  \t \tif ( conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *  \t \t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *  \t \t\t\t// Find allowed parent for paragraph that we are going to insert. If current parent does not allow\n *  \t \t\t\t// to insert paragraph but one of the ancestors does then split nodes to allowed parent.\n *  \t \t\t\tconst splitResult = conversionApi.splitToAllowedParent( paragraph, data.modelCursor );\n *\n *  \t \t\t\t// When there is no split result it means that we can't insert paragraph in this position.\n *  \t \t\t\tif ( splitResult ) {\n *  \t \t\t\t\t// Insert paragraph in allowed position.\n *  \t \t\t\t\tconversionApi.writer.insert( paragraph, splitResult.position );\n *\n *  \t \t\t\t\t// Convert children to paragraph.\n *  \t \t\t\t\tconst { modelRange } = conversionApi.convertChildren(\n *  \t \t\t\t\t\tdata.viewItem,\n *  \t \t\t\t\t\tconversionApi.writer.createPositionAt( paragraph, 0 )\n *  \t \t\t\t\t);\n *\n * \t\t\t\t\t\t// Set as conversion result, attribute converters may use this property.\n *  \t \t\t\t\tdata.modelRange = conversionApi.writer.createRange(\n *  \t \t\t\t\t\tconversionApi.writer.createPositionBefore( paragraph ),\n *  \t \t\t\t\t\tmodelRange.end\n *  \t \t\t\t\t);\n *\n *  \t \t\t\t\t// Continue conversion inside paragraph.\n *  \t \t\t\t\tdata.modelCursor = data.modelRange.end;\n *  \t \t\t\t}\n *  \t \t\t}\n *  \t \t}\n *  \t }, { priority: 'low' } );\n *\n * Before each conversion process, `UpcastDispatcher` fires {@link ~UpcastDispatcher#event:viewCleanup}\n * event which can be used to prepare tree view for conversion.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\n\nvar UpcastDispatcher =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a `UpcastDispatcher` that operates using passed API.\n   *\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n   * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired\n   * by `UpcastDispatcher`.\n   */\n  function UpcastDispatcher() {\n    var conversionApi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, UpcastDispatcher);\n\n    /**\n     * List of the elements that were created during splitting.\n     *\n     * After conversion process the list is cleared.\n     *\n     * @private\n     * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n     */\n    this._splitParts = new Map();\n    /**\n     * Position in the temporary structure where the converted content is inserted. The structure reflect the context of\n     * the target position where the content will be inserted. This property is build based on the context parameter of the\n     * convert method.\n     *\n     * @private\n     * @type {module:engine/model/position~Position|null}\n     */\n\n    this._modelCursor = null;\n    /**\n     * Interface passed by dispatcher to the events callbacks.\n     *\n     * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n     */\n\n    this.conversionApi = Object.assign({}, conversionApi); // `convertItem`, `convertChildren` and `splitToAllowedParent` are bound to this `UpcastDispatcher`\n    // instance and set on `conversionApi`. This way only a part of `UpcastDispatcher` API is exposed.\n\n    this.conversionApi.convertItem = this._convertItem.bind(this);\n    this.conversionApi.convertChildren = this._convertChildren.bind(this);\n    this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this);\n    this.conversionApi.getSplitParts = this._getSplitParts.bind(this);\n  }\n  /**\n   * Starts the conversion process. The entry point for the conversion.\n   *\n   * @fires element\n   * @fires text\n   * @fires documentFragment\n   * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem\n   * Part of the view to be converted.\n   * @param {module:engine/model/writer~Writer} writer Instance of model writer.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is a result of the conversion process\n   * wrapped in `DocumentFragment`. Converted marker elements will be set as that document fragment's\n   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n   */\n\n\n  _createClass(UpcastDispatcher, [{\n    key: \"convert\",\n    value: function convert(viewItem, writer) {\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['$root'];\n      this.fire('viewCleanup', viewItem); // Create context tree and set position in the top element.\n      // Items will be converted according to this position.\n\n      this._modelCursor = createContextTree(context, writer); // Store writer in conversion as a conversion API\n      // to be sure that conversion process will use the same batch.\n\n      this.conversionApi.writer = writer; // Create consumable values list for conversion process.\n\n      this.conversionApi.consumable = ViewConsumable.createFrom(viewItem); // Custom data stored by converter for conversion process.\n\n      this.conversionApi.store = {}; // Do the conversion.\n\n      var _this$_convertItem = this._convertItem(viewItem, this._modelCursor),\n          modelRange = _this$_convertItem.modelRange; // Conversion result is always a document fragment so let's create it.\n\n\n      var documentFragment = writer.createDocumentFragment(); // When there is a conversion result.\n\n      if (modelRange) {\n        // Remove all empty elements that were create while splitting.\n        this._removeEmptyElements(); // Move all items that were converted in context tree to the document fragment.\n\n\n        for (var _i = 0, _Array$from = Array.from(this._modelCursor.parent.getChildren()); _i < _Array$from.length; _i++) {\n          var item = _Array$from[_i];\n          writer.append(item, documentFragment);\n        } // Extract temporary markers elements from model and set as static markers collection.\n\n\n        documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);\n      } // Clear context position.\n\n\n      this._modelCursor = null; // Clear split elements lists.\n\n      this._splitParts.clear(); // Clear conversion API.\n\n\n      this.conversionApi.writer = null;\n      this.conversionApi.store = null; // Return fragment as conversion result.\n\n      return documentFragment;\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n     */\n\n  }, {\n    key: \"_convertItem\",\n    value: function _convertItem(viewItem, modelCursor) {\n      var data = Object.assign({\n        viewItem: viewItem,\n        modelCursor: modelCursor,\n        modelRange: null\n      });\n\n      if (viewItem.is('element')) {\n        this.fire('element:' + viewItem.name, data, this.conversionApi);\n      } else if (viewItem.is('text')) {\n        this.fire('text', data, this.conversionApi);\n      } else {\n        this.fire('documentFragment', data, this.conversionApi);\n      } // Handle incorrect conversion result.\n\n\n      if (data.modelRange && !(data.modelRange instanceof ModelRange)) {\n        /**\n         * Incorrect conversion result was dropped.\n         *\n         * {@link module:engine/model/range~Range Model range} should be a conversion result.\n         *\n         * @error view-conversion-dispatcher-incorrect-result\n         */\n        throw new CKEditorError('view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.');\n      }\n\n      return {\n        modelRange: data.modelRange,\n        modelCursor: data.modelCursor\n      };\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n     */\n\n  }, {\n    key: \"_convertChildren\",\n    value: function _convertChildren(viewItem, modelCursor) {\n      var modelRange = new ModelRange(modelCursor);\n      var nextModelCursor = modelCursor;\n\n      for (var _i2 = 0, _Array$from2 = Array.from(viewItem.getChildren()); _i2 < _Array$from2.length; _i2++) {\n        var viewChild = _Array$from2[_i2];\n\n        var result = this._convertItem(viewChild, nextModelCursor);\n\n        if (result.modelRange instanceof ModelRange) {\n          modelRange.end = result.modelRange.end;\n          nextModelCursor = result.modelCursor;\n        }\n      }\n\n      return {\n        modelRange: modelRange,\n        modelCursor: nextModelCursor\n      };\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n     */\n\n  }, {\n    key: \"_splitToAllowedParent\",\n    value: function _splitToAllowedParent(node, modelCursor) {\n      // Try to find allowed parent.\n      var allowedParent = this.conversionApi.schema.findAllowedParent(modelCursor, node); // When there is no parent that allows to insert node then return `null`.\n\n      if (!allowedParent) {\n        return null;\n      } // When current position parent allows to insert node then return this position.\n\n\n      if (allowedParent === modelCursor.parent) {\n        return {\n          position: modelCursor\n        };\n      } // When allowed parent is in context tree.\n\n\n      if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {\n        return null;\n      } // Split element to allowed parent.\n\n\n      var splitResult = this.conversionApi.writer.split(modelCursor, allowedParent); // Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n      //\n      // The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n      // that got split) to the beginning of the other part of that element:\n      //\n      // <limit><a><b><c>X[]Y</c></b><a></limit> ->\n      // <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n      //\n      // After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n      // Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n      // Also, since we split all those elements, each of them has to have the other part.\n      //\n      // With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n      // them with \"opening tags\" in the reverse order. For that we can use a stack.\n\n      var stack = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = splitResult.range.getWalker()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var treeWalkerValue = _step.value;\n\n          if (treeWalkerValue.type == 'elementEnd') {\n            stack.push(treeWalkerValue.item);\n          } else {\n            // There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n            var originalPart = stack.pop();\n            var splitPart = treeWalkerValue.item;\n\n            this._registerSplitPair(originalPart, splitPart);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return {\n        position: splitResult.position,\n        cursorParent: splitResult.range.end.parent\n      };\n    }\n    /**\n     * Registers that `splitPart` element is a split part of the `originalPart` element.\n     *\n     * Data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} originalPart\n     * @param {module:engine/model/element~Element} splitPart\n     */\n\n  }, {\n    key: \"_registerSplitPair\",\n    value: function _registerSplitPair(originalPart, splitPart) {\n      if (!this._splitParts.has(originalPart)) {\n        this._splitParts.set(originalPart, [originalPart]);\n      }\n\n      var list = this._splitParts.get(originalPart);\n\n      this._splitParts.set(splitPart, list);\n\n      list.push(splitPart);\n    }\n    /**\n     * @private\n     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n     */\n\n  }, {\n    key: \"_getSplitParts\",\n    value: function _getSplitParts(element) {\n      var parts;\n\n      if (!this._splitParts.has(element)) {\n        parts = [element];\n      } else {\n        parts = this._splitParts.get(element);\n      }\n\n      return parts;\n    }\n    /**\n     * Checks if there are any empty elements created while splitting and removes them.\n     *\n     * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n     * as some elements might have become empty after other empty elements were removed from them.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_removeEmptyElements\",\n    value: function _removeEmptyElements() {\n      var anyRemoved = false;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._splitParts.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var element = _step2.value;\n\n          if (element.isEmpty) {\n            this.conversionApi.writer.remove(element);\n\n            this._splitParts.delete(element);\n\n            anyRemoved = true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      if (anyRemoved) {\n        this._removeEmptyElements();\n      }\n    }\n    /**\n     * Fired before the first conversion event, at the beginning of upcast (view to model conversion) process.\n     *\n     * @event viewCleanup\n     * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}\n     * viewItem Part of the view to be converted.\n     */\n\n    /**\n     * Fired when {@link module:engine/view/element~Element} is converted.\n     *\n     * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:\n     * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to\n     * all elements conversion or to conversion of specific elements.\n     *\n     * @event element\n     * @param {Object} data Conversion data. Keep in mind that this object is shared by reference between all\n     * callbacks that will be called. This means that callbacks can override values if needed, and those values will\n     * be available in other callbacks.\n     * @param {module:engine/view/item~Item} data.viewItem Converted item.\n     * @param {module:engine/model/position~Position} data.modelCursor Position where a converter should start changes.\n     * Change this value for the next converter to tell where the conversion should continue.\n     * @param {module:engine/model/range~Range} data.modelRange The current state of conversion result. Every change to\n     * converted element should be reflected by setting or modifying this property.\n     * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by callback.\n     */\n\n    /**\n     * Fired when {@link module:engine/view/text~Text} is converted.\n     *\n     * @event text\n     * @see #event:element\n     */\n\n    /**\n     * Fired when {@link module:engine/view/documentfragment~DocumentFragment} is converted.\n     *\n     * @event documentFragment\n     * @see #event:element\n     */\n\n  }]);\n\n  return UpcastDispatcher;\n}();\n\nexport { UpcastDispatcher as default };\nmix(UpcastDispatcher, EmitterMixin); // Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\n\nfunction extractMarkersFromModelFragment(modelItem, writer) {\n  var markerElements = new Set();\n  var markers = new Map(); // Create ModelTreeWalker.\n\n  var range = ModelRange._createIn(modelItem).getItems(); // Walk through DocumentFragment and collect marker elements.\n\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = range[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var item = _step3.value;\n\n      // Check if current element is a marker.\n      if (item.name == '$marker') {\n        markerElements.add(item);\n      }\n    } // Walk through collected marker elements store its path and remove its from the DocumentFragment.\n\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = markerElements[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var markerElement = _step4.value;\n      var markerName = markerElement.getAttribute('data-name');\n      var currentPosition = writer.createPositionBefore(markerElement); // When marker of given name is not stored it means that we have found the beginning of the range.\n\n      if (!markers.has(markerName)) {\n        markers.set(markerName, new ModelRange(currentPosition.clone())); // Otherwise is means that we have found end of the marker range.\n      } else {\n        markers.get(markerName).end = currentPosition.clone();\n      } // Remove marker element from DocumentFragment.\n\n\n      writer.remove(markerElement);\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return markers;\n} // Creates model fragment according to given context and returns position in the bottom (the deepest) element.\n\n\nfunction createContextTree(contextDefinition, writer) {\n  var position;\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = new SchemaContext(contextDefinition)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var item = _step5.value;\n      var attributes = {};\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = item.getAttributeKeys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var key = _step6.value;\n          attributes[key] = item.getAttribute(key);\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var current = writer.createElement(item.name, attributes);\n\n      if (position) {\n        writer.append(current, position);\n      }\n\n      position = ModelPosition._createAt(current, 0);\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  return position;\n}\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher dispatcher}\n * fires it's events.\n *\n * @interface module:engine/conversion/upcastdispatcher~UpcastConversionApi\n */\n\n/**\n * Starts conversion of given item by firing an appropriate event.\n *\n * Every fired event is passed (as first parameter) an object with `modelRange` property. Every event may set and/or\n * modify that property. When all callbacks are done, the final value of `modelRange` property is returned by this method.\n * The `modelRange` must be {@link module:engine/model/range~Range model range} or `null` (as set by default).\n *\n * @method #convertItem\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range|null} result.modelRange Model range containing result of item conversion,\n * created and modified by callbacks attached to fired event, or `null` if the conversion result was incorrect.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Starts conversion of all children of given item by firing appropriate events for all those children.\n *\n * @method #convertChildren\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Element which children should be converted.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range} result.modelRange Model range containing results of conversion of all children of given item.\n * When no children was converted then range is collapsed.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Checks {@link module:engine/model/schema~Schema schema} to find allowed parent for element that we are going to insert\n * starting from given position. If current parent does not allow to insert element but one of the ancestors does then\n * split nodes to allowed parent.\n *\n * If schema allows to insert node in given position, nothing is split and object with that position is returned.\n *\n * If it was not possible to find allowed parent, `null` is returned, nothing is split.\n *\n * Otherwise, ancestors are split and object with position and the copy of the split element is returned.\n *\n * For instance, if `<image>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *  \t-> split for `<image>` ->\n *\n *  \t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * In the sample above position between `<paragraph>` elements will be returned as `position` and the second `paragraph`\n * as `cursorParent`.\n *\n * @method #splitToAllowedParent\n * @param {module:engine/model/position~Position} position Position on which element is going to be inserted.\n * @param {module:engine/model/node~Node} node Node to insert.\n * @returns {Object|null} Split result. If it was not possible to find allowed position `null` is returned.\n * @returns {module:engine/model/position~Position} position between split elements.\n * @returns {module:engine/model/element~Element} [cursorParent] Element inside which cursor should be placed to\n * continue conversion. When element is not defined it means that there was no split.\n */\n\n/**\n * Returns all the split parts of given `element` that were created during upcasting through using {@link #splitToAllowedParent}.\n * It enables you to easily track those elements and continue processing them after they are split during their children conversion.\n *\n *\t\t<paragraph>Foo<image />bar<image />baz</paragraph> ->\n *\t\t<paragraph>Foo</paragraph><image /><paragraph>bar</paragraph><image /><paragraph>baz</paragraph>\n *\n * For a reference to any of above paragraphs, the function will return all three paragraphs (the original element included),\n * sorted in the order of their creation (the original element is the first one).\n *\n * If given `element` was not split, an array with single element is returned.\n *\n * Example of a usage in a converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( myElement, modelCursor );\n *\n *\t\tconst splitParts = conversionApi.getSplitParts( myElement );\n *\t\tconst lastSplitPart = splitParts[ splitParts.length - 1 ];\n *\n *\t\t// Setting `data.modelRange` basing on split parts:\n *\t\tdata.modelRange = conversionApi.writer.createRange(\n *\t\t\tconversionApi.writer.createPositionBefore( myElement ),\n *\t\t\tconversionApi.writer.createPositionAfter( lastSplitPart )\n *\t\t);\n *\n *\t\t// Setting `data.modelCursor` to continue after the last split element:\n *\t\tdata.modelCursor = conversionApi.writer.createPositionAfter( lastSplitPart );\n *\n * **Tip:** if you are unable to get a reference to the original element (for example because the code is split into multiple converters\n * or even classes) but it was already converted, you might want to check first element in `data.modelRange`. This is a common situation\n * if an attribute converter is separated from an element converter.\n *\n * @method #getSplitParts\n * @param {module:engine/model/element~Element} element\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\n/**\n * Stores information about what parts of processed view item are still waiting to be handled. After a piece of view item\n * was converted, appropriate consumable value should be {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/viewconsumable~ViewConsumable} #consumable\n */\n\n/**\n * Custom data stored by converters for conversion process. Custom properties of this object can be defined and use to\n * pass parameters between converters.\n *\n * The difference between this property and `data` parameter of\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that `data` parameters allows you\n * to pass parameters within a single event and `store` within the whole conversion.\n *\n * @member {Object} #store\n */\n\n/**\n * The model's schema instance.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/model/writer~Writer} instance used to manipulate data during conversion.\n *\n * @member {module:engine/model/writer~Writer} #writer\n */","import \"regenerator-runtime/runtime\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\nvar _marked =\n/*#__PURE__*/\nregeneratorRuntime.mark(_getAllUpcastDefinitions),\n    _marked2 =\n/*#__PURE__*/\nregeneratorRuntime.mark(_getUpcastDefinition);\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/conversion\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport UpcastHelpers from \"./upcasthelpers\";\nimport DowncastHelpers from \"./downcasthelpers\";\n/**\n * A utility class that helps add converters to upcast and downcast dispatchers.\n *\n * We recommend reading the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide first to\n * understand the core concepts of the conversion mechanisms.\n *\n * An instance of the conversion manager is available in the\n * {@link module:core/editor/editor~Editor#conversion `editor.conversion`} property\n * and by default has the following groups of dispatchers (i.e. directions of conversion):\n *\n * * `downcast` (editing and data downcasts)\n * * `editingDowncast`\n * * `dataDowncast`\n * * `upcast`\n *\n * # One-way converters\n *\n * To add a converter to a specific group, use the {@link module:engine/conversion/conversion~Conversion#for `for()`}\n * method:\n *\n *\t\t// Add a converter to editing downcast and data downcast.\n *\t\teditor.conversion.for( 'downcast' ).elementToElement( config ) );\n *\n *\t\t// Add a converter to the data pipepline only:\n *\t\teditor.conversion.for( 'dataDowncast' ).elementToElement( dataConversionConfig ) );\n *\n *\t\t// And a slightly different one for the editing pipeline:\n *\t\teditor.conversion.for( 'editingDowncast' ).elementToElement( editingConversionConfig ) );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for `for()`} method documentation to learn more about\n * available conversion helpers and how to use your custom ones.\n *\n * # Two-way converters\n *\n * Besides using one-way converters via the `for()` method, you can also use other methods available in this\n * class to add two-way converters (upcast and downcast):\n *\n * * {@link module:engine/conversion/conversion~Conversion#elementToElement `elementToElement()`} &ndash;\n * Model element to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement()`} &ndash;\n * Model attribute to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `attributeToAttribute()`} &ndash;\n * Model attribute to view element and vice versa.\n */\n\nvar Conversion =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new conversion instance.\n   *\n   * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n   * Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher>} downcastDispatchers\n   * @param {module:engine/conversion/upcastdispatcher~UpcastDispatcher|\n   * Array.<module:engine/conversion/upcastdispatcher~UpcastDispatcher>} upcastDispatchers\n   */\n  function Conversion(downcastDispatchers, upcastDispatchers) {\n    _classCallCheck(this, Conversion);\n\n    /**\n     * Maps dispatchers group name to ConversionHelpers instances.\n     *\n     * @private\n     * @member {Map.<String,module:engine/conversion/conversionhelpers~ConversionHelpers>}\n     */\n    this._helpers = new Map(); // Define default 'downcast' & 'upcast' dispatchers groups. Those groups are always available as two-way converters needs them.\n\n    this._downcast = Array.isArray(downcastDispatchers) ? downcastDispatchers : [downcastDispatchers];\n\n    this._createConversionHelpers({\n      name: 'downcast',\n      dispatchers: this._downcast,\n      isDowncast: true\n    });\n\n    this._upcast = Array.isArray(upcastDispatchers) ? upcastDispatchers : [upcastDispatchers];\n\n    this._createConversionHelpers({\n      name: 'upcast',\n      dispatchers: this._upcast,\n      isDowncast: false\n    });\n  }\n  /**\n   * Define an alias for registered dispatcher.\n   *\n   *\t\tconst conversion = new Conversion(\n   *\t\t\t[ dataDowncastDispatcher, editingDowncastDispatcher ],\n   *\t\t\tupcastDispatcher\n   *\t\t);\n   *\n   *\t\tconversion.addAlias( 'dataDowncast', dataDowncastDispatcher );\n   *\n   * @param {String} alias An alias of a dispatcher.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n   * module:engine/conversion/upcastdispatcher~UpcastDispatcher} dispatcher Dispatcher which should have an alias.\n   */\n\n\n  _createClass(Conversion, [{\n    key: \"addAlias\",\n    value: function addAlias(alias, dispatcher) {\n      var isDowncast = this._downcast.includes(dispatcher);\n\n      var isUpcast = this._upcast.includes(dispatcher);\n\n      if (!isUpcast && !isDowncast) {\n        /**\n         * Trying to register and alias for a dispatcher that nas not been registered.\n         *\n         * @error conversion-add-alias-dispatcher-not-registered\n         */\n        throw new CKEditorError('conversion-add-alias-dispatcher-not-registered: ' + 'Trying to register and alias for a dispatcher that nas not been registered.');\n      }\n\n      this._createConversionHelpers({\n        name: alias,\n        dispatchers: [dispatcher],\n        isDowncast: isDowncast\n      });\n    }\n    /**\n     * Provides a chainable API to assign converters to conversion dispatchers group.\n     *\n     * If the given group name has not been registered, the\n     * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.\n     *\n     * You can use conversion helpers available directly in the `for()` chain or your custom ones via\n     * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.\n     *\n     * # Using bulit-in conversion helpers\n     *\n     * The `for()` chain comes with a set of conversion helpers which you can use like this:\n     *\n     *\t\teditor.conversion.for( 'downcast' )\n     *\t\t\t.elementToElement( config1 )        // Adds an element-to-element downcast converter.\n     *\t\t\t.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.\n     *\n     *\t\teditor.conversion.for( 'upcast' )\n     *\t\t\t.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.\n     *\n     * Refer to the documentation of built-in conversion helpers to learn about their configuration options.\n     *\n     * * downcast (model-to-view) conversion helpers:\n     *\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.\n     *\n     * * upcast (view-to-model) conversion helpers:\n     *\n     *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},\n     *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},\n     *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.\n     *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.\n     *\n     * # Using custom conversion helpers\n     *\n     * If you need to implement a nontypical converter, you can do so by calling:\n     *\n     *\t\teditor.conversion.for( direction ).add( customHelper );\n     *\n     * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that\n     * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.\n     *\n     * Example:\n     *\n     *\t\teditor.conversion.for( 'upcast' ).add( dispatcher => {\n     *\t\t\tdispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {\n     *\t\t\t\t// Do something with a view <a> element.\n     *\t\t\t} );\n     *\t\t} );\n     *\n     * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n     * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write\n     * custom converters.\n     *\n     * @param {String} groupName The name of dispatchers group to add the converters to.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers|module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n\n  }, {\n    key: \"for\",\n    value: function _for(groupName) {\n      if (!this._helpers.has(groupName)) {\n        /**\n         * Trying to add a converter to an unknown dispatchers group.\n         *\n         * @error conversion-for-unknown-group\n         */\n        throw new CKEditorError('conversion-for-unknown-group: Trying to add a converter to an unknown dispatchers group.');\n      }\n\n      return this._helpers.get(groupName);\n    }\n    /**\n     * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).\n     * For example, the model `<paragraph>Foo</paragraph>` is `<p>Foo</p>` in the view.\n     *\n     *\t\t// A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).\n     *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );\n     *\n     *\t\t// Override other converters by specifying a converter definition with a higher priority.\n     *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );\n     *\n     *\t\t// View specified as an object instead of a string.\n     *\t\teditor.conversion.elementToElement( {\n     *\t\t\tmodel: 'fancyParagraph',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'p',\n     *\t\t\t\tclasses: 'fancy'\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.\n     *\t\teditor.conversion.elementToElement( {\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tview: 'p',\n     *\t\t\tupcastAlso: [\n     *\t\t\t\t'div',\n     *\t\t\t\t{\n     *\t\t\t\t\t// Any element with the `display: block` style.\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\tdisplay: 'block'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t]\n     *\t\t} );\n     *\n     *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n     *\t\teditor.conversion.elementToElement( {\n     *\t\t\tmodel: 'heading',\n     *\t\t\tview: 'h2',\n     *\t\t\t// Convert \"headling-like\" paragraphs to headings.\n     *\t\t\tupcastAlso: viewElement => {\n     *\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n     *\n     *\t\t\t\tif ( !fontSize ) {\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t}\n     *\n     *\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n     *\n     *\t\t\t\tif ( !match ) {\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t}\n     *\n     *\t\t\t\tconst size = Number( match[ 1 ] );\n     *\n     *\t\t\t\tif ( size > 26 ) {\n     *\t\t\t\t\t// Returned value can be an object with the matched properties.\n     *\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n     *\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n     *\n     *\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n     *\t\t\t\t}\n     *\n     *\t\t\t\treturn null;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * `definition.model` is a `String` with a model element name to convert from or to.\n     * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n     *\n     * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n     */\n\n  }, {\n    key: \"elementToElement\",\n    value: function elementToElement(definition) {\n      // Set up downcast converter.\n      this.for('downcast').elementToElement(definition); // Set up upcast converter.\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getAllUpcastDefinitions(definition)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _step.value,\n              model = _step$value.model,\n              view = _step$value.view;\n          this.for('upcast').elementToElement({\n            model: model,\n            view: view,\n            converterPriority: definition.converterPriority\n          });\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).\n     * For example, a model text node with `\"Foo\"` as data and the `bold` attribute is `<strong>Foo</strong>` in the view.\n     *\n     *\t\t// A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).\n     *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );\n     *\n     *\t\t// Override other converters by specifying a converter definition with a higher priority.\n     *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );\n     *\n     *\t\t// View specified as an object instead of a string.\n     *\t\teditor.conversion.attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tclasses: 'bold'\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.\n     *\t\t// The same attribute on different elements may then be handled by a different converter.\n     *\t\teditor.conversion.attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'textDecoration',\n     *\t\t\t\tvalues: [ 'underline', 'lineThrough' ],\n     *\t\t\t\tname: '$text'\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tunderline: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'text-decoration': 'underline'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tlineThrough: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'text-decoration': 'line-through'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.\n     *\t\teditor.conversion.attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: 'strong',\n     *\t\t\tupcastAlso: [\n     *\t\t\t\t'b',\n     *\t\t\t\t{\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tclasses: 'bold'\n     *\t\t\t\t},\n     *\t\t\t\t{\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-weight': 'bold'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tviewElement => {\n     *\t\t\t\t\tconst fontWeight = viewElement.getStyle( 'font-weight' );\n     *\n     *\t\t\t\t\tif ( viewElement.is( 'span' ) && fontWeight && /\\d+/.test() && Number( fontWeight ) > 500 ) {\n     *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n     *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n     *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n     *\n     *\t\t\t\t\t\treturn {\n     *\t\t\t\t\t\t\tname: true,\n     *\t\t\t\t\t\t\tstyles: [ 'font-weight' ]\n     *\t\t\t\t\t\t};\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t]\n     *\t\t} );\n     *\n     *\t\t// Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).\n     *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n     *\t\teditor.conversion.attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'fontSize',\n     *\t\t\t\tvalues: [ 'big', 'small' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tbig: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '1.2em'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tsmall: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '0.8em'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tupcastAlso: {\n     *\t\t\t\tbig: viewElement => {\n     *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n     *\n     *\t\t\t\t\tif ( !fontSize ) {\n     *\t\t\t\t\t\treturn null;\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n     *\n     *\t\t\t\t\tif ( !match ) {\n     *\t\t\t\t\t\treturn null;\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\tconst size = Number( match[ 1 ] );\n     *\n     *\t\t\t\t\tif ( viewElement.is( 'span' ) && size > 10 ) {\n     *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n     *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n     *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n     *\n     *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t},\n     *\t\t\t\tsmall: viewElement => {\n     *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n     *\n     *\t\t\t\t\tif ( !fontSize ) {\n     *\t\t\t\t\t\treturn null;\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n     *\n     *\t\t\t\t\tif ( !match ) {\n     *\t\t\t\t\t\treturn null;\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\tconst size = Number( match[ 1 ] );\n     *\n     *\t\t\t\t\tif ( viewElement.is( 'span' ) && size < 10 ) {\n     *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n     *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n     *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n     *\n     *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object\n     * describing the attribute key and value to convert or a `String` specifying just the attribute key (then `value` is set to `true`).\n     * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n     *\n     * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n     */\n\n  }, {\n    key: \"attributeToElement\",\n    value: function attributeToElement(definition) {\n      // Set up downcast converter.\n      this.for('downcast').attributeToElement(definition); // Set up upcast converter.\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _getAllUpcastDefinitions(definition)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _step2.value,\n              model = _step2$value.model,\n              view = _step2$value.view;\n          this.for('upcast').elementToAttribute({\n            view: view,\n            model: model,\n            converterPriority: definition.converterPriority\n          });\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n    /**\n     * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa).\n     * For example, `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).\n     * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.\n     * To convert text attributes {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}\n     * should be set up.\n     *\n     *\t\t// A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).\n     *\t\teditor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );\n     *\n     *\t\t// Attribute values are strictly specified.\n     *\t\teditor.conversion.attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'image',\n     *\t\t\t\tkey: 'aside',\n     *\t\t\t\tvalues: [ 'aside' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\taside: {\n     *\t\t\t\t\tname: 'img',\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: [ 'aside', 'half-size' ]\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Set the style attribute.\n     *\t\teditor.conversion.attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'image',\n     *\t\t\t\tkey: 'aside',\n     *\t\t\t\tvalues: [ 'aside' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\taside: {\n     *\t\t\t\t\tname: 'img',\n     *\t\t\t\t\tkey: 'style',\n     *\t\t\t\t\tvalue: {\n     *\t\t\t\t\t\tfloat: 'right',\n     *\t\t\t\t\t\twidth: '50%',\n     *\t\t\t\t\t\tmargin: '5px'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Conversion from and to a model attribute key whose value is an enum (`align=right|center`).\n     *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.\n     *\t\teditor.conversion.attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'align',\n     *\t\t\t\tvalues: [ 'right', 'center' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tright: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: 'align-right'\n     *\t\t\t\t},\n     *\t\t\t\tcenter: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: 'align-center'\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tupcastAlso: {\n     *\t\t\t\tright: {\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'text-align': 'right'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tcenter: {\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'text-align': 'center'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * The `definition.model` parameter specifies which model attribute should be converted from and to.\n     * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.\n     * The `key` property is the model attribute key to convert from and to.\n     * The `values` are the possible model attribute values. If `values` is not set, the model attribute value will be the same as the\n     * view attribute value.\n     * If `name` is set, the conversion will be set up only for model elements with the given name.\n     *\n     * The `definition.view` parameter specifies which view attribute should be converted from and to.\n     * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.\n     * The `key` property is the view attribute key to convert from and to.\n     * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be\n     * the same as the model attribute value.\n     * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.\n     * If `key` is `'style'`, `value` is an object with key-value pairs.\n     * In other cases, `value` is a `String`.\n     * If `name` is set, the conversion will be set up only for model elements with the given name.\n     * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`\n     * to `{ key, value, [ name ] }` objects.\n     *\n     * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.\n     * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`\n     * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.\n     *\n     * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should\n     * be given in both parameters.\n     *\n     * @param {Object} definition The converter definition.\n     * @param {String|Object} definition.model The model attribute to convert from and to.\n     * @param {String|Object} definition.view The view attribute to convert from and to.\n     * @param {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [definition.upcastAlso]\n     * Any view element matching `definition.upcastAlso` will also be converted to the given model attribute. `definition.upcastAlso`\n     * is used only if `config.model.values` is specified.\n     */\n\n  }, {\n    key: \"attributeToAttribute\",\n    value: function attributeToAttribute(definition) {\n      // Set up downcast converter.\n      this.for('downcast').attributeToAttribute(definition); // Set up upcast converter.\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = _getAllUpcastDefinitions(definition)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _step3$value = _step3.value,\n              model = _step3$value.model,\n              view = _step3$value.view;\n          this.for('upcast').attributeToAttribute({\n            view: view,\n            model: model\n          });\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n    /**\n     * Creates and caches conversion helpers for given dispatchers group.\n     *\n     * @private\n     * @param {Object} options\n     * @param {String} options.name Group name.\n     * @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n     * module:engine/conversion/upcastdispatcher~UpcastDispatcher>} options.dispatchers\n     * @param {Boolean} options.isDowncast\n     */\n\n  }, {\n    key: \"_createConversionHelpers\",\n    value: function _createConversionHelpers(_ref) {\n      var name = _ref.name,\n          dispatchers = _ref.dispatchers,\n          isDowncast = _ref.isDowncast;\n\n      if (this._helpers.has(name)) {\n        /**\n         * Trying to register a group name that has already been registered.\n         *\n         * @error conversion-group-exists\n         */\n        throw new CKEditorError('conversion-group-exists: Trying to register a group name that has already been registered.');\n      }\n\n      var helpers = isDowncast ? new DowncastHelpers(dispatchers) : new UpcastHelpers(dispatchers);\n\n      this._helpers.set(name, helpers);\n    }\n  }]);\n\n  return Conversion;\n}();\n/**\n * Defines how the model should be converted from and to the view.\n *\n * @typedef {Object} module:engine/conversion/conversion~ConverterDefinition\n *\n * @property {*} [model] The model conversion definition. Describes the model element or model attribute to convert. This parameter differs\n * for different functions that accept `ConverterDefinition`. See the description of the function to learn how to set it.\n * @property {module:engine/view/elementdefinition~ElementDefinition|Object} view The definition of the view element to convert from and\n * to. If `model` describes multiple values, `view` is an object that assigns these values (`view` object keys) to view element definitions\n * (`view` object values).\n * @property {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [upcastAlso]\n * Any view element matching `upcastAlso` will also be converted to the model. If `model` describes multiple values, `upcastAlso`\n * is an object that assigns these values (`upcastAlso` object keys) to {@link module:engine/view/matcher~MatcherPattern}s\n * (`upcastAlso` object values).\n * @property {module:utils/priorities~PriorityString} [converterPriority] The converter priority.\n */\n// Helper function that creates a joint array out of an item passed in `definition.view` and items passed in\n// `definition.upcastAlso`.\n//\n// @param {module:engine/conversion/conversion~ConverterDefinition} definition\n// @returns {Array} Array containing view definitions.\n\n\nexport { Conversion as default };\n\nfunction _getAllUpcastDefinitions(definition) {\n  var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, value, model, view, upcastAlso;\n\n  return regeneratorRuntime.wrap(function _getAllUpcastDefinitions$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!definition.model.values) {\n            _context.next = 31;\n            break;\n          }\n\n          _iteratorNormalCompletion4 = true;\n          _didIteratorError4 = false;\n          _iteratorError4 = undefined;\n          _context.prev = 4;\n          _iterator4 = definition.model.values[Symbol.iterator]();\n\n        case 6:\n          if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n            _context.next = 15;\n            break;\n          }\n\n          value = _step4.value;\n          model = {\n            key: definition.model.key,\n            value: value\n          };\n          view = definition.view[value];\n          upcastAlso = definition.upcastAlso ? definition.upcastAlso[value] : undefined;\n          return _context.delegateYield(_getUpcastDefinition(model, view, upcastAlso), \"t0\", 12);\n\n        case 12:\n          _iteratorNormalCompletion4 = true;\n          _context.next = 6;\n          break;\n\n        case 15:\n          _context.next = 21;\n          break;\n\n        case 17:\n          _context.prev = 17;\n          _context.t1 = _context[\"catch\"](4);\n          _didIteratorError4 = true;\n          _iteratorError4 = _context.t1;\n\n        case 21:\n          _context.prev = 21;\n          _context.prev = 22;\n\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n\n        case 24:\n          _context.prev = 24;\n\n          if (!_didIteratorError4) {\n            _context.next = 27;\n            break;\n          }\n\n          throw _iteratorError4;\n\n        case 27:\n          return _context.finish(24);\n\n        case 28:\n          return _context.finish(21);\n\n        case 29:\n          _context.next = 32;\n          break;\n\n        case 31:\n          return _context.delegateYield(_getUpcastDefinition(definition.model, definition.view, definition.upcastAlso), \"t2\", 32);\n\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[4, 17, 21, 29], [22,, 24, 28]]);\n}\n\nfunction _getUpcastDefinition(model, view, upcastAlso) {\n  var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, upcastAlsoItem;\n\n  return regeneratorRuntime.wrap(function _getUpcastDefinition$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return {\n            model: model,\n            view: view\n          };\n\n        case 2:\n          if (!upcastAlso) {\n            _context2.next = 30;\n            break;\n          }\n\n          upcastAlso = Array.isArray(upcastAlso) ? upcastAlso : [upcastAlso];\n          _iteratorNormalCompletion5 = true;\n          _didIteratorError5 = false;\n          _iteratorError5 = undefined;\n          _context2.prev = 7;\n          _iterator5 = upcastAlso[Symbol.iterator]();\n\n        case 9:\n          if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {\n            _context2.next = 16;\n            break;\n          }\n\n          upcastAlsoItem = _step5.value;\n          _context2.next = 13;\n          return {\n            model: model,\n            view: upcastAlsoItem\n          };\n\n        case 13:\n          _iteratorNormalCompletion5 = true;\n          _context2.next = 9;\n          break;\n\n        case 16:\n          _context2.next = 22;\n          break;\n\n        case 18:\n          _context2.prev = 18;\n          _context2.t0 = _context2[\"catch\"](7);\n          _didIteratorError5 = true;\n          _iteratorError5 = _context2.t0;\n\n        case 22:\n          _context2.prev = 22;\n          _context2.prev = 23;\n\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n\n        case 25:\n          _context2.prev = 25;\n\n          if (!_didIteratorError5) {\n            _context2.next = 28;\n            break;\n          }\n\n          throw _iteratorError5;\n\n        case 28:\n          return _context2.finish(25);\n\n        case 29:\n          return _context2.finish(22);\n\n        case 30:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[7, 18, 22, 30], [23,, 25, 29]]);\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/batch\n */\n\n/**\n * A batch instance groups model changes ({@link module:engine/model/operation/operation~Operation operations}). All operations\n * grouped in a single batch can be reverted together, so you can also think about a batch as of a single undo step. If you want\n * to extend a given undo step, you can add more changes to the batch using {@link module:engine/model/model~Model#enqueueChange}:\n *\n *\t\tmodel.enqueueChange( batch, writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * @see module:engine/model/model~Model#enqueueChange\n * @see module:engine/model/model~Model#change\n */\nvar Batch =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a batch instance.\n   *\n   * @see module:engine/model/model~Model#enqueueChange\n   * @see module:engine/model/model~Model#change\n   * @param {'transparent'|'default'} [type='default'] The type of the batch.\n   */\n  function Batch() {\n    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n\n    _classCallCheck(this, Batch);\n\n    /**\n     * An array of operations that compose this batch.\n     *\n     * @readonly\n     * @type {Array.<module:engine/model/operation/operation~Operation>}\n     */\n    this.operations = [];\n    /**\n     * The type of the batch.\n     *\n     * It can be one of the following values:\n     * * `'default'` &ndash; All \"normal\" batches. This is the most commonly used type.\n     * * `'transparent'` &ndash; A batch that should be ignored by other features, i.e. an initial batch or collaborative editing\n     * changes.\n     *\n     * @readonly\n     * @type {'transparent'|'default'}\n     */\n\n    this.type = type;\n  }\n  /**\n   * Returns the base version of this batch, which is equal to the base version of the first operation in the batch.\n   * If there are no operations in the batch or neither operation has the base version set, it returns `null`.\n   *\n   * @readonly\n   * @type {Number|null}\n   */\n\n\n  _createClass(Batch, [{\n    key: \"addOperation\",\n\n    /**\n     * Adds an operation to the batch instance.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation An operation to add.\n     * @returns {module:engine/model/operation/operation~Operation} The added operation.\n     */\n    value: function addOperation(operation) {\n      operation.batch = this;\n      this.operations.push(operation);\n      return operation;\n    }\n  }, {\n    key: \"baseVersion\",\n    get: function get() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var op = _step.value;\n\n          if (op.baseVersion !== null) {\n            return op.baseVersion;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return Batch;\n}();\n\nexport { Batch as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/utils\n */\nimport Node from \"../node\";\nimport Text from \"../text\";\nimport TextProxy from \"../textproxy\";\nimport Range from \"../range\";\nimport DocumentFragment from \"../documentfragment\";\nimport NodeList from \"../nodelist\";\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Contains functions used for composing model tree by {@link module:engine/model/operation/operation~Operation operations}.\n * Those functions are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.\n *\n * @protected\n * @namespace utils\n */\n\n/**\n * Inserts given nodes at given position.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.insert\n * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.\n * @param {module:engine/model/node~NodeSet} nodes Nodes to insert.\n * @returns {module:engine/model/range~Range} Range spanning over inserted elements.\n */\n\nexport function _insert(position, nodes) {\n  nodes = _normalizeNodes(nodes); // We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.\n\n  var offset = nodes.reduce(function (sum, node) {\n    return sum + node.offsetSize;\n  }, 0);\n  var parent = position.parent; // Insertion might be in a text node, we should split it if that's the case.\n\n  _splitNodeAtPosition(position);\n\n  var index = position.index; // Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,\n  // using basic `Element` API.\n\n  parent._insertChild(index, nodes); // Merge text nodes, if possible. Merging is needed only at points where inserted nodes \"touch\" \"old\" nodes.\n\n\n  _mergeNodesAtIndex(parent, index + nodes.length);\n\n  _mergeNodesAtIndex(parent, index);\n\n  return new Range(position, position.getShiftedBy(offset));\n}\n/**\n * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._remove\n * @param {module:engine/model/range~Range} range Range containing nodes to remove.\n * @returns {Array.<module:engine/model/node~Node>}\n */\n\nexport function _remove(range) {\n  if (!range.isFlat) {\n    /**\n     * Trying to remove a range which starts and ends in different element.\n     *\n     * @error operation-utils-remove-range-not-flat\n     */\n    throw new CKEditorError('operation-utils-remove-range-not-flat: ' + 'Trying to remove a range which starts and ends in different element.');\n  }\n\n  var parent = range.start.parent; // Range may be inside text nodes, we have to split them if that's the case.\n\n  _splitNodeAtPosition(range.start);\n\n  _splitNodeAtPosition(range.end); // Remove the text nodes using basic `Element` API.\n\n\n  var removed = parent._removeChildren(range.start.index, range.end.index - range.start.index); // Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be\n  // touching at the position equal to the removed range beginning. We check merging possibility there.\n\n\n  _mergeNodesAtIndex(parent, range.start.index);\n\n  return removed;\n}\n/**\n * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.move\n * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.\n * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.\n * @returns {module:engine/model/range~Range} Range containing moved nodes.\n */\n\nexport function _move(sourceRange, targetPosition) {\n  if (!sourceRange.isFlat) {\n    /**\n     * Trying to move a range which starts and ends in different element.\n     *\n     * @error operation-utils-move-range-not-flat\n     */\n    throw new CKEditorError('operation-utils-move-range-not-flat: ' + 'Trying to move a range which starts and ends in different element.');\n  }\n\n  var nodes = _remove(sourceRange); // We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and\n  // that change might have an impact on `targetPosition`.\n\n\n  targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);\n  return _insert(targetPosition, nodes);\n}\n/**\n * Sets given attribute on nodes in given range. The attributes are only set on top-level nodes of the range, not on its children.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._setAttribute\n * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set. Must be a flat range.\n * @param {String} key Key of attribute to set.\n * @param {*} value Attribute value.\n */\n\nexport function _setAttribute(range, key, value) {\n  // Range might start or end in text nodes, so we have to split them.\n  _splitNodeAtPosition(range.start);\n\n  _splitNodeAtPosition(range.end); // Iterate over all items in the range.\n\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = range.getItems({\n      shallow: true\n    })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var item = _step.value;\n      // Iterator will return `TextProxy` instances but we know that those text proxies will\n      // always represent full text nodes (this is guaranteed thanks to splitting we did before).\n      // So, we can operate on those text proxies' text nodes.\n      var node = item.is('textProxy') ? item.textNode : item;\n\n      if (value !== null) {\n        node._setAttribute(key, value);\n      } else {\n        node._removeAttribute(key);\n      } // After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.\n\n\n      _mergeNodesAtIndex(node.parent, node.index);\n    } // Try to merge last changed node with it's previous sibling (not covered by the loop above).\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  _mergeNodesAtIndex(range.end.parent, range.end.index);\n}\n/**\n * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See\n * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.normalizeNodes\n * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.\n * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.\n */\n\nexport function _normalizeNodes(nodes) {\n  var normalized = [];\n\n  if (!(nodes instanceof Array)) {\n    nodes = [nodes];\n  } // Convert instances of classes other than Node.\n\n\n  for (var i = 0; i < nodes.length; i++) {\n    if (typeof nodes[i] == 'string') {\n      normalized.push(new Text(nodes[i]));\n    } else if (nodes[i] instanceof TextProxy) {\n      normalized.push(new Text(nodes[i].data, nodes[i].getAttributes()));\n    } else if (nodes[i] instanceof DocumentFragment || nodes[i] instanceof NodeList) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = nodes[i][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var child = _step2.value;\n          normalized.push(child);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    } else if (nodes[i] instanceof Node) {\n      normalized.push(nodes[i]);\n    } // Skip unrecognized type.\n\n  } // Merge text nodes.\n\n\n  for (var _i = 1; _i < normalized.length; _i++) {\n    var node = normalized[_i];\n    var prev = normalized[_i - 1];\n\n    if (node instanceof Text && prev instanceof Text && _haveSameAttributes(node, prev)) {\n      // Doing this instead changing `prev.data` because `data` is readonly.\n      normalized.splice(_i - 1, 2, new Text(prev.data + node.data, prev.getAttributes()));\n      _i--;\n    }\n  }\n\n  return normalized;\n} // Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and\n// merges them into one node if they have same attributes.\n//\n// Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.\n//\n// @private\n// @param {module:engine/model/element~Element} element Parent element of nodes to merge.\n// @param {Number} index Index between nodes to merge.\n\nfunction _mergeNodesAtIndex(element, index) {\n  var nodeBefore = element.getChild(index - 1);\n  var nodeAfter = element.getChild(index); // Check if both of those nodes are text objects with same attributes.\n\n  if (nodeBefore && nodeAfter && nodeBefore.is('text') && nodeAfter.is('text') && _haveSameAttributes(nodeBefore, nodeAfter)) {\n    // Append text of text node after index to the before one.\n    var mergedNode = new Text(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes()); // Remove separate text nodes.\n\n    element._removeChildren(index - 1, 2); // Insert merged text node.\n\n\n    element._insertChild(index - 1, mergedNode);\n  }\n} // Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them\n// containing a part of original text node.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position at which node should be split.\n\n\nfunction _splitNodeAtPosition(position) {\n  var textNode = position.textNode;\n  var element = position.parent;\n\n  if (textNode) {\n    var offsetDiff = position.offset - textNode.startOffset;\n    var index = textNode.index;\n\n    element._removeChildren(index, 1);\n\n    var firstPart = new Text(textNode.data.substr(0, offsetDiff), textNode.getAttributes());\n    var secondPart = new Text(textNode.data.substr(offsetDiff), textNode.getAttributes());\n\n    element._insertChild(index, [firstPart, secondPart]);\n  }\n} // Checks whether two given nodes have same attributes.\n//\n// @private\n// @param {module:engine/model/node~Node} nodeA Node to check.\n// @param {module:engine/model/node~Node} nodeB Node to check.\n// @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.\n\n\nfunction _haveSameAttributes(nodeA, nodeB) {\n  var iteratorA = nodeA.getAttributes();\n  var iteratorB = nodeB.getAttributes();\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = iteratorA[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var attr = _step3.value;\n\n      if (attr[1] !== nodeB.getAttribute(attr[0])) {\n        return false;\n      }\n\n      iteratorB.next();\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return iteratorB.next().done;\n}\n/**\n * Value that can be normalized to an array of {@link module:engine/model/node~Node nodes}.\n *\n * Non-arrays are normalized as follows:\n * * {@link module:engine/model/node~Node Node} is left as is,\n * * {@link module:engine/model/textproxy~TextProxy TextProxy} and `String` are normalized to {@link module:engine/model/text~Text Text},\n * * {@link module:engine/model/nodelist~NodeList NodeList} is normalized to an array containing all nodes that are in that node list,\n * * {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment} is normalized to an array containing all of it's\n * * children.\n *\n * Arrays are processed item by item like non-array values and flattened to one array. Normalization always results in\n * a flat array of {@link module:engine/model/node~Node nodes}. Consecutive text nodes (or items normalized to text nodes) will be\n * merged if they have same attributes.\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/textproxy~TextProxy|String|\n * module:engine/model/nodelist~NodeList|module:engine/model/documentfragment~DocumentFragment|Iterable}\n * module:engine/model/node~NodeSet\n */","import \"core-js/modules/es6.string.anchor\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.function.name\";\nimport _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/writer\n */\nimport AttributeOperation from \"./operation/attributeoperation\";\nimport DetachOperation from \"./operation/detachoperation\";\nimport InsertOperation from \"./operation/insertoperation\";\nimport MarkerOperation from \"./operation/markeroperation\";\nimport MoveOperation from \"./operation/moveoperation\";\nimport RenameOperation from \"./operation/renameoperation\";\nimport RootAttributeOperation from \"./operation/rootattributeoperation\";\nimport SplitOperation from \"./operation/splitoperation\";\nimport MergeOperation from \"./operation/mergeoperation\";\nimport DocumentFragment from \"./documentfragment\";\nimport Text from \"./text\";\nimport Element from \"./element\";\nimport RootElement from \"./rootelement\";\nimport Position from \"./position\";\nimport Range from \"./range.js\";\nimport DocumentSelection from \"./documentselection\";\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify\n * child nodes, attributes or text, set the selection's position and its attributes.\n *\n * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or\n * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.\n *\n *\t\tmodel.change( writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * Note that the writer should never be stored and used outside of the `change()` and\n * `enqueueChange()` blocks.\n *\n * Note that writer's methods do not check the {@link module:engine/model/schema~Schema}. It is possible\n * to create incorrect model structures by using the writer. Read more about in\n * {@glink framework/guides/deep-dive/schema#who-checks-the-schema \"Who checks the schema?\"}.\n *\n * @see module:engine/model/model~Model#change\n * @see module:engine/model/model~Model#enqueueChange\n */\n\nvar Writer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a writer instance.\n   *\n   * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or\n   * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.\n   *\n   * @protected\n   * @param {module:engine/model/model~Model} model\n   * @param {module:engine/model/batch~Batch} batch\n   */\n  function Writer(model, batch) {\n    _classCallCheck(this, Writer);\n\n    /**\n     * Instance of the model on which this writer operates.\n     *\n     * @readonly\n     * @type {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The batch to which this writer will add changes.\n     *\n     * @readonly\n     * @type {module:engine/model/batch~Batch}\n     */\n\n    this.batch = batch;\n  }\n  /**\n   * Creates a new {@link module:engine/model/text~Text text node}.\n   *\n   *\t\twriter.createText( 'foo' );\n   *\t\twriter.createText( 'foo', { bold: true } );\n   *\n   * @param {String} data Text data.\n   * @param {Object} [attributes] Text attributes.\n   * @returns {module:engine/model/text~Text} Created text node.\n   */\n\n\n  _createClass(Writer, [{\n    key: \"createText\",\n    value: function createText(data, attributes) {\n      return new Text(data, attributes);\n    }\n    /**\n     * Creates a new {@link module:engine/model/element~Element element}.\n     *\n     *\t\twriter.createElement( 'paragraph' );\n     *\t\twriter.createElement( 'paragraph', { alignment: 'center' } );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @returns {module:engine/model/element~Element} Created element.\n     */\n\n  }, {\n    key: \"createElement\",\n    value: function createElement(name, attributes) {\n      return new Element(name, attributes);\n    }\n    /**\n     * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n     *\n     * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.\n     */\n\n  }, {\n    key: \"createDocumentFragment\",\n    value: function createDocumentFragment() {\n      return new DocumentFragment();\n    }\n    /**\n     * Inserts item on given position.\n     *\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\twriter.insert( paragraph, position );\n     *\n     * Instead of using position you can use parent and offset:\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\twriter.insert( text, paragraph, 5 );\n     *\n     * You can also use `end` instead of the offset to insert at the end:\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\twriter.insert( text, paragraph, 'end' );\n     *\n     * Or insert before or after another element:\n     *\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\twriter.insert( paragraph, anotherParagraph, 'after' );\n     *\n     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * Note that if the item already has parent it will be removed from the previous parent.\n     *\n     * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,\n     * `model-writer-insert-forbidden-move` is thrown.\n     *\n     * If you want to move {@link module:engine/model/range~Range range} instead of an\n     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n     *\n     * **Note:** For a paste-like content insertion mechanism see\n     * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document\n     * fragment to insert.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * second parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(item, itemOrPosition) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      this._assertWriterUsedCorrectly();\n\n      if (item instanceof Text && item.data == '') {\n        return;\n      }\n\n      var position = Position._createAt(itemOrPosition, offset); // If item has a parent already.\n\n\n      if (item.parent) {\n        // We need to check if item is going to be inserted within the same document.\n        if (isSameTree(item.root, position.root)) {\n          // If it's we just need to move it.\n          this.move(Range._createOn(item), position);\n          return;\n        } // If it isn't the same root.\n        else {\n            if (item.root.document) {\n              // It is forbidden to move a node that was already in a document outside of it.\n              throw new Error('model-writer-insert-forbidden-move: Cannot move a node from a document to a different tree.');\n            } else {\n              // Move between two different document fragments or from document fragment to a document is possible.\n              // In that case, remove the item from it's original parent.\n              this.remove(item);\n            }\n          }\n      }\n\n      var version = position.root.document ? position.root.document.version : null;\n      var insert = new InsertOperation(position, item, version);\n\n      if (item instanceof Text) {\n        insert.shouldReceiveAttributes = true;\n      }\n\n      this.batch.addOperation(insert);\n      this.model.applyOperation(insert); // When element is a DocumentFragment we need to move its markers to Document#markers.\n\n      if (item instanceof DocumentFragment) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = item.markers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                markerName = _step$value[0],\n                markerRange = _step$value[1];\n\n            // We need to migrate marker range from DocumentFragment to Document.\n            var rangeRootPosition = Position._createAt(markerRange.root, 0);\n\n            var range = new Range(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));\n            this.addMarker(markerName, {\n              range: range,\n              usingOperation: true,\n              affectsData: true\n            });\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Creates and inserts text on given position. You can optionally set text attributes:\n     *\n     *\t\twriter.insertText( 'foo', position );\n     *\t\twriter.insertText( 'foo', { bold: true }, position );\n     *\n     * Instead of using position you can use parent and offset or define that text should be inserted at the end\n     * or before or after other node:\n     *\n     *\t\t// Inserts 'foo' in paragraph, at offset 5:\n     *\t\twriter.insertText( 'foo', paragraph, 5 );\n     *\t\t// Inserts 'foo' at the end of a paragraph:\n     *\t\twriter.insertText( 'foo', paragraph, 'end' );\n     *\t\t// Inserts 'foo' after an image:\n     *\t\twriter.insertText( 'foo', image, 'after' );\n     *\n     * These parameters work in the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * @param {String} data Text data.\n     * @param {Object} [attributes] Text attributes.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * third parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"insertText\",\n    value: function insertText(text, attributes, itemOrPosition, offset) {\n      if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n        this.insert(this.createText(text), attributes, itemOrPosition);\n      } else {\n        this.insert(this.createText(text, attributes), itemOrPosition, offset);\n      }\n    }\n    /**\n     * Creates and inserts element on given position. You can optionally set attributes:\n     *\n     *\t\twriter.insertElement( 'paragraph', position );\n     *\t\twriter.insertElement( 'paragraph', { alignment: 'center' }, position );\n     *\n     * Instead of using position you can use parent and offset or define that text should be inserted at the end\n     * or before or after other node:\n     *\n     *\t\t// Inserts paragraph in the root at offset 5:\n     *\t\twriter.insertElement( 'paragraph', root, 5 );\n     *\t\t// Inserts paragraph at the end of a blockquote:\n     *\t\twriter.insertElement( 'paragraph', blockquote, 'end' );\n     *\t\t// Inserts after an image:\n     *\t\twriter.insertElement( 'paragraph', image, 'after' );\n     *\n     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * third parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"insertElement\",\n    value: function insertElement(name, attributes, itemOrPosition, offset) {\n      if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n        this.insert(this.createElement(name), attributes, itemOrPosition);\n      } else {\n        this.insert(this.createElement(name, attributes), itemOrPosition, offset);\n      }\n    }\n    /**\n     * Inserts item at the end of the given parent.\n     *\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\twriter.append( paragraph, root );\n     *\n     * Note that if the item already has parent it will be removed from the previous parent.\n     *\n     * If you want to move {@link module:engine/model/range~Range range} instead of an\n     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}\n     * item Item or document fragment to insert.\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n     */\n\n  }, {\n    key: \"append\",\n    value: function append(item, parent) {\n      this.insert(item, parent, 'end');\n    }\n    /**\n     * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:\n     *\n     *\t\twriter.appendText( 'foo', paragraph );\n     *\t\twriter.appendText( 'foo', { bold: true }, paragraph );\n     *\n     * @param {String} text Text data.\n     * @param {Object} [attributes] Text attributes.\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n     */\n\n  }, {\n    key: \"appendText\",\n    value: function appendText(text, attributes, parent) {\n      if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n        this.insert(this.createText(text), attributes, 'end');\n      } else {\n        this.insert(this.createText(text, attributes), parent, 'end');\n      }\n    }\n    /**\n     * Creates element and inserts it at the end of the parent. You can optionally set attributes:\n     *\n     *\t\twriter.appendElement( 'paragraph', root );\n     *\t\twriter.appendElement( 'paragraph', { alignment: 'center' }, root );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n     */\n\n  }, {\n    key: \"appendElement\",\n    value: function appendElement(name, attributes, parent) {\n      if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n        this.insert(this.createElement(name), attributes, 'end');\n      } else {\n        this.insert(this.createElement(name, attributes), parent, 'end');\n      }\n    }\n    /**\n     * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}\n     * or on a {@link module:engine/model/range~Range range}.\n     *\n     * @param {String} key Attribute key.\n     * @param {*} value Attribute new value.\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range on which the attribute will be set.\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value, itemOrRange) {\n      this._assertWriterUsedCorrectly();\n\n      if (itemOrRange instanceof Range) {\n        var ranges = itemOrRange.getMinimalFlatRanges();\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var range = _step2.value;\n            setAttributeOnRange(this, key, value, range);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } else {\n        setAttributeOnItem(this, key, value, itemOrRange);\n      }\n    }\n    /**\n     * Sets values of attributes on a {@link module:engine/model/item~Item model item}\n     * or on a {@link module:engine/model/range~Range range}.\n     *\n     *\t\twriter.setAttributes( {\n     *\t\t\tbold: true,\n     *\t\t\titalic: true\n     *\t\t}, range );\n     *\n     * @param {Object} attributes Attributes keys and values.\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range on which the attributes will be set.\n     */\n\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(attributes, itemOrRange) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = toMap(attributes)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              key = _step3$value[0],\n              val = _step3$value[1];\n\n          this.setAttribute(key, val, itemOrRange);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n    /**\n     * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}\n     * or from a {@link module:engine/model/range~Range range}.\n     *\n     * @param {String} key Attribute key.\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range from which the attribute will be removed.\n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key, itemOrRange) {\n      this._assertWriterUsedCorrectly();\n\n      if (itemOrRange instanceof Range) {\n        var ranges = itemOrRange.getMinimalFlatRanges();\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = ranges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var range = _step4.value;\n            setAttributeOnRange(this, key, null, range);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      } else {\n        setAttributeOnItem(this, key, null, itemOrRange);\n      }\n    }\n    /**\n     * Removes all attributes from all elements in the range or from the given item.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range from which all attributes will be removed.\n     */\n\n  }, {\n    key: \"clearAttributes\",\n    value: function clearAttributes(itemOrRange) {\n      var _this = this;\n\n      this._assertWriterUsedCorrectly();\n\n      var removeAttributesFromItem = function removeAttributesFromItem(item) {\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = item.getAttributeKeys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var attribute = _step5.value;\n\n            _this.removeAttribute(attribute, item);\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      };\n\n      if (!(itemOrRange instanceof Range)) {\n        removeAttributesFromItem(itemOrRange);\n      } else {\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = itemOrRange.getItems()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var item = _step6.value;\n            removeAttributesFromItem(item);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Moves all items in the source range to the target position.\n     *\n     *\t\twriter.move( sourceRange, targetPosition );\n     *\n     * Instead of the target position you can use parent and offset or define that range should be moved to the end\n     * or before or after chosen item:\n     *\n     *\t\t// Moves all items in the range to the paragraph at offset 5:\n     *\t\twriter.move( sourceRange, paragraph, 5 );\n     *\t\t// Moves all items in the range to the end of a blockquote:\n     *\t\twriter.move( sourceRange, blockquote, 'end' );\n     *\t\t// Moves all items in the range to a position after an image:\n     *\t\twriter.move( sourceRange, image, 'after' );\n     *\n     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * Note that items can be moved only within the same tree. It means that you can move items within the same root\n     * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},\n     * but you can not move items from document fragment to the document or from one detached element to another. Use\n     * {@link module:engine/model/writer~Writer#insert} in such cases.\n     *\n     * @param {module:engine/model/range~Range} range Source range.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * second parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(range, itemOrPosition, offset) {\n      this._assertWriterUsedCorrectly();\n\n      if (!(range instanceof Range)) {\n        /**\n         * Invalid range to move.\n         *\n         * @error writer-move-invalid-range\n         */\n        throw new CKEditorError('writer-move-invalid-range: Invalid range to move.');\n      }\n\n      if (!range.isFlat) {\n        /**\n         * Range to move is not flat.\n         *\n         * @error writer-move-range-not-flat\n         */\n        throw new CKEditorError('writer-move-range-not-flat: Range to move is not flat.');\n      }\n\n      var position = Position._createAt(itemOrPosition, offset); // Do not move anything if the move target is same as moved range start.\n\n\n      if (position.isEqual(range.start)) {\n        return;\n      } // If part of the marker is removed, create additional marker operation for undo purposes.\n\n\n      this._addOperationForAffectedMarkers('move', range);\n\n      if (!isSameTree(range.root, position.root)) {\n        /**\n         * Range is going to be moved within not the same document. Please use\n         * {@link module:engine/model/writer~Writer#insert insert} instead.\n         *\n         * @error writer-move-different-document\n         */\n        throw new CKEditorError('writer-move-different-document: Range is going to be moved between different documents.');\n      }\n\n      var version = range.root.document ? range.root.document.version : null;\n      var operation = new MoveOperation(range.start, range.end.offset - range.start.offset, position, version);\n      this.batch.addOperation(operation);\n      this.model.applyOperation(operation);\n    }\n    /**\n     * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(itemOrRange) {\n      this._assertWriterUsedCorrectly();\n\n      var rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn(itemOrRange);\n      var ranges = rangeToRemove.getMinimalFlatRanges().reverse();\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = ranges[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var flat = _step7.value;\n\n          // If part of the marker is removed, create additional marker operation for undo purposes.\n          this._addOperationForAffectedMarkers('move', flat);\n\n          applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n    /**\n     * Merges two siblings at the given position.\n     *\n     * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or\n     * `writer-merge-no-element-after` error will be thrown.\n     *\n     * @param {module:engine/model/position~Position} position Position between merged elements.\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(position) {\n      this._assertWriterUsedCorrectly();\n\n      var nodeBefore = position.nodeBefore;\n      var nodeAfter = position.nodeAfter; // If part of the marker is removed, create additional marker operation for undo purposes.\n\n      this._addOperationForAffectedMarkers('merge', position);\n\n      if (!(nodeBefore instanceof Element)) {\n        /**\n         * Node before merge position must be an element.\n         *\n         * @error writer-merge-no-element-before\n         */\n        throw new CKEditorError('writer-merge-no-element-before: Node before merge position must be an element.');\n      }\n\n      if (!(nodeAfter instanceof Element)) {\n        /**\n         * Node after merge position must be an element.\n         *\n         * @error writer-merge-no-element-after\n         */\n        throw new CKEditorError('writer-merge-no-element-after: Node after merge position must be an element.');\n      }\n\n      if (!position.root.document) {\n        this._mergeDetached(position);\n      } else {\n        this._merge(position);\n      }\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n     * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * See {@link module:engine/model/position~PositionStickiness}.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionFromPath\",\n    value: function createPositionFromPath(root, path, stickiness) {\n      return this.model.createPositionFromPath(root, path, stickiness);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAt\",\n    value: function createPositionAt(itemOrPosition, offset) {\n      return this.model.createPositionAt(itemOrPosition, offset);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAfter\",\n    value: function createPositionAfter(item) {\n      return this.model.createPositionAfter(item);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionBefore\",\n    value: function createPositionBefore(item) {\n      return this.model.createPositionBefore(item);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.\n     *\n     * @param {module:engine/model/position~Position} start Start position.\n     * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRange\",\n    value: function createRange(start, end) {\n      return this.model.createRange(start, end);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.\n     *\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRangeIn\",\n    value: function createRangeIn(element) {\n      return this.model.createRangeIn(element);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.\n     *\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRangeOn\",\n    value: function createRangeOn(element) {\n      return this.model.createRangeOn(element);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createSelection `Model#createSelection()`}.\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @returns {module:engine/model/selection~Selection}\n     */\n\n  }, {\n    key: \"createSelection\",\n    value: function createSelection(selectable, placeOrOffset, options) {\n      return this.model.createSelection(selectable, placeOrOffset, options);\n    }\n    /**\n     * Performs merge action in a detached tree.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position Position between merged elements.\n     */\n\n  }, {\n    key: \"_mergeDetached\",\n    value: function _mergeDetached(position) {\n      var nodeBefore = position.nodeBefore;\n      var nodeAfter = position.nodeAfter;\n      this.move(Range._createIn(nodeAfter), Position._createAt(nodeBefore, 'end'));\n      this.remove(nodeAfter);\n    }\n    /**\n     * Performs merge action in a non-detached tree.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position Position between merged elements.\n     */\n\n  }, {\n    key: \"_merge\",\n    value: function _merge(position) {\n      var targetPosition = Position._createAt(position.nodeBefore, 'end');\n\n      var sourcePosition = Position._createAt(position.nodeAfter, 0);\n\n      var graveyard = position.root.document.graveyard;\n      var graveyardPosition = new Position(graveyard, [0]);\n      var version = position.root.document.version;\n      var merge = new MergeOperation(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version);\n      this.batch.addOperation(merge);\n      this.model.applyOperation(merge);\n    }\n    /**\n     * Renames the given element.\n     *\n     * @param {module:engine/model/element~Element} element The element to rename.\n     * @param {String} newName New element name.\n     */\n\n  }, {\n    key: \"rename\",\n    value: function rename(element, newName) {\n      this._assertWriterUsedCorrectly();\n\n      if (!(element instanceof Element)) {\n        /**\n         * Trying to rename an object which is not an instance of Element.\n         *\n         * @error writer-rename-not-element-instance\n         */\n        throw new CKEditorError('writer-rename-not-element-instance: Trying to rename an object which is not an instance of Element.');\n      }\n\n      var version = element.root.document ? element.root.document.version : null;\n      var renameOperation = new RenameOperation(Position._createBefore(element), element.name, newName, version);\n      this.batch.addOperation(renameOperation);\n      this.model.applyOperation(renameOperation);\n    }\n    /**\n     * Splits elements starting from the given position and going to the top of the model tree as long as given\n     * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.\n     *\n     * The element needs to have a parent. It cannot be a root element nor a document fragment.\n     * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.\n     *\n     * @param {module:engine/model/position~Position} position Position of split.\n     * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.\n     * @returns {Object} result Split result.\n     * @returns {module:engine/model/position~Position} result.position Position between split elements.\n     * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ends\n     * at the beginning of the first copy element.\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(position, limitElement) {\n      this._assertWriterUsedCorrectly();\n\n      var splitElement = position.parent;\n\n      if (!splitElement.parent) {\n        /**\n         * Element with no parent can not be split.\n         *\n         * @error writer-split-element-no-parent\n         */\n        throw new CKEditorError('writer-split-element-no-parent: Element with no parent can not be split.');\n      } // When limit element is not defined lets set splitElement parent as limit.\n\n\n      if (!limitElement) {\n        limitElement = splitElement.parent;\n      }\n\n      if (!position.parent.getAncestors({\n        includeSelf: true\n      }).includes(limitElement)) {\n        throw new CKEditorError('writer-split-invalid-limit-element: Limit element is not a position ancestor.');\n      } // We need to cache elements that will be created as a result of the first split because\n      // we need to create a range from the end of the first split element to the beginning of the\n      // first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.\n\n\n      var firstSplitElement, firstCopyElement;\n\n      do {\n        var version = splitElement.root.document ? splitElement.root.document.version : null;\n        var howMany = splitElement.maxOffset - position.offset;\n        var split = new SplitOperation(position, howMany, null, version);\n        this.batch.addOperation(split);\n        this.model.applyOperation(split); // Cache result of the first split.\n\n        if (!firstSplitElement && !firstCopyElement) {\n          firstSplitElement = splitElement;\n          firstCopyElement = position.parent.nextSibling;\n        }\n\n        position = this.createPositionAfter(position.parent);\n        splitElement = position.parent;\n      } while (splitElement !== limitElement);\n\n      return {\n        position: position,\n        range: new Range(Position._createAt(firstSplitElement, 'end'), Position._createAt(firstCopyElement, 0))\n      };\n    }\n    /**\n     * Wraps the given range with the given element or with a new element (if a string was passed).\n     *\n     * **Note:** range to wrap should be a \"flat range\" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).\n     * If not, an error will be thrown.\n     *\n     * @param {module:engine/model/range~Range} range Range to wrap.\n     * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.\n     */\n\n  }, {\n    key: \"wrap\",\n    value: function wrap(range, elementOrString) {\n      this._assertWriterUsedCorrectly();\n\n      if (!range.isFlat) {\n        /**\n         * Range to wrap is not flat.\n         *\n         * @error writer-wrap-range-not-flat\n         */\n        throw new CKEditorError('writer-wrap-range-not-flat: Range to wrap is not flat.');\n      }\n\n      var element = elementOrString instanceof Element ? elementOrString : new Element(elementOrString);\n\n      if (element.childCount > 0) {\n        /**\n         * Element to wrap with is not empty.\n         *\n         * @error writer-wrap-element-not-empty\n         */\n        throw new CKEditorError('writer-wrap-element-not-empty: Element to wrap with is not empty.');\n      }\n\n      if (element.parent !== null) {\n        /**\n         * Element to wrap with is already attached to a tree model.\n         *\n         * @error writer-wrap-element-attached\n         */\n        throw new CKEditorError('writer-wrap-element-attached: Element to wrap with is already attached to tree model.');\n      }\n\n      this.insert(element, range.start); // Shift the range-to-wrap because we just inserted an element before that range.\n\n      var shiftedRange = new Range(range.start.getShiftedBy(1), range.end.getShiftedBy(1));\n      this.move(shiftedRange, Position._createAt(element, 0));\n    }\n    /**\n     * Unwraps children of the given element  all its children are moved before it and then the element is removed.\n     * Throws error if you try to unwrap an element which does not have a parent.\n     *\n     * @param {module:engine/model/element~Element} element Element to unwrap.\n     */\n\n  }, {\n    key: \"unwrap\",\n    value: function unwrap(element) {\n      this._assertWriterUsedCorrectly();\n\n      if (element.parent === null) {\n        /**\n         * Trying to unwrap an element which has no parent.\n         *\n         * @error writer-unwrap-element-no-parent\n         */\n        throw new CKEditorError('writer-unwrap-element-no-parent: Trying to unwrap an element which has no parent.');\n      }\n\n      this.move(Range._createIn(element), this.createPositionAfter(element));\n      this.remove(element);\n    }\n    /**\n     * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n     * changes in the document and updates its range automatically, when model tree changes.\n     *\n     * As the first parameter you can set marker name.\n     *\n     * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See\n     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n     * markers managed by operations and not-managed by operations.\n     *\n     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n     * `true` when the marker change changes the data returned by the\n     * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n     *\n     * Create marker directly base on marker's name:\n     *\n     *\t\taddMarker( markerName, { range, usingOperation: false } );\n     *\n     * Create marker using operation:\n     *\n     *\t\taddMarker( markerName, { range, usingOperation: true } );\n     *\n     * Create marker that affects the editor data:\n     *\n     *\t\taddMarker( markerName, { range, usingOperation: false, affectsData: true } );\n     *\n     * Note: For efficiency reasons, it's best to create and keep as little markers as possible.\n     *\n     * @see module:engine/model/markercollection~Marker\n     * @param {String} name Name of a marker to create - must be unique.\n     * @param {Object} options\n     * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.\n     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n     * @param {module:engine/model/range~Range} options.range Marker range.\n     * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.\n     * @returns {module:engine/model/markercollection~Marker} Marker that was set.\n     */\n\n  }, {\n    key: \"addMarker\",\n    value: function addMarker(name, options) {\n      this._assertWriterUsedCorrectly();\n\n      if (!options || typeof options.usingOperation != 'boolean') {\n        /**\n         * The `options.usingOperation` parameter is required when adding a new marker.\n         *\n         * @error writer-addMarker-no-usingOperation\n         */\n        throw new CKEditorError('writer-addMarker-no-usingOperation: The options.usingOperation parameter is required when adding a new marker.');\n      }\n\n      var usingOperation = options.usingOperation;\n      var range = options.range;\n      var affectsData = options.affectsData === undefined ? false : options.affectsData;\n\n      if (this.model.markers.has(name)) {\n        /**\n         * Marker with provided name already exists.\n         *\n         * @error writer-addMarker-marker-exists\n         */\n        throw new CKEditorError('writer-addMarker-marker-exists: Marker with provided name already exists.');\n      }\n\n      if (!range) {\n        /**\n         * Range parameter is required when adding a new marker.\n         *\n         * @error writer-addMarker-no-range\n         */\n        throw new CKEditorError('writer-addMarker-no-range: Range parameter is required when adding a new marker.');\n      }\n\n      if (!usingOperation) {\n        return this.model.markers._set(name, range, usingOperation, affectsData);\n      }\n\n      applyMarkerOperation(this, name, null, range, affectsData);\n      return this.model.markers.get(name);\n    }\n    /**\n     * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n     * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the\n     * marker's range directly using this method.\n     *\n     * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique\n     * name is created and returned.\n     *\n     * As the second parameter you can set the new marker data or leave this parameter as empty which will just refresh\n     * the marker by triggering downcast conversion for it. Refreshing the marker is useful when you want to change\n     * the marker {@link module:engine/view/element~Element view element} without changing any marker data.\n     *\n     * \t\tlet isCommentActive = false;\n     *\n     * \t\tmodel.conversion.markerToHighlight( {\n     * \t\t\tmodel: 'comment',\n     *\t\t\tview: data => {\n     *\t\t\t\tconst classes = [ 'comment-marker' ];\n     *\n     *\t\t\t\tif ( isCommentActive ) {\n     *\t\t\t\t\tclasses.push( 'comment-marker--active' );\n     *\t\t\t\t}\n     *\n     *\t\t\t\treturn { classes };\n     *\t\t\t}\n     * \t\t} );\n     *\n     * \t\t// Change the property that indicates if marker is displayed as active or not.\n     * \t\tisCommentActive = true;\n     *\n     * \t\t// And refresh the marker to convert it with additional class.\n     * \t\tmodel.change( writer => writer.updateMarker( 'comment' ) );\n     *\n     * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See\n     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n     * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.\n     *\n     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n     * `true` when the marker change changes the data returned by\n     * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n     *\n     * Update marker directly base on marker's name:\n     *\n     *\t\tupdateMarker( markerName, { range } );\n     *\n     * Update marker using operation:\n     *\n     *\t\tupdateMarker( marker, { range, usingOperation: true } );\n     *\t\tupdateMarker( markerName, { range, usingOperation: true } );\n     *\n     * Change marker's option (start using operations to manage it):\n     *\n     *\t\tupdateMarker( marker, { usingOperation: true } );\n     *\n     * Change marker's option (inform the engine, that the marker does not affect the data anymore):\n     *\n     *\t\tupdateMarker( markerName, { affectsData: false } );\n     *\n     * @see module:engine/model/markercollection~Marker\n     * @param {String} markerOrName Name of a marker to update, or a marker instance.\n     * @param {Object} [options] If options object is not defined then marker will be refreshed by triggering\n     * downcast conversion for this marker with the same data.\n     * @param {module:engine/model/range~Range} [options.range] Marker range to update.\n     * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.\n     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n     * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.\n     */\n\n  }, {\n    key: \"updateMarker\",\n    value: function updateMarker(markerOrName, options) {\n      this._assertWriterUsedCorrectly();\n\n      var markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n      var currentMarker = this.model.markers.get(markerName);\n\n      if (!currentMarker) {\n        /**\n         * Marker with provided name does not exists.\n         *\n         * @error writer-updateMarker-marker-not-exists\n         */\n        throw new CKEditorError('writer-updateMarker-marker-not-exists: Marker with provided name does not exists.');\n      }\n\n      if (!options) {\n        this.model.markers._refresh(currentMarker);\n\n        return;\n      }\n\n      var hasUsingOperationDefined = typeof options.usingOperation == 'boolean';\n      var affectsDataDefined = typeof options.affectsData == 'boolean'; // Use previously defined marker's affectsData if the property is not provided.\n\n      var affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;\n\n      if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {\n        /**\n         * One of the options is required - provide range, usingOperations or affectsData.\n         *\n         * @error writer-updateMarker-wrong-options\n         */\n        throw new CKEditorError('writer-updateMarker-wrong-options: One of the options is required - provide range, usingOperations or affectsData.');\n      }\n\n      var currentRange = currentMarker.getRange();\n      var updatedRange = options.range ? options.range : currentRange;\n\n      if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {\n        // The marker type is changed so it's necessary to create proper operations.\n        if (options.usingOperation) {\n          // If marker changes to a managed one treat this as synchronizing existing marker.\n          // Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.\n          applyMarkerOperation(this, markerName, null, updatedRange, affectsData);\n        } else {\n          // If marker changes to a marker that do not use operations then we need to create additional operation\n          // that removes that marker first.\n          applyMarkerOperation(this, markerName, currentRange, null, affectsData); // Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.\n\n          this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n        }\n\n        return;\n      } // Marker's type doesn't change so update it accordingly.\n\n\n      if (currentMarker.managedUsingOperations) {\n        applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);\n      } else {\n        this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n      }\n    }\n    /**\n     * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.\n     * The marker is removed accordingly to how it has been created, so if the marker was created using operation,\n     * it will be destroyed using operation.\n     *\n     * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.\n     */\n\n  }, {\n    key: \"removeMarker\",\n    value: function removeMarker(markerOrName) {\n      this._assertWriterUsedCorrectly();\n\n      var name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\n      if (!this.model.markers.has(name)) {\n        /**\n         * Trying to remove marker which does not exist.\n         *\n         * @error writer-removeMarker-no-marker\n         */\n        throw new CKEditorError('writer-removeMarker-no-marker: Trying to remove marker which does not exist.');\n      }\n\n      var marker = this.model.markers.get(name);\n\n      if (!marker.managedUsingOperations) {\n        this.model.markers._remove(name);\n\n        return;\n      }\n\n      var oldRange = marker.getRange();\n      applyMarkerOperation(this, name, oldRange, null, marker.affectsData);\n    }\n    /**\n     * Sets the document's selection (ranges and direction) to the specified location based on the given\n     * {@link module:engine/model/selection~Selectable selectable} or creates an empty selection if no arguments were passed.\n     *\n     *\t\t// Sets selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\twriter.setSelection( range );\n     *\n     *\t\t// Sets selection to given ranges.\n     *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\twriter.setSelection( range );\n     *\n     *\t\t// Sets selection to other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\twriter.setSelection( otherSelection );\n     *\n     *\t\t// Sets selection to the given document selection.\n     *\t\tconst documentSelection = model.document.selection;\n     *\t\twriter.setSelection( documentSelection );\n     *\n     *\t\t// Sets collapsed selection at the given position.\n     *\t\tconst position = writer.createPosition( root, path );\n     *\t\twriter.setSelection( position );\n     *\n     *\t\t// Sets collapsed selection at the position of the given node and an offset.\n     *\t\twriter.setSelection( paragraph, offset );\n     *\n     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n    \t * that element and ends after the last child of that element.\n     *\n     *\t\twriter.setSelection( paragraph, 'in' );\n     *\n     * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n     *\n     *\t\twriter.setSelection( paragraph, 'on' );\n     *\n     *\t\t// Removes all selection's ranges.\n     *\t\twriter.setSelection( null );\n     *\n     * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.\n     *\n     *\t\t// Sets selection as backward.\n     *\t\twriter.setSelection( range, { backward: true } );\n     *\n     * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     */\n\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selectable, placeOrOffset, options) {\n      this._assertWriterUsedCorrectly();\n\n      this.model.document.selection._setTo(selectable, placeOrOffset, options);\n    }\n    /**\n     * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n     *\n     * The location can be specified in the same form as\n     * {@link #createPositionAt `writer.createPositionAt()`} parameters.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"setSelectionFocus\",\n    value: function setSelectionFocus(itemOrPosition, offset) {\n      this._assertWriterUsedCorrectly();\n\n      this.model.document.selection._setFocus(itemOrPosition, offset);\n    }\n    /**\n     * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.\n     *\n     * Using key and value pair:\n     *\n     * \twriter.setSelectionAttribute( 'italic', true );\n     *\n     * Using key-value object:\n     *\n     * \twriter.setSelectionAttribute( { italic: true, bold: false } );\n     *\n     * Using iterable object:\n     *\n     * \twriter.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );\n     *\n     * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set\n     * or object / iterable of key => value attribute pairs.\n     * @param {*} [value] Attribute value.\n     */\n\n  }, {\n    key: \"setSelectionAttribute\",\n    value: function setSelectionAttribute(keyOrObjectOrIterable, value) {\n      this._assertWriterUsedCorrectly();\n\n      if (typeof keyOrObjectOrIterable === 'string') {\n        this._setSelectionAttribute(keyOrObjectOrIterable, value);\n      } else {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = toMap(keyOrObjectOrIterable)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var _step8$value = _slicedToArray(_step8.value, 2),\n                key = _step8$value[0],\n                _value = _step8$value[1];\n\n            this._setSelectionAttribute(key, _value);\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Removes attribute(s) with given key(s) from the selection.\n     *\n     * Remove one attribute:\n     *\n     *\t\twriter.removeSelectionAttribute( 'italic' );\n     *\n     * Remove multiple attributes:\n     *\n     *\t\twriter.removeSelectionAttribute( [ 'italic', 'bold' ] );\n     *\n     * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.\n     */\n\n  }, {\n    key: \"removeSelectionAttribute\",\n    value: function removeSelectionAttribute(keyOrIterableOfKeys) {\n      this._assertWriterUsedCorrectly();\n\n      if (typeof keyOrIterableOfKeys === 'string') {\n        this._removeSelectionAttribute(keyOrIterableOfKeys);\n      } else {\n        var _iteratorNormalCompletion9 = true;\n        var _didIteratorError9 = false;\n        var _iteratorError9 = undefined;\n\n        try {\n          for (var _iterator9 = keyOrIterableOfKeys[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n            var key = _step9.value;\n\n            this._removeSelectionAttribute(key);\n          }\n        } catch (err) {\n          _didIteratorError9 = true;\n          _iteratorError9 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n              _iterator9.return();\n            }\n          } finally {\n            if (_didIteratorError9) {\n              throw _iteratorError9;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}\n     * of the selection from left to right.\n     *\n     * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,\n     * then the selection (after being moved by the user) inherits attributes from its left-hand side.\n     * This method allows to temporarily override this behavior by forcing the gravity to the right.\n     *\n     * For the following model fragment:\n     *\n     *\t\t<$text bold=\"true\" linkHref=\"url\">bar[]</$text><$text bold=\"true\">biz</$text>\n     *\n     * * Default gravity: selection will have the `bold` and `linkHref` attributes.\n     * * Overridden gravity: selection will have `bold` attribute.\n     *\n     * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n     * of the process.\n     *\n     * @returns {String} The unique id which allows restoring the gravity.\n     */\n\n  }, {\n    key: \"overrideSelectionGravity\",\n    value: function overrideSelectionGravity() {\n      return this.model.document.selection._overrideGravity();\n    }\n    /**\n     * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.\n     *\n     * Restoring the gravity is only possible using the unique identifier returned by\n     * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored\n     * the same number of times it was overridden.\n     *\n     * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.\n     */\n\n  }, {\n    key: \"restoreSelectionGravity\",\n    value: function restoreSelectionGravity(uid) {\n      this.model.document.selection._restoreGravity(uid);\n    }\n    /**\n     * @private\n     * @param {String} key Key of the attribute to remove.\n     * @param {*} value Attribute value.\n     */\n\n  }, {\n    key: \"_setSelectionAttribute\",\n    value: function _setSelectionAttribute(key, value) {\n      var selection = this.model.document.selection; // Store attribute in parent element if the selection is collapsed in an empty node.\n\n      if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n        var storeKey = DocumentSelection._getStoreAttributeKey(key);\n\n        this.setAttribute(storeKey, value, selection.anchor.parent);\n      }\n\n      selection._setAttribute(key, value);\n    }\n    /**\n     * @private\n     * @param {String} key Key of the attribute to remove.\n     */\n\n  }, {\n    key: \"_removeSelectionAttribute\",\n    value: function _removeSelectionAttribute(key) {\n      var selection = this.model.document.selection; // Remove stored attribute from parent element if the selection is collapsed in an empty node.\n\n      if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n        var storeKey = DocumentSelection._getStoreAttributeKey(key);\n\n        this.removeAttribute(storeKey, selection.anchor.parent);\n      }\n\n      selection._removeAttribute(key);\n    }\n    /**\n     * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_assertWriterUsedCorrectly\",\n    value: function _assertWriterUsedCorrectly() {\n      /**\n       * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()` or\n       * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.\n       *\n       * The writer can only be used inside these blocks which ensures that the model\n       * can only be changed during such \"sessions\".\n       *\n       * @error writer-incorrect-use\n       */\n      if (this.model._currentWriter !== this) {\n        throw new CKEditorError('writer-incorrect-use: Trying to use a writer outside the change() block.');\n      }\n    }\n    /**\n     * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers\n     * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range\n     * can be later correctly processed during undo.\n     *\n     * @private\n     * @param {'move'|'merge'} type Writer action type.\n     * @param {module:engine/model/position~Position|module:engine/model/range~Range} positionOrRange Position or range\n     * where the writer action happens.\n     */\n\n  }, {\n    key: \"_addOperationForAffectedMarkers\",\n    value: function _addOperationForAffectedMarkers(type, positionOrRange) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = this.model.markers[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var marker = _step10.value;\n\n          if (!marker.managedUsingOperations) {\n            continue;\n          }\n\n          var markerRange = marker.getRange();\n          var isAffected = false;\n\n          if (type == 'move') {\n            isAffected = positionOrRange.containsPosition(markerRange.start) || positionOrRange.start.isEqual(markerRange.start) || positionOrRange.containsPosition(markerRange.end) || positionOrRange.end.isEqual(markerRange.end);\n          } else {\n            // if type == 'merge'.\n            var elementBefore = positionOrRange.nodeBefore;\n            var elementAfter = positionOrRange.nodeAfter; //               Start:  <p>Foo[</p><p>Bar]</p>\n            //         After merge:  <p>Foo[Bar]</p>\n            // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n            //\n\n            var affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd; //               Start:  <p>[Foo</p><p>]Bar</p>\n            //         After merge:  <p>[Foo]Bar</p>\n            // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n            //\n\n            var affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0; //               Start:  <p>[Foo</p>]<p>Bar</p>\n            //         After merge:  <p>[Foo]Bar</p>\n            // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n            //\n\n            var affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter; //               Start:  <p>Foo</p>[<p>Bar]</p>\n            //         After merge:  <p>Foo[Bar]</p>\n            // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n            //\n\n            var affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;\n            isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;\n          }\n\n          if (isAffected) {\n            this.updateMarker(marker.name, {\n              range: markerRange\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Writer;\n}(); // Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.\n//\n// Because attribute operation needs to have the same attribute value on the whole range, this function splits\n// the range into smaller parts.\n//\n// Given `range` must be flat.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.\n\n\nexport { Writer as default };\n\nfunction setAttributeOnRange(writer, key, value, range) {\n  var model = writer.model;\n  var doc = model.document; // Position of the last split, the beginning of the new range.\n\n  var lastSplitPosition = range.start; // Currently position in the scanning range. Because we need value after the position, it is not a current\n  // position of the iterator but the previous one (we need to iterate one more time to get the value after).\n\n  var position; // Value before the currently position.\n\n  var valueBefore; // Value after the currently position.\n\n  var valueAfter;\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = range.getWalker({\n      shallow: true\n    })[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var val = _step11.value;\n      valueAfter = val.item.getAttribute(key); // At the first run of the iterator the position in undefined. We also do not have a valueBefore, but\n      // because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).\n\n      if (position && valueBefore != valueAfter) {\n        // if valueBefore == value there is nothing to change, so we add operation only if these values are different.\n        if (valueBefore != value) {\n          addOperation();\n        }\n\n        lastSplitPosition = position;\n      }\n\n      position = val.nextPosition;\n      valueBefore = valueAfter;\n    } // Because position in the loop is not the iterator position (see let position comment), the last position in\n    // the while loop will be last but one position in the range. We need to check the last position manually.\n\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n\n  if (position instanceof Position && position != lastSplitPosition && valueBefore != value) {\n    addOperation();\n  }\n\n  function addOperation() {\n    var range = new Range(lastSplitPosition, position);\n    var version = range.root.document ? doc.version : null;\n    var operation = new AttributeOperation(range, key, valueBefore, value, version);\n    writer.batch.addOperation(operation);\n    model.applyOperation(operation);\n  }\n} // Sets given attribute to the given node. When attribute value is null then attribute will be removed.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\n\n\nfunction setAttributeOnItem(writer, key, value, item) {\n  var model = writer.model;\n  var doc = model.document;\n  var previousValue = item.getAttribute(key);\n  var range, operation;\n\n  if (previousValue != value) {\n    var isRootChanged = item.root === item;\n\n    if (isRootChanged) {\n      // If we change attributes of root element, we have to use `RootAttributeOperation`.\n      var version = item.document ? doc.version : null;\n      operation = new RootAttributeOperation(item, key, previousValue, value, version);\n    } else {\n      range = new Range(Position._createBefore(item), writer.createPositionAfter(item));\n\n      var _version = range.root.document ? doc.version : null;\n\n      operation = new AttributeOperation(range, key, previousValue, value, _version);\n    }\n\n    writer.batch.addOperation(operation);\n    model.applyOperation(operation);\n  }\n} // Creates and applies marker operation to {@link module:engine/model/operation/operation~Operation operation}.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} name Marker name.\n// @param {module:engine/model/range~Range} oldRange Marker range before the change.\n// @param {module:engine/model/range~Range} newRange Marker range after the change.\n// @param {Boolean} affectsData\n\n\nfunction applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {\n  var model = writer.model;\n  var doc = model.document;\n  var operation = new MarkerOperation(name, oldRange, newRange, model.markers, affectsData, doc.version);\n  writer.batch.addOperation(operation);\n  model.applyOperation(operation);\n} // Creates `MoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.\n// The operation will be applied on given model instance and added to given operation instance.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position from which nodes are removed.\n// @param {Number} howMany Number of nodes to remove.\n// @param {Batch} batch Batch to which the operation will be added.\n// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.\n\n\nfunction applyRemoveOperation(position, howMany, batch, model) {\n  var operation;\n\n  if (position.root.document) {\n    var doc = model.document;\n    var graveyardPosition = new Position(doc.graveyard, [0]);\n    operation = new MoveOperation(position, howMany, graveyardPosition, doc.version);\n  } else {\n    operation = new DetachOperation(position, howMany);\n  }\n\n  batch.addOperation(operation);\n  model.applyOperation(operation);\n} // Returns `true` if both root elements are the same element or both are documents root elements.\n//\n// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or\n// within the same document fragment), but when element supposed to be moved from document fragment to the document, or\n// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or\n// collaboration may track changes on the document but ignore changes on detached fragments and should not get\n// unexpected `move` operation.\n\n\nfunction isSameTree(rootA, rootB) {\n  // If it is the same root this is the same tree.\n  if (rootA === rootB) {\n    return true;\n  } // If both roots are documents root it is operation within the document what we still treat as the same tree.\n\n\n  if (rootA instanceof RootElement && rootB instanceof RootElement) {\n    return true;\n  }\n\n  return false;\n}","import \"core-js/modules/es6.string.repeat\";\nimport \"core-js/modules/es6.regexp.split\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.array.from\";\nimport _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/differ\n */\nimport Position from \"./position\";\nimport Range from \"./range\";\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\n\nvar Differ =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a `Differ` instance.\n   *\n   * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n   */\n  function Differ(markerCollection) {\n    _classCallCheck(this, Differ);\n\n    /**\n     * Reference to the model's marker collection.\n     *\n     * @private\n     * @type {module:engine/model/markercollection~MarkerCollection}\n     */\n    this._markerCollection = markerCollection;\n    /**\n     * A map that stores changes that happened in a given element.\n     *\n     * The keys of the map are references to the model elements.\n     * The values of the map are arrays with changes that were done on this element.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._changesInElement = new Map();\n    /**\n     * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n     * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n     * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._elementSnapshots = new Map();\n    /**\n     * A map that stores all changed markers.\n     *\n     * The keys of the map are marker names.\n     * The values of the map are objects with the `oldRange` and `newRange` properties. They store the marker range\n     * state before and after the change.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._changedMarkers = new Map();\n    /**\n     * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n     * when changes are sorted.\n     *\n     * @private\n     * @type {Number}\n     */\n\n    this._changeCount = 0;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n     * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores those changes that did not take place in graveyard root.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n\n    this._cachedChanges = null;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n     * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n\n    this._cachedChangesWithGraveyard = null;\n  }\n  /**\n   * Informs whether there are any changes buffered in `Differ`.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  _createClass(Differ, [{\n    key: \"bufferOperation\",\n\n    /**\n     * Buffers the given operation. An operation has to be buffered before it is executed.\n     *\n     * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n     * in the state before the operation is executed.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n     */\n    value: function bufferOperation(operation) {\n      // Below we take an operation, check its type, then use its parameters in marking (private) methods.\n      // The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n      // Marking changes in them would cause a \"double\" changing then.\n      //\n      switch (operation.type) {\n        case 'insert':\n          {\n            if (this._isInInsertedElement(operation.position.parent)) {\n              return;\n            }\n\n            this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);\n\n            break;\n          }\n\n        case 'addAttribute':\n        case 'removeAttribute':\n        case 'changeAttribute':\n          {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = operation.range.getItems()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var item = _step.value;\n\n                if (this._isInInsertedElement(item.parent)) {\n                  continue;\n                }\n\n                this._markAttribute(item);\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            break;\n          }\n\n        case 'remove':\n        case 'move':\n        case 'reinsert':\n          {\n            // When range is moved to the same position then not mark it as a change.\n            // See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n            if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {\n              return;\n            }\n\n            var sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);\n\n            var targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);\n\n            if (!sourceParentInserted) {\n              this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);\n            }\n\n            if (!targetParentInserted) {\n              this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);\n            }\n\n            break;\n          }\n\n        case 'rename':\n          {\n            if (this._isInInsertedElement(operation.position.parent)) {\n              return;\n            }\n\n            this._markRemove(operation.position.parent, operation.position.offset, 1);\n\n            this._markInsert(operation.position.parent, operation.position.offset, 1);\n\n            var range = Range._createFromPositionAndShift(operation.position, 1);\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = this._markerCollection.getMarkersIntersectingRange(range)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var marker = _step2.value;\n                var markerRange = marker.getRange();\n                this.bufferMarkerChange(marker.name, markerRange, markerRange, marker.affectsData);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n\n            break;\n          }\n\n        case 'split':\n          {\n            var splitElement = operation.splitPosition.parent; // Mark that children of the split element were removed.\n\n            if (!this._isInInsertedElement(splitElement)) {\n              this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);\n            } // Mark that the new element (split copy) was inserted.\n\n\n            if (!this._isInInsertedElement(operation.insertionPosition.parent)) {\n              this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);\n            } // If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n\n\n            if (operation.graveyardPosition) {\n              this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);\n            }\n\n            break;\n          }\n\n        case 'merge':\n          {\n            // Mark that the merged element was removed.\n            var mergedElement = operation.sourcePosition.parent;\n\n            if (!this._isInInsertedElement(mergedElement.parent)) {\n              this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);\n            } // Mark that the merged element was inserted into graveyard.\n\n\n            var graveyardParent = operation.graveyardPosition.parent;\n\n            this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1); // Mark that children of merged element were inserted at new parent.\n\n\n            var mergedIntoElement = operation.targetPosition.parent;\n\n            if (!this._isInInsertedElement(mergedIntoElement)) {\n              this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);\n            }\n\n            break;\n          }\n      } // Clear cache after each buffered operation as it is no longer valid.\n\n\n      this._cachedChanges = null;\n    }\n    /**\n     * Buffers a marker change.\n     *\n     * @param {String} markerName The name of the marker that changed.\n     * @param {module:engine/model/range~Range|null} oldRange Marker range before the change or `null` if the marker has just\n     * been created.\n     * @param {module:engine/model/range~Range|null} newRange Marker range after the change or `null` if the marker was removed.\n     * @param {Boolean} affectsData Flag indicating whether marker affects the editor data.\n     */\n\n  }, {\n    key: \"bufferMarkerChange\",\n    value: function bufferMarkerChange(markerName, oldRange, newRange, affectsData) {\n      var buffered = this._changedMarkers.get(markerName);\n\n      if (!buffered) {\n        this._changedMarkers.set(markerName, {\n          oldRange: oldRange,\n          newRange: newRange,\n          affectsData: affectsData\n        });\n      } else {\n        buffered.newRange = newRange;\n        buffered.affectsData = affectsData;\n\n        if (buffered.oldRange == null && buffered.newRange == null) {\n          // The marker is going to be removed (`newRange == null`) but it did not exist before the first buffered change\n          // (`buffered.oldRange == null`). In this case, do not keep the marker in buffer at all.\n          this._changedMarkers.delete(markerName);\n        }\n      }\n    }\n    /**\n     * Returns all markers that should be removed as a result of buffered changes.\n     *\n     * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n     */\n\n  }, {\n    key: \"getMarkersToRemove\",\n    value: function getMarkersToRemove() {\n      var result = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this._changedMarkers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              name = _step3$value[0],\n              change = _step3$value[1];\n\n          if (change.oldRange != null) {\n            result.push({\n              name: name,\n              range: change.oldRange\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Returns all markers which should be added as a result of buffered changes.\n     *\n     * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n     */\n\n  }, {\n    key: \"getMarkersToAdd\",\n    value: function getMarkersToAdd() {\n      var result = [];\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this._changedMarkers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              name = _step4$value[0],\n              change = _step4$value[1];\n\n          if (change.newRange != null) {\n            result.push({\n              name: name,\n              range: change.newRange\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Returns all markers which changed.\n     *\n     * @returns {Array.<Object>}\n     */\n\n  }, {\n    key: \"getChangedMarkers\",\n    value: function getChangedMarkers() {\n      return Array.from(this._changedMarkers).map(function (item) {\n        return {\n          name: item[0],\n          data: {\n            oldRange: item[1].oldRange,\n            newRange: item[1].newRange\n          }\n        };\n      });\n    }\n    /**\n     * Checks whether some of the buffered changes affect the editor data.\n     *\n     * Types of changes which affect the editor data:\n     *\n     * * model structure changes,\n     * * attribute changes,\n     * * changes of markers which were defined as `affectingData`.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasDataChanges\",\n    value: function hasDataChanges() {\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this._changedMarkers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              change = _step5$value[1];\n\n          if (change.affectsData) {\n            return true;\n          }\n        } // If markers do not affect the data, check whether there are some changes in elements.\n\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return this._changesInElement.size > 0;\n    }\n    /**\n     * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n     * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n     *\n     * The diff set is returned as an array of diff items, each describing a change done on the model. The items are sorted by\n     * the position on which the change happened. If a position {@link module:engine/model/position~Position#isBefore is before}\n     * another one, it will be on an earlier index in the diff set.\n     *\n     * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n     * previous {@link #getChanges} call, the next call will return the cached value.\n     *\n     * @param {Object} options Additional options.\n     * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n     * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n     * @returns {Array.<Object>} Diff between the old and the new model tree state.\n     */\n\n  }, {\n    key: \"getChanges\",\n    value: function getChanges() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        includeChangesInGraveyard: false\n      };\n\n      // If there are cached changes, just return them instead of calculating changes again.\n      if (this._cachedChanges) {\n        if (options.includeChangesInGraveyard) {\n          return this._cachedChangesWithGraveyard.slice();\n        } else {\n          return this._cachedChanges.slice();\n        }\n      } // Will contain returned results.\n\n\n      var diffSet = []; // Check all changed elements.\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this._changesInElement.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var element = _step6.value;\n\n          // Get changes for this element and sort them.\n          var changes = this._changesInElement.get(element).sort(function (a, b) {\n            if (a.offset === b.offset) {\n              if (a.type != b.type) {\n                // If there are multiple changes at the same position, \"remove\" change should be first.\n                // If the order is different, for example, we would first add some nodes and then removed them\n                // (instead of the nodes that we should remove).\n                return a.type == 'remove' ? -1 : 1;\n              }\n\n              return 0;\n            }\n\n            return a.offset < b.offset ? -1 : 1;\n          }); // Get children of this element before any change was applied on it.\n\n\n          var snapshotChildren = this._elementSnapshots.get(element); // Get snapshot of current element's children.\n\n\n          var elementChildren = _getChildrenSnapshot(element.getChildren()); // Generate actions basing on changes done on element.\n\n\n          var actions = _generateActionsFromChanges(snapshotChildren.length, changes);\n\n          var _i2 = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\n          var j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n          // Process every action.\n\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = actions[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var action = _step7.value;\n\n              if (action === 'i') {\n                // Generate diff item for this element and insert it into the diff set.\n                diffSet.push(this._getInsertDiff(element, _i2, elementChildren[_i2].name));\n                _i2++;\n              } else if (action === 'r') {\n                // Generate diff item for this element and insert it into the diff set.\n                diffSet.push(this._getRemoveDiff(element, _i2, snapshotChildren[j].name));\n                j++;\n              } else if (action === 'a') {\n                // Take attributes from saved and current children.\n                var elementAttributes = elementChildren[_i2].attributes;\n                var snapshotAttributes = snapshotChildren[j].attributes;\n                var range = void 0;\n\n                if (elementChildren[_i2].name == '$text') {\n                  range = new Range(Position._createAt(element, _i2), Position._createAt(element, _i2 + 1));\n                } else {\n                  var index = element.offsetToIndex(_i2);\n                  range = new Range(Position._createAt(element, _i2), Position._createAt(element.getChild(index), 0));\n                } // Generate diff items for this change (there might be multiple attributes changed and\n                // there is a single diff for each of them) and insert them into the diff set.\n\n\n                diffSet.push.apply(diffSet, _toConsumableArray(this._getAttributesDiff(range, snapshotAttributes, elementAttributes)));\n                _i2++;\n                j++;\n              } else {\n                // `action` is 'equal'. Child not changed.\n                _i2++;\n                j++;\n              }\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        } // Then, sort the changes by the position (change at position before other changes is first).\n\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      diffSet.sort(function (a, b) {\n        // If the change is in different root, we don't care much, but we'd like to have all changes in given\n        // root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n        // will be processed first.\n        if (a.position.root != b.position.root) {\n          return a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n        } // If change happens at the same position...\n\n\n        if (a.position.isEqual(b.position)) {\n          // Keep chronological order of operations.\n          return a.changeCount - b.changeCount;\n        } // If positions differ, position \"on the left\" should be earlier in the result.\n\n\n        return a.position.isBefore(b.position) ? -1 : 1;\n      }); // Glue together multiple changes (mostly on text nodes).\n\n      for (var i = 1; i < diffSet.length; i++) {\n        var prevDiff = diffSet[i - 1];\n        var thisDiff = diffSet[i]; // Glue remove changes if they happen on text on same position.\n\n        var isConsecutiveTextRemove = prevDiff.type == 'remove' && thisDiff.type == 'remove' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.isEqual(thisDiff.position); // Glue insert changes if they happen on text on consecutive fragments.\n\n        var isConsecutiveTextAdd = prevDiff.type == 'insert' && thisDiff.type == 'insert' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset; // Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\n        var isConsecutiveAttributeChange = prevDiff.type == 'attribute' && thisDiff.type == 'attribute' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n        if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {\n          diffSet[i - 1].length++;\n\n          if (isConsecutiveAttributeChange) {\n            diffSet[i - 1].range.end = diffSet[i - 1].range.end.getShiftedBy(1);\n          }\n\n          diffSet.splice(i, 1);\n          i--;\n        }\n      } // Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\n\n      for (var _i = 0, _diffSet = diffSet; _i < _diffSet.length; _i++) {\n        var item = _diffSet[_i];\n        delete item.changeCount;\n\n        if (item.type == 'attribute') {\n          delete item.position;\n          delete item.length;\n        }\n      }\n\n      this._changeCount = 0; // Cache changes.\n\n      this._cachedChangesWithGraveyard = diffSet.slice();\n      this._cachedChanges = diffSet.slice().filter(_changesInGraveyardFilter);\n\n      if (options.includeChangesInGraveyard) {\n        return this._cachedChangesWithGraveyard;\n      } else {\n        return this._cachedChanges;\n      }\n    }\n    /**\n     * Resets `Differ`. Removes all buffered changes.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._changesInElement.clear();\n\n      this._elementSnapshots.clear();\n\n      this._changedMarkers.clear();\n\n      this._cachedChanges = null;\n    }\n    /**\n     * Saves and handles an insert change.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Number} offset\n     * @param {Number} howMany\n     */\n\n  }, {\n    key: \"_markInsert\",\n    value: function _markInsert(parent, offset, howMany) {\n      var changeItem = {\n        type: 'insert',\n        offset: offset,\n        howMany: howMany,\n        count: this._changeCount++\n      };\n\n      this._markChange(parent, changeItem);\n    }\n    /**\n     * Saves and handles a remove change.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Number} offset\n     * @param {Number} howMany\n     */\n\n  }, {\n    key: \"_markRemove\",\n    value: function _markRemove(parent, offset, howMany) {\n      var changeItem = {\n        type: 'remove',\n        offset: offset,\n        howMany: howMany,\n        count: this._changeCount++\n      };\n\n      this._markChange(parent, changeItem);\n\n      this._removeAllNestedChanges(parent, offset, howMany);\n    }\n    /**\n     * Saves and handles an attribute change.\n     *\n     * @private\n     * @param {module:engine/model/item~Item} item\n     */\n\n  }, {\n    key: \"_markAttribute\",\n    value: function _markAttribute(item) {\n      var changeItem = {\n        type: 'attribute',\n        offset: item.startOffset,\n        howMany: item.offsetSize,\n        count: this._changeCount++\n      };\n\n      this._markChange(item.parent, changeItem);\n    }\n    /**\n     * Saves and handles a model change.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Object} changeItem\n     */\n\n  }, {\n    key: \"_markChange\",\n    value: function _markChange(parent, changeItem) {\n      // First, make a snapshot of this parent's children (it will be made only if it was not made before).\n      this._makeSnapshot(parent); // Then, get all changes that already were done on the element (empty array if this is the first change).\n\n\n      var changes = this._getChangesForElement(parent); // Then, look through all the changes, and transform them or the new change.\n\n\n      this._handleChange(changeItem, changes); // Add the new change.\n\n\n      changes.push(changeItem); // Remove incorrect changes. During transformation some change might be, for example, included in another.\n      // In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\n      for (var i = 0; i < changes.length; i++) {\n        if (changes[i].howMany < 1) {\n          changes.splice(i, 1);\n          i--;\n        }\n      }\n    }\n    /**\n     * Gets an array of changes that have already been saved for a given element.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} element\n     * @returns {Array.<Object>}\n     */\n\n  }, {\n    key: \"_getChangesForElement\",\n    value: function _getChangesForElement(element) {\n      var changes;\n\n      if (this._changesInElement.has(element)) {\n        changes = this._changesInElement.get(element);\n      } else {\n        changes = [];\n\n        this._changesInElement.set(element, changes);\n      }\n\n      return changes;\n    }\n    /**\n     * Saves a children snapshot for a given element.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} element\n     */\n\n  }, {\n    key: \"_makeSnapshot\",\n    value: function _makeSnapshot(element) {\n      if (!this._elementSnapshots.has(element)) {\n        this._elementSnapshots.set(element, _getChildrenSnapshot(element.getChildren()));\n      }\n    }\n    /**\n     * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n     * change and/or the old change.\n     *\n     * @private\n     * @param {Object} inc Incoming (new) change.\n     * @param {Array.<Object>} changes An array containing all the changes done on that element.\n     */\n\n  }, {\n    key: \"_handleChange\",\n    value: function _handleChange(inc, changes) {\n      // We need a helper variable that will store how many nodes are to be still handled for this change item.\n      // `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n      // needs to be differentiated.\n      //\n      // This comes up when there are multiple changes that are affected by `inc` change item.\n      //\n      // For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n      // Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n      //\n      // Then, we:\n      // - \"forget\" about first insert change (it is \"eaten\" by remove),\n      // - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n      // - but still we have to change offset of the second insert change from `5` to `3`!\n      //\n      // So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n      // while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n      inc.nodesToHandle = inc.howMany;\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = changes[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var old = _step8.value;\n          var incEnd = inc.offset + inc.howMany;\n          var oldEnd = old.offset + old.howMany;\n\n          if (inc.type == 'insert') {\n            if (old.type == 'insert') {\n              if (inc.offset <= old.offset) {\n                old.offset += inc.howMany;\n              } else if (inc.offset < oldEnd) {\n                old.howMany += inc.nodesToHandle;\n                inc.nodesToHandle = 0;\n              }\n            }\n\n            if (old.type == 'remove') {\n              if (inc.offset < old.offset) {\n                old.offset += inc.howMany;\n              }\n            }\n\n            if (old.type == 'attribute') {\n              if (inc.offset <= old.offset) {\n                old.offset += inc.howMany;\n              } else if (inc.offset < oldEnd) {\n                // This case is more complicated, because attribute change has to be split into two.\n                // Example (assume that uppercase and lowercase letters mean different attributes):\n                //\n                // initial state:\t\tabcxyz\n                // attribute change:\taBCXYz\n                // incoming insert:\t\taBCfooXYz\n                //\n                // Change ranges cannot intersect because each item has to be described exactly (it was either\n                // not changed, inserted, removed, or its attribute was changed). That's why old attribute\n                // change has to be split and both parts has to be handled separately from now on.\n                var howMany = old.howMany;\n                old.howMany = inc.offset - old.offset; // Add the second part of attribute change to the beginning of processed array so it won't\n                // be processed again in this loop.\n\n                changes.unshift({\n                  type: 'attribute',\n                  offset: incEnd,\n                  howMany: howMany - old.howMany,\n                  count: this._changeCount++\n                });\n              }\n            }\n          }\n\n          if (inc.type == 'remove') {\n            if (old.type == 'insert') {\n              if (incEnd <= old.offset) {\n                old.offset -= inc.howMany;\n              } else if (incEnd <= oldEnd) {\n                if (inc.offset < old.offset) {\n                  var intersectionLength = incEnd - old.offset;\n                  old.offset = inc.offset;\n                  old.howMany -= intersectionLength;\n                  inc.nodesToHandle -= intersectionLength;\n                } else {\n                  old.howMany -= inc.nodesToHandle;\n                  inc.nodesToHandle = 0;\n                }\n              } else {\n                if (inc.offset <= old.offset) {\n                  inc.nodesToHandle -= old.howMany;\n                  old.howMany = 0;\n                } else if (inc.offset < oldEnd) {\n                  var _intersectionLength = oldEnd - inc.offset;\n\n                  old.howMany -= _intersectionLength;\n                  inc.nodesToHandle -= _intersectionLength;\n                }\n              }\n            }\n\n            if (old.type == 'remove') {\n              if (incEnd <= old.offset) {\n                old.offset -= inc.howMany;\n              } else if (inc.offset < old.offset) {\n                inc.nodesToHandle += old.howMany;\n                old.howMany = 0;\n              }\n            }\n\n            if (old.type == 'attribute') {\n              if (incEnd <= old.offset) {\n                old.offset -= inc.howMany;\n              } else if (inc.offset < old.offset) {\n                var _intersectionLength2 = incEnd - old.offset;\n\n                old.offset = inc.offset;\n                old.howMany -= _intersectionLength2;\n              } else if (inc.offset < oldEnd) {\n                if (incEnd <= oldEnd) {\n                  // On first sight in this case we don't need to split attribute operation into two.\n                  // However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n                  // For that reason, no two changes may intersect.\n                  // So we cannot have an attribute change that \"contains\" remove change.\n                  // Attribute change needs to be split.\n                  var _howMany = old.howMany;\n                  old.howMany = inc.offset - old.offset;\n                  var howManyAfter = _howMany - old.howMany - inc.nodesToHandle; // Add the second part of attribute change to the beginning of processed array so it won't\n                  // be processed again in this loop.\n\n                  changes.unshift({\n                    type: 'attribute',\n                    offset: inc.offset,\n                    howMany: howManyAfter,\n                    count: this._changeCount++\n                  });\n                } else {\n                  old.howMany -= oldEnd - inc.offset;\n                }\n              }\n            }\n          }\n\n          if (inc.type == 'attribute') {\n            // In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n            if (old.type == 'insert') {\n              if (inc.offset < old.offset && incEnd > old.offset) {\n                if (incEnd > oldEnd) {\n                  // This case is similar to a case described when incoming change was insert and old change was attribute.\n                  // See comment above.\n                  //\n                  // This time incoming change is attribute. We need to split incoming change in this case too.\n                  // However this time, the second part of the attribute change needs to be processed further\n                  // because there might be other changes that it collides with.\n                  var attributePart = {\n                    type: 'attribute',\n                    offset: oldEnd,\n                    howMany: incEnd - oldEnd,\n                    count: this._changeCount++\n                  };\n\n                  this._handleChange(attributePart, changes);\n\n                  changes.push(attributePart);\n                }\n\n                inc.nodesToHandle = old.offset - inc.offset;\n                inc.howMany = inc.nodesToHandle;\n              } else if (inc.offset >= old.offset && inc.offset < oldEnd) {\n                if (incEnd > oldEnd) {\n                  inc.nodesToHandle = incEnd - oldEnd;\n                  inc.offset = oldEnd;\n                } else {\n                  inc.nodesToHandle = 0;\n                }\n              }\n            }\n\n            if (old.type == 'remove') {\n              // This is a case when attribute change \"contains\" remove change.\n              // The attribute change needs to be split into two because changes cannot intersect.\n              if (inc.offset < old.offset && incEnd > old.offset) {\n                var _attributePart = {\n                  type: 'attribute',\n                  offset: old.offset,\n                  howMany: incEnd - old.offset,\n                  count: this._changeCount++\n                };\n\n                this._handleChange(_attributePart, changes);\n\n                changes.push(_attributePart);\n                inc.nodesToHandle = old.offset - inc.offset;\n                inc.howMany = inc.nodesToHandle;\n              }\n            }\n\n            if (old.type == 'attribute') {\n              // There are only two conflicting scenarios possible here:\n              if (inc.offset >= old.offset && incEnd <= oldEnd) {\n                // `old` change includes `inc` change, or they are the same.\n                inc.nodesToHandle = 0;\n                inc.howMany = 0;\n                inc.offset = 0;\n              } else if (inc.offset <= old.offset && incEnd >= oldEnd) {\n                // `inc` change includes `old` change.\n                old.howMany = 0;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      inc.howMany = inc.nodesToHandle;\n      delete inc.nodesToHandle;\n    }\n    /**\n     * Returns an object with a single insert change description.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent The element in which the change happened.\n     * @param {Number} offset The offset at which change happened.\n     * @param {String} name The name of the removed element or `'$text'` for a character.\n     * @returns {Object} The diff item.\n     */\n\n  }, {\n    key: \"_getInsertDiff\",\n    value: function _getInsertDiff(parent, offset, name) {\n      return {\n        type: 'insert',\n        position: Position._createAt(parent, offset),\n        name: name,\n        length: 1,\n        changeCount: this._changeCount++\n      };\n    }\n    /**\n     * Returns an object with a single remove change description.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent The element in which change happened.\n     * @param {Number} offset The offset at which change happened.\n     * @param {String} name The name of the removed element or `'$text'` for a character.\n     * @returns {Object} The diff item.\n     */\n\n  }, {\n    key: \"_getRemoveDiff\",\n    value: function _getRemoveDiff(parent, offset, name) {\n      return {\n        type: 'remove',\n        position: Position._createAt(parent, offset),\n        name: name,\n        length: 1,\n        changeCount: this._changeCount++\n      };\n    }\n    /**\n     * Returns an array of objects where each one is a single attribute change description.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range The range where the change happened.\n     * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n     * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n     * @returns {Array.<Object>} An array containing one or more diff items.\n     */\n\n  }, {\n    key: \"_getAttributesDiff\",\n    value: function _getAttributesDiff(range, oldAttributes, newAttributes) {\n      // Results holder.\n      var diffs = []; // Clone new attributes as we will be performing changes on this object.\n\n      newAttributes = new Map(newAttributes); // Look through old attributes.\n\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = oldAttributes[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var _step9$value = _slicedToArray(_step9.value, 2),\n              key = _step9$value[0],\n              oldValue = _step9$value[1];\n\n          // Check what is the new value of the attribute (or if it was removed).\n          var newValue = newAttributes.has(key) ? newAttributes.get(key) : null; // If values are different (or attribute was removed)...\n\n          if (newValue !== oldValue) {\n            // Add diff item.\n            diffs.push({\n              type: 'attribute',\n              position: range.start,\n              range: range.clone(),\n              length: 1,\n              attributeKey: key,\n              attributeOldValue: oldValue,\n              attributeNewValue: newValue,\n              changeCount: this._changeCount++\n            });\n          } // Prevent returning two diff items for the same change.\n\n\n          newAttributes.delete(key);\n        } // Look through new attributes that weren't handled above.\n\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = newAttributes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var _step10$value = _slicedToArray(_step10.value, 2),\n              key = _step10$value[0],\n              _newValue = _step10$value[1];\n\n          // Each of them is a new attribute. Add diff item.\n          diffs.push({\n            type: 'attribute',\n            position: range.start,\n            range: range.clone(),\n            length: 1,\n            attributeKey: key,\n            attributeOldValue: null,\n            attributeNewValue: _newValue,\n            changeCount: this._changeCount++\n          });\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      return diffs;\n    }\n    /**\n     * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} element Element to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isInInsertedElement\",\n    value: function _isInInsertedElement(element) {\n      var parent = element.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      var changes = this._changesInElement.get(parent);\n\n      var offset = element.startOffset;\n\n      if (changes) {\n        var _iteratorNormalCompletion11 = true;\n        var _didIteratorError11 = false;\n        var _iteratorError11 = undefined;\n\n        try {\n          for (var _iterator11 = changes[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n            var change = _step11.value;\n\n            if (change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError11 = true;\n          _iteratorError11 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n              _iterator11.return();\n            }\n          } finally {\n            if (_didIteratorError11) {\n              throw _iteratorError11;\n            }\n          }\n        }\n      }\n\n      return this._isInInsertedElement(parent);\n    }\n    /**\n     * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n     * and `howMany`.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Number} offset\n     * @param {Number} howMany\n     */\n\n  }, {\n    key: \"_removeAllNestedChanges\",\n    value: function _removeAllNestedChanges(parent, offset, howMany) {\n      var range = new Range(Position._createAt(parent, offset), Position._createAt(parent, offset + howMany));\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = range.getItems({\n          shallow: true\n        })[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var item = _step12.value;\n\n          if (item.is('element')) {\n            this._elementSnapshots.delete(item);\n\n            this._changesInElement.delete(item);\n\n            this._removeAllNestedChanges(item, 0, item.maxOffset);\n          }\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n    }\n  }]);\n\n  return Differ;\n}(); // Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\n\n\nexport { Differ as default };\n\nfunction _getChildrenSnapshot(children) {\n  var snapshot = [];\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = children[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var child = _step13.value;\n\n      if (child.is('text')) {\n        for (var i = 0; i < child.data.length; i++) {\n          snapshot.push({\n            name: '$text',\n            attributes: new Map(child.getAttributes())\n          });\n        }\n      } else {\n        snapshot.push({\n          name: child.name,\n          attributes: new Map(child.getAttributes())\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return snapshot;\n} // Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\n\n\nfunction _generateActionsFromChanges(oldChildrenLength, changes) {\n  var actions = [];\n  var offset = 0;\n  var oldChildrenHandled = 0; // Go through all buffered changes.\n\n  var _iteratorNormalCompletion14 = true;\n  var _didIteratorError14 = false;\n  var _iteratorError14 = undefined;\n\n  try {\n    for (var _iterator14 = changes[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n      var change = _step14.value;\n\n      // First, fill \"holes\" between changes with \"equal\" actions.\n      if (change.offset > offset) {\n        actions.push.apply(actions, _toConsumableArray('e'.repeat(change.offset - offset).split('')));\n        oldChildrenHandled += change.offset - offset;\n      } // Then, fill up actions accordingly to change type.\n\n\n      if (change.type == 'insert') {\n        actions.push.apply(actions, _toConsumableArray('i'.repeat(change.howMany).split(''))); // The last handled offset is after inserted range.\n\n        offset = change.offset + change.howMany;\n      } else if (change.type == 'remove') {\n        actions.push.apply(actions, _toConsumableArray('r'.repeat(change.howMany).split(''))); // The last handled offset is at the position where the nodes were removed.\n\n        offset = change.offset; // We removed `howMany` old nodes, update `oldChildrenHandled`.\n\n        oldChildrenHandled += change.howMany;\n      } else {\n        actions.push.apply(actions, _toConsumableArray('a'.repeat(change.howMany).split(''))); // The last handled offset is at the position after the changed range.\n\n        offset = change.offset + change.howMany; // We changed `howMany` old nodes, update `oldChildrenHandled`.\n\n        oldChildrenHandled += change.howMany;\n      }\n    } // Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n    // has not been changed / removed at the end of their parent.\n\n  } catch (err) {\n    _didIteratorError14 = true;\n    _iteratorError14 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n        _iterator14.return();\n      }\n    } finally {\n      if (_didIteratorError14) {\n        throw _iteratorError14;\n      }\n    }\n  }\n\n  if (oldChildrenHandled < oldChildrenLength) {\n    actions.push.apply(actions, _toConsumableArray('e'.repeat(oldChildrenLength - oldChildrenHandled).split('')));\n  }\n\n  return actions;\n} // Filter callback for Array.filter that filters out change entries that are in graveyard.\n\n\nfunction _changesInGraveyardFilter(entry) {\n  var posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n  var rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n  return !posInGy && !rangeInGy;\n}","import \"core-js/modules/es6.number.constructor\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.set\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/history\n */\n\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\nvar History =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an empty History instance.\n   */\n  function History() {\n    _classCallCheck(this, History);\n\n    /**\n     * Operations added to the history.\n     *\n     * @protected\n     * @member {Array.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_operations\n     */\n    this._operations = [];\n    /**\n     * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n     * {@link module:engine/model/operation/operation~Operation operation}.\n     *\n     * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n     * value is an operation that has been undone by the \"undoing operation\".\n     *\n     * @private\n     * @member {Map} module:engine/model/history~History#_undoPairs\n     */\n\n    this._undoPairs = new Map();\n    /**\n     * Holds all undone operations.\n     *\n     * @private\n     * @member {Set.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_undoneOperations\n     */\n\n    this._undoneOperations = new Set();\n  }\n  /**\n   * Adds an operation to the history.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n   */\n\n\n  _createClass(History, [{\n    key: \"addOperation\",\n    value: function addOperation(operation) {\n      if (this._operations.includes(operation)) {\n        return;\n      }\n\n      this._operations.push(operation);\n    }\n    /**\n     * Returns operations added to the history.\n     *\n     * @param {Number} [from=0] Base version from which operations should be returned (inclusive). Defaults to `0`, which means\n     * that operations from the first one will be returned.\n     * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which operations should be returned (exclusive).\n     * Defaults to `Number.POSITIVE_INFINITY` which means that operations up to the last one will be returned.\n     * @returns {Iterable.<module:engine/model/operation/operation~Operation>} Operations added to the history.\n     */\n\n  }, {\n    key: \"getOperations\",\n    value: function getOperations() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n\n      if (from < 0) {\n        return [];\n      }\n\n      return this._operations.slice(from, to);\n    }\n    /**\n     * Returns operation from the history that bases on given `baseVersion`.\n     *\n     * @param {Number} baseVersion Base version of the operation to get.\n     * @returns {module:engine/model/operation/operation~Operation|null} Operation with given base version or `null` if\n     * there is no such operation in history.\n     */\n\n  }, {\n    key: \"getOperation\",\n    value: function getOperation(baseVersion) {\n      return this._operations[baseVersion];\n    }\n    /**\n     * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n     * history is keeping more context information about operations, which helps in operational transformation.\n     *\n     * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n     * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n     */\n\n  }, {\n    key: \"setOperationAsUndone\",\n    value: function setOperationAsUndone(undoneOperation, undoingOperation) {\n      this._undoPairs.set(undoingOperation, undoneOperation);\n\n      this._undoneOperations.add(undoneOperation);\n    }\n    /**\n     * Checks whether given `operation` is undoing any other operation.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n     * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n     */\n\n  }, {\n    key: \"isUndoingOperation\",\n    value: function isUndoingOperation(operation) {\n      return this._undoPairs.has(operation);\n    }\n    /**\n     * Checks whether given `operation` has been undone by any other operation.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n     * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n     */\n\n  }, {\n    key: \"isUndoneOperation\",\n    value: function isUndoneOperation(operation) {\n      return this._undoneOperations.has(operation);\n    }\n    /**\n     * For given `undoingOperation`, returns the operation which has been undone by it.\n     *\n     * @param {module:engine/model/operation/operation~Operation} undoingOperation\n     * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n     * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n     */\n\n  }, {\n    key: \"getUndoneOperation\",\n    value: function getUndoneOperation(undoingOperation) {\n      return this._undoPairs.get(undoingOperation);\n    }\n  }]);\n\n  return History;\n}();\n\nexport { History as default };","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Set of utils to handle unicode characters.\n *\n * @module utils/unicode\n */\n\n/**\n * Checks whether given `character` is a combining mark.\n *\n * @param {String} character Character to check.\n * @returns {Boolean}\n */\nexport function isCombiningMark(character) {\n  return !!character && character.length == 1 && /[\\u0300-\\u036f\\u1ab0-\\u1aff\\u1dc0-\\u1dff\\u20d0-\\u20ff\\ufe20-\\ufe2f]/.test(character);\n}\n/**\n * Checks whether given `character` is a high half of surrogate pair.\n *\n * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair\n * consist of high surrogate pair character followed by low surrogate pair character.\n *\n * @param {String} character Character to check.\n * @returns {Boolean}\n */\n\nexport function isHighSurrogateHalf(character) {\n  return !!character && character.length == 1 && /[\\ud800-\\udbff]/.test(character);\n}\n/**\n * Checks whether given `character` is a low half of surrogate pair.\n *\n * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair\n * consist of high surrogate pair character followed by low surrogate pair character.\n *\n * @param {String} character Character to check.\n * @returns {Boolean}\n */\n\nexport function isLowSurrogateHalf(character) {\n  return !!character && character.length == 1 && /[\\udc00-\\udfff]/.test(character);\n}\n/**\n * Checks whether given offset in a string is inside a surrogate pair (between two surrogate halves).\n *\n * @param {String} string String to check.\n * @param {Number} offset Offset to check.\n * @returns {Boolean}\n */\n\nexport function isInsideSurrogatePair(string, offset) {\n  return isHighSurrogateHalf(string.charAt(offset - 1)) && isLowSurrogateHalf(string.charAt(offset));\n}\n/**\n * Checks whether given offset in a string is between base character and combining mark or between two combining marks.\n *\n * @param {String} string String to check.\n * @param {Number} offset Offset to check.\n * @returns {Boolean}\n */\n\nexport function isInsideCombinedSymbol(string, offset) {\n  return isCombiningMark(string.charAt(offset));\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/document\n */\nimport Differ from \"./differ\";\nimport RootElement from \"./rootelement\";\nimport History from \"./history\";\nimport DocumentSelection from \"./documentselection\";\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es';\nvar graveyardName = '$graveyard';\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots  e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar Document =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an empty document instance with no {@link #roots} (other than\n   * the {@link #graveyard graveyard root}).\n   */\n  function Document(model) {\n    var _this = this;\n\n    _classCallCheck(this, Document);\n\n    /**\n     * The {@link module:engine/model/model~Model model} that the document is a part of.\n     *\n     * @readonly\n     * @type {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The document version. It starts from `0` and every operation increases the version number. It is used to ensure that\n     * operations are applied on a proper document version.\n     *\n     * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n     * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n    this.version = 0;\n    /**\n     * The document's history.\n     *\n     * @readonly\n     * @type {module:engine/model/history~History}\n     */\n\n    this.history = new History(this);\n    /**\n     * The selection in this document.\n     *\n     * @readonly\n     * @type {module:engine/model/documentselection~DocumentSelection}\n     */\n\n    this.selection = new DocumentSelection(this);\n    /**\n     * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n     * {@link #getRoot} to manipulate it.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection}\n     */\n\n    this.roots = new Collection({\n      idProperty: 'rootName'\n    });\n    /**\n     * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n     *\n     * @readonly\n     * @type {module:engine/model/differ~Differ}\n     */\n\n    this.differ = new Differ(model.markers);\n    /**\n     * Post-fixer callbacks registered to the model document.\n     *\n     * @private\n     * @type {Set.<Function>}\n     */\n\n    this._postFixers = new Set();\n    /**\n     * A boolean indicates whether the selection has changed until\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    this._hasSelectionChangedFromTheLastChangeBlock = false; // Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n\n    this.createRoot('$root', graveyardName); // First, if the operation is a document operation check if it's base version is correct.\n\n    this.listenTo(model, 'applyOperation', function (evt, args) {\n      var operation = args[0];\n\n      if (operation.isDocumentOperation && operation.baseVersion !== _this.version) {\n        /**\n         * Only operations with matching versions can be applied.\n         *\n         * @error document-applyOperation-wrong-version\n         * @param {module:engine/model/operation/operation~Operation} operation\n         */\n        throw new CKEditorError('model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.', {\n          operation: operation\n        });\n      }\n    }, {\n      priority: 'highest'\n    }); // Then, still before an operation is applied on model, buffer the change in differ.\n\n    this.listenTo(model, 'applyOperation', function (evt, args) {\n      var operation = args[0];\n\n      if (operation.isDocumentOperation) {\n        _this.differ.bufferOperation(operation);\n      }\n    }, {\n      priority: 'high'\n    }); // After the operation is applied, bump document's version and add the operation to the history.\n\n    this.listenTo(model, 'applyOperation', function (evt, args) {\n      var operation = args[0];\n\n      if (operation.isDocumentOperation) {\n        _this.version++;\n\n        _this.history.addOperation(operation);\n      }\n    }, {\n      priority: 'low'\n    }); // Listen to selection changes. If selection changed, mark it.\n\n    this.listenTo(this.selection, 'change', function () {\n      _this._hasSelectionChangedFromTheLastChangeBlock = true;\n    }); // Buffer marker changes.\n    // This is not covered in buffering operations because markers may change outside of them (when they\n    // are modified using `model.markers` collection, not through `MarkerOperation`).\n\n    this.listenTo(model.markers, 'update', function (evt, marker, oldRange, newRange) {\n      // Whenever marker is updated, buffer that change.\n      _this.differ.bufferMarkerChange(marker.name, oldRange, newRange, marker.affectsData);\n\n      if (oldRange === null) {\n        // If this is a new marker, add a listener that will buffer change whenever marker changes.\n        marker.on('change', function (evt, oldRange) {\n          _this.differ.bufferMarkerChange(marker.name, oldRange, marker.getRange(), marker.affectsData);\n        });\n      }\n    });\n  }\n  /**\n   * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n   *\n   * @readonly\n   * @member {module:engine/model/rootelement~RootElement}\n   */\n\n\n  _createClass(Document, [{\n    key: \"createRoot\",\n\n    /**\n     * Creates a new root.\n     *\n     * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n     * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n     * @param {String} [rootName='main'] A unique root name.\n     * @returns {module:engine/model/rootelement~RootElement} The created root.\n     */\n    value: function createRoot() {\n      var elementName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$root';\n      var rootName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'main';\n\n      if (this.roots.get(rootName)) {\n        /**\n         * A root with the specified name already exists.\n         *\n         * @error model-document-createRoot-name-exists\n         * @param {module:engine/model/document~Document} doc\n         * @param {String} name\n         */\n        throw new CKEditorError('model-document-createRoot-name-exists: Root with specified name already exists.', {\n          name: rootName\n        });\n      }\n\n      var root = new RootElement(this, elementName, rootName);\n      this.roots.add(root);\n      return root;\n    }\n    /**\n     * Removes all event listeners set by the document instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.selection.destroy();\n      this.stopListening();\n    }\n    /**\n     * Returns a root by its name.\n     *\n     * @param {String} [name='main'] A unique root name.\n     * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n     * there is no root with the given name.\n     */\n\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n      return this.roots.get(name);\n    }\n    /**\n     * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n     *\n     * @returns {Array.<String>} Roots names.\n     */\n\n  }, {\n    key: \"getRootNames\",\n    value: function getRootNames() {\n      return Array.from(this.roots, function (root) {\n        return root.rootName;\n      }).filter(function (name) {\n        return name != graveyardName;\n      });\n    }\n    /**\n     * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n     * will operate on a correct model state.\n     *\n     * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n     * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n     * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n     * not be fixed in the new document tree state.\n     *\n     * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n     * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n     * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n     * for the user.\n     *\n     * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n     * callback should add an empty paragraph so that the editor is never empty:\n     *\n     *\t\tdocument.registerPostFixer( writer => {\n     *\t\t\tconst changes = document.differ.getChanges();\n     *\n     *\t\t\t// Check if the changes lead to an empty root in the editor.\n     *\t\t\tfor ( const entry of changes ) {\n     *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n     *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n     *\n     *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n     *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n     *\t\t\t\t\treturn true;\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @param {Function} postFixer\n     */\n\n  }, {\n    key: \"registerPostFixer\",\n    value: function registerPostFixer(postFixer) {\n      this._postFixers.add(postFixer);\n    }\n    /**\n     * A custom `toJSON()` method to solve child-parent circular dependencies.\n     *\n     * @returns {Object} A clone of this object with the document property changed to a string.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = clone(this); // Due to circular references we need to remove parent reference.\n\n      json.selection = '[engine.model.DocumentSelection]';\n      json.model = '[engine.model.Model]';\n      return json;\n    }\n    /**\n     * Check if there were any changes done on document, and if so, call post-fixers,\n     * fire `change` event for features and conversion and then reset the differ.\n     * Fire `change:data` event when at least one operation or buffered marker changes the data.\n     *\n     * @protected\n     * @fires change\n     * @fires change:data\n     * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n     */\n\n  }, {\n    key: \"_handleChangeBlock\",\n    value: function _handleChangeBlock(writer) {\n      if (this._hasDocumentChangedFromTheLastChangeBlock()) {\n        this._callPostFixers(writer); // Refresh selection attributes according to the final position in the model after the change.\n\n\n        this.selection.refresh();\n\n        if (this.differ.hasDataChanges()) {\n          this.fire('change:data', writer.batch);\n        } else {\n          this.fire('change', writer.batch);\n        } // Theoretically, it is not necessary to refresh selection after change event because\n        // post-fixers are the last who should change the model, but just in case...\n\n\n        this.selection.refresh();\n        this.differ.reset();\n      }\n\n      this._hasSelectionChangedFromTheLastChangeBlock = false;\n    }\n    /**\n     * Returns whether there is a buffered change or if the selection has changed from the last\n     * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n     * or {@link module:engine/model/model~Model#change `change()` block}.\n     *\n     * @protected\n     * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n     */\n\n  }, {\n    key: \"_hasDocumentChangedFromTheLastChangeBlock\",\n    value: function _hasDocumentChangedFromTheLastChangeBlock() {\n      return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n    }\n    /**\n     * Returns the default root for this document which is either the first root that was added to the document using\n     * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n     *\n     * @protected\n     * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n     */\n\n  }, {\n    key: \"_getDefaultRoot\",\n    value: function _getDefaultRoot() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.roots[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var root = _step.value;\n\n          if (root !== this.graveyard) {\n            return root;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return this.graveyard;\n    }\n    /**\n     * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n     * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n     *\n     * @protected\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"_getDefaultRange\",\n    value: function _getDefaultRange() {\n      var defaultRoot = this._getDefaultRoot();\n\n      var model = this.model;\n      var schema = model.schema; // Find the first position where the selection can be put.\n\n      var position = model.createPositionFromPath(defaultRoot, [0]);\n      var nearestRange = schema.getNearestSelectionRange(position); // If valid selection range is not found - return range collapsed at the beginning of the root.\n\n      return nearestRange || model.createRange(position);\n    }\n    /**\n     * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n     * the {@link #selection document's selection}.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range A range to check.\n     * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n     */\n\n  }, {\n    key: \"_validateSelectionRange\",\n    value: function _validateSelectionRange(range) {\n      return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);\n    }\n    /**\n     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n     *\n     * @private\n     * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n     */\n\n  }, {\n    key: \"_callPostFixers\",\n    value: function _callPostFixers(writer) {\n      var wasFixed = false;\n\n      do {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this._postFixers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var callback = _step2.value;\n            // Ensure selection attributes are up to date before each post-fixer.\n            // https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n            //\n            // It might be good to refresh the selection after each operation but at the moment it leads\n            // to losing attributes for composition or and spell checking\n            // https://github.com/ckeditor/ckeditor5-typing/issues/188\n            this.selection.refresh();\n            wasFixed = callback(writer);\n\n            if (wasFixed) {\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } while (wasFixed);\n    }\n    /**\n     * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost\n     * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed\n     * during that block's execution.\n     *\n     * The changes which this event will cover include:\n     *\n     * * document structure changes,\n     * * selection changes,\n     * * marker changes.\n     *\n     * If you want to be notified about all these changes, then simply listen to this event like this:\n     *\n     *\t\tmodel.document.on( 'change', () => {\n     *\t\t\tconsole.log( 'The document has changed!' );\n     *\t\t} );\n     *\n     * If, however, you only want to be notified about the data changes, then use the\n     * {@link module:engine/model/document~Document#event:change:data change:data} event,\n     * which is fired for document structure changes and marker changes (which affects the data).\n     *\n     *\t\tmodel.document.on( 'change:data', () => {\n     *\t\t\tconsole.log( 'The data has changed!' );\n     *\t\t} );\n     *\n     * @event change\n     * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n     */\n\n    /**\n     * It is a narrower version of the {@link #event:change} event. It is fired for changes which\n     * affect the editor data. This is:\n     *\n     * * document structure changes,\n     * * marker changes (which affects the data).\n     *\n     * If you want to be notified about the data changes, then listen to this event:\n     *\n     *\t\tmodel.document.on( 'change:data', () => {\n     *\t\t\tconsole.log( 'The data has changed!' );\n     *\t\t} );\n     *\n     * If you would like to listen to all document changes, then check out the\n     * {@link module:engine/model/document~Document#event:change change} event.\n     *\n     * @event change:data\n     * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n     */\n\n  }, {\n    key: \"graveyard\",\n    get: function get() {\n      return this.getRoot(graveyardName);\n    }\n  }]);\n\n  return Document;\n}();\n\nexport { Document as default };\nmix(Document, EmitterMixin); // Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\n\nfunction validateTextNodePosition(rangeBoundary) {\n  var textNode = rangeBoundary.textNode;\n\n  if (textNode) {\n    var data = textNode.data;\n    var offset = rangeBoundary.offset - textNode.startOffset;\n    return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);\n  }\n\n  return true;\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/liveposition\n */\nimport Position from \"./position\";\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * `LivePosition` is a type of {@link module:engine/model/position~Position Position}\n * that updates itself as {@link module:engine/model/document~Document document}\n * is changed through operations. It may be used as a bookmark.\n *\n * **Note:** Contrary to {@link module:engine/model/position~Position}, `LivePosition` works only in roots that are\n * {@link module:engine/model/rootelement~RootElement}.\n * If {@link module:engine/model/documentfragment~DocumentFragment} is passed, error will be thrown.\n *\n * **Note:** Be very careful when dealing with `LivePosition`. Each `LivePosition` instance bind events that might\n * have to be unbound.\n * Use {@link module:engine/model/liveposition~LivePosition#detach} whenever you don't need `LivePosition` anymore.\n *\n * @extends module:engine/model/position~Position\n */\n\nvar LivePosition =\n/*#__PURE__*/\nfunction (_Position) {\n  _inherits(LivePosition, _Position);\n\n  /**\n   * Creates a live position.\n   *\n   * @see module:engine/model/position~Position\n   * @param {module:engine/model/rootelement~RootElement} root\n   * @param {Array.<Number>} path\n   * @param {module:engine/model/position~PositionStickiness} [stickiness]\n   */\n  function LivePosition(root, path) {\n    var _this;\n\n    var stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';\n\n    _classCallCheck(this, LivePosition);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LivePosition).call(this, root, path, stickiness));\n\n    if (!_this.root.is('rootElement')) {\n      /**\n       * LivePosition's root has to be an instance of RootElement.\n       *\n       * @error liveposition-root-not-rootelement\n       */\n      throw new CKEditorError('model-liveposition-root-not-rootelement: LivePosition\\'s root has to be an instance of RootElement.');\n    }\n\n    bindWithDocument.call(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance\n   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was\n   * referring to it).\n   */\n\n\n  _createClass(LivePosition, [{\n    key: \"detach\",\n    value: function detach() {\n      this.stopListening();\n    }\n    /**\n     * Creates a {@link module:engine/model/position~Position position instance}, which is equal to this live position.\n     *\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"toPosition\",\n    value: function toPosition() {\n      return new Position(this.root, this.path.slice(), this.stickiness);\n    }\n    /**\n     * Creates a `LivePosition` instance that is equal to position.\n     *\n     * @param {module:engine/model/position~Position} position\n     * @param {module:engine/model/position~PositionStickiness} [stickiness]\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }], [{\n    key: \"fromPosition\",\n    value: function fromPosition(position, stickiness) {\n      return new this(position.root, position.path.slice(), stickiness ? stickiness : position.stickiness);\n    }\n    /**\n     * @static\n     * @protected\n     * @method module:engine/model/liveposition~LivePosition._createAfter\n     * @see module:engine/model/position~Position._createAfter\n     * @param {module:engine/model/node~Node} node\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone']\n     * @returns {module:engine/model/liveposition~LivePosition}\n     */\n\n    /**\n     * @static\n     * @protected\n     * @method module:engine/model/liveposition~LivePosition._createBefore\n     * @see module:engine/model/position~Position._createBefore\n     * @param {module:engine/model/node~Node} node\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone']\n     * @returns {module:engine/model/liveposition~LivePosition}\n     */\n\n    /**\n     * @static\n     * @protected\n     * @method module:engine/model/liveposition~LivePosition._createAt\n     * @see module:engine/model/position~Position._createAt\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset]\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone']\n     * @returns {module:engine/model/liveposition~LivePosition}\n     */\n\n    /**\n     * Fired when `LivePosition` instance is changed due to changes on {@link module:engine/model/document~Document}.\n     *\n     * @event module:engine/model/liveposition~LivePosition#change\n     * @param {module:engine/model/position~Position} oldPosition Position equal to this live position before it got changed.\n     */\n\n  }]);\n\n  return LivePosition;\n}(Position); // Binds this `LivePosition` to the {@link module:engine/model/document~Document document} that owns\n// this position's {@link module:engine/model/position~Position#root root}.\n//\n// @private\n\n\nexport { LivePosition as default };\n\nfunction bindWithDocument() {\n  var _this2 = this;\n\n  this.listenTo(this.root.document.model, 'applyOperation', function (event, args) {\n    var operation = args[0];\n\n    if (!operation.isDocumentOperation) {\n      return;\n    }\n\n    transform.call(_this2, operation);\n  }, {\n    priority: 'low'\n  });\n} // Updates this position accordingly to the updates applied to the model. Bases on change events.\n//\n// @private\n// @param {module:engine/model/operation/operation~Operation} operation Executed operation.\n\n\nfunction transform(operation) {\n  var result = this.getTransformedByOperation(operation);\n\n  if (!this.isEqual(result)) {\n    var oldPosition = this.toPosition();\n    this.path = result.path;\n    this.root = result.root;\n    this.fire('change', oldPosition);\n  }\n}\n\nmix(LivePosition, EmitterMixin);","import \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/insertcontent\n */\nimport Position from \"../position\";\nimport LivePosition from \"../liveposition\";\nimport Element from \"../element\";\nimport Range from \"../range\";\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport DocumentSelection from \"../documentselection\";\nimport Selection from \"../selection\";\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste\n * functionality to work.\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\n\nexport default function insertContent(model, content, selectable, placeOrOffset) {\n  return model.change(function (writer) {\n    var selection;\n\n    if (!selectable) {\n      selection = model.document.selection;\n    } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n      selection = selectable;\n    } else {\n      selection = writer.createSelection(selectable, placeOrOffset);\n    }\n\n    var insertionPosition = selection.getFirstPosition();\n\n    if (!selection.isCollapsed) {\n      model.deleteContent(selection, {\n        doNotAutoparagraph: true\n      });\n    }\n\n    var insertion = new Insertion(model, writer, insertionPosition);\n    var nodesToInsert;\n\n    if (content.is('documentFragment')) {\n      nodesToInsert = content.getChildren();\n    } else {\n      nodesToInsert = [content];\n    }\n\n    insertion.handleNodes(nodesToInsert, {\n      // The set of children being inserted is the only set in this context\n      // so it's the first and last (it's a hack ;)).\n      isFirst: true,\n      isLast: true\n    });\n    var newRange = insertion.getSelectionRange();\n    /* istanbul ignore else */\n\n    if (newRange) {\n      if (selection instanceof DocumentSelection) {\n        writer.setSelection(newRange);\n      } else {\n        selection.setTo(newRange);\n      }\n    } else {\n      // We are not testing else because it's a safe check for unpredictable edge cases:\n      // an insertion without proper range to select.\n\n      /**\n       * Cannot determine a proper selection range after insertion.\n       *\n       * @warning insertcontent-no-range\n       */\n      log.warn('insertcontent-no-range: Cannot determine a proper selection range after insertion.');\n    }\n\n    var affectedRange = insertion.getAffectedRange() || model.createRange(insertionPosition);\n    insertion.destroy();\n    return affectedRange;\n  });\n}\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\n\nvar Insertion =\n/*#__PURE__*/\nfunction () {\n  function Insertion(model, writer, position) {\n    _classCallCheck(this, Insertion);\n\n    /**\n     * The model in context of which the insertion should be performed.\n     *\n     * @member {module:engine/model~Model} #model\n     */\n    this.model = model;\n    /**\n     * Batch to which operations will be added.\n     *\n     * @member {module:engine/controller/writer~Batch} #writer\n     */\n\n    this.writer = writer;\n    /**\n     * The position at which (or near which) the next node will be inserted.\n     *\n     * @member {module:engine/model/position~Position} #position\n     */\n\n    this.position = position;\n    /**\n     * Elements with which the inserted elements can be merged.\n     *\n     *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n     *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n     *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n     *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n     *\n     *\n     * @member {Set} #canMergeWith\n     */\n\n    this.canMergeWith = new Set([this.position.parent]);\n    /**\n     * Schema of the model.\n     *\n     * @member {module:engine/model/schema~Schema} #schema\n     */\n\n    this.schema = model.schema;\n    this._filterAttributesOf = [];\n    /**\n     * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n     */\n\n    this._affectedStart = null;\n    /**\n     * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n     */\n\n    this._affectedEnd = null;\n  }\n  /**\n   * Handles insertion of a set of nodes.\n   *\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n   * @param {Object} parentContext Context in which parent of these nodes was supposed to be inserted.\n   * If the parent context is passed it means that the parent element was stripped (was not allowed).\n   */\n\n\n  _createClass(Insertion, [{\n    key: \"handleNodes\",\n    value: function handleNodes(nodes, parentContext) {\n      nodes = Array.from(nodes);\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n\n        this._handleNode(node, {\n          isFirst: i === 0 && parentContext.isFirst,\n          isLast: i === nodes.length - 1 && parentContext.isLast\n        });\n      } // TMP this will become a post-fixer.\n\n\n      this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);\n      this._filterAttributesOf = [];\n    }\n    /**\n     * Returns range to be selected after insertion.\n     * Returns `null` if there is no valid range to select after insertion.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n\n  }, {\n    key: \"getSelectionRange\",\n    value: function getSelectionRange() {\n      if (this.nodeToSelect) {\n        return Range._createOn(this.nodeToSelect);\n      }\n\n      return this.model.schema.getNearestSelectionRange(this.position);\n    }\n    /**\n     * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n     * before the insertion. Returns `null` if no changes were done.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n\n  }, {\n    key: \"getAffectedRange\",\n    value: function getAffectedRange() {\n      if (!this._affectedStart) {\n        return null;\n      }\n\n      return new Range(this._affectedStart, this._affectedEnd);\n    }\n    /**\n     * Destroys `Insertion` instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._affectedStart) {\n        this._affectedStart.detach();\n      }\n\n      if (this._affectedEnd) {\n        this._affectedEnd.detach();\n      }\n    }\n    /**\n     * Handles insertion of a single node.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node\n     * @param {Object} context\n     * @param {Boolean} context.isFirst Whether the given node is the first one in the content to be inserted.\n     * @param {Boolean} context.isLast Whether the given node is the last one in the content to be inserted.\n     */\n\n  }, {\n    key: \"_handleNode\",\n    value: function _handleNode(node, context) {\n      // Let's handle object in a special way.\n      // * They should never be merged with other elements.\n      // * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n      if (this.schema.isObject(node)) {\n        this._handleObject(node, context);\n\n        return;\n      } // Try to find a place for the given node.\n      // Split the position.parent's branch up to a point where the node can be inserted.\n      // If it isn't allowed in the whole branch, then of course don't split anything.\n\n\n      var isAllowed = this._checkAndSplitToAllowedPosition(node, context);\n\n      if (!isAllowed) {\n        this._handleDisallowedNode(node, context);\n\n        return;\n      }\n\n      this._insert(node); // After the node was inserted we may try to merge it with its siblings.\n      // This should happen only if it was the first and/or last of the nodes (so only with boundary nodes)\n      // and only if the selection was in those elements initially.\n      //\n      // E.g.:\n      // <p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n      // and:\n      // <p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n      // but:\n      // <p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging)\n      // <p>x</p>[<img>]<p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging, note: after running deleteContents\n      //\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t it's exactly the same case as above)\n\n\n      this._mergeSiblingsOf(node, context);\n    }\n    /**\n     * @private\n     * @param {module:engine/model/element~Element} node The object element.\n     * @param {Object} context\n     */\n\n  }, {\n    key: \"_handleObject\",\n    value: function _handleObject(node, context) {\n      // Try finding it a place in the tree.\n      if (this._checkAndSplitToAllowedPosition(node)) {\n        this._insert(node);\n      } // Try autoparagraphing.\n      else {\n          this._tryAutoparagraphing(node, context);\n        }\n    }\n    /**\n     * @private\n     * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n     * @param {Object} context\n     */\n\n  }, {\n    key: \"_handleDisallowedNode\",\n    value: function _handleDisallowedNode(node, context) {\n      // If the node is an element, try inserting its children (strip the parent).\n      if (node.is('element')) {\n        this.handleNodes(node.getChildren(), context);\n      } // If text is not allowed, try autoparagraphing it.\n      else {\n          this._tryAutoparagraphing(node, context);\n        }\n    }\n    /**\n     * @private\n     * @param {module:engine/model/node~Node} node The node to insert.\n     */\n\n  }, {\n    key: \"_insert\",\n    value: function _insert(node) {\n      /* istanbul ignore if */\n      if (!this.schema.checkChild(this.position, node)) {\n        // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n        // Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n        log.error('insertcontent-wrong-position: The node cannot be inserted on the given position.', {\n          node: node,\n          position: this.position\n        });\n        return;\n      }\n\n      var livePos = LivePosition.fromPosition(this.position, 'toNext');\n\n      this._setAffectedBoundaries(this.position);\n\n      this.writer.insert(node, this.position);\n      this.position = livePos.toPosition();\n      livePos.detach(); // The last inserted object should be selected because we can't put a collapsed selection after it.\n\n      if (this.schema.isObject(node) && !this.schema.checkChild(this.position, '$text')) {\n        this.nodeToSelect = node;\n      } else {\n        this.nodeToSelect = null;\n      }\n\n      this._filterAttributesOf.push(node);\n    }\n    /**\n     * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n     * mark the affected range.\n     *\n     * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n     * during merging, but the logic there is more complicated so it is left out of this function.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position\n     */\n\n  }, {\n    key: \"_setAffectedBoundaries\",\n    value: function _setAffectedBoundaries(position) {\n      // Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n      // <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n      // This is why it cannot be a range but two separate positions.\n      if (!this._affectedStart) {\n        this._affectedStart = LivePosition.fromPosition(position, 'toPrevious');\n      } // If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n      // inserted into the parent but the next node is moved-out of that parent:\n      // (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n      // (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n\n\n      if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {\n        if (this._affectedEnd) {\n          this._affectedEnd.detach();\n        }\n\n        this._affectedEnd = LivePosition.fromPosition(position, 'toNext');\n      }\n    }\n    /**\n     * @private\n     * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n     * @param {Object} context\n     */\n\n  }, {\n    key: \"_mergeSiblingsOf\",\n    value: function _mergeSiblingsOf(node, context) {\n      if (!(node instanceof Element)) {\n        return;\n      }\n\n      var mergeLeft = this._canMergeLeft(node, context);\n\n      var mergeRight = this._canMergeRight(node, context);\n\n      var mergePosLeft = LivePosition._createBefore(node);\n\n      mergePosLeft.stickiness = 'toNext';\n\n      var mergePosRight = LivePosition._createAfter(node);\n\n      mergePosRight.stickiness = 'toNext';\n\n      if (mergeLeft) {\n        var livePosition = LivePosition.fromPosition(this.position);\n        livePosition.stickiness = 'toNext'; // If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n        // removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n        // by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n        // shown as `][`).\n        //\n        // Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n        //\n        // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n        //\n        // Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n\n        if (this._affectedStart.isEqual(mergePosLeft)) {\n          this._affectedStart.detach();\n\n          this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toPrevious');\n        }\n\n        this.writer.merge(mergePosLeft); // If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n        //\n        // Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n        //\n        // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n        // <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n\n        if (mergePosLeft.isEqual(this._affectedEnd) && context.isLast) {\n          this._affectedEnd.detach();\n\n          this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toNext');\n        }\n\n        this.position = livePosition.toPosition();\n        livePosition.detach();\n      }\n\n      if (mergeRight) {\n        /* istanbul ignore if */\n        if (!this.position.isEqual(mergePosRight)) {\n          // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n          // At this point the insertion position should be after the node we'll merge. If it isn't,\n          // it should need to be secured as in the left merge case.\n          log.error('insertcontent-wrong-position-on-merge: The insertion position should equal the merge position');\n        } // Move the position to the previous node, so it isn't moved to the graveyard on merge.\n        // <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n\n\n        this.position = Position._createAt(mergePosRight.nodeBefore, 'end'); // OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n        // NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n\n        var _livePosition = LivePosition.fromPosition(this.position, 'toPrevious'); // See comment above on moving `_affectedStart`.\n\n\n        if (this._affectedEnd.isEqual(mergePosRight)) {\n          this._affectedEnd.detach();\n\n          this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, 'end', 'toNext');\n        }\n\n        this.writer.merge(mergePosRight); // See comment above on moving `_affectedStart`.\n\n        if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && context.isFirst) {\n          this._affectedStart.detach();\n\n          this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, 'toPrevious');\n        }\n\n        this.position = _livePosition.toPosition();\n\n        _livePosition.detach();\n      }\n\n      if (mergeLeft || mergeRight) {\n        // After merge elements that were marked by _insert() to be filtered might be gone so\n        // we need to mark the new container.\n        this._filterAttributesOf.push(this.position.parent);\n      }\n\n      mergePosLeft.detach();\n      mergePosRight.detach();\n    }\n    /**\n     * Checks whether specified node can be merged with previous sibling element.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n     * @param {Object} context\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_canMergeLeft\",\n    value: function _canMergeLeft(node, context) {\n      var previousSibling = node.previousSibling;\n      return context.isFirst && previousSibling instanceof Element && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);\n    }\n    /**\n     * Checks whether specified node can be merged with next sibling element.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n     * @param {Object} context\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_canMergeRight\",\n    value: function _canMergeRight(node, context) {\n      var nextSibling = node.nextSibling;\n      return context.isLast && nextSibling instanceof Element && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);\n    }\n    /**\n     * Tries wrapping the node in a new paragraph and inserting it this way.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n     * @param {Object} context\n     */\n\n  }, {\n    key: \"_tryAutoparagraphing\",\n    value: function _tryAutoparagraphing(node, context) {\n      var paragraph = this.writer.createElement('paragraph'); // Do not autoparagraph if the paragraph won't be allowed there,\n      // cause that would lead to an infinite loop. The paragraph would be rejected in\n      // the next _handleNode() call and we'd be here again.\n\n      if (this._getAllowedIn(paragraph, this.position.parent) && this.schema.checkChild(paragraph, node)) {\n        paragraph._appendChild(node);\n\n        this._handleNode(paragraph, context);\n      }\n    }\n    /**\n     * @private\n     * @param {module:engine/model/node~Node} node\n     * @returns {Boolean} Whether an allowed position was found.\n     * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n     */\n\n  }, {\n    key: \"_checkAndSplitToAllowedPosition\",\n    value: function _checkAndSplitToAllowedPosition(node) {\n      var allowedIn = this._getAllowedIn(node, this.position.parent);\n\n      if (!allowedIn) {\n        return false;\n      }\n\n      while (allowedIn != this.position.parent) {\n        // If a parent which we'd need to leave is a limit element, break.\n        if (this.schema.isLimit(this.position.parent)) {\n          return false;\n        }\n\n        if (this.position.isAtStart) {\n          // If insertion position is at the beginning of the parent, move it out instead of splitting.\n          // <p>^Foo</p> -> ^<p>Foo</p>\n          var parent = this.position.parent;\n          this.position = this.writer.createPositionBefore(parent); // Special case  parent is empty (<p>^</p>).\n          // We can remove the element after moving insertion position out of it.\n\n          if (parent.isEmpty) {\n            this.writer.remove(parent);\n          }\n        } else if (this.position.isAtEnd) {\n          // If insertion position is at the end of the parent, move it out instead of splitting.\n          // <p>Foo^</p> -> <p>Foo</p>^\n          this.position = this.writer.createPositionAfter(this.position.parent);\n        } else {\n          var tempPos = this.writer.createPositionAfter(this.position.parent);\n\n          this._setAffectedBoundaries(this.position);\n\n          this.writer.split(this.position);\n          this.position = tempPos;\n          this.canMergeWith.add(this.position.nodeAfter);\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node to check.\n     * @param {module:engine/model/element~Element} element The element in which the node's correctness should be checked.\n     * @returns {module:engine/model/element~Element|null}\n     */\n\n  }, {\n    key: \"_getAllowedIn\",\n    value: function _getAllowedIn(node, element) {\n      if (this.schema.checkChild(element, node)) {\n        return element;\n      }\n\n      if (element.parent) {\n        return this._getAllowedIn(node, element.parent);\n      }\n\n      return null;\n    }\n  }]);\n\n  return Insertion;\n}();","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\nimport LivePosition from \"../liveposition\";\nimport Range from \"../range\";\nimport DocumentSelection from \"../documentselection\";\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {module:engine/model/batch~Batch} batch Batch to which the operations will be added.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n *\n * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n */\n\nexport default function deleteContent(model, selection) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (selection.isCollapsed) {\n    return;\n  }\n\n  var selRange = selection.getFirstRange(); // If the selection is already removed, don't do anything.\n\n  if (selRange.root.rootName == '$graveyard') {\n    return;\n  }\n\n  var schema = model.schema;\n  model.change(function (writer) {\n    // 1. Replace the entire content with paragraph.\n    // See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {\n      replaceEntireContentWithParagraph(writer, selection, schema);\n      return;\n    }\n\n    var startPos = selRange.start;\n    var endPos = LivePosition.fromPosition(selRange.end, 'toNext'); // 2. Remove the content if there is any.\n\n    if (!selRange.start.isTouching(selRange.end)) {\n      writer.remove(selRange);\n    } // 3. Merge elements in the right branch to the elements in the left branch.\n    // The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n    //\n    // <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n    //\n    // However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n    // as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n    // want to override that behavior anyway.\n\n\n    if (!options.leaveUnmerged) {\n      mergeBranches(writer, startPos, endPos); // TMP this will be replaced with a postfixer.\n      // We need to check and strip disallowed attributes in all nested nodes because after merge\n      // some attributes could end up in a path where are disallowed.\n      //\n      // e.g. bold is disallowed for <H1>\n      // <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\n      schema.removeDisallowedAttributes(startPos.parent.getChildren(), writer);\n    }\n\n    collapseSelectionAt(writer, selection, startPos); // 4. Add a paragraph to set selection in it.\n    // Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n\n    if (shouldAutoparagraph(schema, startPos)) {\n      // If auto-paragraphing is off, find the closest valid selection range and collapse the selection there.\n      // If there is no valid selection range, create paragraph anyway and set selection there.\n      var validSelectionRange = schema.getNearestSelectionRange(startPos);\n\n      if (options.doNotAutoparagraph && validSelectionRange) {\n        collapseSelectionAt(writer, selection, validSelectionRange);\n      } else {\n        insertParagraph(writer, startPos, selection);\n      }\n    }\n\n    endPos.detach();\n  });\n} // This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\n\nfunction mergeBranches(writer, startPos, endPos) {\n  var startParent = startPos.parent;\n  var endParent = endPos.parent; // If both positions ended up in the same parent, then there's nothing more to merge:\n  // <$root><p>x[]</p><p>{}y</p></$root> => <$root><p>xy</p>[]{}</$root>\n\n  if (startParent == endParent) {\n    return;\n  } // If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\n\n  if (writer.model.schema.isLimit(startParent) || writer.model.schema.isLimit(endParent)) {\n    return;\n  } // Check if operations we'll need to do won't need to cross object or limit boundaries.\n  // E.g., we can't merge endParent into startParent in this case:\n  // <limit><startParent>x[]</startParent></limit><endParent>{}</endParent>\n\n\n  if (!checkCanBeMerged(startPos, endPos, writer.model.schema)) {\n    return;\n  } // Remember next positions to merge. For example:\n  // <a><b>x[]</b></a><c><d>{}y</d></c>\n  // will become:\n  // <a><b>xy</b>[]</a><c>{}</c>\n\n\n  startPos = writer.createPositionAfter(startParent);\n  endPos = writer.createPositionBefore(endParent);\n\n  if (!endPos.isEqual(startPos)) {\n    // In this case, before we merge, we need to move `endParent` to the `startPos`:\n    // <a><b>x[]</b></a><c><d>{}y</d></c>\n    // becomes:\n    // <a><b>x</b>[]<d>y</d></a><c>{}</c>\n    writer.insert(endParent, startPos);\n  } // Merge two siblings:\n  // <a>x</a>[]<b>y</b> -> <a>xy</a> (the usual case)\n  // <a><b>x</b>[]<d>y</d></a><c></c> -> <a><b>xy</b>[]</a><c></c> (this is the \"move parent\" case shown above)\n\n\n  writer.merge(startPos); // Remove empty end ancestors:\n  // <a>fo[o</a><b><a><c>bar]</c></a></b>\n  // becomes:\n  // <a>fo[]</a><b><a>{}</a></b>\n  // So we can remove <a> and <b>.\n\n  while (endPos.parent.isEmpty) {\n    var parentToRemove = endPos.parent;\n    endPos = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Continue merging next level.\n\n\n  mergeBranches(writer, startPos, endPos);\n}\n\nfunction shouldAutoparagraph(schema, position) {\n  var isTextAllowed = schema.checkChild(position, '$text');\n  var isParagraphAllowed = schema.checkChild(position, 'paragraph');\n  return !isTextAllowed && isParagraphAllowed;\n} // Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\n\n\nfunction checkCanBeMerged(leftPos, rightPos, schema) {\n  var rangeToCheck = new Range(leftPos, rightPos);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = rangeToCheck.getWalker()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      if (schema.isLimit(value.item)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction insertParagraph(writer, position, selection) {\n  var paragraph = writer.createElement('paragraph');\n  writer.insert(paragraph, position);\n  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));\n}\n\nfunction replaceEntireContentWithParagraph(writer, selection) {\n  var limitElement = writer.model.schema.getLimitElement(selection);\n  writer.remove(writer.createRangeIn(limitElement));\n  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);\n} // We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\n\n\nfunction shouldEntireContentBeReplacedWithParagraph(schema, selection) {\n  var limitElement = schema.getLimitElement(selection);\n\n  if (!selection.containsEntireContent(limitElement)) {\n    return false;\n  }\n\n  var range = selection.getFirstRange();\n\n  if (range.start.parent == range.end.parent) {\n    return false;\n  }\n\n  return schema.checkChild(limitElement, 'paragraph');\n} // Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\n\n\nfunction collapseSelectionAt(writer, selection, positionOrRange) {\n  if (selection instanceof DocumentSelection) {\n    writer.setSelection(positionOrRange);\n  } else {\n    selection.setTo(positionOrRange);\n  }\n}","import \"core-js/modules/es6.string.includes\";\nimport _typeof from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/typeof\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/modifyselection\n */\nimport Position from \"../position\";\nimport TreeWalker from \"../treewalker\";\nimport Range from \"../range\";\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport DocumentSelection from \"../documentselection\";\nvar wordBoundaryCharacters = ' ,.?!:;\"-()';\n/**\n * Modifies the selection. Currently, the supported modifications are:\n *\n * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n * Possible values for `unit` are:\n *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q` is a normal\n *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n *  why `'character'` value is most natural and common method of modifying selection.\n *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n *  For example `` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n *  extension will include whole \"surrogate pair\".\n *  * `'word'` - moves selection by a whole word.\n *\n * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n *\n * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#modifySelection}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection to modify.\n * @param {Object} [options]\n * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n */\n\nexport default function modifySelection(model, selection) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var schema = model.schema;\n  var isForward = options.direction != 'backward';\n  var unit = options.unit ? options.unit : 'character';\n  var focus = selection.focus;\n  var walker = new TreeWalker({\n    boundaries: getSearchRange(focus, isForward),\n    singleCharacters: true,\n    direction: isForward ? 'forward' : 'backward'\n  });\n  var data = {\n    walker: walker,\n    schema: schema,\n    isForward: isForward,\n    unit: unit\n  };\n  var next;\n\n  var _loop = function _loop() {\n    if (next.done) {\n      return {\n        v: void 0\n      };\n    }\n\n    var position = tryExtendingTo(data, next.value);\n\n    if (position) {\n      if (selection instanceof DocumentSelection) {\n        model.change(function (writer) {\n          writer.setSelectionFocus(position);\n        });\n      } else {\n        selection.setFocus(position);\n      }\n\n      return {\n        v: void 0\n      };\n    }\n  };\n\n  while (next = walker.next()) {\n    var _ret = _loop();\n\n    if (_typeof(_ret) === \"object\") return _ret.v;\n  }\n} // Checks whether the selection can be extended to the the walker's next value (next position).\n// @param {{ walker, unit, isForward, schema }} data\n// @param {module:engine/view/treewalker~TreeWalkerValue} value\n\nfunction tryExtendingTo(data, value) {\n  // If found text, we can certainly put the focus in it. Let's just find a correct position\n  // based on the unit.\n  if (value.type == 'text') {\n    if (data.unit === 'word') {\n      return getCorrectWordBreakPosition(data.walker, data.isForward);\n    }\n\n    return getCorrectPosition(data.walker, data.unit, data.isForward);\n  } // Entering an element.\n\n\n  if (value.type == (data.isForward ? 'elementStart' : 'elementEnd')) {\n    // If it's an object, we can select it now.\n    if (data.schema.isObject(value.item)) {\n      return Position._createAt(value.item, data.isForward ? 'after' : 'before');\n    } // If text allowed on this position, extend to this place.\n\n\n    if (data.schema.checkChild(value.nextPosition, '$text')) {\n      return value.nextPosition;\n    }\n  } // Leaving an element.\n  else {\n      // If leaving a limit element, stop.\n      if (data.schema.isLimit(value.item)) {\n        // NOTE: Fast-forward the walker until the end.\n        data.walker.skip(function () {\n          return true;\n        });\n        return;\n      } // If text allowed on this position, extend to this place.\n\n\n      if (data.schema.checkChild(value.nextPosition, '$text')) {\n        return value.nextPosition;\n      }\n    }\n} // Finds a correct position by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {String} unit The unit by which selection should be modified.\n\n\nfunction getCorrectPosition(walker, unit) {\n  var textNode = walker.position.textNode;\n\n  if (textNode) {\n    var data = textNode.data;\n    var offset = walker.position.offset - textNode.startOffset;\n\n    while (isInsideSurrogatePair(data, offset) || unit == 'character' && isInsideCombinedSymbol(data, offset)) {\n      walker.next();\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n\n  return walker.position;\n} // Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction getCorrectWordBreakPosition(walker, isForward) {\n  var textNode = walker.position.textNode;\n\n  if (textNode) {\n    var offset = walker.position.offset - textNode.startOffset;\n\n    while (!isAtWordBoundary(textNode.data, offset, isForward) && !isAtNodeBoundary(textNode, offset, isForward)) {\n      walker.next(); // Check of adjacent text nodes with different attributes (like BOLD).\n      // Example          : 'foofoo []bar<$text bold=\"true\">bar</$text> bazbaz'\n      // should expand to : 'foofoo [bar<$text bold=\"true\">bar</$text>] bazbaz'.\n\n      var nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore; // Scan only text nodes. Ignore inline elements (like `<softBreak>`).\n\n      if (nextNode && nextNode.is('text')) {\n        // Check boundary char of an adjacent text node.\n        var boundaryChar = nextNode.data.charAt(isForward ? 0 : nextNode.data.length - 1); // Go to the next node if the character at the boundary of that node belongs to the same word.\n\n        if (!wordBoundaryCharacters.includes(boundaryChar)) {\n          // If adjacent text node belongs to the same word go to it & reset values.\n          walker.next();\n          textNode = walker.position.textNode;\n        }\n      }\n\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n\n  return walker.position;\n}\n\nfunction getSearchRange(start, isForward) {\n  var root = start.root;\n\n  var searchEnd = Position._createAt(root, isForward ? 'end' : 0);\n\n  if (isForward) {\n    return new Range(start, searchEnd);\n  } else {\n    return new Range(searchEnd, start);\n  }\n} // Checks if selection is on word boundary.\n//\n// @param {String} data The text node value to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction isAtWordBoundary(data, offset, isForward) {\n  // The offset to check depends on direction.\n  var offsetToCheck = offset + (isForward ? 0 : -1);\n  return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));\n} // Checks if selection is on node boundary.\n//\n// @param {module:engine/model/text~Text} textNode The text node to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction isAtNodeBoundary(textNode, offset, isForward) {\n  return offset === (isForward ? textNode.endOffset : 0);\n}","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/getselectedcontent\n */\n\n/**\n * Gets a clone of the selected content.\n *\n * For example, for the following selection:\n *\n * ```html\n * <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n * ```\n *\n * It will return a document fragment with such a content:\n *\n * ```html\n * <quote><h>st</h></quote><p>se</p>\n * ```\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection of which content will be returned.\n * @returns {module:engine/model/documentfragment~DocumentFragment}\n */\nexport default function getSelectedContent(model, selection) {\n  return model.change(function (writer) {\n    var frag = writer.createDocumentFragment();\n    var range = selection.getFirstRange();\n\n    if (!range || range.isCollapsed) {\n      return frag;\n    }\n\n    var root = range.start.root;\n    var commonPath = range.start.getCommonPath(range.end);\n    var commonParent = root.getNodeByPath(commonPath); // ## 1st step\n    //\n    // First, we'll clone a fragment represented by a minimal flat range\n    // containing the original range to be cloned.\n    // E.g. let's consider such a range:\n    //\n    // <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n    //\n    // A minimal flat range containing this one is:\n    //\n    // <p>x</p>[<quote><p>y</p><h>first</h></quote><p>second</p>]<p>z</p>\n    //\n    // We can easily clone this structure, preserving e.g. the <quote> element.\n\n    var flatSubtreeRange;\n\n    if (range.start.parent == range.end.parent) {\n      // The original range is flat, so take it.\n      flatSubtreeRange = range;\n    } else {\n      flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range.start.path[commonPath.length]), writer.createPositionAt(commonParent, range.end.path[commonPath.length] + 1));\n    }\n\n    var howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset; // Clone the whole contents.\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = flatSubtreeRange.getItems({\n        shallow: true\n      })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var item = _step.value;\n\n        if (item.is('textProxy')) {\n          writer.appendText(item.data, item.getAttributes(), frag);\n        } else {\n          writer.append(item._clone(true), frag);\n        }\n      } // ## 2nd step\n      //\n      // If the original range wasn't flat, then we need to remove the excess nodes from the both ends of the cloned fragment.\n      //\n      // For example, for the range shown in the 1st step comment, we need to remove these pieces:\n      //\n      // <quote>[<p>y</p>]<h>[fir]st</h></quote><p>se[cond]</p>\n      //\n      // So this will be the final copied content:\n      //\n      // <quote><h>st</h></quote><p>se</p>\n      //\n      // In order to do that, we remove content from these two ranges:\n      //\n      // [<quote><p>y</p><h>fir]st</h></quote><p>se[cond</p>]\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (flatSubtreeRange != range) {\n      // Find the position of the original range in the cloned fragment.\n      var newRange = range._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];\n\n      var leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);\n      var rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, 'end'));\n      removeRangeContent(rightExcessRange, writer);\n      removeRangeContent(leftExcessRange, writer);\n    }\n\n    return frag;\n  });\n} // After https://github.com/ckeditor/ckeditor5-engine/issues/690 is fixed,\n// this function will, most likely, be able to rewritten using getMinimalFlatRanges().\n\nfunction removeRangeContent(range, writer) {\n  var parentsToCheck = [];\n  Array.from(range.getItems({\n    direction: 'backward'\n  })) // We should better store ranges because text proxies will lose integrity\n  // with the text nodes when we'll start removing content.\n  .map(function (item) {\n    return writer.createRangeOn(item);\n  }) // Filter only these items which are fully contained in the passed range.\n  //\n  // E.g. for the following range: [<quote><p>y</p><h>fir]st</h>\n  // the walker will return the entire <h> element, when only the \"fir\" item inside it is fully contained.\n  .filter(function (itemRange) {\n    // We should be able to use Range.containsRange, but https://github.com/ckeditor/ckeditor5-engine/issues/691.\n    var contained = (itemRange.start.isAfter(range.start) || itemRange.start.isEqual(range.start)) && (itemRange.end.isBefore(range.end) || itemRange.end.isEqual(range.end));\n    return contained;\n  }).forEach(function (itemRange) {\n    parentsToCheck.push(itemRange.start.parent);\n    writer.remove(itemRange);\n  }); // Remove ancestors of the removed items if they turned to be empty now\n  // (their whole content was contained in the range).\n\n  parentsToCheck.forEach(function (parentToCheck) {\n    var parent = parentToCheck;\n\n    while (parent.parent && parent.isEmpty) {\n      var removeRange = writer.createRangeOn(parent);\n      parent = parent.parent;\n      writer.remove(removeRange);\n    }\n  });\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/selection-post-fixer\n */\nimport Range from \"../range\";\nimport Position from \"../position\";\n/**\n * Injects selection post-fixer to the model.\n *\n * The role of the selection post-fixer is to ensure that the selection is in a correct place\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct position means that:\n *\n * * All collapsed selection ranges are in a place where the {@link module:engine/model/schema~Schema}\n * allows a `$text`.\n * * None of the selection's non-collapsed ranges crosses a {@link module:engine/model/schema~Schema#isLimit limit element}\n * boundary (a range must be rooted within one limit element).\n * * Only {@link module:engine/model/schema~Schema#isObject object elements} can be selected from the outside\n * (e.g. `[<paragraph>foo</paragraph>]` is invalid). This rule applies independently to both selection ends, so this\n * selection is correct: `<paragraph>f[oo</paragraph><image></image>]`.\n *\n * If the position is not correct, the post-fixer will automatically correct it.\n *\n * ## Fixing a non-collapsed selection\n *\n * See as an example a selection that starts in a P1 element and ends inside the text of a TD element\n * (`[` and `]` are range boundaries and `(l)` denotes an element defined as `isLimit=true`):\n *\n *\t\troot\n *\t\t |- element P1\n *\t\t |   |- \"foo\"                                      root\n *\t\t |- element TABLE (l)                   P1         TABLE             P2\n *\t\t |   |- element TR (l)                 f o[o     TR      TR         b a r\n *\t\t |   |   |- element TD (l)                       TD      TD\n *\t\t |   |       |- \"aaa\"                          a]a a    b b b\n *\t\t |   |- element TR (l)\n *\t\t |   |   |- element TD (l)                           ||\n *\t\t |   |       |- \"bbb\"                                ||\n *\t\t |- element P2                                       VV\n *\t\t |   |- \"bar\"\n *\t\t                                                   root\n *\t\t                                        P1         TABLE]            P2\n *\t\t                                       f o[o     TR      TR         b a r\n *\t\t                                                 TD      TD\n *\t\t                                               a a a    b b b\n *\n * In the example above, the TABLE, TR and TD are defined as `isLimit=true` in the schema. The range which is not contained within\n * a single limit element must be expanded to select the outermost limit element. The range end is inside the text node of the TD element.\n * As the TD element is a child of the TR and TABLE elements, where both are defined as `isLimit=true` in the schema, the range must be\n * expanded to select the whole TABLE element.\n *\n * **Note** If the selection contains multiple ranges, the method returns a minimal set of ranges that are not intersecting after expanding\n * them to select `isLimit=true` elements.\n *\n * @param {module:engine/model/model~Model} model\n */\n\nexport function injectSelectionPostFixer(model) {\n  model.document.registerPostFixer(function (writer) {\n    return selectionPostFixer(writer, model);\n  });\n} // The selection post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n\nfunction selectionPostFixer(writer, model) {\n  var selection = model.document.selection;\n  var schema = model.schema;\n  var ranges = [];\n  var wasFixed = false;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = selection.getRanges()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var modelRange = _step.value;\n      // Go through all ranges in selection and try fixing each of them.\n      // Those ranges might overlap but will be corrected later.\n      var correctedRange = tryFixingRange(modelRange, schema);\n\n      if (correctedRange) {\n        ranges.push(correctedRange);\n        wasFixed = true;\n      } else {\n        ranges.push(modelRange);\n      }\n    } // If any of ranges were corrected update the selection.\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (wasFixed) {\n    // The above algorithm might create ranges that intersects each other when selection contains more then one range.\n    // This is case happens mostly on Firefox which creates multiple ranges for selected table.\n    var fixedRanges = ranges; // Fixing selection with many ranges usually breaks the selection in Firefox. As only Firefox supports multiple selection ranges\n    // we simply create one continuous range from fixed selection ranges (even if they are not adjacent).\n\n    if (ranges.length > 1) {\n      var selectionStart = ranges[0].start;\n      var selectionEnd = ranges[ranges.length - 1].end;\n      fixedRanges = [new Range(selectionStart, selectionEnd)];\n    }\n\n    writer.setSelection(fixedRanges, {\n      backward: selection.isBackward\n    });\n  }\n} // Tries fixing a range if it's incorrect.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\n\n\nfunction tryFixingRange(range, schema) {\n  if (range.isCollapsed) {\n    return tryFixingCollapsedRange(range, schema);\n  }\n\n  return tryFixingNonCollapsedRage(range, schema);\n} // Tries to fix collapsed ranges.\n//\n// * Fixes situation when a range is in a place where $text is not allowed\n//\n// @param {module:engine/model/range~Range} range Collapsed range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\n\n\nfunction tryFixingCollapsedRange(range, schema) {\n  var originalPosition = range.start;\n  var nearestSelectionRange = schema.getNearestSelectionRange(originalPosition); // This might be null ie when editor data is empty.\n  // In such cases there is no need to fix the selection range.\n\n  if (!nearestSelectionRange) {\n    return null;\n  }\n\n  var fixedPosition = nearestSelectionRange.start; // Fixed position is the same as original - no need to return corrected range.\n\n  if (originalPosition.isEqual(fixedPosition)) {\n    return null;\n  } // Check single node selection (happens in tables).\n\n\n  if (fixedPosition.nodeAfter && schema.isLimit(fixedPosition.nodeAfter)) {\n    return new Range(fixedPosition, Position._createAfter(fixedPosition.nodeAfter));\n  }\n\n  return new Range(fixedPosition);\n} // Tries to fix an expanded range.\n//\n// @param {module:engine/model/range~Range} range Expanded range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\n\n\nfunction tryFixingNonCollapsedRage(range, schema) {\n  var start = range.start;\n  var end = range.end;\n  var isTextAllowedOnStart = schema.checkChild(start, '$text');\n  var isTextAllowedOnEnd = schema.checkChild(end, '$text');\n  var startLimitElement = schema.getLimitElement(start);\n  var endLimitElement = schema.getLimitElement(end); // Ranges which both end are inside the same limit element (or root) might needs only minor fix.\n\n  if (startLimitElement === endLimitElement) {\n    // Range is valid when both position allows to place a text:\n    // - <block>f[oobarba]z</block>\n    // This would be \"fixed\" by a next check but as it will be the same it's better to return null so the selection stays the same.\n    if (isTextAllowedOnStart && isTextAllowedOnEnd) {\n      return null;\n    } // Range that is on non-limit element (or is partially) must be fixed so it is placed inside the block around $text:\n    // - [<block>foo</block>]    ->    <block>[foo]</block>\n    // - [<block>foo]</block>    ->    <block>[foo]</block>\n    // - <block>f[oo</block>]    ->    <block>f[oo]</block>\n    // - [<block>foo</block><object></object>]    ->    <block>[foo</block><object></object>]\n\n\n    if (checkSelectionOnNonLimitElements(start, end, schema)) {\n      var isStartObject = start.nodeAfter && schema.isObject(start.nodeAfter);\n      var fixedStart = isStartObject ? null : schema.getNearestSelectionRange(start, 'forward');\n      var isEndObject = end.nodeBefore && schema.isObject(end.nodeBefore);\n      var fixedEnd = isEndObject ? null : schema.getNearestSelectionRange(end, 'backward'); // The schema.getNearestSelectionRange might return null - if that happens use original position.\n\n      var rangeStart = fixedStart ? fixedStart.start : start;\n      var rangeEnd = fixedEnd ? fixedEnd.start : end;\n      return new Range(rangeStart, rangeEnd);\n    }\n  }\n\n  var isStartInLimit = startLimitElement && !startLimitElement.is('rootElement');\n  var isEndInLimit = endLimitElement && !endLimitElement.is('rootElement'); // At this point we eliminated valid positions on text nodes so if one of range positions is placed inside a limit element\n  // then the range crossed limit element boundaries and needs to be fixed.\n\n  if (isStartInLimit || isEndInLimit) {\n    var bothInSameParent = start.nodeAfter && end.nodeBefore && start.nodeAfter.parent === end.nodeBefore.parent;\n    var expandStart = isStartInLimit && (!bothInSameParent || !isInObject(start.nodeAfter, schema));\n    var expandEnd = isEndInLimit && (!bothInSameParent || !isInObject(end.nodeBefore, schema)); // Although we've already found limit element on start/end positions we must find the outer-most limit element.\n    // as limit elements might be nested directly inside (ie table > tableRow > tableCell).\n\n    var _fixedStart = start;\n    var _fixedEnd = end;\n\n    if (expandStart) {\n      _fixedStart = Position._createBefore(findOutermostLimitAncestor(startLimitElement, schema));\n    }\n\n    if (expandEnd) {\n      _fixedEnd = Position._createAfter(findOutermostLimitAncestor(endLimitElement, schema));\n    }\n\n    return new Range(_fixedStart, _fixedEnd);\n  } // Range was not fixed at this point so it is valid - ie it was placed around limit element already.\n\n\n  return null;\n} // Finds the outer-most ancestor.\n//\n// @param {module:engine/model/node~Node} startingNode\n// @param {module:engine/model/schema~Schema} schema\n// @param {String} expandToDirection Direction of expansion - either 'start' or 'end' of the range.\n// @returns {module:engine/model/node~Node}\n\n\nfunction findOutermostLimitAncestor(startingNode, schema) {\n  var isLimitNode = startingNode;\n  var parent = isLimitNode; // Find outer most isLimit block as such blocks might be nested (ie. in tables).\n\n  while (schema.isLimit(parent) && parent.parent) {\n    isLimitNode = parent;\n    parent = parent.parent;\n  }\n\n  return isLimitNode;\n} // Checks whether any of range boundaries is placed around non-limit elements.\n//\n// @param {module:engine/model/position~Position} start\n// @param {module:engine/model/position~Position} end\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\n\n\nfunction checkSelectionOnNonLimitElements(start, end, schema) {\n  var startIsOnBlock = start.nodeAfter && !schema.isLimit(start.nodeAfter) || schema.checkChild(start, '$text');\n  var endIsOnBlock = end.nodeBefore && !schema.isLimit(end.nodeBefore) || schema.checkChild(end, '$text'); // We should fix such selection when one of those nodes needs fixing.\n\n  return startIsOnBlock || endIsOnBlock;\n} // Checks if node exists and if it's an object.\n//\n// @param {module:engine/model/node~Node} node\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\n\n\nfunction isInObject(node, schema) {\n  return node && schema.isObject(node);\n}","import \"core-js/modules/es6.regexp.search\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/model\n */\nimport Batch from \"./batch\";\nimport Writer from \"./writer\";\nimport Schema from \"./schema\";\nimport Document from \"./document\";\nimport MarkerCollection from \"./markercollection\";\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ModelElement from \"./element\";\nimport ModelRange from \"./range\";\nimport ModelPosition from \"./position\";\nimport ModelSelection from \"./selection\";\nimport _insertContent from \"./utils/insertcontent\";\nimport _deleteContent from \"./utils/deletecontent\";\nimport _modifySelection from \"./utils/modifyselection\";\nimport _getSelectedContent from \"./utils/getselectedcontent\";\nimport { injectSelectionPostFixer } from \"./utils/selection-post-fixer\";\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Model =\n/*#__PURE__*/\nfunction () {\n  function Model() {\n    var _this = this;\n\n    _classCallCheck(this, Model);\n\n    /**\n     * Model's marker collection.\n     *\n     * @readonly\n     * @member {module:engine/model/markercollection~MarkerCollection}\n     */\n    this.markers = new MarkerCollection();\n    /**\n     * Model's document.\n     *\n     * @readonly\n     * @member {module:engine/model/document~Document}\n     */\n\n    this.document = new Document(this);\n    /**\n     * Model's schema.\n     *\n     * @readonly\n     * @member {module:engine/model/schema~Schema}\n     */\n\n    this.schema = new Schema();\n    /**\n     * All callbacks added by {@link module:engine/model/model~Model#change} or\n     * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n     *\n     * @private\n     * @type {Array.<Function>}\n     */\n\n    this._pendingChanges = [];\n    /**\n     * The last created and currently used writer instance.\n     *\n     * @private\n     * @member {module:engine/model/writer~Writer}\n     */\n\n    this._currentWriter = null;\n    ['insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation'].forEach(function (methodName) {\n      return _this.decorate(methodName);\n    }); // Adding operation validation with `highest` priority, so it is called before any other feature would like\n    // to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n\n    this.on('applyOperation', function (evt, args) {\n      var operation = args[0];\n\n      operation._validate();\n    }, {\n      priority: 'highest'\n    }); // Register some default abstract entities.\n\n    this.schema.register('$root', {\n      isLimit: true\n    });\n    this.schema.register('$block', {\n      allowIn: '$root',\n      isBlock: true\n    });\n    this.schema.register('$text', {\n      allowIn: '$block',\n      isInline: true\n    });\n    this.schema.register('$clipboardHolder', {\n      allowContentOf: '$root',\n      isLimit: true\n    });\n    this.schema.extend('$text', {\n      allowIn: '$clipboardHolder'\n    }); // An element needed by the `upcastElementToMarker` converter.\n    // This element temporarily represents a marker boundary during the conversion process and is removed\n    // at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a\n    // better place for this registration but both know nothing about `Schema`.\n\n    this.schema.register('$marker');\n    this.schema.addChildCheck(function (context, childDefinition) {\n      if (childDefinition.name === '$marker') {\n        return true;\n      }\n    });\n    injectSelectionPostFixer(this);\n  }\n  /**\n   * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n   * (including detached nodes  i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n   * the {@link module:engine/model/document~Document#selection document's selection}, and\n   * {@link module:engine/model/model~Model#markers model markers}.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n   *\t\t} );\n   *\n   * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n   * into a single undo step.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n   *\n   *\t\t\tmodel.change( writer => {\n   *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n   *\t\t\t} );\n   *\n   * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n   *\t\t} );\n   *\n   * The callback of the `change()` block is executed synchronously.\n   *\n   * You can also return a value from the change block.\n   *\n   *\t\tconst img = model.change( writer => {\n   *\t\t\treturn writer.createElement( 'img' );\n   *\t\t} );\n   *\n   * @see #enqueueChange\n   * @param {Function} callback Callback function which may modify the model.\n   * @returns {*} Value returned by the callback.\n   */\n\n\n  _createClass(Model, [{\n    key: \"change\",\n    value: function change(callback) {\n      if (this._pendingChanges.length === 0) {\n        // If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n        this._pendingChanges.push({\n          batch: new Batch(),\n          callback: callback\n        });\n\n        return this._runPendingChanges()[0];\n      } else {\n        // If this is not the outermost block, just execute the callback.\n        return callback(this._currentWriter);\n      }\n    }\n    /**\n     * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n     *\n     * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n     * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n     * it will be delayed and executed after the outermost block.\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconsole.log( 1 );\n     *\n     *\t\t\tmodel.enqueueChange( writer => {\n     *\t\t\t\tconsole.log( 2 );\n     *\t\t\t} );\n     *\n     * \t\t\tconsole.log( 3 );\n     *\t\t} ); // Will log: 1, 3, 2.\n     *\n     * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n     * By default, a new batch is created. In the sample above, `change` and `enqueueChange` blocks use a different\n     * batch (and different {@link module:engine/model/writer~Writer} since each of them operates on the separate batch).\n     *\n     * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n     *\n     *\t\tmodel.enqueueChange( batch, writer => {\n     *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n     *\t\t} );\n     *\n     * The batch instance can be obtained from {@link module:engine/model/writer~Writer#batch the writer}.\n     *\n     * @param {module:engine/model/batch~Batch|'transparent'|'default'} batchOrType Batch or batch type should be used in the callback.\n     * If not defined, a new batch will be created.\n     * @param {Function} callback Callback function which may modify the model.\n     */\n\n  }, {\n    key: \"enqueueChange\",\n    value: function enqueueChange(batchOrType, callback) {\n      if (typeof batchOrType === 'string') {\n        batchOrType = new Batch(batchOrType);\n      } else if (typeof batchOrType == 'function') {\n        callback = batchOrType;\n        batchOrType = new Batch();\n      }\n\n      this._pendingChanges.push({\n        batch: batchOrType,\n        callback: callback\n      });\n\n      if (this._pendingChanges.length == 1) {\n        this._runPendingChanges();\n      }\n    }\n    /**\n     * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying\n     * {@link module:engine/model/operation/operation~Operation operations} to the model.\n     *\n     * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).\n     * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.\n     * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section\n     * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.\n     */\n\n  }, {\n    key: \"applyOperation\",\n    value: function applyOperation(operation) {\n      operation._execute();\n    }\n    /**\n     * Inserts content at the position in the editor specified by the selection, as one would expect the paste\n     * functionality to work.\n     *\n     * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting\n     * the content, clears the given selection's content before inserting nodes and moves the selection\n     * to its target position at the end of the process.\n     * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the\n     * pasting feature should do.\n     *\n     * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.\n     *\n     * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used\n     * inside a {@link #change `change()` block}.\n     *\n     * # Conversion and schema\n     *\n     * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content\n     * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does\n     * is only adding nodes to the model. Additionally, you need to define\n     * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n     * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n     *\n     * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods\n     * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML\n     * unless converters are defined for all elements and attributes in that HTML.\n     *\n     * # Examples\n     *\n     * Using `insertContent()` with a manually created model structure:\n     *\n     *\t\t// Let's create a document fragment containing such content as:\n     *\t\t//\n     *\t\t// <paragrap>foo</paragraph>\n     *\t\t// <blockQuote>\n     *\t\t//    <paragraph>bar</paragraph>\n     *\t\t// </blockQuote>\n     *\t\tconst docFrag = editor.model.change( writer => {\n     *\t\t\tconst p1 = writer.createElement( 'paragraph' );\n     *\t\t\tconst p2 = writer.createElement( 'paragraph' );\n     *\t\t\tconst blockQuote = writer.createElement( 'blockQuote' );\n     *\t\t\tconst docFrag = writer.createDocumentFragment();\n     *\n     *\t\t\twriter.append( p1, docFrag );\n     *\t\t\twriter.append( blockQuote, docFrag );\n     *\t\t\twriter.append( p2, blockQuote );\n     *\t\t\twriter.insertText( 'foo', p1 );\n     *\t\t\twriter.insertText( 'bar', p2 );\n     *\n     *\t\t\treturn docFrag;\n     *\t\t} );\n     *\n     *\t\t// insertContent() does not have to be used in a change() block. It can, though,\n     *\t\t// so this code could be moved to the callback defined above.\n     *\t\teditor.model.insertContent( docFrag );\n     *\n     * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):\n     *\n     *\t\t// You can create your own HtmlDataProcessor instance or use editor.data.processor\n     *\t\t// if you have not overridden the default one (which is the HtmlDataProcessor instance).\n     *\t\tconst htmlDP = new HtmlDataProcessor();\n     *\n     *\t\t// Convert an HTML string to a view document fragment:\n     *\t\tconst viewFragment = htmlDP.toView( htmlString );\n     *\n     *\t\t// Convert the view document fragment to a model document fragment\n     *\t\t// in the context of $root. This conversion takes the schema into\n     *\t\t// account so if, for example, the view document fragment contained a bare text node,\n     *\t\t// this text node cannot be a child of $root, so it will be automatically\n     *\t\t// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),\n     *\t\t// and e.g. convert the content like it would happen in a <paragraph>.\n     *\t\t// Note: The clipboard feature uses a custom context called $clipboardHolder\n     *\t\t// which has a loosened schema.\n     *\t\tconst modelFragment = editor.data.toModel( viewFragment );\n     *\n     *\t\teditor.model.insertContent( modelFragment );\n     *\n     * By default this method will use the document selection but it can also be used with a position, range or selection instance.\n     *\n     *\t\t// Insert text at the current document selection position.\n     *\t\teditor.model.change( writer => {\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ) );\n     *\t\t} );\n     *\n     *\t\t// Insert text at a given position - the document selection will not be modified.\n     *\t\teditor.model.change( writer => {\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );\n     *\n     *\t\t\t// Which is a shorthand for:\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );\n     *\t\t} );\n     *\n     * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable`\n     * it will be moved to the target position (where the document selection should be moved after the insertion).\n     *\n     *\t\teditor.model.change( writer => {\n     *\t\t\t// Insert text replacing the given selection instance.\n     *\t\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ), selection );\n     *\n     *\t\t\t// insertContent() modifies the passed selection instance so it can be used to set the document selection.\n     *\t\t\t// Note: This is not necessary when you passed the document selection to insertContent().\n     *\t\t\twriter.setSelection( selection );\n     *\t\t} );\n     *\n     * @fires insertContent\n     * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n     * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n     * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.\n     * This param defines a position in relation to that item.\n     * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n     * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n     * at the insertion position.\n     */\n\n  }, {\n    key: \"insertContent\",\n    value: function insertContent(content, selectable, placeOrOffset) {\n      return _insertContent(this, content, selectable, placeOrOffset);\n    }\n    /**\n     * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n     *\n     * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n     * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n     * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n     * then that behavior should be implemented in the view's listener. At the same time, the table feature\n     * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n     * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n     * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n     *\n     * @fires deleteContent\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * Selection of which the content should be deleted.\n     * @param {Object} [options]\n     * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n     *\n     * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:\n     *\n     * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)\n     * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n     *\n     * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n     * elements will not be merged.\n     *\n     * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n     * paragraph when the entire content was selected.\n     *\n     * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:\n     *\n     * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n     * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)\n     *\n     * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n     * to a place where text cannot be inserted.\n     *\n     * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n     *\n     * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n     * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n     *\n     * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n     *\n     * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n     */\n\n  }, {\n    key: \"deleteContent\",\n    value: function deleteContent(selection, options) {\n      _deleteContent(this, selection, options);\n    }\n    /**\n     * Modifies the selection. Currently, the supported modifications are:\n     *\n     * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n     * Possible values for `unit` are:\n     *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n     *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n     *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q` is a normal\n     *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n     *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n     *  why `'character'` value is most natural and common method of modifying selection.\n     *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n     *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n     *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n     *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n     *  For example `` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n     *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n     *  extension will include whole \"surrogate pair\".\n     *  * `'word'` - moves selection by a whole word.\n     *\n     * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n     *\n     * @fires modifySelection\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * The selection to modify.\n     * @param {Object} [options]\n     * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n     * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n     */\n\n  }, {\n    key: \"modifySelection\",\n    value: function modifySelection(selection, options) {\n      _modifySelection(this, selection, options);\n    }\n    /**\n     * Gets a clone of the selected content.\n     *\n     * For example, for the following selection:\n     *\n     * ```html\n     * <paragraph>x</paragraph>\n     * <blockQuote>\n     *\t<paragraph>y</paragraph>\n     *\t<heading1>fir[st</heading1>\n     * </blockQuote>\n     * <paragraph>se]cond</paragraph>\n     * <paragraph>z</paragraph>\n     * ```\n     *\n     * It will return a document fragment with such a content:\n     *\n     * ```html\n     * <blockQuote>\n     *\t<heading1>st</heading1>\n     * </blockQuote>\n     * <paragraph>se</paragraph>\n     * ```\n     *\n     * @fires getSelectedContent\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * The selection of which content will be returned.\n     * @returns {module:engine/model/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"getSelectedContent\",\n    value: function getSelectedContent(selection) {\n      return _getSelectedContent(this, selection);\n    }\n    /**\n     * Checks whether the given {@link module:engine/model/range~Range range} or\n     * {@link module:engine/model/element~Element element} has any meaningful content.\n     *\n     * Meaningful content is:\n     *\n     * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain\n     * any non-whitespace characters),\n     * * or any {@link module:engine/model/schema~Schema#isObject object element},\n     * * or any {@link module:engine/model/markercollection~Marker marker} which\n     * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.\n     *\n     * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.\n     * However, a range containing an `<image></image>` (which would normally be marked in the schema as an object element)\n     * is considered non-empty.\n     *\n     * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n     * @param {Object} [options]\n     * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasContent\",\n    value: function hasContent(rangeOrElement, options) {\n      var range = rangeOrElement instanceof ModelElement ? ModelRange._createIn(rangeOrElement) : rangeOrElement;\n\n      if (range.isCollapsed) {\n        return false;\n      } // Check if there are any markers which affects data in this given range.\n\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.markers.getMarkersIntersectingRange(range)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var intersectingMarker = _step.value;\n\n          if (intersectingMarker.affectsData) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _ref = options || {},\n          _ref$ignoreWhitespace = _ref.ignoreWhitespaces,\n          ignoreWhitespaces = _ref$ignoreWhitespace === void 0 ? false : _ref$ignoreWhitespace;\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = range.getItems()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var item = _step2.value;\n\n          if (item.is('textProxy')) {\n            if (!ignoreWhitespaces) {\n              return true;\n            } else if (item.data.search(/\\S/) !== -1) {\n              return true;\n            }\n          } else if (this.schema.isObject(item)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Creates a position from the given root and path in that root.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n     * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * See {@link module:engine/model/position~PositionStickiness}.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionFromPath\",\n    value: function createPositionFromPath(root, path, stickiness) {\n      return new ModelPosition(root, path, stickiness);\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/model/position~Position position},\n     * * a parent element and offset in that element,\n     * * a parent element and `'end'` (the position will be set at the end of that element),\n     * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`\n     * (the position will be set before or after the given model item).\n     *\n     * This method is a shortcut to other factory methods such as:\n     *\n     * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},\n     * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"createPositionAt\",\n    value: function createPositionAt(itemOrPosition, offset) {\n      return ModelPosition._createAt(itemOrPosition, offset);\n    }\n    /**\n     * Creates a new position after the given {@link module:engine/model/item~Item model item}.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAfter\",\n    value: function createPositionAfter(item) {\n      return ModelPosition._createAfter(item);\n    }\n    /**\n     * Creates a new position before the given {@link module:engine/model/item~Item model item}.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionBefore\",\n    value: function createPositionBefore(item) {\n      return ModelPosition._createBefore(item);\n    }\n    /**\n     * Creates a range spanning from the `start` position to the `end` position.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconst range = writer.createRange( start, end );\n     *\t\t} );\n     *\n     * @param {module:engine/model/position~Position} start Start position.\n     * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed\n     * to the `start` position.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRange\",\n    value: function createRange(start, end) {\n      return new ModelRange(start, end);\n    }\n    /**\n     * Creates a range inside the given element which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconst range = writer.createRangeIn( paragraph );\n     *\t\t} );\n     *\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRangeIn\",\n    value: function createRangeIn(element) {\n      return ModelRange._createIn(element);\n    }\n    /**\n     * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.\n     *\n     * Note: This method is also available on `writer` instance as\n     * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconst range = writer.createRangeOn( paragraph );\n     *\t\t} );\n     *\n     * @param {module:engine/model/item~Item} item\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRangeOn\",\n    value: function createRangeOn(item) {\n      return ModelRange._createOn(item);\n    }\n    /**\n     * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n     * or creates an empty selection if no arguments were passed.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.\n     *\n     *\t\t// Creates empty selection without ranges.\n     *\t\tconst selection = writer.createSelection();\n     *\n     *\t\t// Creates selection at the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tconst selection = writer.createSelection( range );\n     *\n     *\t\t// Creates selection at the given ranges\n     *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tconst selection = writer.createSelection( ranges );\n     *\n     *\t\t// Creates selection from the other selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tconst selection = writer.createSelection( otherSelection );\n     *\n     *\t\t// Creates selection from the given document selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst documentSelection = model.document.selection;\n     *\t\tconst selection = writer.createSelection( documentSelection );\n     *\n     *\t\t// Creates selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tconst selection = writer.createSelection( position );\n     *\n     *\t\t// Creates selection at the given offset in the given element.\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\tconst selection = writer.createSelection( paragraph, offset );\n     *\n     *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n     *\t\t// first child of that element and ends after the last child of that element.\n     *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n     *\t\t// just after the item.\n     *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n     *\n     *\t\t// Additional options (`'backward'`) can be specified as the last argument.\n     *\n     *\t\t// Creates backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @returns {module:engine/model/selection~Selection}\n     */\n\n  }, {\n    key: \"createSelection\",\n    value: function createSelection(selectable, placeOrOffset, options) {\n      return new ModelSelection(selectable, placeOrOffset, options);\n    }\n    /**\n     * Creates a {@link module:engine/model/batch~Batch} instance.\n     *\n     * **Note:** In most cases creating a batch instance is not necessary as they are created when using:\n     *\n     * * {@link #change `change()`},\n     * * {@link #enqueueChange `enqueueChange()`}.\n     *\n     * @returns {module:engine/model/batch~Batch}\n     */\n\n  }, {\n    key: \"createBatch\",\n    value: function createBatch() {\n      return new Batch();\n    }\n    /**\n     * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.document.destroy();\n      this.stopListening();\n    }\n    /**\n     * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n     * which calls callbacks and returns array of values returned by these callbacks.\n     *\n     * @private\n     * @returns {Array.<*>} Array of values returned by callbacks.\n     */\n\n  }, {\n    key: \"_runPendingChanges\",\n    value: function _runPendingChanges() {\n      var ret = [];\n      this.fire('_beforeChanges');\n\n      while (this._pendingChanges.length) {\n        // Create a new writer using batch instance created for this chain of changes.\n        var currentBatch = this._pendingChanges[0].batch;\n        this._currentWriter = new Writer(this, currentBatch); // Execute changes callback and gather the returned value.\n\n        var callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);\n\n        ret.push(callbackReturnValue);\n\n        this.document._handleChangeBlock(this._currentWriter);\n\n        this._pendingChanges.shift();\n\n        this._currentWriter = null;\n      }\n\n      this.fire('_afterChanges');\n      return ret;\n    }\n    /**\n     * Fired when entering the outermost {@link module:engine/model/model~Model#enqueueChange} or\n     * {@link module:engine/model/model~Model#change} block.\n     *\n     * @protected\n     * @event _beforeChanges\n     */\n\n    /**\n     * Fired when leaving the outermost {@link module:engine/model/model~Model#enqueueChange} or\n     * {@link module:engine/model/model~Model#change} block.\n     *\n     * @protected\n     * @event _afterChanges\n     */\n\n    /**\n     * Fired every time any {@link module:engine/model/operation/operation~Operation operation} is applied on the model\n     * using {@link #applyOperation}.\n     *\n     * Note that this event is suitable only for very specific use-cases. Use it if you need to listen to every single operation\n     * applied on the document. However, in most cases {@link module:engine/model/document~Document#event:change} should\n     * be used.\n     *\n     * A few callbacks are already added to this event by engine internal classes:\n     *\n     * * with `highest` priority operation is validated,\n     * * with `normal` priority operation is executed,\n     * * with `low` priority the {@link module:engine/model/document~Document} updates its version,\n     * * with `low` priority {@link module:engine/model/liveposition~LivePosition} and {@link module:engine/model/liverange~LiveRange}\n     * update themselves.\n     *\n     * @event applyOperation\n     * @param {Array} args Arguments of the `applyOperation` which is an array with a single element - applied\n     * {@link module:engine/model/operation/operation~Operation operation}.\n     */\n\n    /**\n     * Event fired when {@link #insertContent} method is called.\n     *\n     * The {@link #insertContent default action of that method} is implemented as a\n     * listener to this event so it can be fully customized by the features.\n     *\n     * **Note** The `selectable` parameter for the {@link #insertContent} is optional. When `undefined` value is passed the method uses\n     * `model.document.selection`.\n     *\n     * @event insertContent\n     * @param {Array} args The arguments passed to the original method.\n     */\n\n    /**\n     * Event fired when {@link #deleteContent} method is called.\n     *\n     * The {@link #deleteContent default action of that method} is implemented as a\n     * listener to this event so it can be fully customized by the features.\n     *\n     * @event deleteContent\n     * @param {Array} args The arguments passed to the original method.\n     */\n\n    /**\n     * Event fired when {@link #modifySelection} method is called.\n     *\n     * The {@link #modifySelection default action of that method} is implemented as a\n     * listener to this event so it can be fully customized by the features.\n     *\n     * @event modifySelection\n     * @param {Array} args The arguments passed to the original method.\n     */\n\n    /**\n     * Event fired when {@link #getSelectedContent} method is called.\n     *\n     * The {@link #getSelectedContent default action of that method} is implemented as a\n     * listener to this event so it can be fully customized by the features.\n     *\n     * @event getSelectedContent\n     * @param {Array} args The arguments passed to the original method.\n     */\n\n  }]);\n\n  return Model;\n}();\n\nexport { Model as default };\nmix(Model, ObservableMixin);","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/keystrokehandler\n */\nimport DomEmitterMixin from \"./dom/emittermixin\";\nimport { getCode, parseKeystroke } from \"./keyboard\";\n/**\n * Keystroke handler allows registering callbacks for given keystrokes.\n *\n * The most frequent use of this class is through the {@link module:core/editor/editor~Editor#keystrokes `editor.keystrokes`}\n * property. It allows listening to keystrokes executed in the editing view:\n *\n *\t\teditor.keystrokes.set( 'Ctrl+A', ( keyEvtData, cancel ) => {\n *\t\t\tconsole.log( 'Ctrl+A has been pressed' );\n *\t\t\tcancel();\n *\t\t} );\n *\n * However, this utility class can be used in various part of the UI. For instance, a certain {@link module:ui/view~View}\n * can use it like this:\n *\n *\t\tclass MyView extends View {\n *\t\t\tconstructor() {\n *\t\t\t\tthis.keystrokes = new KeystrokeHandler();\n *\n * \t\t\t\tthis.keystrokes.set( 'tab', handleTabKey );\n *\t\t\t}\n *\n *\t\t\trender() {\n *\t\t\t\tsuper.render();\n *\n *\t\t\t\tthis.keystrokes.listenTo( this.element );\n *\t\t\t}\n *\t\t}\n *\n * That keystroke handler will listen to `keydown` events fired in this view's main element.\n *\n */\n\nvar KeystrokeHandler =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the keystroke handler.\n   */\n  function KeystrokeHandler() {\n    _classCallCheck(this, KeystrokeHandler);\n\n    /**\n     * Listener used to listen to events for easier keystroke handler destruction.\n     *\n     * @protected\n     * @member {module:utils/dom/emittermixin~Emitter}\n     */\n    this._listener = Object.create(DomEmitterMixin);\n  }\n  /**\n   * Starts listening for `keydown` events from a given emitter.\n   *\n   * @param {module:utils/emittermixin~Emitter} emitter\n   */\n\n\n  _createClass(KeystrokeHandler, [{\n    key: \"listenTo\",\n    value: function listenTo(emitter) {\n      var _this = this;\n\n      // The #_listener works here as a kind of dispatcher. It groups the events coming from the same\n      // keystroke so the listeners can be attached to them with different priorities.\n      //\n      // E.g. all the keystrokes with the `keyCode` of 42 coming from the `emitter` are propagated\n      // as a `_keydown:42` event by the `_listener`. If there's a callback created by the `set`\n      // method for this 42 keystroke, it listens to the `_listener#_keydown:42` event only and interacts\n      // only with other listeners of this particular event, thus making it possible to prioritize\n      // the listeners and safely cancel execution, when needed. Instead of duplicating the Emitter logic,\n      // the KeystrokeHandler reuses it to do its job.\n      this._listener.listenTo(emitter, 'keydown', function (evt, keyEvtData) {\n        _this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n      });\n    }\n    /**\n     * Registers a handler for the specified keystroke.\n     *\n     * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by\n     * the {@link module:utils/keyboard~parseKeystroke} function.\n     * @param {Function} callback A function called with the\n     * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and\n     * a helper funcion to call both `preventDefault()` and `stopPropagation()` on the underlying event.\n     * @param {Object} [options={}] Additional options.\n     * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke\n     * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority\n     * are called in the order they were added.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(keystroke, callback) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var keyCode = parseKeystroke(keystroke);\n      var priority = options.priority; // Execute the passed callback on KeystrokeHandler#_keydown.\n      // TODO: https://github.com/ckeditor/ckeditor5-utils/issues/144\n\n      this._listener.listenTo(this._listener, '_keydown:' + keyCode, function (evt, keyEvtData) {\n        callback(keyEvtData, function () {\n          // Stop the event in the DOM: no listener in the web page\n          // will be triggered by this event.\n          keyEvtData.preventDefault();\n          keyEvtData.stopPropagation(); // Stop the event in the KeystrokeHandler: no more callbacks\n          // will be executed for this keystroke.\n\n          evt.stop();\n        }); // Mark this keystroke as handled by the callback. See: #press.\n\n        evt.return = true;\n      }, {\n        priority: priority\n      });\n    }\n    /**\n     * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.\n     *\n     * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEvtData Key event data.\n     * @returns {Boolean} Whether the keystroke was handled.\n     */\n\n  }, {\n    key: \"press\",\n    value: function press(keyEvtData) {\n      return !!this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n    }\n    /**\n     * Destroys the keystroke handler.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._listener.stopListening();\n    }\n  }]);\n\n  return KeystrokeHandler;\n}();\n\nexport { KeystrokeHandler as default };","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/editor/editor\n */\nimport Config from '@ckeditor/ckeditor5-utils/src/config';\nimport EditingController from '@ckeditor/ckeditor5-engine/src/controller/editingcontroller';\nimport PluginCollection from \"../plugincollection\";\nimport CommandCollection from \"../commandcollection\";\nimport Locale from '@ckeditor/ckeditor5-utils/src/locale';\nimport DataController from '@ckeditor/ckeditor5-engine/src/controller/datacontroller';\nimport Conversion from '@ckeditor/ckeditor5-engine/src/conversion/conversion';\nimport Model from '@ckeditor/ckeditor5-engine/src/model/model';\nimport EditingKeystrokeHandler from \"../editingkeystrokehandler\";\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Class representing a basic, generic editor.\n *\n * Check out the list of its subclasses to learn about specific editor implementations.\n *\n * All editor implementations (like {@link module:editor-classic/classiceditor~ClassicEditor} or\n * {@link module:editor-inline/inlineeditor~InlineEditor}) should extend this class. They can add their\n * own methods and properties.\n *\n * When you are implementing a plugin, then this editor represents the API\n * which your plugin can expect to get when using its {@link module:core/plugin~Plugin#editor} property.\n *\n * This API should be sufficient in order to implement the \"editing\" part of your feature\n * (schema definition, conversion, commands, keystrokes, etc.).\n * It does not define the editor UI, which is available only if the\n * the specific editor implements also the {@link module:core/editor/editorwithui~EditorWithUI} interface\n * (as most editor implementations do).\n *\n * @abstract\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Editor =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new instance of the Editor class.\n   *\n   * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.\n   *\n   * @param {Object} [config] The editor config.\n   */\n  function Editor(config) {\n    var _this = this;\n\n    _classCallCheck(this, Editor);\n\n    var availablePlugins = this.constructor.builtinPlugins;\n    /**\n     * Holds all configurations specific to this editor instance.\n     *\n     *\t\teditor.config.get( 'image.toolbar' );\n     *\t\t// -> [ 'imageStyle:full', 'imageStyle:side', '|', 'imageTextAlternative' ]\n     *\n     * @readonly\n     * @member {module:utils/config~Config}\n     */\n\n    this.config = new Config(config, this.constructor.defaultConfig);\n    this.config.define('plugins', availablePlugins);\n    /**\n     * The plugins loaded and in use by this editor instance.\n     *\n     *\t\teditor.plugins.get( 'Clipboard' ); // -> instance of the Clipboard plugin.\n     *\n     * @readonly\n     * @member {module:core/plugincollection~PluginCollection}\n     */\n\n    this.plugins = new PluginCollection(this, availablePlugins);\n    /**\n     * Commands registered to the editor.\n     *\n     * Use the shorthand {@link #execute `editor.execute()`} method to execute commands:\n     *\n     *\t\t// Execute the bold command:\n     *\t\teditor.execute( 'bold' );\n     *\n     *\t\t// Check the state of the bold command:\n     *\t\teditor.commands.get( 'bold' ).value;\n     *\n     * @readonly\n     * @member {module:core/commandcollection~CommandCollection}\n     */\n\n    this.commands = new CommandCollection();\n    /**\n     * @readonly\n     * @member {module:utils/locale~Locale}\n     */\n\n    this.locale = new Locale(this.config.get('language'));\n    /**\n     * Shorthand for {@link module:utils/locale~Locale#t}.\n     *\n     * @see module:utils/locale~Locale#t\n     * @method #t\n     */\n\n    this.t = this.locale.t;\n    /**\n     * Indicates the editor life-cycle state.\n     *\n     * The editor is in one of the following states:\n     *\n     * * `initializing` - during the editor initialization (before {@link module:core/editor/editor~Editor.create `Editor.create()`})\n     * finished its job,\n     * * `ready` - after the promise returned by the {@link module:core/editor/editor~Editor.create `Editor.create()`}\n     * method is resolved,\n     * * `destroyed` - once the {@link #destroy `editor.destroy()`} method was called.\n     *\n     * @observable\n     * @member {'initializing'|'ready'|'destroyed'} #state\n     */\n\n    this.set('state', 'initializing');\n    this.once('ready', function () {\n      return _this.state = 'ready';\n    }, {\n      priority: 'high'\n    });\n    this.once('destroy', function () {\n      return _this.state = 'destroyed';\n    }, {\n      priority: 'high'\n    });\n    /**\n     * Defines whether this editor is in read-only mode.\n     *\n     * In read-only mode the editor {@link #commands commands} are disabled so it is not possible\n     * to modify the document by using them. Also, the editable element(s) become non-editable.\n     *\n     * In order to make the editor read-only, you can set this value directly:\n     *\n     *\t\teditor.isReadOnly = true;\n     *\n     * @observable\n     * @member {Boolean} #isReadOnly\n     */\n\n    this.set('isReadOnly', false);\n    /**\n     * The editor's model.\n     *\n     * The central point of the editor's abstract data model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n\n    this.model = new Model();\n    /**\n     * The {@link module:engine/controller/datacontroller~DataController data controller}.\n     * Used e.g. for setting and retrieving editor data.\n     *\n     * @readonly\n     * @member {module:engine/controller/datacontroller~DataController}\n     */\n\n    this.data = new DataController(this.model);\n    /**\n     * The {@link module:engine/controller/editingcontroller~EditingController editing controller}.\n     * Controls user input and rendering the content for editing.\n     *\n     * @readonly\n     * @member {module:engine/controller/editingcontroller~EditingController}\n     */\n\n    this.editing = new EditingController(this.model);\n    this.editing.view.document.bind('isReadOnly').to(this);\n    /**\n     * Conversion manager through which you can register model to view and view to model converters.\n     *\n     * See {@link module:engine/conversion/conversion~Conversion}'s documentation to learn how to add converters.\n     *\n     * @readonly\n     * @member {module:engine/conversion/conversion~Conversion}\n     */\n\n    this.conversion = new Conversion([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);\n    this.conversion.addAlias('dataDowncast', this.data.downcastDispatcher);\n    this.conversion.addAlias('editingDowncast', this.editing.downcastDispatcher);\n    /**\n     * Instance of the {@link module:core/editingkeystrokehandler~EditingKeystrokeHandler}.\n     *\n     * It allows setting simple keystrokes:\n     *\n     *\t\t// Execute the bold command on Ctrl+E:\n     *\t\teditor.keystrokes.set( 'Ctrl+E', 'bold' );\n     *\n     *\t\t// Execute your own callback:\n     *\t\teditor.keystrokes.set( 'Ctrl+E', ( data, cancel ) => {\n     *\t\t\tconsole.log( data.keyCode );\n     *\n     *\t\t\t// Prevent default (native) action and stop the underlying keydown event\n     *\t\t\t// so no other editor feature will interfere.\n     *\t\t\tcancel();\n     *\t\t} );\n     *\n     * Note: Certain, typing oriented keystrokes (like <kbd>Backspace</kbd> or <kbd>Enter</kbd>) are handled\n     * by low level mechanism and trying to listen to them via the keystroke handler will not work reliably.\n     * To handle those specific keystrokes see the events fired by the\n     * {@link module:engine/view/document~Document editing view document} (`editor.editing.view.document`).\n     *\n     * @readonly\n     * @member {module:core/editingkeystrokehandler~EditingKeystrokeHandler}\n     */\n\n    this.keystrokes = new EditingKeystrokeHandler(this);\n    this.keystrokes.listenTo(this.editing.view.document);\n  }\n  /**\n   * Loads and initializes plugins specified in the config.\n   *\n   * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which resolves\n   * once the initialization is completed providing an array of loaded plugins.\n   */\n\n\n  _createClass(Editor, [{\n    key: \"initPlugins\",\n    value: function initPlugins() {\n      var config = this.config;\n      var plugins = config.get('plugins') || [];\n      var removePlugins = config.get('removePlugins') || [];\n      var extraPlugins = config.get('extraPlugins') || [];\n      return this.plugins.init(plugins.concat(extraPlugins), removePlugins);\n    }\n    /**\n     * Destroys the editor instance, releasing all resources used by it.\n     *\n     * **Note** The editor cannot be destroyed during the initialization phase so if it is called\n     * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.\n     *\n     * @fires destroy\n     * @returns {Promise} A promise that resolves once the editor instance is fully destroyed.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      var readyPromise = Promise.resolve();\n\n      if (this.state == 'initializing') {\n        readyPromise = new Promise(function (resolve) {\n          return _this2.once('ready', resolve);\n        });\n      }\n\n      return readyPromise.then(function () {\n        _this2.fire('destroy');\n\n        _this2.stopListening();\n\n        _this2.commands.destroy();\n      }).then(function () {\n        return _this2.plugins.destroy();\n      }).then(function () {\n        _this2.model.destroy();\n\n        _this2.data.destroy();\n\n        _this2.editing.destroy();\n\n        _this2.keystrokes.destroy();\n      });\n    }\n    /**\n     * Executes specified command with given parameters.\n     *\n     * Shorthand for:\n     *\n     *\t\teditor.commands.get( commandName ).execute( ... );\n     *\n     * @param {String} commandName Name of command to execute.\n     * @param {*} [...commandParams] Command parameters.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this$commands;\n\n      (_this$commands = this.commands).execute.apply(_this$commands, arguments);\n    }\n    /**\n     * Creates and initializes a new editor instance.\n     *\n     * This is an abstract method. Every editor type needs to implement its own initialization logic.\n     *\n     * See the `create()` methods of the existing editor types to learn how to use them:\n     *\n     * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}\n     * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}\n     * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}\n     * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}\n     *\n     * @abstract\n     * @method module:core/editor/editor~Editor.create\n     */\n\n  }]);\n\n  return Editor;\n}();\n\nexport { Editor as default };\nmix(Editor, ObservableMixin);\n/**\n * Fired when {@link module:engine/controller/datacontroller~DataController#event:ready data} and all additional\n * editor components are ready.\n *\n * Note: This event is most useful for plugin developers. When integrating the editor with your website or\n * application you do not have to listen to `editor#ready` because when the promise returned by the static\n * {@link module:core/editor/editor~Editor.create `Editor.create()`} event is resolved, the editor is already ready.\n * In fact, since the first moment when the editor instance is available to you is inside `then()`'s callback,\n * you cannot even add a listener to the `editor#ready` event.\n *\n * See also the {@link #state `editor.state`} property.\n *\n * @event ready\n */\n\n/**\n * Fired when this editor instance is destroyed. The editor at this point is not usable and this event should be used to\n * perform the clean-up in any plugin.\n *\n *\n * See also the {@link #state `editor.state`} property.\n *\n * @event destroy\n */\n\n/**\n * An array of plugins built into this editor class.\n * It is used in CKEditor 5 builds to provide a list of plugins which are later automatically initialized\n * during the editor initialization.\n *\n * They will be automatically initialized by the editor, unless listed in `config.removePlugins` and\n * unless `config.plugins` is passed.\n *\n *\t\t// Build some plugins into the editor class first.\n *\t\tClassicEditor.builtinPlugins = [ FooPlugin, BarPlugin ];\n *\n *\t\t// Normally, you need to define config.plugins, but since ClassicEditor.builtinPlugins was\n *\t\t// defined, now you can call create() without any configuration.\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.plugins.get( FooPlugin ); // -> instance of the Foo plugin\n *\t\t\t\teditor.plugins.get( BarPlugin ); // -> instance of the Bar plugin\n *\t\t\t} );\n *\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement, {\n *\t\t\t\t// Don't initialize this plugins (note: it's defined by a string):\n *\t\t\t\tremovePlugins: [ 'Foo' ]\n *\t\t\t} )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.plugins.get( FooPlugin ); // -> undefined\n *\t\t\t\teditor.config.get( BarPlugin ); // -> instance of the Bar plugin\n *\t\t\t} );\n *\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement, {\n *\t\t\t\t// Load only this plugin. Can also be define by a string if\n *\t\t\t\t// this plugin was built into the editor class.\n *\t\t\t\tplugins: [ FooPlugin ]\n *\t\t\t} )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.plugins.get( FooPlugin ); // -> instance of the Foo plugin\n *\t\t\t\teditor.config.get( BarPlugin ); // -> undefined\n *\t\t\t} );\n *\n * See also {@link module:core/editor/editor~Editor.defaultConfig}.\n *\n * @static\n * @member {Array.<Function>} module:core/editor/editor~Editor.builtinPlugins\n */\n\n/**\n * The default config which is built into the editor class.\n * It is used in CKEditor 5 builds to provide the default config options which are later used during editor initialization.\n *\n *\t\tClassicEditor.defaultConfig = {\n *\t\t\tfoo: 1,\n *\t\t\tbar: 2\n *\t\t};\n *\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.config.get( 'foo' ); // -> 1\n *\t\t\t\teditor.config.get( 'bar' ); // -> 2\n *\t\t\t} );\n *\n *\t\t// The default options can be overridden by the config passed to create().\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement, { bar: 3 } )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.config.get( 'foo' ); // -> 1\n *\t\t\t\teditor.config.get( 'bar' ); // -> 3\n *\t\t\t} );\n *\n * See also {@link module:core/editor/editor~Editor.builtinPlugins}.\n *\n * @static\n * @member {Object} module:core/editor/editor~Editor.defaultConfig\n */","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/editor/utils/dataapimixin\n */\n\n/**\n * Implementation of the {@link module:core/editor/utils/dataapimixin~DataApi}.\n *\n * @mixin DataApiMixin\n * @implements module:core/editor/utils/dataapimixin~DataApi\n */\nvar DataApiMixin = {\n  /**\n   * @inheritDoc\n   */\n  setData: function setData(data) {\n    this.data.set(data);\n  },\n\n  /**\n   * @inheritDoc\n   */\n  getData: function getData(options) {\n    return this.data.get(options);\n  }\n};\nexport default DataApiMixin;\n/**\n * Interface defining editor methods for setting and getting data to and from the editor's main root element\n * using the {@link module:core/editor/editor~Editor#data data pipeline}.\n *\n * This interface is not a part of the {@link module:core/editor/editor~Editor} class because one may want to implement\n * an editor with multiple root elements, in which case the methods for setting and getting data will need to be implemented\n * differently.\n *\n * @interface DataApi\n */\n\n/**\n * Sets the data in the editor.\n *\n *\t\teditor.setData( '<p>This is editor!</p>' );\n *\n * By default the editor accepts HTML. This can be controlled by injecting a different data processor.\n * See the {@glink features/markdown Markdown output} guide for more details.\n *\n * Note: Not only is the format of the data configurable, but the type of the `setData()`'s parameter does not\n * have to be a string either. You can e.g. accept an object or a DOM `DocumentFragment` if you consider this\n * the right format for you.\n *\n * @method #setData\n * @param {String} data Input data.\n */\n\n/**\n * Gets the data from the editor.\n *\n *\t\teditor.getData(); // -> '<p>This is editor!</p>'\n *\n * By default the editor outputs HTML. This can be controlled by injecting a different data processor.\n * See the {@glink features/markdown Markdown output} guide for more details.\n *\n * Note: Not only is the format of the data configurable, but the type of the `getData()`'s return value does not\n * have to be a string either. You can e.g. return an object or a DOM `DocumentFragment` if you consider this\n * the right format for you.\n *\n * @method #getData\n * @param {Object} [options]\n * @param {String} [options.rootName='main'] Root name.\n * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `'empty'` by default,\n * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming\n * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).\n * @returns {String} Output data.\n */","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/setdatainelement\n */\n\n/* globals HTMLTextAreaElement */\n\n/**\n * Sets data in a given element.\n *\n * @param {HTMLElement} el The element in which the data will be set.\n * @param {String} data The data string.\n */\nexport default function setDataInElement(el, data) {\n  if (el instanceof HTMLTextAreaElement) {\n    el.value = data;\n  }\n\n  el.innerHTML = data;\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport setDataInElement from '@ckeditor/ckeditor5-utils/src/dom/setdatainelement';\n/**\n * @module core/editor/utils/elementapimixin\n */\n\n/**\n * Implementation of the {@link module:core/editor/utils/elementapimixin~ElementApi}.\n *\n * @mixin ElementApiMixin\n * @implements module:core/editor/utils/elementapimixin~ElementApi\n */\n\nvar ElementApiMixin = {\n  /**\n   * @inheritDoc\n   */\n  updateSourceElement: function updateSourceElement() {\n    if (!this.sourceElement) {\n      /**\n       * Cannot update the source element of a detached editor.\n       *\n       * The {@link ~ElementApi#updateSourceElement `updateSourceElement()`} method cannot be called if you did not\n       * pass an element to `Editor.create()`.\n       *\n       * @error editor-missing-sourceelement\n       */\n      throw new CKEditorError('editor-missing-sourceelement: Cannot update the source element of a detached editor.');\n    }\n\n    setDataInElement(this.sourceElement, this.data.get());\n  }\n};\nexport default ElementApiMixin;\n/**\n * Interface describing an editor that replaced a DOM element (was \"initialized on an element\").\n *\n * Such an editor should provide a method to\n * {@link module:core/editor/utils/elementapimixin~ElementApi#updateSourceElement update the replaced element with the current data}.\n *\n * @interface ElementApi\n */\n\n/**\n * The element on which the editor has been initialized.\n *\n * @readonly\n * @member {HTMLElement} #sourceElement\n */\n\n/**\n * Updates the {@link #sourceElement editor source element}'s content with the data.\n *\n * @method #updateSourceElement\n */","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { isFunction } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * @module core/editor/utils/attachtoform\n */\n\n/**\n * Checks if the editor is initialized on a `<textarea>` element that belongs to a form. If yes, it updates the editor's element\n * content before submitting the form.\n *\n * This helper requires the {@link module:core/editor/utils/elementapimixin~ElementApi ElementApi interface}.\n *\n * @param {module:core/editor/editor~Editor} editor Editor instance.\n */\n\nexport default function attachToForm(editor) {\n  if (!isFunction(editor.updateSourceElement)) {\n    /**\n     * The editor passed to `attachToForm()` must implement the\n     * {@link module:core/editor/utils/elementapimixin~ElementApi} interface.\n     *\n     * @error attachtoform-missing-elementapi-interface\n     */\n    throw new CKEditorError('attachtoform-missing-elementapi-interface: Editor passed to attachToForm() must implement ElementApi.');\n  }\n\n  var sourceElement = editor.sourceElement; // Only when replacing a textarea which is inside of a form element.\n\n  if (sourceElement && sourceElement.tagName.toLowerCase() === 'textarea' && sourceElement.form) {\n    var originalSubmit;\n    var form = sourceElement.form;\n\n    var onSubmit = function onSubmit() {\n      return editor.updateSourceElement();\n    }; // Replace the original form#submit() to call a custom submit function first.\n    // Check if #submit is a function because the form might have an input named \"submit\".\n\n\n    if (isFunction(form.submit)) {\n      originalSubmit = form.submit;\n\n      form.submit = function () {\n        onSubmit();\n        originalSubmit.apply(form);\n      };\n    } // Update the replaced textarea with data before each form#submit event.\n\n\n    form.addEventListener('submit', onSubmit); // Remove the submit listener and revert the original submit method on\n    // editor#destroy.\n\n    editor.on('destroy', function () {\n      form.removeEventListener('submit', onSubmit);\n\n      if (originalSubmit) {\n        form.submit = originalSubmit;\n      }\n    });\n  }\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/dataprocessor/basichtmlwriter\n */\n\n/* globals document */\n\n/**\n * Basic HTML writer. It uses the native `innerHTML` property for basic conversion\n * from a document fragment to an HTML string.\n *\n * @implements module:engine/dataprocessor/htmlwriter~HtmlWriter\n */\nvar BasicHtmlWriter =\n/*#__PURE__*/\nfunction () {\n  function BasicHtmlWriter() {\n    _classCallCheck(this, BasicHtmlWriter);\n  }\n\n  _createClass(BasicHtmlWriter, [{\n    key: \"getHtml\",\n\n    /**\n     * Returns an HTML string created from the document fragment.\n     *\n     * @param {DocumentFragment} fragment\n     * @returns {String}\n     */\n    value: function getHtml(fragment) {\n      var doc = document.implementation.createHTMLDocument('');\n      var container = doc.createElement('div');\n      container.appendChild(fragment);\n      return container.innerHTML;\n    }\n  }]);\n\n  return BasicHtmlWriter;\n}();\n\nexport { BasicHtmlWriter as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"regenerator-runtime/runtime\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/componentfactory\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * A helper class implementing the UI component ({@link module:ui/view~View view}) factory.\n *\n * It allows functions producing specific UI components to be registered under their unique names\n * in the factory. A registered component can be then instantiated by providing its name.\n * Note that names are case insensitive.\n *\n *\t\t// The editor provides localization tools for the factory.\n *\t\tconst factory = new ComponentFactory( editor );\n *\n *\t\tfactory.add( 'foo', locale => new FooView( locale ) );\n *\t\tfactory.add( 'bar', locale => new BarView( locale ) );\n *\n *\t\t// An instance of FooView.\n *\t\tconst fooInstance = factory.create( 'foo' );\n *\n *\t\t// Names are case insensitive so this is also allowed:\n *\t\tconst barInstance = factory.create( 'Bar' );\n *\n * The {@link module:core/editor/editor~Editor#locale editor locale} is passed to the factory\n * function when {@link module:ui/componentfactory~ComponentFactory#create} is called.\n */\n\nvar ComponentFactory =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the factory.\n   *\n   * @constructor\n   * @param {module:core/editor/editor~Editor} editor The editor instance.\n   */\n  function ComponentFactory(editor) {\n    _classCallCheck(this, ComponentFactory);\n\n    /**\n     * The editor instance that the factory belongs to.\n     *\n     * @readonly\n     * @member {module:core/editor/editor~Editor}\n     */\n    this.editor = editor;\n    /**\n     * Registered component factories.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._components = new Map();\n  }\n  /**\n   * Returns an iterator of registered component names. Names are returned in lower case.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  _createClass(ComponentFactory, [{\n    key: \"names\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function names() {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, value;\n\n      return regeneratorRuntime.wrap(function names$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 3;\n              _iterator = this._components.values()[Symbol.iterator]();\n\n            case 5:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 12;\n                break;\n              }\n\n              value = _step.value;\n              _context.next = 9;\n              return value.originalName;\n\n            case 9:\n              _iteratorNormalCompletion = true;\n              _context.next = 5;\n              break;\n\n            case 12:\n              _context.next = 18;\n              break;\n\n            case 14:\n              _context.prev = 14;\n              _context.t0 = _context[\"catch\"](3);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 18:\n              _context.prev = 18;\n              _context.prev = 19;\n\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n\n            case 21:\n              _context.prev = 21;\n\n              if (!_didIteratorError) {\n                _context.next = 24;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 24:\n              return _context.finish(21);\n\n            case 25:\n              return _context.finish(18);\n\n            case 26:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, names, this, [[3, 14, 18, 26], [19,, 21, 25]]);\n    })\n    /**\n     * Registers a component factory function that will be used by the\n     * {@link #create create} method and called with the\n     * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,\n     * allowing localization of the {@link module:ui/view~View view}.\n     *\n     * @param {String} name The name of the component.\n     * @param {Function} callback The callback that returns the component.\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(name, callback) {\n      if (this.has(name)) {\n        /**\n         * The item already exists in the component factory.\n         *\n         * @error componentfactory-item-exists\n         * @param {String} name The name of the component.\n         */\n        throw new CKEditorError('componentfactory-item-exists: The item already exists in the component factory.', {\n          name: name\n        });\n      }\n\n      this._components.set(getNormalized(name), {\n        callback: callback,\n        originalName: name\n      });\n    }\n    /**\n     * Creates an instance of a component registered in the factory under a specific name.\n     *\n     * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to\n     * the previously {@link #add added} factory function, allowing localization of the\n     * {@link module:ui/view~View view}.\n     *\n     * @param {String} name The name of the component.\n     * @returns {module:ui/view~View} The instantiated component view.\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(name) {\n      if (!this.has(name)) {\n        /**\n         * The required component is not registered in the component factory. Please make sure\n         * the provided name is correct and the component has been correctly\n         * {@link #add added} to the factory.\n         *\n         * @error componentfactory-item-missing\n         * @param {String} name The name of the missing component.\n         */\n        throw new CKEditorError('componentfactory-item-missing: The required component is not registered in the factory.', {\n          name: name\n        });\n      }\n\n      return this._components.get(getNormalized(name)).callback(this.editor.locale);\n    }\n    /**\n     * Checks if a component of a given name is registered in the factory.\n     *\n     * @param {String} name The name of the component.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(name) {\n      return this._components.has(getNormalized(name));\n    }\n  }]);\n\n  return ComponentFactory;\n}(); //\n// Ensures that the component name used as the key in the internal map is in lower case.\n//\n// @private\n// @param {String} name\n// @returns {String}\n\n\nexport { ComponentFactory as default };\n\nfunction getNormalized(name) {\n  return String(name).toLowerCase();\n}","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global setTimeout, clearTimeout */\n\n/**\n * @module utils/focustracker\n */\nimport DomEmitterMixin from \"./dom/emittermixin\";\nimport ObservableMixin from \"./observablemixin\";\nimport CKEditorError from \"./ckeditorerror\";\nimport mix from \"./mix\";\n/**\n * Allows observing a group of `HTMLElement`s whether at least one of them is focused.\n *\n * Used by the {@link module:core/editor/editor~Editor} in order to track whether the focus is still within the application,\n * or were used outside of its UI.\n *\n * **Note** `focus` and `blur` listeners use event capturing, so it is only needed to register wrapper `HTMLElement`\n * which contain other `focusable` elements. But note that this wrapper element has to be focusable too\n * (have e.g. `tabindex=\"-1\"`).\n *\n * @mixes module:utils/dom/emittermixin~EmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar FocusTracker =\n/*#__PURE__*/\nfunction () {\n  function FocusTracker() {\n    _classCallCheck(this, FocusTracker);\n\n    /**\n     * True when one of the registered elements is focused.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isFocused\n     */\n    this.set('isFocused', false);\n    /**\n     * The currently focused element.\n     *\n     * While {@link #isFocused `isFocused`} remains `true`, the focus can\n     * move between different UI elements. This property tracks those\n     * elements and tells which one is currently focused.\n     *\n     * @readonly\n     * @observable\n     * @member {HTMLElement|null}\n     */\n\n    this.set('focusedElement', null);\n    /**\n     * List of registered elements.\n     *\n     * @private\n     * @member {Set.<HTMLElement>}\n     */\n\n    this._elements = new Set();\n    /**\n     * Event loop timeout.\n     *\n     * @private\n     * @member {Number}\n     */\n\n    this._nextEventLoopTimeout = null;\n  }\n  /**\n   * Starts tracking the specified element.\n   *\n   * @param {HTMLElement} element\n   */\n\n\n  _createClass(FocusTracker, [{\n    key: \"add\",\n    value: function add(element) {\n      var _this = this;\n\n      if (this._elements.has(element)) {\n        throw new CKEditorError('focusTracker-add-element-already-exist');\n      }\n\n      this.listenTo(element, 'focus', function () {\n        return _this._focus(element);\n      }, {\n        useCapture: true\n      });\n      this.listenTo(element, 'blur', function () {\n        return _this._blur();\n      }, {\n        useCapture: true\n      });\n\n      this._elements.add(element);\n    }\n    /**\n     * Stops tracking the specified element and stops listening on this element.\n     *\n     * @param {HTMLElement} element\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(element) {\n      if (element === this.focusedElement) {\n        this._blur(element);\n      }\n\n      if (this._elements.has(element)) {\n        this.stopListening(element);\n\n        this._elements.delete(element);\n      }\n    }\n    /**\n     * Destroys the focus tracker by:\n     * - Disabling all event listeners attached to tracked elements.\n     * - Removing all tracked elements that were previously added.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stopListening();\n    }\n    /**\n     * Stores currently focused element and set {#isFocused} as `true`.\n     *\n     * @private\n     * @param {HTMLElement} element Element which has been focused.\n     */\n\n  }, {\n    key: \"_focus\",\n    value: function _focus(element) {\n      clearTimeout(this._nextEventLoopTimeout);\n      this.focusedElement = element;\n      this.isFocused = true;\n    }\n    /**\n     * Clears currently focused element and set {@link #isFocused} as `false`.\n     * This method uses `setTimeout` to change order of fires `blur` and `focus` events.\n     *\n     * @private\n     * @fires blur\n     */\n\n  }, {\n    key: \"_blur\",\n    value: function _blur() {\n      var _this2 = this;\n\n      clearTimeout(this._nextEventLoopTimeout);\n      this._nextEventLoopTimeout = setTimeout(function () {\n        _this2.focusedElement = null;\n        _this2.isFocused = false;\n      }, 0);\n    }\n    /**\n     * @event focus\n     */\n\n    /**\n     * @event blur\n     */\n\n  }]);\n\n  return FocusTracker;\n}();\n\nexport { FocusTracker as default };\nmix(FocusTracker, DomEmitterMixin);\nmix(FocusTracker, ObservableMixin);","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/editor/editorui\n */\nimport ComponentFactory from '@ckeditor/ckeditor5-ui/src/componentfactory';\nimport FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * A class providing the minimal interface that is required to successfully bootstrap any editor UI.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar EditorUI =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the editor UI class.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor instance.\n   */\n  function EditorUI(editor) {\n    var _this = this;\n\n    _classCallCheck(this, EditorUI);\n\n    /**\n     * The editor that the UI belongs to.\n     *\n     * @readonly\n     * @member {module:core/editor/editor~Editor} #editor\n     */\n    this.editor = editor;\n    /**\n     * An instance of the {@link module:ui/componentfactory~ComponentFactory}, a registry used by plugins\n     * to register factories of specific UI components.\n     *\n     * @readonly\n     * @member {module:ui/componentfactory~ComponentFactory} #componentFactory\n     */\n\n    this.componentFactory = new ComponentFactory(editor);\n    /**\n     * Stores the information about the editor UI focus and propagates it so various plugins and components\n     * are unified as a focus group.\n     *\n     * @readonly\n     * @member {module:utils/focustracker~FocusTracker} #focusTracker\n     */\n\n    this.focusTracker = new FocusTracker();\n    /**\n     * Stores all editable elements used by the editor instance.\n     *\n     * @protected\n     * @member {Map.<String,HTMLElement>}\n     */\n\n    this._editableElements = new Map(); // Informs UI components that should be refreshed after layout change.\n\n    this.listenTo(editor.editing.view.document, 'layoutChanged', function () {\n      return _this.update();\n    });\n  }\n  /**\n   * The main (outermost) DOM element of the editor UI.\n   *\n   * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which\n   * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}\n   * it is the editable element itself (as there is no other wrapper). However, in\n   * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not\n   * come with a single \"main\" HTML element (its editable element and toolbar are separate).\n   *\n   * This property can be understood as a shorthand for retrieving the element that a specific editor integration\n   * considers to be its main DOM element.\n   *\n   * @readonly\n   * @member {HTMLElement|null} #element\n   */\n\n\n  _createClass(EditorUI, [{\n    key: \"update\",\n\n    /**\n     * Fires the {@link module:core/editor/editorui~EditorUI#event:update `update`} event.\n     *\n     * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to\n     * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).\n     */\n    value: function update() {\n      this.fire('update');\n    }\n    /**\n     * Destroys the UI.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stopListening();\n      this.focusTracker.destroy();\n      this._editableElements = new Map();\n    }\n    /**\n     * Returns the editable editor element with the given name or null if editable does not exist.\n     *\n     * @param {String} [rootName=main] The editable name.\n     * @returns {HTMLElement|undefined}\n     */\n\n  }, {\n    key: \"getEditableElement\",\n    value: function getEditableElement() {\n      var rootName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n      return this._editableElements.get(rootName);\n    }\n    /**\n     * Returns array of names of all editor editable elements.\n     *\n     * @returns {Iterable.<String>}\n     */\n\n  }, {\n    key: \"getEditableElementsNames\",\n    value: function getEditableElementsNames() {\n      return this._editableElements.keys();\n    }\n    /**\n     * Fired when the editor UI is ready.\n     *\n     * Fired before {@link module:engine/controller/datacontroller~DataController#event:ready}.\n     *\n     * @event ready\n     */\n\n    /**\n     * Fired whenever the UI (all related components) should be refreshed.\n     *\n     * **Note:**: The event is fired after each {@link module:engine/view/document~Document#event:layoutChanged}.\n     * It can also be fired manually via the {@link module:core/editor/editorui~EditorUI#update} method.\n     *\n     * @event update\n     */\n\n  }, {\n    key: \"element\",\n    get: function get() {\n      return null;\n    }\n  }]);\n\n  return EditorUI;\n}();\n\nexport { EditorUI as default };\nmix(EditorUI, EmitterMixin);","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/toolbar/enabletoolbarkeyboardfocus\n */\n\n/**\n * Enables focus/blur toolbar navigation using `Alt+F10` and `Esc` keystrokes.\n *\n * @param {Object} options Options of the utility.\n * @param {*} options.origin A view to which the focus will return when `Esc` is pressed and\n * `options.toolbar` is focused.\n * @param {module:utils/keystrokehandler~KeystrokeHandler} options.originKeystrokeHandler A keystroke\n * handler to register `Alt+F10` keystroke.\n * @param {module:utils/focustracker~FocusTracker} options.originFocusTracker A focus tracker\n * for `options.origin`.\n * @param {module:ui/toolbar/toolbarview~ToolbarView} options.toolbar A toolbar which is to gain\n * focus when `Alt+F10` is pressed.\n * @param {Function} [options.beforeFocus] A callback executed before the `options.toolbar` gains focus\n * upon the `Alt+F10` keystroke.\n * @param {Function} [options.afterBlur] A callback executed after `options.toolbar` loses focus upon\n * `Esc` keystroke but before the focus goes back to `options.origin`.\n */\nexport default function enableToolbarKeyboardFocus(_ref) {\n  var origin = _ref.origin,\n      originKeystrokeHandler = _ref.originKeystrokeHandler,\n      originFocusTracker = _ref.originFocusTracker,\n      toolbar = _ref.toolbar,\n      beforeFocus = _ref.beforeFocus,\n      afterBlur = _ref.afterBlur;\n  // Because toolbar items can get focus, the overall state of the toolbar must\n  // also be tracked.\n  originFocusTracker.add(toolbar.element); // Focus the toolbar on the keystroke, if not already focused.\n\n  originKeystrokeHandler.set('Alt+F10', function (data, cancel) {\n    if (originFocusTracker.isFocused && !toolbar.focusTracker.isFocused) {\n      if (beforeFocus) {\n        beforeFocus();\n      }\n\n      toolbar.focus();\n      cancel();\n    }\n  }); // Blur the toolbar and bring the focus back to origin.\n\n  toolbar.keystrokes.set('Esc', function (data, cancel) {\n    if (toolbar.focusTracker.isFocused) {\n      origin.focus();\n\n      if (afterBlur) {\n        afterBlur();\n      }\n\n      cancel();\n    }\n  });\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/toolbar/normalizetoolbarconfig\n */\n\n/**\n * Normalizes the toolbar configuration (`config.toolbar`), which:\n *\n * * may be defined as an `Array`:\n *\n * \t\ttoolbar: [ 'heading', 'bold', 'italic', 'link', ... ]\n *\n * * or an `Object`:\n *\n *\t\ttoolbar: {\n *\t\t\titems: [ 'heading', 'bold', 'italic', 'link', ... ],\n *\t\t\t...\n *\t\t}\n *\n * * or may not be defined at all (`undefined`)\n *\n * and returns it in the object form.\n *\n * @param {Array|Object|undefined} config The value of `config.toolbar`.\n * @returns {Object} A normalized toolbar config object.\n */\nexport default function normalizeToolbarConfig(config) {\n  if (Array.isArray(config)) {\n    return {\n      items: config\n    };\n  }\n\n  if (!config) {\n    return {\n      items: []\n    };\n  }\n\n  return Object.assign({\n    items: []\n  }, config);\n}","import _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.string.anchor\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.map\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.weak-map\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/placeholder\n */\nimport \"../../theme/placeholder.css\"; // Each document stores information about its placeholder elements and check functions.\n\nvar documentPlaceholders = new WeakMap();\n/**\n * A helper that enables a placeholder on the provided view element (also updates its visibility).\n * The placeholder is a CSS pseudoelement (with a text content) attached to the element.\n *\n * To change the placeholder text, simply call this method again with new options.\n *\n * To disable the placeholder, use {@link module:engine/view/placeholder~disablePlaceholder `disablePlaceholder()`} helper.\n *\n * @param {Object} [options] Configuration options of the placeholder.\n * @param {module:engine/view/view~View} options.view Editing view instance.\n * @param {module:engine/view/element~Element} options.element Element that will gain a placeholder.\n * See `options.isDirectHost` to learn more.\n * @param {String} options.text Placeholder text.\n * @param {Boolean} [options.isDirectHost=true] If set `false`, the placeholder will not be enabled directly\n * in the passed `element` but in one of its children (selected automatically, i.e. a first empty child element).\n * Useful when attaching placeholders to elements that can host other elements (not just text), for instance,\n * editable root elements.\n */\n\nexport function enablePlaceholder(options) {\n  var view = options.view,\n      element = options.element,\n      text = options.text,\n      _options$isDirectHost = options.isDirectHost,\n      isDirectHost = _options$isDirectHost === void 0 ? true : _options$isDirectHost;\n  var doc = view.document; // Use a single a single post fixer perdocument to update all placeholders.\n\n  if (!documentPlaceholders.has(doc)) {\n    documentPlaceholders.set(doc, new Map()); // If a post-fixer callback makes a change, it should return `true` so other postfixers\n    // can reevaluate the document again.\n\n    doc.registerPostFixer(function (writer) {\n      return updateDocumentPlaceholders(doc, writer);\n    });\n  } // Store information about the element placeholder under its document.\n\n\n  documentPlaceholders.get(doc).set(element, {\n    text: text,\n    isDirectHost: isDirectHost\n  }); // Update the placeholders right away.\n\n  view.change(function (writer) {\n    return updateDocumentPlaceholders(doc, writer);\n  });\n}\n/**\n * Disables the placeholder functionality from a given element.\n *\n * See {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} to learn more.\n *\n * @param {module:engine/view/view~View} view\n * @param {module:engine/view/element~Element} element\n */\n\nexport function disablePlaceholder(view, element) {\n  var doc = element.document;\n  view.change(function (writer) {\n    if (!documentPlaceholders.has(doc)) {\n      return;\n    }\n\n    var placeholders = documentPlaceholders.get(doc);\n    var config = placeholders.get(element);\n    writer.removeAttribute('data-placeholder', config.hostElement);\n    hidePlaceholder(writer, config.hostElement);\n    placeholders.delete(element);\n  });\n}\n/**\n * Shows a placeholder in the provided element by changing related attributes and CSS classes.\n *\n * **Note**: This helper will not update the placeholder visibility nor manage the\n * it in any way in the future. What it does is a onetime state change of an element. Use\n * {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} and\n * {@link module:engine/view/placeholder~disablePlaceholder `disablePlaceholder()`} for full\n * placeholder functionality.\n *\n * **Note**: This helper will blindly show the placeholder directly in the root editable element if\n * one is passed, which could result in a visual clash if the editable element has some children\n * (for instance, an empty paragraph). Use {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`}\n * in that case or make sure the correct element is passed to the helper.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/view/element~Element} element\n * @returns {Boolean} `true`, if any changes were made to the `element`.\n */\n\nexport function showPlaceholder(writer, element) {\n  if (!element.hasClass('ck-placeholder')) {\n    writer.addClass('ck-placeholder', element);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Hides a placeholder in the element by changing related attributes and CSS classes.\n *\n * **Note**: This helper will not update the placeholder visibility nor manage the\n * it in any way in the future. What it does is a onetime state change of an element. Use\n * {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} and\n * {@link module:engine/view/placeholder~disablePlaceholder `disablePlaceholder()`} for full\n * placeholder functionality.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/view/element~Element} element\n * @returns {Boolean} `true`, if any changes were made to the `element`.\n */\n\nexport function hidePlaceholder(writer, element) {\n  if (element.hasClass('ck-placeholder')) {\n    writer.removeClass('ck-placeholder', element);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Checks if a placeholder should be displayed in the element.\n *\n * **Note**: This helper will blindly check the possibility of showing a placeholder directly in the\n * root editable element if one is passed, which may not be the expected result. If an element can\n * host other elements (not just text), most likely one of its children should be checked instead\n * because it will be the final host for the placeholder. Use\n * {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} in that case or make\n * sure the correct element is passed to the helper.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/view/element~Element} element\n * @param {String} text\n * @returns {Boolean}\n */\n\nexport function needsPlaceholder(element) {\n  var doc = element.document; // The element was removed from document.\n\n  if (!doc) {\n    return false;\n  } // The element is empty only as long as it contains nothing but uiElements.\n\n\n  var isEmptyish = !Array.from(element.getChildren()).some(function (element) {\n    return !element.is('uiElement');\n  }); // If the element is empty and the document is blurred.\n\n  if (!doc.isFocused && isEmptyish) {\n    return true;\n  }\n\n  var viewSelection = doc.selection;\n  var selectionAnchor = viewSelection.anchor; // If document is focused and the element is empty but the selection is not anchored inside it.\n\n  if (isEmptyish && selectionAnchor && selectionAnchor.parent !== element) {\n    return true;\n  }\n\n  return false;\n} // Updates all placeholders associated with a document in a postfixer callback.\n//\n// @private\n// @param { module:engine/model/document~Document} doc\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n// @returns {Boolean} True if any changes were made to the view document.\n\nfunction updateDocumentPlaceholders(doc, writer) {\n  var placeholders = documentPlaceholders.get(doc);\n  var wasViewModified = false;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = placeholders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          element = _step$value[0],\n          config = _step$value[1];\n\n      if (updatePlaceholder(writer, element, config)) {\n        wasViewModified = true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return wasViewModified;\n} // Updates a single placeholder in a postfixer callback.\n//\n// @private\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n// @param {module:engine/view/element~Element} element\n// @param {Object} config Configuration of the placeholder\n// @param {String} config.text\n// @param {Boolean} config.isDirectHost\n// @returns {Boolean} True if any changes were made to the view document.\n\n\nfunction updatePlaceholder(writer, element, config) {\n  var text = config.text,\n      isDirectHost = config.isDirectHost;\n  var hostElement = isDirectHost ? element : getChildPlaceholderHostSubstitute(element);\n  var wasViewModified = false; // When not a direct host, it could happen that there is no child element\n  // capable of displaying a placeholder.\n\n  if (!hostElement) {\n    return false;\n  } // Cache the host element. It will be necessary for disablePlaceholder() to know\n  // which element should have class and attribute removed because, depending on\n  // the config.isDirectHost value, it could be the element or one of its descendants.\n\n\n  config.hostElement = hostElement; // This may be necessary when updating the placeholder text to something else.\n\n  if (hostElement.getAttribute('data-placeholder') !== text) {\n    writer.setAttribute('data-placeholder', text, hostElement);\n    wasViewModified = true;\n  }\n\n  if (needsPlaceholder(hostElement)) {\n    if (showPlaceholder(writer, hostElement)) {\n      wasViewModified = true;\n    }\n  } else if (hidePlaceholder(writer, hostElement)) {\n    wasViewModified = true;\n  }\n\n  return wasViewModified;\n} // Gets a child element capable of displaying a placeholder if a parent element can host more\n// than just text (for instance, when it is a root editable element). The child element\n// can then be used in other placeholder helpers as a substitute of its parent.\n//\n// @private\n// @param {module:engine/view/element~Element} parent\n// @returns {module:engine/view/element~Element|null}\n\n\nfunction getChildPlaceholderHostSubstitute(parent) {\n  if (parent.childCount === 1) {\n    var firstChild = parent.getChild(0);\n\n    if (firstChild.is('element') && !firstChild.is('uiElement')) {\n      return firstChild;\n    }\n  }\n\n  return null;\n}","import \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/elementreplacer\n */\n\n/**\n * Utility class allowing to hide existing HTML elements or replace them with given ones in a way that doesn't remove\n * the original elements from the DOM.\n */\nvar ElementReplacer =\n/*#__PURE__*/\nfunction () {\n  function ElementReplacer() {\n    _classCallCheck(this, ElementReplacer);\n\n    /**\n     * The elements replaced by {@link #replace} and their replacements.\n     *\n     * @private\n     * @member {Array.<Object>}\n     */\n    this._replacedElements = [];\n  }\n  /**\n   * Hides the `element` and, if specified, inserts the the given element next to it.\n   *\n   * The effect of this method can be reverted by {@link #restore}.\n   *\n   * @param {HTMLElement} element The element to replace.\n   * @param {HTMLElement} [newElement] The replacement element. If not passed, then the `element` will just be hidden.\n   */\n\n\n  _createClass(ElementReplacer, [{\n    key: \"replace\",\n    value: function replace(element, newElement) {\n      this._replacedElements.push({\n        element: element,\n        newElement: newElement\n      });\n\n      element.style.display = 'none';\n\n      if (newElement) {\n        element.parentNode.insertBefore(newElement, element.nextSibling);\n      }\n    }\n    /**\n     * Restores what {@link #replace} did.\n     */\n\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      this._replacedElements.forEach(function (_ref) {\n        var element = _ref.element,\n            newElement = _ref.newElement;\n        element.style.display = '';\n\n        if (newElement) {\n          newElement.remove();\n        }\n      });\n\n      this._replacedElements = [];\n    }\n  }]);\n\n  return ElementReplacer;\n}();\n\nexport { ElementReplacer as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/viewcollection\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\n/**\n * Collects {@link module:ui/view~View} instances.\n *\n *\t\tconst parentView = new ParentView( locale );\n *\t\tconst collection = new ViewCollection( locale );\n *\n *\t\tcollection.setParent( parentView.element );\n *\n *\t\tconst viewA = new ChildView( locale );\n *\t\tconst viewB = new ChildView( locale );\n *\n * View collection renders and manages view {@link module:ui/view~View#element elements}:\n *\n *\t\tcollection.add( viewA );\n *\t\tcollection.add( viewB );\n *\n *\t\tconsole.log( parentView.element.firsChild ); // -> viewA.element\n *\t\tconsole.log( parentView.element.lastChild ); // -> viewB.element\n *\n * It {@link module:ui/viewcollection~ViewCollection#delegate propagates} DOM events too:\n *\n *\t\t// Delegate #click and #keydown events from viewA and viewB to the parentView.\n *\t\tcollection.delegate( 'click' ).to( parentView );\n *\n *\t\tparentView.on( 'click', ( evt ) => {\n *\t\t\tconsole.log( `${ evt.source } has been clicked.` );\n *\t\t} );\n *\n *\t\t// This event will be delegated to the parentView.\n *\t\tviewB.fire( 'click' );\n *\n * **Note**: A view collection can be used directly in the {@link module:ui/template~TemplateDefinition definition}\n * of a {@link module:ui/template~Template template}.\n *\n * @extends module:utils/collection~Collection\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar ViewCollection =\n/*#__PURE__*/\nfunction (_Collection) {\n  _inherits(ViewCollection, _Collection);\n\n  /**\n   * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.\n   *\n   * @param {module:utils/locale~Locale} [locale] The {@link module:core/editor/editor~Editor editor's locale} instance.\n   */\n  function ViewCollection(locale) {\n    var _this;\n\n    _classCallCheck(this, ViewCollection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ViewCollection).call(this, {\n      // An #id Number attribute should be legal and not break the `ViewCollection` instance.\n      // https://github.com/ckeditor/ckeditor5-ui/issues/93\n      idProperty: 'viewUid'\n    })); // Handle {@link module:ui/view~View#element} in DOM when a new view is added to the collection.\n\n    _this.on('add', function (evt, view, index) {\n      if (!view.isRendered) {\n        view.render();\n      }\n\n      if (view.element && _this._parentElement) {\n        _this._parentElement.insertBefore(view.element, _this._parentElement.children[index]);\n      }\n    }); // Handle {@link module:ui/view~View#element} in DOM when a view is removed from the collection.\n\n\n    _this.on('remove', function (evt, view) {\n      if (view.element && _this._parentElement) {\n        view.element.remove();\n      }\n    });\n    /**\n     * The {@link module:core/editor/editor~Editor#locale editor's locale} instance.\n     * See the view {@link module:ui/view~View#locale locale} property.\n     *\n     * @member {module:utils/locale~Locale}\n     */\n\n\n    _this.locale = locale;\n    /**\n     * A parent element within which child views are rendered and managed in DOM.\n     *\n     * @protected\n     * @member {HTMLElement}\n     */\n\n    _this._parentElement = null;\n    return _this;\n  }\n  /**\n   * Destroys the view collection along with child views.\n   * See the view {@link module:ui/view~View#destroy} method.\n   */\n\n\n  _createClass(ViewCollection, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.map(function (view) {\n        return view.destroy();\n      });\n    }\n    /**\n     * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and\n     * {@link #remove removing} views in the collection synchronizes their\n     * {@link module:ui/view~View#element elements} in the parent element.\n     *\n     * @param {HTMLElement} element A new parent element.\n     */\n\n  }, {\n    key: \"setParent\",\n    value: function setParent(elementOrDocFragment) {\n      this._parentElement = elementOrDocFragment;\n    }\n    /**\n     * Delegates selected events coming from within views in the collection to any\n     * {@link module:utils/emittermixin~Emitter}.\n     *\n     * For the following views and collection:\n     *\n     *\t\tconst viewA = new View();\n     *\t\tconst viewB = new View();\n     *\t\tconst viewC = new View();\n     *\n     *\t\tconst views = parentView.createCollection();\n     *\n     *\t\tviews.delegate( 'eventX' ).to( viewB );\n     *\t\tviews.delegate( 'eventX', 'eventY' ).to( viewC );\n     *\n     *\t\tviews.add( viewA );\n     *\n     * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:\n     *\n     *\t\tviewA.fire( 'eventX', customData );\n     *\n     * and `eventY` is delegated (fired by) `viewC` along with `customData`:\n     *\n     *\t\tviewA.fire( 'eventY', customData );\n     *\n     * See {@link module:utils/emittermixin~EmitterMixin#delegate}.\n     *\n     * @param {...String} events {@link module:ui/view~View} event names to be delegated to another\n     * {@link module:utils/emittermixin~Emitter}.\n     * @returns {Object}\n     * @returns {Function} return.to A function which accepts the destination of\n     * {@link module:utils/emittermixin~EmitterMixin#delegate delegated} events.\n     */\n\n  }, {\n    key: \"delegate\",\n    value: function delegate() {\n      var _this2 = this;\n\n      for (var _len = arguments.length, events = new Array(_len), _key = 0; _key < _len; _key++) {\n        events[_key] = arguments[_key];\n      }\n\n      if (!events.length || !isStringArray(events)) {\n        /**\n         * All event names must be strings.\n         *\n         * @error ui-viewcollection-delegate-wrong-events\n         */\n        throw new CKEditorError('ui-viewcollection-delegate-wrong-events: All event names must be strings.');\n      }\n\n      return {\n        /**\n         * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.\n         *\n         * @memberOf module:ui/viewcollection~ViewCollection#delegate\n         * @function module:ui/viewcollection~ViewCollection#delegate.to\n         * @param {module:utils/emittermixin~EmitterMixin} dest An `EmitterMixin` instance which is\n         * the destination for delegated events.\n         */\n        to: function to(dest) {\n          // Activate delegating on existing views in this collection.\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = _this2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var view = _step.value;\n\n              for (var _i3 = 0, _events3 = events; _i3 < _events3.length; _i3++) {\n                var evtName = _events3[_i3];\n                view.delegate(evtName).to(dest);\n              }\n            } // Activate delegating on future views in this collection.\n\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          _this2.on('add', function (evt, view) {\n            for (var _i = 0, _events = events; _i < _events.length; _i++) {\n              var evtName = _events[_i];\n              view.delegate(evtName).to(dest);\n            }\n          }); // Deactivate delegating when view is removed from this collection.\n\n\n          _this2.on('remove', function (evt, view) {\n            for (var _i2 = 0, _events2 = events; _i2 < _events2.length; _i2++) {\n              var evtName = _events2[_i2];\n              view.stopDelegating(evtName, dest);\n            }\n          });\n        }\n      };\n    }\n    /**\n     * Removes a child view from the collection. If the {@link #setParent parent element} of the\n     * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed\n     * in DOM, reflecting the order of the collection.\n     *\n     * See the {@link #add} method.\n     *\n     * @method #remove\n     * @param {module:ui/view~View|Number|String} subject The view to remove, its id or index in the collection.\n     * @returns {Object} The removed view.\n     */\n\n  }]);\n\n  return ViewCollection;\n}(Collection); // Check if all entries of the array are of `String` type.\n//\n// @private\n// @param {Array} arr An array to be checked.\n// @returns {Boolean}\n\n\nexport { ViewCollection as default };\n\nfunction isStringArray(arr) {\n  return arr.every(function (a) {\n    return typeof a == 'string';\n  });\n}","import _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\nimport \"core-js/modules/es6.regexp.split\";\nimport _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"regenerator-runtime/runtime\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/template\n */\n\n/* global document */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport View from \"./view\";\nimport ViewCollection from \"./viewcollection\";\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport { isObject, cloneDeepWith } from 'lodash-es';\nvar xhtmlNs = 'http://www.w3.org/1999/xhtml';\n/**\n * A basic Template class. It renders a DOM HTML element or text from a\n * {@link module:ui/template~TemplateDefinition definition} and supports element attributes, children,\n * bindings to {@link module:utils/observablemixin~Observable observables} and DOM event propagation.\n *\n * A simple template can look like this:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\tclass: 'foo',\n *\t\t\t\tstyle: {\n *\t\t\t\t\tbackgroundColor: 'yellow'\n *\t\t\t\t}\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\t\t\t}\n *\t\t\tchildren: [\n *\t\t\t\t'A paragraph.'\n *\t\t\t]\n *\t\t} ).render();\n *\n * and it will render the following HTML element:\n *\n *\t\t<p class=\"foo\" style=\"background-color: yellow;\">A paragraph.</p>\n *\n * Additionally, the `observable` will always fire `clicked` upon clicking `<p>` in the DOM.\n *\n * See {@link module:ui/template~TemplateDefinition} to know more about templates and complex\n * template definitions.\n *\n* @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar Template =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the {@link ~Template} class.\n   *\n   * @param {module:ui/template~TemplateDefinition} def The definition of the template.\n   */\n  function Template(def) {\n    _classCallCheck(this, Template);\n\n    Object.assign(this, normalize(clone(def)));\n    /**\n     * Indicates whether this particular Template instance has been\n     * {@link #render rendered}.\n     *\n     * @readonly\n     * @protected\n     * @member {Boolean}\n     */\n\n    this._isRendered = false;\n    /**\n     * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template\n     * renders to an HTML element.\n     *\n     * @member {String} #tag\n     */\n\n    /**\n     * The text of the template. It also indicates that the template renders to a DOM text node.\n     *\n     * @member {Array.<String|module:ui/template~TemplateValueSchema>} #text\n     */\n\n    /**\n     * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with\n     * the attributes of an HTML element.\n     *\n     * **Note**: This property only makes sense when {@link #tag} is defined.\n     *\n     * @member {Object} #attributes\n     */\n\n    /**\n     * The children of the template. They can be either:\n     * * independent instances of {@link ~Template} (subtemplates),\n     * * native DOM Nodes.\n     *\n     * **Note**: This property only makes sense when {@link #tag} is defined.\n     *\n     * @member {Array.<module:ui/template~Template|Node>} #children\n     */\n\n    /**\n     * The DOM event listeners of the template.\n     *\n     * @member {Object} #eventListeners\n     */\n\n    /**\n     * The data used by the {@link #revert} method to restore a node to its original state.\n     *\n     * See: {@link #apply}.\n     *\n     * @readonly\n     * @protected\n     * @member {module:ui/template~RenderData}\n     */\n\n    this._revertData = null;\n  }\n  /**\n   * Renders a DOM Node (an HTML element or text) out of the template.\n   *\n   *\t\tconst domNode = new Template( { ... } ).render();\n   *\n   * See: {@link #apply}.\n   *\n   * @returns {HTMLElement|Text}\n   */\n\n\n  _createClass(Template, [{\n    key: \"render\",\n    value: function render() {\n      var node = this._renderNode({\n        intoFragment: true\n      });\n\n      this._isRendered = true;\n      return node;\n    }\n    /**\n     * Applies the template to an existing DOM Node, either HTML element or text.\n     *\n     * **Note:** No new DOM nodes will be created. Applying extends:\n     *\n     * {@link module:ui/template~TemplateDefinition attributes},\n     * {@link module:ui/template~TemplateDefinition event listeners}, and\n     * `textContent` of {@link module:ui/template~TemplateDefinition children} only.\n     *\n     * **Note:** Existing `class` and `style` attributes are extended when a template\n     * is applied to an HTML element, while other attributes and `textContent` are overridden.\n     *\n     * **Note:** The process of applying a template can be easily reverted using the\n     * {@link module:ui/template~Template#revert} method.\n     *\n     *\t\tconst element = document.createElement( 'div' );\n     *\t\tconst observable = new Model( { divClass: 'my-div' } );\n     *\t\tconst emitter = Object.create( EmitterMixin );\n     *\t\tconst bind = Template.bind( observable, emitter );\n     *\n     *\t\tnew Template( {\n     *\t\t\tattributes: {\n     *\t\t\t\tid: 'first-div',\n     *\t\t\t\tclass: bind.to( 'divClass' )\n     *\t\t\t},\n     *\t\t\ton: {\n     *\t\t\t\tclick: bind( 'elementClicked' ) // Will be fired by the observable.\n     *\t\t\t},\n     *\t\t\tchildren: [\n     *\t\t\t\t'Div text.'\n     *\t\t\t]\n     *\t\t} ).apply( element );\n     *\n     *\t\tconsole.log( element.outerHTML ); // -> '<div id=\"first-div\" class=\"my-div\"></div>'\n     *\n     * @see module:ui/template~Template#render\n     * @see module:ui/template~Template#revert\n     * @param {Node} node Root node for the template to apply.\n     */\n\n  }, {\n    key: \"apply\",\n    value: function apply(node) {\n      this._revertData = getEmptyRevertData();\n\n      this._renderNode({\n        node: node,\n        isApplying: true,\n        revertData: this._revertData\n      });\n\n      return node;\n    }\n    /**\n     * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.\n     *\n     * @param {Node} node The root node for the template to revert. In most of the cases, it is the\n     * same node used by {@link module:ui/template~Template#apply}.\n     */\n\n  }, {\n    key: \"revert\",\n    value: function revert(node) {\n      if (!this._revertData) {\n        /**\n         * Attempting to revert a template which has not been applied yet.\n         *\n         * @error ui-template-revert-not-applied\n         */\n        throw new CKEditorError('ui-template-revert-not-applied: Attempting to revert a template which has not been applied yet.');\n      }\n\n      this._revertTemplateFromNode(node, this._revertData);\n    }\n    /**\n     * Returns an iterator which traverses the template in search of {@link module:ui/view~View}\n     * instances and returns them one by one.\n     *\n     *\t\tconst viewFoo = new View();\n     *\t\tconst viewBar = new View();\n     *\t\tconst viewBaz = new View();\n     *\t\tconst template = new Template( {\n     *\t\t\ttag: 'div',\n     *\t\t\tchildren: [\n     *\t\t\t\tviewFoo,\n     *\t\t\t\t{\n     *\t\t\t\t\ttag: 'div',\n     *\t\t\t\t\tchildren: [\n     *\t\t\t\t\t\tviewBar\n     *\t\t\t\t\t]\n     *\t\t\t\t},\n     *\t\t\t\tviewBaz\n     *\t\t\t]\n     *\t\t} );\n     *\n     *\t\t// Logs: viewFoo, viewBar, viewBaz\n     *\t\tfor ( const view of template.getViews() ) {\n     *\t\t\tconsole.log( view );\n     *\t\t}\n     *\n     * @returns {Iterable.<module:ui/view~View>}\n     */\n\n  }, {\n    key: \"getViews\",\n    value:\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function getViews() {\n      var _marked, search;\n\n      return regeneratorRuntime.wrap(function getViews$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              search = function _ref(def) {\n                var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, child;\n\n                return regeneratorRuntime.wrap(function search$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        if (!def.children) {\n                          _context.next = 32;\n                          break;\n                        }\n\n                        _iteratorNormalCompletion = true;\n                        _didIteratorError = false;\n                        _iteratorError = undefined;\n                        _context.prev = 4;\n                        _iterator = def.children[Symbol.iterator]();\n\n                      case 6:\n                        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                          _context.next = 18;\n                          break;\n                        }\n\n                        child = _step.value;\n\n                        if (!isView(child)) {\n                          _context.next = 13;\n                          break;\n                        }\n\n                        _context.next = 11;\n                        return child;\n\n                      case 11:\n                        _context.next = 15;\n                        break;\n\n                      case 13:\n                        if (!isTemplate(child)) {\n                          _context.next = 15;\n                          break;\n                        }\n\n                        return _context.delegateYield(search(child), \"t0\", 15);\n\n                      case 15:\n                        _iteratorNormalCompletion = true;\n                        _context.next = 6;\n                        break;\n\n                      case 18:\n                        _context.next = 24;\n                        break;\n\n                      case 20:\n                        _context.prev = 20;\n                        _context.t1 = _context[\"catch\"](4);\n                        _didIteratorError = true;\n                        _iteratorError = _context.t1;\n\n                      case 24:\n                        _context.prev = 24;\n                        _context.prev = 25;\n\n                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n                          _iterator.return();\n                        }\n\n                      case 27:\n                        _context.prev = 27;\n\n                        if (!_didIteratorError) {\n                          _context.next = 30;\n                          break;\n                        }\n\n                        throw _iteratorError;\n\n                      case 30:\n                        return _context.finish(27);\n\n                      case 31:\n                        return _context.finish(24);\n\n                      case 32:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _marked, null, [[4, 20, 24, 32], [25,, 27, 31]]);\n              };\n\n              _marked =\n              /*#__PURE__*/\n              regeneratorRuntime.mark(search);\n              return _context2.delegateYield(search(this), \"t0\", 3);\n\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, getViews, this);\n    })\n    /**\n     * An entry point to the interface which binds DOM nodes to\n     * {@link module:utils/observablemixin~Observable observables}.\n     * There are two types of bindings:\n     *\n     * * HTML element attributes or text `textContent` synchronized with attributes of an\n     * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}\n     * and {@link module:ui/template~BindChain#if}.\n     *\n     *\t\tconst bind = Template.bind( observable, emitter );\n     *\n     *\t\tnew Template( {\n     *\t\t\tattributes: {\n     *\t\t\t\t// Binds the element \"class\" attribute to observable#classAttribute.\n     *\t\t\t\tclass: bind.to( 'classAttribute' )\n     *\t\t\t}\n     *\t\t} ).render();\n     *\n     * * DOM events fired on HTML element propagated through\n     * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.\n     *\n     *\t\tconst bind = Template.bind( observable, emitter );\n     *\n     *\t\tnew Template( {\n     *\t\t\ton: {\n     *\t\t\t\t// Will be fired by the observable.\n     *\t\t\t\tclick: bind( 'elementClicked' )\n     *\t\t\t}\n     *\t\t} ).render();\n     *\n     * Also see {@link module:ui/view~View#bindTemplate}.\n     *\n     * @param {module:utils/observablemixin~Observable} observable An observable which provides boundable attributes.\n     * @param {module:utils/emittermixin~Emitter} emitter An emitter that listens to observable attribute\n     * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.\n     * @returns {module:ui/template~BindChain}\n     */\n\n  }, {\n    key: \"_renderNode\",\n\n    /**\n     * Renders a DOM Node (either an HTML element or text) out of the template.\n     *\n     * @protected\n     * @param {module:ui/template~RenderData} data Rendering data.\n     */\n    value: function _renderNode(data) {\n      var isInvalid;\n\n      if (data.node) {\n        // When applying, a definition cannot have \"tag\" and \"text\" at the same time.\n        isInvalid = this.tag && this.text;\n      } else {\n        // When rendering, a definition must have either \"tag\" or \"text\": XOR( this.tag, this.text ).\n        isInvalid = this.tag ? this.text : !this.text;\n      }\n\n      if (isInvalid) {\n        /**\n         * Node definition cannot have the \"tag\" and \"text\" properties at the same time.\n         * Node definition must have either \"tag\" or \"text\" when rendering a new Node.\n         *\n         * @error ui-template-wrong-syntax\n         */\n        throw new CKEditorError('ui-template-wrong-syntax: Node definition must have either \"tag\" or \"text\" when rendering a new Node.');\n      }\n\n      if (this.text) {\n        return this._renderText(data);\n      } else {\n        return this._renderElement(data);\n      }\n    }\n    /**\n     * Renders an HTML element out of the template.\n     *\n     * @protected\n     * @param {module:ui/template~RenderData} data Rendering data.\n     */\n\n  }, {\n    key: \"_renderElement\",\n    value: function _renderElement(data) {\n      var node = data.node;\n\n      if (!node) {\n        node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);\n      }\n\n      this._renderAttributes(data);\n\n      this._renderElementChildren(data);\n\n      this._setUpListeners(data);\n\n      return node;\n    }\n    /**\n     * Renders a text node out of {@link module:ui/template~Template#text}.\n     *\n     * @protected\n     * @param {module:ui/template~RenderData} data Rendering data.\n     */\n\n  }, {\n    key: \"_renderText\",\n    value: function _renderText(data) {\n      var node = data.node; // Save the original textContent to revert it in #revert().\n\n      if (node) {\n        data.revertData.text = node.textContent;\n      } else {\n        node = data.node = document.createTextNode('');\n      } // Check if this Text Node is bound to Observable. Cases:\n      //\n      //\t\ttext: [ Template.bind( ... ).to( ... ) ]\n      //\n      //\t\ttext: [\n      //\t\t\t'foo',\n      //\t\t\tTemplate.bind( ... ).to( ... ),\n      //\t\t\t...\n      //\t\t]\n      //\n\n\n      if (hasTemplateBinding(this.text)) {\n        this._bindToObservable({\n          schema: this.text,\n          updater: getTextUpdater(node),\n          data: data\n        });\n      } // Simply set text. Cases:\n      //\n      //\t\ttext: [ 'all', 'are', 'static' ]\n      //\n      //\t\ttext: [ 'foo' ]\n      //\n      else {\n          node.textContent = this.text.join('');\n        }\n\n      return node;\n    }\n    /**\n     * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.\n     *\n     * @protected\n     * @param {module:ui/template~RenderData} data Rendering data.\n     */\n\n  }, {\n    key: \"_renderAttributes\",\n    value: function _renderAttributes(data) {\n      var attrName, attrValue, domAttrValue, attrNs;\n\n      if (!this.attributes) {\n        return;\n      }\n\n      var node = data.node;\n      var revertData = data.revertData;\n\n      for (attrName in this.attributes) {\n        // Current attribute value in DOM.\n        domAttrValue = node.getAttribute(attrName); // The value to be set.\n\n        attrValue = this.attributes[attrName]; // Save revert data.\n\n        if (revertData) {\n          revertData.attributes[attrName] = domAttrValue;\n        } // Detect custom namespace:\n        //\n        //\t\tclass: {\n        //\t\t\tns: 'abc',\n        //\t\t\tvalue: Template.bind( ... ).to( ... )\n        //\t\t}\n        //\n\n\n        attrNs = isObject(attrValue[0]) && attrValue[0].ns ? attrValue[0].ns : null; // Activate binding if one is found. Cases:\n        //\n        //\t\tclass: [\n        //\t\t\tTemplate.bind( ... ).to( ... )\n        //\t\t]\n        //\n        //\t\tclass: [\n        //\t\t\t'bar',\n        //\t\t\tTemplate.bind( ... ).to( ... ),\n        //\t\t\t'baz'\n        //\t\t]\n        //\n        //\t\tclass: {\n        //\t\t\tns: 'abc',\n        //\t\t\tvalue: Template.bind( ... ).to( ... )\n        //\t\t}\n        //\n\n        if (hasTemplateBinding(attrValue)) {\n          // Normalize attributes with additional data like namespace:\n          //\n          //\t\tclass: {\n          //\t\t\tns: 'abc',\n          //\t\t\tvalue: [ ... ]\n          //\t\t}\n          //\n          var valueToBind = attrNs ? attrValue[0].value : attrValue; // Extend the original value of attributes like \"style\" and \"class\",\n          // don't override them.\n\n          if (revertData && shouldExtend(attrName)) {\n            valueToBind.unshift(domAttrValue);\n          }\n\n          this._bindToObservable({\n            schema: valueToBind,\n            updater: getAttributeUpdater(node, attrName, attrNs),\n            data: data\n          });\n        } // Style attribute could be an Object so it needs to be parsed in a specific way.\n        //\n        //\t\tstyle: {\n        //\t\t\twidth: '100px',\n        //\t\t\theight: Template.bind( ... ).to( ... )\n        //\t\t}\n        //\n        else if (attrName == 'style' && typeof attrValue[0] !== 'string') {\n            this._renderStyleAttribute(attrValue[0], data);\n          } // Otherwise simply set the static attribute:\n          //\n          //\t\tclass: [ 'foo' ]\n          //\n          //\t\tclass: [ 'all', 'are', 'static' ]\n          //\n          //\t\tclass: [\n          //\t\t\t{\n          //\t\t\t\tns: 'abc',\n          //\t\t\t\tvalue: [ 'foo' ]\n          //\t\t\t}\n          //\t\t]\n          //\n          else {\n              // Extend the original value of attributes like \"style\" and \"class\",\n              // don't override them.\n              if (revertData && domAttrValue && shouldExtend(attrName)) {\n                attrValue.unshift(domAttrValue);\n              }\n\n              attrValue = attrValue // Retrieve \"values\" from:\n              //\n              //\t\tclass: [\n              //\t\t\t{\n              //\t\t\t\tns: 'abc',\n              //\t\t\t\tvalue: [ ... ]\n              //\t\t\t}\n              //\t\t]\n              //\n              .map(function (val) {\n                return val ? val.value || val : val;\n              }) // Flatten the array.\n              .reduce(function (prev, next) {\n                return prev.concat(next);\n              }, []) // Convert into string.\n              .reduce(arrayValueReducer, '');\n\n              if (!isFalsy(attrValue)) {\n                node.setAttributeNS(attrNs, attrName, attrValue);\n              }\n            }\n      }\n    }\n    /**\n     * Renders the `style` attribute of an HTML element based on\n     * {@link module:ui/template~Template#attributes}.\n     *\n     * A style attribute is an {Object} with static values:\n     *\n     *\t\tattributes: {\n     *\t\t\tstyle: {\n     *\t\t\t\tcolor: 'red'\n     *\t\t\t}\n     *\t\t}\n     *\n     * or values bound to {@link module:ui/model~Model} properties:\n     *\n     *\t\tattributes: {\n     *\t\t\tstyle: {\n     *\t\t\t\tcolor: bind.to( ... )\n     *\t\t\t}\n     *\t\t}\n     *\n     * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be\n     * needed.\n     *\n     * @private\n     * @param {Object} styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.\n     * @param {module:ui/template~RenderData} data Rendering data.\n     */\n\n  }, {\n    key: \"_renderStyleAttribute\",\n    value: function _renderStyleAttribute(styles, data) {\n      var node = data.node;\n\n      for (var styleName in styles) {\n        var styleValue = styles[styleName]; // Cases:\n        //\n        //\t\tstyle: {\n        //\t\t\tcolor: bind.to( 'attribute' )\n        //\t\t}\n        //\n\n        if (hasTemplateBinding(styleValue)) {\n          this._bindToObservable({\n            schema: [styleValue],\n            updater: getStyleUpdater(node, styleName),\n            data: data\n          });\n        } // Cases:\n        //\n        //\t\tstyle: {\n        //\t\t\tcolor: 'red'\n        //\t\t}\n        //\n        else {\n            node.style[styleName] = styleValue;\n          }\n      }\n    }\n    /**\n     * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.\n     *\n     * @protected\n     * @param {module:ui/template~RenderData} data Rendering data.\n     */\n\n  }, {\n    key: \"_renderElementChildren\",\n    value: function _renderElementChildren(data) {\n      var node = data.node;\n      var container = data.intoFragment ? document.createDocumentFragment() : node;\n      var isApplying = data.isApplying;\n      var childIndex = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var child = _step2.value;\n\n          if (isViewCollection(child)) {\n            if (!isApplying) {\n              child.setParent(node); // Note: ViewCollection renders its children.\n\n              var _iteratorNormalCompletion3 = true;\n              var _didIteratorError3 = false;\n              var _iteratorError3 = undefined;\n\n              try {\n                for (var _iterator3 = child[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                  var view = _step3.value;\n                  container.appendChild(view.element);\n                }\n              } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                    _iterator3.return();\n                  }\n                } finally {\n                  if (_didIteratorError3) {\n                    throw _iteratorError3;\n                  }\n                }\n              }\n            }\n          } else if (isView(child)) {\n            if (!isApplying) {\n              if (!child.isRendered) {\n                child.render();\n              }\n\n              container.appendChild(child.element);\n            }\n          } else if (isNode(child)) {\n            container.appendChild(child);\n          } else {\n            if (isApplying) {\n              var revertData = data.revertData;\n              var childRevertData = getEmptyRevertData();\n              revertData.children.push(childRevertData);\n\n              child._renderNode({\n                node: container.childNodes[childIndex++],\n                isApplying: true,\n                revertData: childRevertData\n              });\n            } else {\n              container.appendChild(child.render());\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      if (data.intoFragment) {\n        node.appendChild(container);\n      }\n    }\n    /**\n     * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}\n     * on an HTML element.\n     *\n     * @protected\n     * @param {module:ui/template~RenderData} data Rendering data.\n     */\n\n  }, {\n    key: \"_setUpListeners\",\n    value: function _setUpListeners(data) {\n      var _this = this;\n\n      if (!this.eventListeners) {\n        return;\n      }\n\n      var _loop = function _loop(key) {\n        var revertBindings = _this.eventListeners[key].map(function (schemaItem) {\n          var _key$split = key.split('@'),\n              _key$split2 = _slicedToArray(_key$split, 2),\n              domEvtName = _key$split2[0],\n              domSelector = _key$split2[1];\n\n          return schemaItem.activateDomEventListener(domEvtName, domSelector, data);\n        });\n\n        if (data.revertData) {\n          data.revertData.bindings.push(revertBindings);\n        }\n      };\n\n      for (var key in this.eventListeners) {\n        _loop(key);\n      }\n    }\n    /**\n     * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}\n     * activates the binding and sets its initial value.\n     *\n     * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or\n     * text node `textContent`.\n     *\n     * @protected\n     * @param {Object} options Binding options.\n     * @param {module:ui/template~TemplateValueSchema} options.schema\n     * @param {Function} options.updater A function which updates the DOM (like attribute or text).\n     * @param {module:ui/template~RenderData} options.data Rendering data.\n     */\n\n  }, {\n    key: \"_bindToObservable\",\n    value: function _bindToObservable(_ref2) {\n      var schema = _ref2.schema,\n          updater = _ref2.updater,\n          data = _ref2.data;\n      var revertData = data.revertData; // Set initial values.\n\n      syncValueSchemaValue(schema, updater, data);\n      var revertBindings = schema // Filter \"falsy\" (false, undefined, null, '') value schema components out.\n      .filter(function (item) {\n        return !isFalsy(item);\n      }) // Filter inactive bindings from schema, like static strings ('foo'), numbers (42), etc.\n      .filter(function (item) {\n        return item.observable;\n      }) // Once only the actual binding are left, let the emitter listen to observable change:attribute event.\n      // TODO: Reduce the number of listeners attached as many bindings may listen\n      // to the same observable attribute.\n      .map(function (templateBinding) {\n        return templateBinding.activateAttributeListener(schema, updater, data);\n      });\n\n      if (revertData) {\n        revertData.bindings.push(revertBindings);\n      }\n    }\n    /**\n     * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to\n     * return it to the original state.\n     *\n     * @protected\n     * @param {HTMLElement|Text} node A node to be reverted.\n     * @param {module:ui/template~RenderData#revertData} revertData Stores information about\n     * what changes have been made by {@link #apply} to the node.\n     */\n\n  }, {\n    key: \"_revertTemplateFromNode\",\n    value: function _revertTemplateFromNode(node, revertData) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = revertData.bindings[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var binding = _step4.value;\n          // Each binding may consist of several observable+observable#attribute.\n          // like the following has 2:\n          //\n          //\t\tclass: [\n          //\t\t\t'x',\n          //\t\t\tbind.to( 'foo' ),\n          //\t\t\t'y',\n          //\t\t\tbind.to( 'bar' )\n          //\t\t]\n          //\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = binding[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var revertBinding = _step5.value;\n              revertBinding();\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      if (revertData.text) {\n        node.textContent = revertData.text;\n        return;\n      }\n\n      for (var attrName in revertData.attributes) {\n        var attrValue = revertData.attributes[attrName]; // When the attribute has **not** been set before #apply().\n\n        if (attrValue === null) {\n          node.removeAttribute(attrName);\n        } else {\n          node.setAttribute(attrName, attrValue);\n        }\n      }\n\n      for (var i = 0; i < revertData.children.length; ++i) {\n        this._revertTemplateFromNode(node.childNodes[i], revertData.children[i]);\n      }\n    }\n  }], [{\n    key: \"bind\",\n    value: function bind(observable, emitter) {\n      return {\n        to: function to(eventNameOrFunctionOrAttribute, callback) {\n          return new TemplateToBinding({\n            eventNameOrFunction: eventNameOrFunctionOrAttribute,\n            attribute: eventNameOrFunctionOrAttribute,\n            observable: observable,\n            emitter: emitter,\n            callback: callback\n          });\n        },\n        if: function _if(attribute, valueIfTrue, callback) {\n          return new TemplateIfBinding({\n            observable: observable,\n            emitter: emitter,\n            attribute: attribute,\n            valueIfTrue: valueIfTrue,\n            callback: callback\n          });\n        }\n      };\n    }\n    /**\n     * Extends an existing {@link module:ui/template~Template} instance with some additional content\n     * from another {@link module:ui/template~TemplateDefinition}.\n     *\n     *\t\tconst bind = Template.bind( observable, emitter );\n     *\n     *\t\tconst template = new Template( {\n     *\t\t\ttag: 'p',\n     *\t\t\tattributes: {\n     *\t\t\t\tclass: 'a',\n     *\t\t\t\tdata-x: bind.to( 'foo' )\n     *\t\t\t},\n     *\t\t\tchildren: [\n     *\t\t\t\t{\n     *\t\t\t\t\ttag: 'span',\n     *\t\t\t\t\tattributes: {\n     *\t\t\t\t\t\tclass: 'b'\n     *\t\t\t\t\t},\n     *\t\t\t\t\tchildren: [\n     *\t\t\t\t\t\t'Span'\n     *\t\t\t\t\t]\n     *\t\t\t\t}\n     *\t\t\t]\n     *\t\t } );\n     *\n     *\t\t// Instance-level extension.\n     *\t\tTemplate.extend( template, {\n     *\t\t\tattributes: {\n     *\t\t\t\tclass: 'b',\n     *\t\t\t\tdata-x: bind.to( 'bar' )\n     *\t\t\t},\n     *\t\t\tchildren: [\n     *\t\t\t\t{\n     *\t\t\t\t\tattributes: {\n     *\t\t\t\t\t\tclass: 'c'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t]\n     *\t\t} );\n     *\n     *\t\t// Child extension.\n     *\t\tTemplate.extend( template.children[ 0 ], {\n     *\t\t\tattributes: {\n     *\t\t\t\tclass: 'd'\n     *\t\t\t}\n     *\t\t} );\n     *\n     * the `outerHTML` of `template.render()` is:\n     *\n     *\t\t<p class=\"a b\" data-x=\"{ observable.foo } { observable.bar }\">\n     *\t\t\t<span class=\"b c d\">Span</span>\n     *\t\t</p>\n     *\n     * @param {module:ui/template~Template} template An existing template instance to be extended.\n     * @param {module:ui/template~TemplateDefinition} def Additional definition to be applied to a template.\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend(template, def) {\n      if (template._isRendered) {\n        /**\n         * Extending a template after rendering may not work as expected. To make sure\n         * the {@link module:ui/template~Template.extend extending} works for an element,\n         * make sure it happens before {@link #render} is called.\n         *\n         * @error template-extend-render\n         */\n        log.warn('template-extend-render: Attempting to extend a template which has already been rendered.');\n      }\n\n      extendTemplate(template, normalize(clone(def)));\n    }\n  }]);\n\n  return Template;\n}();\n\nexport { Template as default };\nmix(Template, EmitterMixin);\n/**\n * Describes a binding created by the {@link module:ui/template~Template.bind} interface.\n *\n * @protected\n */\n\nexport var TemplateBinding =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.\n   *\n   * @param {module:ui/template~TemplateDefinition} def The definition of the binding.\n   */\n  function TemplateBinding(def) {\n    _classCallCheck(this, TemplateBinding);\n\n    Object.assign(this, def);\n    /**\n     * An observable instance of the binding. It either:\n     *\n     * * provides the attribute with the value,\n     * * or passes the event when a corresponding DOM event is fired.\n     *\n     * @member {module:utils/observablemixin~ObservableMixin} module:ui/template~TemplateBinding#observable\n     */\n\n    /**\n     * An {@link module:utils/emittermixin~Emitter} used by the binding to:\n     *\n     * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},\n     * * or listen to the event in the DOM.\n     *\n     * @member {module:utils/emittermixin~EmitterMixin} module:ui/template~TemplateBinding#emitter\n     */\n\n    /**\n     * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.\n     *\n     * @member {String} module:ui/template~TemplateBinding#attribute\n     */\n\n    /**\n     * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.\n     *\n     * @member {Function} [module:ui/template~TemplateBinding#callback]\n     */\n  }\n  /**\n   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the\n   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.\n   *\n   * @param {Node} [node] A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.\n   * @returns {*} The value of {@link module:ui/template~TemplateBinding#attribute} in\n   * {@link module:ui/template~TemplateBinding#observable}.\n   */\n\n\n  _createClass(TemplateBinding, [{\n    key: \"getValue\",\n    value: function getValue(node) {\n      var value = this.observable[this.attribute];\n      return this.callback ? this.callback(value, node) : value;\n    }\n    /**\n     * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in\n     * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated\n     * value of {@link module:ui/template~TemplateValueSchema}.\n     *\n     * @param {module:ui/template~TemplateValueSchema} schema A full schema to generate an attribute or text in the DOM.\n     * @param {Function} updater A DOM updater function used to update the native DOM attribute or text.\n     * @param {module:ui/template~RenderData} data Rendering data.\n     * @returns {Function} A function to sever the listener binding.\n     */\n\n  }, {\n    key: \"activateAttributeListener\",\n    value: function activateAttributeListener(schema, updater, data) {\n      var _this2 = this;\n\n      var callback = function callback() {\n        return syncValueSchemaValue(schema, updater, data);\n      };\n\n      this.emitter.listenTo(this.observable, 'change:' + this.attribute, callback); // Allows revert of the listener.\n\n      return function () {\n        _this2.emitter.stopListening(_this2.observable, 'change:' + _this2.attribute, callback);\n      };\n    }\n  }]);\n\n  return TemplateBinding;\n}();\n/**\n * Describes either:\n *\n * * a binding to an {@link module:utils/observablemixin~Observable},\n * * or a native DOM event binding.\n *\n * It is created by the {@link module:ui/template~BindChain#to} method.\n *\n * @protected\n */\n\nexport var TemplateToBinding =\n/*#__PURE__*/\nfunction (_TemplateBinding) {\n  _inherits(TemplateToBinding, _TemplateBinding);\n\n  function TemplateToBinding() {\n    _classCallCheck(this, TemplateToBinding);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TemplateToBinding).apply(this, arguments));\n  }\n\n  _createClass(TemplateToBinding, [{\n    key: \"activateDomEventListener\",\n\n    /**\n     * Activates the listener for the native DOM event, which when fired, is propagated by\n     * the {@link module:ui/template~TemplateBinding#emitter}.\n     *\n     * @param {String} domEvtName The name of the native DOM event.\n     * @param {String} domSelector The selector in the DOM to filter delegated events.\n     * @param {module:ui/template~RenderData} data Rendering data.\n     * @returns {Function} A function to sever the listener binding.\n     */\n    value: function activateDomEventListener(domEvtName, domSelector, data) {\n      var _this3 = this;\n\n      var callback = function callback(evt, domEvt) {\n        if (!domSelector || domEvt.target.matches(domSelector)) {\n          if (typeof _this3.eventNameOrFunction == 'function') {\n            _this3.eventNameOrFunction(domEvt);\n          } else {\n            _this3.observable.fire(_this3.eventNameOrFunction, domEvt);\n          }\n        }\n      };\n\n      this.emitter.listenTo(data.node, domEvtName, callback); // Allows revert of the listener.\n\n      return function () {\n        _this3.emitter.stopListening(data.node, domEvtName, callback);\n      };\n    }\n  }]);\n\n  return TemplateToBinding;\n}(TemplateBinding);\n/**\n * Describes a binding to {@link module:utils/observablemixin~ObservableMixin} created by the {@link module:ui/template~BindChain#if}\n * method.\n *\n * @protected\n */\n\nexport var TemplateIfBinding =\n/*#__PURE__*/\nfunction (_TemplateBinding2) {\n  _inherits(TemplateIfBinding, _TemplateBinding2);\n\n  function TemplateIfBinding() {\n    _classCallCheck(this, TemplateIfBinding);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TemplateIfBinding).apply(this, arguments));\n  }\n\n  _createClass(TemplateIfBinding, [{\n    key: \"getValue\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function getValue(node) {\n      var value = _get(_getPrototypeOf(TemplateIfBinding.prototype), \"getValue\", this).call(this, node);\n\n      return isFalsy(value) ? false : this.valueIfTrue || true;\n    }\n    /**\n     * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in\n     * {@link module:ui/template~TemplateBinding#observable} is `true`.\n     *\n     * @member {String} [module:ui/template~TemplateIfBinding#valueIfTrue]\n     */\n\n  }]);\n\n  return TemplateIfBinding;\n}(TemplateBinding); // Checks whether given {@link module:ui/template~TemplateValueSchema} contains a\n// {@link module:ui/template~TemplateBinding}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @returns {Boolean}\n\nfunction hasTemplateBinding(schema) {\n  if (!schema) {\n    return false;\n  } // Normalize attributes with additional data like namespace:\n  //\n  //\t\tclass: {\n  //\t\t\tns: 'abc',\n  //\t\t\tvalue: [ ... ]\n  //\t\t}\n  //\n\n\n  if (schema.value) {\n    schema = schema.value;\n  }\n\n  if (Array.isArray(schema)) {\n    return schema.some(hasTemplateBinding);\n  } else if (schema instanceof TemplateBinding) {\n    return true;\n  }\n\n  return false;\n} // Assembles the value using {@link module:ui/template~TemplateValueSchema} and stores it in a form of\n// an Array. Each entry of the Array corresponds to one of {@link module:ui/template~TemplateValueSchema}\n// items.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\n// @returns {Array}\n\n\nfunction getValueSchemaValue(schema, node) {\n  return schema.map(function (schemaItem) {\n    // Process {@link module:ui/template~TemplateBinding} bindings.\n    if (schemaItem instanceof TemplateBinding) {\n      return schemaItem.getValue(node);\n    } // All static values like strings, numbers, and \"falsy\" values (false, null, undefined, '', etc.) just pass.\n\n\n    return schemaItem;\n  });\n} // A function executed each time the bound Observable attribute changes, which updates the DOM with a value\n// constructed from {@link module:ui/template~TemplateValueSchema}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Function} updater A function which updates the DOM (like attribute or text).\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\n\n\nfunction syncValueSchemaValue(schema, updater, _ref3) {\n  var node = _ref3.node;\n  var value = getValueSchemaValue(schema, node); // Check if schema is a single Template.bind.if, like:\n  //\n  //\t\tclass: Template.bind.if( 'foo' )\n  //\n\n  if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {\n    value = value[0];\n  } else {\n    value = value.reduce(arrayValueReducer, '');\n  }\n\n  if (isFalsy(value)) {\n    updater.remove();\n  } else {\n    updater.set(value);\n  }\n} // Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset `textContent`.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @returns {Object}\n\n\nfunction getTextUpdater(node) {\n  return {\n    set: function set(value) {\n      node.textContent = value;\n    },\n    remove: function remove() {\n      node.textContent = '';\n    }\n  };\n} // Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset an attribute.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} attrName Name of the attribute to be modified.\n// @param {String} [ns=null] Namespace to use.\n// @returns {Object}\n\n\nfunction getAttributeUpdater(el, attrName, ns) {\n  return {\n    set: function set(value) {\n      el.setAttributeNS(ns, attrName, value);\n    },\n    remove: function remove() {\n      el.removeAttributeNS(ns, attrName);\n    }\n  };\n} // Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of CSSStyleDeclaration to set or remove a style.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} styleName Name of the style to be modified.\n// @returns {Object}\n\n\nfunction getStyleUpdater(el, styleName) {\n  return {\n    set: function set(value) {\n      el.style[styleName] = value;\n    },\n    remove: function remove() {\n      el.style[styleName] = null;\n    }\n  };\n} // Clones definition of the template.\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition}\n\n\nfunction clone(def) {\n  var clone = cloneDeepWith(def, function (value) {\n    // Don't clone the `Template.bind`* bindings because of the references to Observable\n    // and DomEmitterMixin instances inside, which would also be traversed and cloned by greedy\n    // cloneDeepWith algorithm. There's no point in cloning Observable/DomEmitterMixins\n    // along with the definition.\n    //\n    // Don't clone Template instances if provided as a child. They're simply #render()ed\n    // and nothing should interfere.\n    //\n    // Also don't clone View instances if provided as a child of the Template. The template\n    // instance will be extracted from the View during the normalization and there's no need\n    // to clone it.\n    if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {\n      return value;\n    }\n  });\n  return clone;\n} // Normalizes given {@link module:ui/template~TemplateDefinition}.\n//\n// See:\n//  * {@link normalizeAttributes}\n//  * {@link normalizeListeners}\n//  * {@link normalizePlainTextDefinition}\n//  * {@link normalizeTextDefinition}\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition} Normalized definition.\n\n\nfunction normalize(def) {\n  if (typeof def == 'string') {\n    def = normalizePlainTextDefinition(def);\n  } else if (def.text) {\n    normalizeTextDefinition(def);\n  }\n\n  if (def.on) {\n    def.eventListeners = normalizeListeners(def.on); // Template mixes EmitterMixin, so delete #on to avoid collision.\n\n    delete def.on;\n  }\n\n  if (!def.text) {\n    if (def.attributes) {\n      normalizeAttributes(def.attributes);\n    }\n\n    var children = [];\n\n    if (def.children) {\n      if (isViewCollection(def.children)) {\n        children.push(def.children);\n      } else {\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = def.children[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var child = _step6.value;\n\n            if (isTemplate(child) || isView(child) || isNode(child)) {\n              children.push(child);\n            } else {\n              children.push(new Template(child));\n            }\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n      }\n    }\n\n    def.children = children;\n  }\n\n  return def;\n} // Normalizes \"attributes\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tattributes: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: {\n//\t\t\t\tvalue: 'bar'\n//\t\t\t}\n//\t\t}\n//\n// becomes\n//\n//\t\tattributes: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: {\n//\t\t\t\tvalue: [ 'bar' ]\n//\t\t\t}\n//\t\t}\n//\n// @param {Object} attributes\n\n\nfunction normalizeAttributes(attributes) {\n  for (var a in attributes) {\n    if (attributes[a].value) {\n      attributes[a].value = [].concat(attributes[a].value);\n    }\n\n    arrayify(attributes, a);\n  }\n} // Normalizes \"on\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\ton: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// becomes\n//\n//\t\ton: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// @param {Object} listeners\n// @returns {Object} Object containing normalized listeners.\n\n\nfunction normalizeListeners(listeners) {\n  for (var l in listeners) {\n    arrayify(listeners, l);\n  }\n\n  return listeners;\n} // Normalizes \"string\" {@link module:ui/template~TemplateDefinition}.\n//\n//\t\t\"foo\"\n//\n// becomes\n//\n//\t\t{ text: [ 'foo' ] },\n//\n// @param {String} def\n// @returns {module:ui/template~TemplateDefinition} Normalized template definition.\n\n\nfunction normalizePlainTextDefinition(def) {\n  return {\n    text: [def]\n  };\n} // Normalizes text {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tchildren: [\n//\t\t\t{ text: 'def' },\n//\t\t\t{ text: {@link module:ui/template~TemplateBinding} }\n//\t\t]\n//\n// becomes\n//\n//\t\tchildren: [\n//\t\t\t{ text: [ 'def' ] },\n//\t\t\t{ text: [ {@link module:ui/template~TemplateBinding} ] }\n//\t\t]\n//\n// @param {module:ui/template~TemplateDefinition} def\n\n\nfunction normalizeTextDefinition(def) {\n  if (!Array.isArray(def.text)) {\n    def.text = [def.text];\n  }\n} // Wraps an entry in Object in an Array, if not already one.\n//\n//\t\t{\n//\t\t\tx: 'y',\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// becomes\n//\n//\t\t{\n//\t\t\tx: [ 'y' ],\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// @param {Object} obj\n// @param {String} key\n\n\nfunction arrayify(obj, key) {\n  if (!Array.isArray(obj[key])) {\n    obj[key] = [obj[key]];\n  }\n} // A helper which concatenates the value avoiding unwanted\n// leading white spaces.\n//\n// @param {String} prev\n// @param {String} cur\n// @returns {String}\n\n\nfunction arrayValueReducer(prev, cur) {\n  if (isFalsy(cur)) {\n    return prev;\n  } else if (isFalsy(prev)) {\n    return cur;\n  } else {\n    return \"\".concat(prev, \" \").concat(cur);\n  }\n} // Extends one object defined in the following format:\n//\n//\t\t{\n//\t\t\tkey1: [Array1],\n//\t\t\tkey2: [Array2],\n//\t\t\t...\n//\t\t\tkeyN: [ArrayN]\n//\t\t}\n//\n// with another object of the same data format.\n//\n// @param {Object} obj Base object.\n// @param {Object} ext Object extending base.\n// @returns {String}\n\n\nfunction extendObjectValueArray(obj, ext) {\n  for (var a in ext) {\n    if (obj[a]) {\n      var _obj$a;\n\n      (_obj$a = obj[a]).push.apply(_obj$a, _toConsumableArray(ext[a]));\n    } else {\n      obj[a] = ext[a];\n    }\n  }\n} // A helper for {@link module:ui/template~Template#extend}. Recursively extends {@link module:ui/template~Template} instance\n// with content from {@link module:ui/template~TemplateDefinition}. See {@link module:ui/template~Template#extend} to learn more.\n//\n// @param {module:ui/template~Template} def A template instance to be extended.\n// @param {module:ui/template~TemplateDefinition} def A definition which is to extend the template instance.\n\n\nfunction extendTemplate(template, def) {\n  if (def.attributes) {\n    if (!template.attributes) {\n      template.attributes = {};\n    }\n\n    extendObjectValueArray(template.attributes, def.attributes);\n  }\n\n  if (def.eventListeners) {\n    if (!template.eventListeners) {\n      template.eventListeners = {};\n    }\n\n    extendObjectValueArray(template.eventListeners, def.eventListeners);\n  }\n\n  if (def.text) {\n    var _template$text;\n\n    (_template$text = template.text).push.apply(_template$text, _toConsumableArray(def.text));\n  }\n\n  if (def.children && def.children.length) {\n    if (template.children.length != def.children.length) {\n      /**\n       * The number of children in extended definition does not match.\n       *\n       * @error ui-template-extend-children-mismatch\n       */\n      throw new CKEditorError('ui-template-extend-children-mismatch: The number of children in extended definition does not match.');\n    }\n\n    var childIndex = 0;\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = def.children[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var childDef = _step7.value;\n        extendTemplate(template.children[childIndex++], childDef);\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n  }\n} // Checks if value is \"falsy\".\n// Note: 0 (Number) is not \"falsy\" in this context.\n//\n// @private\n// @param {*} value Value to be checked.\n\n\nfunction isFalsy(value) {\n  return !value && value !== 0;\n} // Checks if the item is an instance of {@link module:ui/view~View}\n//\n// @private\n// @param {*} value Value to be checked.\n\n\nfunction isView(item) {\n  return item instanceof View;\n} // Checks if the item is an instance of {@link module:ui/template~Template}\n//\n// @private\n// @param {*} value Value to be checked.\n\n\nfunction isTemplate(item) {\n  return item instanceof Template;\n} // Checks if the item is an instance of {@link module:ui/viewcollection~ViewCollection}\n//\n// @private\n// @param {*} value Value to be checked.\n\n\nfunction isViewCollection(item) {\n  return item instanceof ViewCollection;\n} // Creates an empty skeleton for {@link module:ui/template~Template#revert}\n// data.\n//\n// @private\n\n\nfunction getEmptyRevertData() {\n  return {\n    children: [],\n    bindings: [],\n    attributes: {}\n  };\n} // Checks whether an attribute should be extended when\n// {@link module:ui/template~Template#apply} is called.\n//\n// @private\n// @param {String} attrName Attribute name to check.\n\n\nfunction shouldExtend(attrName) {\n  return attrName == 'class' || attrName == 'style';\n}\n/**\n * A definition of the {@link module:ui/template~Template}. It describes what kind of\n * node a template will render (HTML element or text), attributes of an element, DOM event\n * listeners and children.\n *\n * Also see:\n * * {@link module:ui/template~TemplateValueSchema} to learn about HTML element attributes,\n * * {@link module:ui/template~TemplateListenerSchema} to learn about DOM event listeners.\n *\n * A sample definition on an HTML element can look like this:\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\ttag: 'span',\n *\t\t\t\t\tattributes: { ... },\n *\t\t\t\t\tchildren: [ ... ],\n *\t\t\t\t},\n *\t\t\t\t{\n *\t\t\t\t\ttext: 'statictext'\n *\t\t\t\t},\n *\t\t\t\t'also-statictext',\n *\t\t\t],\n *\t\t\tattributes: {\n *\t\t\t\tclass: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tid: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tstyle: {@link module:ui/template~TemplateValueSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\t'click': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// Document.querySelector format is also accepted.\n *\t\t\t\t'keyup@a.some-class': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t}\n *\t\t} );\n *\n * A {@link module:ui/view~View}, another {@link module:ui/template~Template} or a native DOM node\n * can also become a child of a template. When a view is passed, its {@link module:ui/view~View#element} is used:\n *\n *\t\tconst view = new SomeView();\n *\t\tconst childTemplate = new Template( { ... } );\n *\t\tconst childNode = document.createElement( 'b' );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: [\n *\t\t\t\t// view#element will be added as a child of this <p>.\n *\t\t\t\tview,\n *\n * \t\t\t\t// The output of childTemplate.render() will be added here.\n *\t\t\t\tchildTemplate,\n *\n *\t\t\t\t// Native DOM nodes are included directly in the rendered output.\n *\t\t\t\tchildNode\n *\t\t\t]\n *\t\t} );\n *\n * An entire {@link module:ui/viewcollection~ViewCollection} can be used as a child in the definition:\n *\n *\t\tconst collection = new ViewCollection();\n *\t\tcollection.add( someView );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: collection\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateDefinition\n * @type Object\n *\n * @property {String} tag See the template {@link module:ui/template~Template#tag} property.\n *\n * @property {Array.<module:ui/template~TemplateDefinition>} [children]\n * See the template {@link module:ui/template~Template#children} property.\n *\n * @property {Object.<String, module:ui/template~TemplateValueSchema>} [attributes]\n * See the template {@link module:ui/template~Template#attributes} property.\n *\n * @property {String|module:ui/template~TemplateValueSchema|Array.<String|module:ui/template~TemplateValueSchema>} [text]\n * See the template {@link module:ui/template~Template#text} property.\n *\n * @property {Object.<String, module:ui/template~TemplateListenerSchema>} [on]\n * See the template {@link module:ui/template~Template#eventListeners} property.\n */\n\n/**\n * Describes a value of an HTML element attribute or `textContent`. It allows combining multiple\n * data sources like static values and {@link module:utils/observablemixin~Observable} attributes.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn where to use it,\n * * {@link module:ui/template~Template.bind} to learn how to configure\n * {@link module:utils/observablemixin~Observable} attribute bindings,\n * * {@link module:ui/template~Template#render} to learn how to render a template,\n * * {@link module:ui/template~BindChain#to `to()`} and {@link module:ui/template~BindChain#if `if()`}\n * methods to learn more about bindings.\n *\n * Attribute values can be described in many different ways:\n *\n *\t\t// Bind helper will create bindings to attributes of the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// A plain string schema.\n *\t\t\t\t'class': 'static-text',\n *\n *\t\t\t\t// An object schema, binds to the \"foo\" attribute of the\n *\t\t\t\t// observable and follows its value.\n *\t\t\t\t'class': bind.to( 'foo' ),\n *\n *\t\t\t\t// An array schema, combines the above.\n *\t\t\t\t'class': [\n *\t\t\t\t\t'static-text',\n *\t\t\t\t\tbind.to( 'bar', () => { ... } ),\n *\n * \t\t\t\t\t// Bindings can also be conditional.\n *\t\t\t\t\tbind.if( 'baz', 'class-when-baz-is-true' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema, with a custom namespace, e.g. useful for creating SVGs.\n *\t\t\t\t'class': {\n *\t\t\t\t\tns: 'http://ns.url',\n *\t\t\t\t\tvalue: [\n *\t\t\t\t\t\tbind.if( 'baz', 'value-when-true' ),\n *\t\t\t\t\t\t'static-text'\n *\t\t\t\t\t]\n *\t\t\t\t},\n *\n *\t\t\t\t// An object schema, specific for styles.\n *\t\t\t\tstyle: {\n *\t\t\t\t\tcolor: 'red',\n *\t\t\t\t\tbackgroundColor: bind.to( 'qux', () => { ... } )\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * Text nodes can also have complex values:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\t// Will render a \"foo\" text node.\n *\t\tnew Template( {\n *\t\t\ttext: 'foo'\n *\t\t} );\n *\n *\t\t// Will render a \"static text: {observable.foo}\" text node.\n *\t\t// The text of the node will be updated as the \"foo\" attribute changes.\n *\t\tnew Template( {\n *\t\t\ttext: [\n *\t\t\t\t'static text: ',\n *\t\t\t\tbind.to( 'foo', () => { ... } )\n *\t\t\t]\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateValueSchema\n * @type {Object|String|Array}\n */\n\n/**\n * Describes an event listener attached to an HTML element. Such listener can propagate DOM events\n * through an {@link module:utils/observablemixin~Observable} instance, execute custom callbacks\n * or both, if necessary.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn more about template definitions,\n * * {@link module:ui/template~BindChain#to `to()`} method to learn more about bindings.\n *\n * Check out different ways of attaching event listeners below:\n *\n *\t\t// Bind helper will propagate events through the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\ton: {\n *\t\t\t\t// An object schema. The observable will fire the \"clicked\" event upon DOM \"click\".\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\n *\t\t\t\t// An object schema. It will work for \"click\" event on \"a.foo\" children only.\n *\t\t\t\t'click@a.foo': bind.to( 'clicked' )\n *\n *\t\t\t\t// An array schema, makes the observable propagate multiple events.\n *\t\t\t\tclick: [\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( 'executed' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema with a custom callback.\n *\t\t\t\t'click@a.foo': {\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( evt => {\n *\t\t\t\t\t\tconsole.log( `${ evt.target } has been clicked!` );\n *\t\t\t\t\t} }\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateListenerSchema\n * @type {Object|String|Array}\n */\n\n/**\n * The return value of {@link ~Template.bind `Template.bind()`}. It provides `to()` and `if()`\n * methods to create the {@link module:utils/observablemixin~Observable observable} attribute and event bindings.\n *\n * @interface module:ui/template~BindChain\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to either:\n *\n * * an HTML element attribute or a text node `textContent`, so it remains in sync with the observable\n * attribute as it changes,\n * * or an HTML element DOM event, so the DOM events are propagated through an observable.\n *\n * Some common use cases of `to()` bindings are presented below:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// class=\"...\" attribute gets bound to `observable#a`\n *\t\t\t\tclass: bind.to( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t// <p>...</p> gets bound to observable#b; always `toUpperCase()`.\n *\t\t\t\t{\n *\t\t\t\t\ttext: bind.to( 'b', ( value, node ) => value.toUpperCase() )\n *\t\t\t\t}\n *\t\t\t],\n *\t\t\ton: {\n *\t\t\t\tclick: [\n *\t\t\t\t\t// An observable will fire \"clicked\" upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\n *\t\t\t\t\t// A custom callback will be executed upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( () => {\n *\t\t\t\t\t\t...\n *\t\t\t\t\t} )\n *\t\t\t\t]\n *\t\t\t}\n *\t\t} ).render();\n *\n * Learn more about using `to()` in the {@link module:ui/template~TemplateValueSchema} and\n * {@link module:ui/template~TemplateListenerSchema}.\n *\n * @method #to\n * @param {String|Function} eventNameOrFunctionOrAttribute An attribute name of\n * {@link module:utils/observablemixin~Observable} or a DOM event name or an event callback.\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to an HTML element attribute or a text\n * node `textContent` so it remains in sync with the observable attribute as it changes.\n *\n * Unlike {@link module:ui/template~BindChain#to}, it controls the presence of the attribute or `textContent`\n * depending on the \"falseness\" of an {@link module:utils/observablemixin~Observable} attribute.\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'input',\n *\t\t\tattributes: {\n *\t\t\t\t// <input checked> when `observable#a` is not undefined/null/false/''\n *\t\t\t\t// <input> when `observable#a` is undefined/null/false\n *\t\t\t\tchecked: bind.if( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\t// <input>\"b-is-not-set\"</input> when `observable#b` is undefined/null/false/''\n *\t\t\t\t\t// <input></input> when `observable#b` is not \"falsy\"\n *\t\t\t\t\ttext: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )\n *\t\t\t\t}\n *\t\t\t]\n *\t\t} ).render();\n *\n * Learn more about using `if()` in the {@link module:ui/template~TemplateValueSchema}.\n *\n * @method #if\n * @param {String} attribute An attribute name of {@link module:utils/observablemixin~Observable} used in the binding.\n * @param {String} [valueIfTrue] Value set when the {@link module:utils/observablemixin~Observable} attribute is not\n * undefined/null/false/'' (empty string).\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * The {@link module:ui/template~Template#_renderNode} configuration.\n *\n * @private\n * @interface module:ui/template~RenderData\n */\n\n/**\n * Tells {@link module:ui/template~Template#_renderNode} to render\n * children into `DocumentFragment` first and then append the fragment\n * to the parent element. It is a speed optimization.\n *\n * @member {Boolean} #intoFragment\n */\n\n/**\n * A node which is being rendered.\n *\n * @member {HTMLElement|Text} #node\n */\n\n/**\n * Indicates whether the {@module:ui/template~RenderNodeOptions#node} has\n * been provided by {@module:ui/template~Template#apply}.\n *\n * @member {Boolean} #isApplying\n */\n\n/**\n * An object storing the data that helps {@module:ui/template~Template#revert}\n * bringing back an element to its initial state, i.e. before\n * {@module:ui/template~Template#apply} was called.\n *\n * @member {Object} #revertData\n */","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/view\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ViewCollection from \"./viewcollection\";\nimport Template from \"./template\";\nimport DomEmitterMixin from '@ckeditor/ckeditor5-utils/src/dom/emittermixin';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport \"../theme/globals/globals.css\";\n/**\n * The basic view class, which represents an HTML element created out of a\n * {@link module:ui/view~View#template}. Views are building blocks of the user interface and handle\n * interaction\n *\n * Views {@link module:ui/view~View#registerChild aggregate} children in\n * {@link module:ui/view~View#createCollection collections} and manage the life cycle of DOM\n * listeners e.g. by handling rendering and destruction.\n *\n * See the {@link module:ui/template~TemplateDefinition} syntax to learn more about shaping view\n * elements, attributes and listeners.\n *\n *\t\tclass SampleView extends View {\n *\t\t\tconstructor( locale ) {\n *\t\t\t\tsuper( locale );\n *\n *\t\t\t\tconst bind = this.bindTemplate;\n *\n *\t\t\t\t// Views define their interface (state) using observable attributes.\n *\t\t\t\tthis.set( 'elementClass', 'bar' );\n *\n *\t\t\t\tthis.setTemplate( {\n *\t\t\t\t\ttag: 'p',\n *\n *\t\t\t\t\t// The element of the view can be defined with its children.\n *\t\t\t\t\tchildren: [\n *\t\t\t\t\t\t'Hello',\n *\t\t\t\t\t\t{\n *\t\t\t\t\t\t\ttag: 'b',\n *\t\t\t\t\t\t\tchildren: [ 'world!' ]\n *\t\t\t\t\t\t}\n *\t\t\t\t\t],\n *\t\t\t\t\tattributes: {\n *\t\t\t\t\t\tclass: [\n *\t\t\t\t\t\t\t'foo',\n *\n *\t\t\t\t\t\t\t// Observable attributes control the state of the view in DOM.\n *\t\t\t\t\t\t\tbind.to( 'elementClass' )\n *\t\t\t\t\t\t]\n *\t\t\t\t\t},\n *\t\t\t\t\ton: {\n *\t\t\t\t\t\t// Views listen to DOM events and propagate them.\n *\t\t\t\t\t\tclick: bind.to( 'clicked' )\n *\t\t\t\t\t}\n *\t\t\t\t} );\n *\t\t\t}\n *\t\t}\n *\n *\t\tconst view = new SampleView( locale );\n *\n *\t\tview.render();\n *\n *\t\t// Append <p class=\"foo bar\">Hello<b>world</b></p> to the <body>\n *\t\tdocument.body.appendChild( view.element );\n *\n *\t\t// Change the class attribute to <p class=\"foo baz\">Hello<b>world</b></p>\n *\t\tview.elementClass = 'baz';\n *\n *\t\t// Respond to the \"click\" event in DOM by executing a custom action.\n *\t\tview.on( 'clicked', () => {\n *\t\t\tconsole.log( 'The view has been clicked!' );\n *\t\t} );\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar View =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the {@link module:ui/view~View} class.\n   *\n   * Also see {@link #render}.\n   *\n   * @param {module:utils/locale~Locale} [locale] The localization services instance.\n   */\n  function View(locale) {\n    _classCallCheck(this, View);\n\n    /**\n     * An HTML element of the view. `null` until {@link #render rendered}\n     * from the {@link #template}.\n     *\n     *\t\tclass SampleView extends View {\n     *\t\t\tconstructor() {\n     *\t\t\t\tsuper();\n     *\n     *\t\t\t\t// A template instance the #element will be created from.\n     *\t\t\t\tthis.setTemplate( {\n     *\t\t\t\t\ttag: 'p'\n     *\n     *\t\t\t\t\t// ...\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tconst view = new SampleView();\n     *\n     *\t\t// Renders the #template.\n     *\t\tview.render();\n     *\n     *\t\t// Append the HTML element of the view to <body>.\n     *\t\tdocument.body.appendChild( view.element );\n     *\n     * **Note**: The element of the view can also be assigned directly:\n     *\n     *\t\tview.element = document.querySelector( '#my-container' );\n     *\n     * @member {HTMLElement}\n     */\n    this.element = null;\n    /**\n     * Set `true` when the view has already been {@link module:ui/view~View#render rendered}.\n     *\n     * @readonly\n     * @member {Boolean} #isRendered\n     */\n\n    this.isRendered = false;\n    /**\n     * A set of tools to localize the user interface.\n     *\n     * Also see {@link module:core/editor/editor~Editor#locale}.\n     *\n     * @readonly\n     * @member {module:utils/locale~Locale}\n     */\n\n    this.locale = locale;\n    /**\n     * Shorthand for {@link module:utils/locale~Locale#t}.\n     *\n     * Note: If {@link #locale} instance hasn't been passed to the view this method may not\n     * be available.\n     *\n     * @see module:utils/locale~Locale#t\n     * @method\n     */\n\n    this.t = locale && locale.t;\n    /**\n     * Collections registered with {@link #createCollection}.\n     *\n     * @protected\n     * @member {Set.<module:ui/viewcollection~ViewCollection>}\n     */\n\n    this._viewCollections = new Collection();\n    /**\n     * A collection of view instances, which have been added directly\n     * into the {@link module:ui/template~Template#children}.\n     *\n     * @protected\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n    this._unboundChildren = this.createCollection(); // Pass parent locale to its children.\n\n    this._viewCollections.on('add', function (evt, collection) {\n      collection.locale = locale;\n    });\n    /**\n     * Template of this view. It provides the {@link #element} representing\n     * the view in DOM, which is {@link #render rendered}.\n     *\n     * @member {module:ui/template~Template} #template\n     */\n\n    /**\n     * Cached {@link module:ui/template~BindChain bind chain} object created by the\n     * {@link #template}. See {@link #bindTemplate}.\n     *\n     * @private\n     * @member {Object} #_bindTemplate\n     */\n\n\n    this.decorate('render');\n  }\n  /**\n   * Shorthand for {@link module:ui/template~Template.bind}, a binding\n   * {@link module:ui/template~BindChain interface} preconfigured for the view instance.\n   *\n   * It provides {@link module:ui/template~BindChain#to `to()`} and\n   * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with\n   * observable attributes and attach DOM listeners.\n   *\n   *\t\tclass SampleView extends View {\n   *\t\t\tconstructor( locale ) {\n   *\t\t\t\tsuper( locale );\n   *\n   *\t\t\t\tconst bind = this.bindTemplate;\n   *\n   *\t\t\t\t// These {@link module:utils/observablemixin~Observable observable} attributes will control\n   *\t\t\t\t// the state of the view in DOM.\n   *\t\t\t\tthis.set( {\n   *\t\t\t\t\telementClass: 'foo',\n   *\t\t\t\t \tisEnabled: true\n   *\t\t\t\t } );\n   *\n   *\t\t\t\tthis.setTemplate( {\n   *\t\t\t\t\ttag: 'p',\n   *\n   *\t\t\t\t\tattributes: {\n   *\t\t\t\t\t\t// The class HTML attribute will follow elementClass\n   *\t\t\t\t\t\t// and isEnabled view attributes.\n   *\t\t\t\t\t\tclass: [\n   *\t\t\t\t\t\t\tbind.to( 'elementClass' )\n   *\t\t\t\t\t\t\tbind.if( 'isEnabled', 'present-when-enabled' )\n   *\t\t\t\t\t\t]\n   *\t\t\t\t\t},\n   *\n   *\t\t\t\t\ton: {\n   *\t\t\t\t\t\t// The view will fire the \"clicked\" event upon clicking <p> in DOM.\n   *\t\t\t\t\t\tclick: bind.to( 'clicked' )\n   *\t\t\t\t\t}\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t}\n   *\n   * @method #bindTemplate\n   */\n\n\n  _createClass(View, [{\n    key: \"createCollection\",\n\n    /**\n     * Creates a new collection of views, which can be used as\n     * {@link module:ui/template~Template#children} of this view.\n     *\n     *\t\tclass SampleView extends View {\n     *\t\t\tconstructor( locale ) {\n     *\t\t\t\tsuper( locale );\n     *\n     *\t\t\t\tthis.items = this.createCollection();\n    \t *\n     *\t\t\t\tthis.setTemplate( {\n     *\t\t\t\t\ttag: 'p',\n     *\n     *\t\t\t\t\t// `items` collection will render here.\n     *\t\t\t\t\tchildren: this.items\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tconst view = new SampleView( locale );\n     *\t\tconst child = new ChildView( locale );\n     *\n     *\t\tview.render();\n     *\n     *\t\t// It will append <p></p> to the <body>.\n     *\t\tdocument.body.appendChild( view.element );\n     *\n     *\t\t// From now on the child is nested under its parent, which is also reflected in DOM.\n     *\t\t// <p><child#element></p>\n     *\t\tview.items.add( child );\n     *\n     * @returns {module:ui/viewcollection~ViewCollection} A new collection of view instances.\n     */\n    value: function createCollection() {\n      var collection = new ViewCollection();\n\n      this._viewCollections.add(collection);\n\n      return collection;\n    }\n    /**\n     * Registers a new child view under the view instance. Once registered, a child\n     * view is managed by its parent, including {@link #render rendering}\n     * and {@link #destroy destruction}.\n     *\n     * To revert this, use {@link #deregisterChild}.\n     *\n     *\t\tclass SampleView extends View {\n     *\t\t\tconstructor( locale ) {\n     *\t\t\t\tsuper( locale );\n     *\n     *\t\t\t\tthis.childA = new SomeChildView( locale );\n     *\t\t\t\tthis.childB = new SomeChildView( locale );\n     *\n     *\t\t\t\tthis.setTemplate( { tag: 'p' } );\n     *\n     *\t\t\t\t// Register the children.\n     *\t\t\t\tthis.registerChild( [ this.childA, this.childB ] );\n     *\t\t\t}\n     *\n     *\t\t\trender() {\n     *\t\t\t\tsuper.render();\n     *\n     *\t\t\t\tthis.element.appendChild( this.childA.element );\n     *\t\t\t\tthis.element.appendChild( this.childB.element );\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tconst view = new SampleView( locale );\n     *\n     *\t\tview.render();\n     *\n     *\t\t// Will append <p><childA#element><b></b><childB#element></p>.\n     *\t\tdocument.body.appendChild( view.element );\n     *\n     * **Note**: There's no need to add child views if they're already referenced in the\n     * {@link #template}:\n     *\n     *\t\tclass SampleView extends View {\n     *\t\t\tconstructor( locale ) {\n     *\t\t\t\tsuper( locale );\n     *\n     *\t\t\t\tthis.childA = new SomeChildView( locale );\n     *\t\t\t\tthis.childB = new SomeChildView( locale );\n     *\n     *\t\t\t\tthis.setTemplate( {\n     *\t\t\t\t\ttag: 'p',\n     *\n    \t *\t\t\t\t\t// These children will be added automatically. There's no\n    \t *\t\t\t\t\t// need to call {@link #registerChild} for any of them.\n     *\t\t\t\t\tchildren: [ this.childA, this.childB ]\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\n     *\t\t\t// ...\n     *\t\t}\n     *\n     * @param {module:ui/view~View|Iterable.<module:ui/view~View>} children Children views to be registered.\n     */\n\n  }, {\n    key: \"registerChild\",\n    value: function registerChild(children) {\n      if (!isIterable(children)) {\n        children = [children];\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n\n          this._unboundChildren.add(child);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * The opposite of {@link #registerChild}. Removes a child view from this view instance.\n     * Once removed, the child is no longer managed by its parent, e.g. it can safely\n     * become a child of another parent view.\n     *\n     * @see #registerChild\n     * @param {module:ui/view~View|Iterable.<module:ui/view~View>} children Child views to be removed.\n     */\n\n  }, {\n    key: \"deregisterChild\",\n    value: function deregisterChild(children) {\n      if (!isIterable(children)) {\n        children = [children];\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var child = _step2.value;\n\n          this._unboundChildren.remove(child);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n    /**\n     * Sets the {@link #template} of the view with with given definition.\n     *\n     * A shorthand for:\n     *\n     *\t\tview.setTemplate( definition );\n     *\n     * @param {module:ui/template~TemplateDefinition} definition Definition of view's template.\n     */\n\n  }, {\n    key: \"setTemplate\",\n    value: function setTemplate(definition) {\n      this.template = new Template(definition);\n    }\n    /**\n     * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with\n     * with given definition.\n     *\n     * A shorthand for:\n     *\n     *\t\tTemplate.extend( view.template, definition );\n     *\n     * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.\n     *\n     * @param {module:ui/template~TemplateDefinition} definition Definition which\n     * extends the {@link #template}.\n     */\n\n  }, {\n    key: \"extendTemplate\",\n    value: function extendTemplate(definition) {\n      Template.extend(this.template, definition);\n    }\n    /**\n     * Recursively renders the view.\n     *\n     * Once the view is rendered:\n     * * the {@link #element} becomes an HTML element out of {@link #template},\n     * * the {@link #isRendered} flag is set `true`.\n     *\n     * **Note**: The children of the view:\n     * * defined directly in the {@link #template}\n     * * residing in collections created by the {@link #createCollection} method,\n     * * and added by {@link #registerChild}\n     * are also rendered in the process.\n     *\n     * In general, `render()` method is the right place to keep the code which refers to the\n     * {@link #element} and should be executed at the very beginning of the view's life cycle.\n     *\n     * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before\n     * the view is rendered. To allow an early customization of the view (e.g. by its parent),\n     * such references should be done in `render()`.\n     *\n     *\t\tclass SampleView extends View {\n     *\t\t\tconstructor() {\n     *\t\t\t\tthis.setTemplate( {\n     *\t\t\t\t\t// ...\n     *\t\t\t\t} );\n     *\t\t\t},\n     *\n     *\t\t\trender() {\n     *\t\t\t\t// View#element becomes available.\n     *\t\t\t\tsuper.render();\n     *\n     *\t\t\t\t// The \"scroll\" listener depends on #element.\n     *\t\t\t\tthis.listenTo( window, 'scroll', () => {\n     *\t\t\t\t\t// A reference to #element would render the #template and make it non-extendable.\n     *\t\t\t\t\tif ( window.scrollY > 0 ) {\n     *\t\t\t\t\t\tthis.element.scrollLeft = 100;\n     *\t\t\t\t\t} else {\n     *\t\t\t\t\t\tthis.element.scrollLeft = 0;\n     *\t\t\t\t\t}\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\tconst view = new SampleView();\n     *\n     *\t\t// Let's customize the view before it gets rendered.\n     *\t\tview.extendTemplate( {\n     *\t\t\tattributes: {\n     *\t\t\t\tclass: [\n     *\t\t\t\t\t'additional-class'\n     *\t\t\t\t]\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Late rendering allows customization of the view.\n     *\t\tview.render();\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (this.isRendered) {\n        /**\n         * This View has already been rendered.\n         *\n         * @error ui-view-render-rendered\n         */\n        throw new CKEditorError('ui-view-render-already-rendered: This View has already been rendered.');\n      } // Render #element of the view.\n\n\n      if (this.template) {\n        this.element = this.template.render(); // Autoregister view children from #template.\n\n        this.registerChild(this.template.getViews());\n      }\n\n      this.isRendered = true;\n    }\n    /**\n     * Recursively destroys the view instance and child views added by {@link #registerChild} and\n     * residing in collections created by the {@link #createCollection}.\n     *\n     * Destruction disables all event listeners:\n     * * created on the view, e.g. `view.on( 'event', () => {} )`,\n     * * defined in the {@link #template} for DOM events.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stopListening();\n\n      this._viewCollections.map(function (c) {\n        return c.destroy();\n      }); // Template isn't obligatory for views.\n\n\n      if (this.template && this.template._revertData) {\n        this.template.revert(this.element);\n      }\n    }\n    /**\n     * Event fired by the {@link #render} method. Actual rendering is executed as a listener to\n     * this event with the default priority.\n     *\n     * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n     *\n     * @event render\n     */\n\n  }, {\n    key: \"bindTemplate\",\n    get: function get() {\n      if (this._bindTemplate) {\n        return this._bindTemplate;\n      }\n\n      return this._bindTemplate = Template.bind(this, this);\n    }\n  }]);\n\n  return View;\n}();\n\nexport { View as default };\nmix(View, DomEmitterMixin);\nmix(View, ObservableMixin);","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/editorui/editoruiview\n */\n\n/* globals document */\nimport View from \"../view\";\nimport Template from \"../template\";\nimport \"../../theme/components/editorui/editorui.css\";\n/**\n * The editor UI view class. Base class for the editor main views.\n *\n * @extends module:ui/view~View\n */\n\nvar EditorUIView =\n/*#__PURE__*/\nfunction (_View) {\n  _inherits(EditorUIView, _View);\n\n  /**\n   * Creates an instance of the editor UI view class.\n   *\n   * @param {module:utils/locale~Locale} [locale] The locale instance.\n   */\n  function EditorUIView(locale) {\n    var _this;\n\n    _classCallCheck(this, EditorUIView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EditorUIView).call(this, locale));\n    /**\n     * Collection of the child views, detached from the DOM\n     * structure of the editor, like panels, icons etc.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection} #body\n     */\n\n    _this.body = _this.createCollection();\n    /**\n     * The element holding elements of the 'body' region.\n     *\n     * @private\n     * @member {HTMLElement} #_bodyCollectionContainer\n     */\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(EditorUIView, [{\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(EditorUIView.prototype), \"render\", this).call(this);\n\n      this._renderBodyCollection();\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._bodyCollectionContainer.remove();\n\n      return _get(_getPrototypeOf(EditorUIView.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Creates and appends to `<body>` the {@link #body} collection container.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_renderBodyCollection\",\n    value: function _renderBodyCollection() {\n      var bodyElement = this._bodyCollectionContainer = new Template({\n        tag: 'div',\n        attributes: {\n          class: ['ck', 'ck-reset_all', 'ck-body', 'ck-rounded-corners']\n        },\n        children: this.body\n      }).render();\n      document.body.appendChild(bodyElement);\n    }\n  }]);\n\n  return EditorUIView;\n}(View);\n\nexport { EditorUIView as default };","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/tounit\n */\n\n/**\n * Returns a helper function, which adds a desired trailing\n * `unit` to the passed value.\n *\n * @param {String} unit An unit like \"px\" or \"em\".\n * @returns {module:utils/dom/tounit~helper}\n */\nexport default function toUnit(unit) {\n  /**\n   * A function, which adds a predefined trailing `unit`\n   * to the passed `value`.\n   *\n   * @function helper\n  \t * @param {*} value A value to be given the unit.\n  \t * @returns {String} A value with the trailing unit.\n   */\n  return function (value) {\n    return value + unit;\n  };\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/panel/sticky/stickypanelview\n */\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport View from \"../../view\";\nimport Template from \"../../template\";\nimport toUnit from '@ckeditor/ckeditor5-utils/src/dom/tounit';\nimport \"../../../theme/components/panel/stickypanel.css\";\nvar toPx = toUnit('px');\n/**\n * The sticky panel view class.\n */\n\nvar StickyPanelView =\n/*#__PURE__*/\nfunction (_View) {\n  _inherits(StickyPanelView, _View);\n\n  /**\n   * @inheritDoc\n   */\n  function StickyPanelView(locale) {\n    var _this;\n\n    _classCallCheck(this, StickyPanelView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StickyPanelView).call(this, locale));\n    var bind = _this.bindTemplate;\n    /**\n     * Controls whether the sticky panel should be active.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isActive\n     */\n\n    _this.set('isActive', false);\n    /**\n     * Controls whether the sticky panel is in the \"sticky\" state.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isSticky\n     */\n\n\n    _this.set('isSticky', false);\n    /**\n     * The limiter element for the sticky panel instance. Its bounding rect limits\n     * the \"stickyness\" of the panel, i.e. when the panel reaches the bottom\n     * edge of the limiter, it becomes sticky to that edge and does not float\n     * off the limiter. It is mandatory for the panel to work properly and once\n     * set, it cannot be changed.\n     *\n     * @readonly\n     * @observable\n     * @member {HTMLElement} #limiterElement\n     */\n\n\n    _this.set('limiterElement', null);\n    /**\n     * The offset from the bottom edge of {@link #limiterElement}\n     * which stops the panel from stickying any further to prevent limiter's content\n     * from being completely covered.\n     *\n     * @readonly\n     * @observable\n     * @default 50\n     * @member {Number} #limiterBottomOffset\n     */\n\n\n    _this.set('limiterBottomOffset', 50);\n    /**\n     * The offset from the top edge of the web browser's viewport which makes the\n     * panel become sticky. The default value is `0`, which means the panel becomes\n     * sticky when it's upper edge touches the top of the page viewport.\n     *\n     * This attribute is useful when the web page has UI elements positioned to the top\n     * either using `position: fixed` or `position: sticky`, which would cover the\n     * sticky panel or viceversa (depending on the `z-index` hierarchy).\n     *\n     * @readonly\n     * @observable\n     * @default 0\n     * @member {Number} #viewportTopOffset\n     */\n\n\n    _this.set('viewportTopOffset', 0);\n    /**\n     * Controls the `margin-left` CSS style of the panel.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {String} #_marginLeft\n     */\n\n\n    _this.set('_marginLeft', null);\n    /**\n     * Set `true` if the sticky panel reached the bottom edge of the\n     * {@link #limiterElement}.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {Boolean} #_isStickyToTheLimiter\n     */\n\n\n    _this.set('_isStickyToTheLimiter', false);\n    /**\n     * Set `true` if the sticky panel uses the {@link #viewportTopOffset},\n     * i.e. not {@link #_isStickyToTheLimiter} and the {@link #viewportTopOffset}\n     * is not `0`.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {Boolean} #_hasViewportTopOffset\n     */\n\n\n    _this.set('_hasViewportTopOffset', false);\n    /**\n     * Collection of the child views which creates balloon panel contents.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n\n    _this.content = _this.createCollection();\n    /**\n     * The DOM bounding client rect of the {@link module:ui/view~View#element} of the panel.\n     *\n     * @protected\n     * @member {Object} #_panelRect\n     */\n\n    /**\n     * The DOM bounding client rect of the {@link #limiterElement}\n     * of the panel.\n     *\n     * @protected\n     * @member {Object} #_limiterRect\n     */\n\n    /**\n     * A dummy element which visually fills the space as long as the\n     * actual panel is sticky. It prevents flickering of the UI.\n     *\n     * @protected\n     * @property {HTMLElement}\n     */\n\n    _this._contentPanelPlaceholder = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel__placeholder'],\n        style: {\n          display: bind.to('isSticky', function (isSticky) {\n            return isSticky ? 'block' : 'none';\n          }),\n          height: bind.to('isSticky', function (isSticky) {\n            return isSticky ? toPx(_this._panelRect.height) : null;\n          })\n        }\n      }\n    }).render();\n    /**\n     * The panel which accepts children into {@link #content} collection.\n     * Also an element which is positioned when {@link #isSticky}.\n     *\n     * @protected\n     * @property {HTMLElement}\n     */\n\n    _this._contentPanel = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel__content', // Toggle class of the panel when \"sticky\" state changes in the view.\n        bind.if('isSticky', 'ck-sticky-panel__content_sticky'), bind.if('_isStickyToTheLimiter', 'ck-sticky-panel__content_sticky_bottom-limit')],\n        style: {\n          width: bind.to('isSticky', function (isSticky) {\n            return isSticky ? toPx(_this._contentPanelPlaceholder.getBoundingClientRect().width) : null;\n          }),\n          top: bind.to('_hasViewportTopOffset', function (_hasViewportTopOffset) {\n            return _hasViewportTopOffset ? toPx(_this.viewportTopOffset) : null;\n          }),\n          bottom: bind.to('_isStickyToTheLimiter', function (_isStickyToTheLimiter) {\n            return _isStickyToTheLimiter ? toPx(_this.limiterBottomOffset) : null;\n          }),\n          marginLeft: bind.to('_marginLeft')\n        }\n      },\n      children: _this.content\n    }).render();\n\n    _this.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel']\n      },\n      children: [_this._contentPanelPlaceholder, _this._contentPanel]\n    });\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(StickyPanelView, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(StickyPanelView.prototype), \"render\", this).call(this); // Check if the panel should go into the sticky state immediately.\n\n\n      this._checkIfShouldBeSticky(); // Update sticky state of the panel as the window is being scrolled.\n\n\n      this.listenTo(global.window, 'scroll', function () {\n        _this2._checkIfShouldBeSticky();\n      }); // Synchronize with `model.isActive` because sticking an inactive panel is pointless.\n\n      this.listenTo(this, 'change:isActive', function () {\n        _this2._checkIfShouldBeSticky();\n      });\n    }\n    /**\n     * Analyzes the environment to decide whether the panel should\n     * be sticky or not.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_checkIfShouldBeSticky\",\n    value: function _checkIfShouldBeSticky() {\n      var panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();\n\n      var limiterRect;\n\n      if (!this.limiterElement) {\n        this.isSticky = false;\n      } else {\n        limiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect(); // The panel must be active to become sticky.\n\n        this.isSticky = this.isActive && // The limiter's top edge must be beyond the upper edge of the visible viewport (+the viewportTopOffset).\n        limiterRect.top < this.viewportTopOffset && // The model#limiterElement's height mustn't be smaller than the panel's height and model#limiterBottomOffset.\n        // There's no point in entering the sticky mode if the model#limiterElement is very, very small, because\n        // it would immediately set model#_isStickyToTheLimiter true and, given model#limiterBottomOffset, the panel\n        // would be positioned before the model#limiterElement.\n        this._panelRect.height + this.limiterBottomOffset < limiterRect.height;\n      } // Stick the panel to the top edge of the viewport simulating CSS position:sticky.\n      // TODO: Possibly replaced by CSS in the future http://caniuse.com/#feat=css-sticky\n\n\n      if (this.isSticky) {\n        this._isStickyToTheLimiter = limiterRect.bottom < panelRect.height + this.limiterBottomOffset + this.viewportTopOffset;\n        this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;\n        this._marginLeft = this._isStickyToTheLimiter ? null : toPx(-global.window.scrollX);\n      } // Detach the panel from the top edge of the viewport.\n      else {\n          this._isStickyToTheLimiter = false;\n          this._hasViewportTopOffset = false;\n          this._marginLeft = null;\n        }\n    }\n  }]);\n\n  return StickyPanelView;\n}(View);\n\nexport { StickyPanelView as default };","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/toolbar/toolbarseparatorview\n */\nimport View from \"../view\";\n/**\n * The toolbar separator view class.\n *\n * @extends module:ui/view~View\n */\n\nvar ToolbarSeparatorView =\n/*#__PURE__*/\nfunction (_View) {\n  _inherits(ToolbarSeparatorView, _View);\n\n  /**\n   * @inheritDoc\n   */\n  function ToolbarSeparatorView(locale) {\n    var _this;\n\n    _classCallCheck(this, ToolbarSeparatorView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ToolbarSeparatorView).call(this, locale));\n\n    _this.setTemplate({\n      tag: 'span',\n      attributes: {\n        class: ['ck', 'ck-toolbar__separator']\n      }\n    });\n\n    return _this;\n  }\n\n  return ToolbarSeparatorView;\n}(View);\n\nexport { ToolbarSeparatorView as default };","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/bindings/preventdefault\n */\n\n/**\n * A helper which executes a native `Event.preventDefault()` if the target of an event equals the\n * {@link module:ui/view~View#element element of the view}. It shortens the definition of a\n * {@link module:ui/view~View#template template}.\n *\n *\t\t// In a class extending View.\n *\t\timport preventDefault from '@ckeditor/ckeditor5-ui/src/bindings/preventdefault';\n *\n *\t\t// ...\n *\n *\t\tthis.setTemplate( {\n *\t\t\ttag: 'div',\n *\n *\t\t\ton: {\n *\t\t\t\t// Prevent the default mousedown action on this view.\n *\t\t\t\tmousedown: preventDefault( this )\n *\t\t\t}\n *\t\t} );\n *\n * @param {module:ui/view~View} view View instance that defines the template.\n * @returns {module:ui/template~TemplateToBinding}\n */\nexport default function preventDefault(view) {\n  return view.bindTemplate.to(function (evt) {\n    if (evt.target === view.element) {\n      evt.preventDefault();\n    }\n  });\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _assertThisInitialized from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/toolbar/toolbarview\n */\nimport View from \"../view\";\nimport FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';\nimport FocusCycler from \"../focuscycler\";\nimport KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';\nimport ToolbarSeparatorView from \"./toolbarseparatorview\";\nimport preventDefault from \"../bindings/preventdefault.js\";\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport \"../../theme/components/toolbar/toolbar.css\";\n/**\n * The toolbar view class.\n *\n * @extends module:ui/view~View\n * @implements module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable\n */\n\nvar ToolbarView =\n/*#__PURE__*/\nfunction (_View) {\n  _inherits(ToolbarView, _View);\n\n  /**\n   * @inheritDoc\n   */\n  function ToolbarView(locale) {\n    var _this;\n\n    _classCallCheck(this, ToolbarView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ToolbarView).call(this, locale));\n    var bind = _this.bindTemplate;\n    /**\n     * Collection of the toolbar items (like buttons).\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n    _this.items = _this.createCollection();\n    /**\n     * Tracks information about DOM focus in the list.\n     *\n     * @readonly\n     * @member {module:utils/focustracker~FocusTracker}\n     */\n\n    _this.focusTracker = new FocusTracker();\n    /**\n     * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.\n     *\n     * @readonly\n     * @member {module:utils/keystrokehandler~KeystrokeHandler}\n     */\n\n    _this.keystrokes = new KeystrokeHandler();\n    /**\n     * Controls the orientation of toolbar items.\n     *\n     * @observable\n     * @member {Boolean} #isVertical\n     */\n\n    _this.set('isVertical', false);\n    /**\n     * An additional CSS class added to the {@link #element}.\n     *\n     * @observable\n     * @member {String} #class\n     */\n\n\n    _this.set('class');\n    /**\n     * Helps cycling over focusable {@link #items} in the toolbar.\n     *\n     * @readonly\n     * @protected\n     * @member {module:ui/focuscycler~FocusCycler}\n     */\n\n\n    _this._focusCycler = new FocusCycler({\n      focusables: _this.items,\n      focusTracker: _this.focusTracker,\n      keystrokeHandler: _this.keystrokes,\n      actions: {\n        // Navigate toolbar items backwards using the arrow[left,up] keys.\n        focusPrevious: ['arrowleft', 'arrowup'],\n        // Navigate toolbar items forwards using the arrow[right,down] keys.\n        focusNext: ['arrowright', 'arrowdown']\n      }\n    });\n\n    _this.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-toolbar', bind.if('isVertical', 'ck-toolbar_vertical'), bind.to('class')]\n      },\n      children: _this.items,\n      on: {\n        // https://github.com/ckeditor/ckeditor5-ui/issues/206\n        mousedown: preventDefault(_assertThisInitialized(_this))\n      }\n    });\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(ToolbarView, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(ToolbarView.prototype), \"render\", this).call(this); // Items added before rendering should be known to the #focusTracker.\n\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var item = _step.value;\n          this.focusTracker.add(item.element);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.items.on('add', function (evt, item) {\n        _this2.focusTracker.add(item.element);\n      });\n      this.items.on('remove', function (evt, item) {\n        _this2.focusTracker.remove(item.element);\n      }); // Start listening for the keystrokes coming from #element.\n\n      this.keystrokes.listenTo(this.element);\n    }\n    /**\n     * Focuses the first focusable in {@link #items}.\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this._focusCycler.focusFirst();\n    }\n    /**\n     * Focuses the last focusable in {@link #items}.\n     */\n\n  }, {\n    key: \"focusLast\",\n    value: function focusLast() {\n      this._focusCycler.focusLast();\n    }\n    /**\n     * A utility which expands a plain toolbar configuration into\n     * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.\n     *\n     * @param {Array.<String>} config The toolbar items config.\n     * @param {module:ui/componentfactory~ComponentFactory} factory A factory producing toolbar items.\n     */\n\n  }, {\n    key: \"fillFromConfig\",\n    value: function fillFromConfig(config, factory) {\n      var _this3 = this;\n\n      config.map(function (name) {\n        if (name == '|') {\n          _this3.items.add(new ToolbarSeparatorView());\n        } else if (factory.has(name)) {\n          _this3.items.add(factory.create(name));\n        } else {\n          /**\n           * There was a problem processing the configuration of the toolbar. The item with the given\n           * name does not exist so it was omitted when rendering the toolbar.\n           *\n           * This warning usually shows up when the {@link module:core/plugin~Plugin} which is supposed\n           * to provide a toolbar item has not been loaded or there is a typo in the configuration.\n           *\n           * Make sure the plugin responsible for this toolbar item is loaded and the toolbar configuration\n           * is correct, e.g. {@link module:basic-styles/bold~Bold} is loaded for the `'bold'` toolbar item.\n           *\n           * You can use the following snippet to retrieve all available toolbar items:\n           *\n           *\t\tArray.from( editor.ui.componentFactory.names() );\n           *\n           * @error toolbarview-item-unavailable\n           * @param {String} name The name of the component.\n           */\n          log.warn('toolbarview-item-unavailable: The requested toolbar item is unavailable.', {\n            name: name\n          });\n        }\n      });\n    }\n  }]);\n\n  return ToolbarView;\n}(View);\n\nexport { ToolbarView as default };","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals HTMLTextAreaElement */\n\n/**\n * @module utils/dom/getdatafromelement\n */\n\n/**\n * Gets data from a given source element.\n *\n * @param {HTMLElement} el The element from which the data will be retrieved.\n * @returns {String} The data string.\n */\nexport default function getDataFromElement(el) {\n  if (el instanceof HTMLTextAreaElement) {\n    return el.value;\n  }\n\n  return el.innerHTML;\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _assertThisInitialized from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module editor-classic/classiceditor\n */\nimport Editor from '@ckeditor/ckeditor5-core/src/editor/editor';\nimport DataApiMixin from '@ckeditor/ckeditor5-core/src/editor/utils/dataapimixin';\nimport ElementApiMixin from '@ckeditor/ckeditor5-core/src/editor/utils/elementapimixin';\nimport attachToForm from '@ckeditor/ckeditor5-core/src/editor/utils/attachtoform';\nimport HtmlDataProcessor from '@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor';\nimport ClassicEditorUI from \"./classiceditorui\";\nimport ClassicEditorUIView from \"./classiceditoruiview\";\nimport getDataFromElement from '@ckeditor/ckeditor5-utils/src/dom/getdatafromelement';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isElement } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * The {@glink builds/guides/overview#classic-editor classic editor} implementation.\n * It uses an inline editable and a sticky toolbar, all enclosed in a boxed UI.\n * See the {@glink examples/builds/classic-editor demo}.\n *\n * In order to create a classic editor instance, use the static\n * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method.\n *\n * # Classic editor and classic build\n *\n * The classic editor can be used directly from source (if you installed the\n * [`@ckeditor/ckeditor5-editor-classic`](https://www.npmjs.com/package/@ckeditor/ckeditor5-editor-classic) package)\n * but it is also available in the {@glink builds/guides/overview#classic-editor classic build}.\n *\n * {@glink builds/guides/overview Builds} are ready-to-use editors with plugins bundled in. When using the editor from\n * source you need to take care of loading all plugins by yourself\n * (through the {@link module:core/editor/editorconfig~EditorConfig#plugins `config.plugins`} option).\n * Using the editor from source gives much better flexibility and allows easier customization.\n *\n * Read more about initializing the editor from source or as a build in\n * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.\n *\n * @mixes module:core/editor/utils/dataapimixin~DataApiMixin\n * @mixes module:core/editor/utils/elementapimixin~ElementApiMixin\n * @implements module:core/editor/editorwithui~EditorWithUI\n * @extends module:core/editor/editor~Editor\n */\n\nvar ClassicEditor =\n/*#__PURE__*/\nfunction (_Editor) {\n  _inherits(ClassicEditor, _Editor);\n\n  /**\n   * Creates an instance of the classic editor.\n   *\n   * **Note:** do not use the constructor to create editor instances. Use the static\n   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.\n   *\n   * @protected\n   * @param {HTMLElement|String} sourceElementOrData The DOM element that will be the source for the created editor\n   * or the editor's initial data. For more information see\n   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.\n   * @param {module:core/editor/editorconfig~EditorConfig} config The editor configuration.\n   */\n  function ClassicEditor(sourceElementOrData, config) {\n    var _this;\n\n    _classCallCheck(this, ClassicEditor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClassicEditor).call(this, config));\n\n    if (isElement(sourceElementOrData)) {\n      _this.sourceElement = sourceElementOrData;\n    }\n\n    _this.data.processor = new HtmlDataProcessor();\n\n    _this.model.document.createRoot();\n\n    _this.ui = new ClassicEditorUI(_assertThisInitialized(_this), new ClassicEditorUIView(_this.locale, _this.editing.view));\n    attachToForm(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Destroys the editor instance, releasing all resources used by it.\n   *\n   * Updates the editor's source element with the data.\n   *\n   * @returns {Promise}\n   */\n\n\n  _createClass(ClassicEditor, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.sourceElement) {\n        this.updateSourceElement();\n      }\n\n      this.ui.destroy();\n      return _get(_getPrototypeOf(ClassicEditor.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Creates a new classic editor instance.\n     *\n     * There are three ways how the editor can be initialized.\n     *\n     * # Replacing a DOM element (and loading data from it)\n     *\n     * You can initialize the editor using an existing DOM element:\n     *\n     *\t\tClassicEditor\n     *\t\t\t.create( document.querySelector( '#editor' ) )\n     *\t\t\t.then( editor => {\n     *\t\t\t\tconsole.log( 'Editor was initialized', editor );\n     *\t\t\t} )\n     *\t\t\t.catch( err => {\n     *\t\t\t\tconsole.error( err.stack );\n     *\t\t\t} );\n     *\n     * The element's content will be used as the editor data and the element will be replaced by the editor UI.\n     *\n     * # Creating a detached editor\n     *\n     * Alternatively, you can initialize the editor by passing the initial data directly as a string.\n     * In this case, the editor will render an element that must be inserted into the DOM:\n     *\n     *\t\tClassicEditor\n     *\t\t\t.create( '<p>Hello world!</p>' )\n     *\t\t\t.then( editor => {\n     *\t\t\t\tconsole.log( 'Editor was initialized', editor );\n     *\n     *\t\t\t\t// Initial data was provided so the editor UI element needs to be added manually to the DOM.\n     *\t\t\t\tdocument.body.appendChild( editor.ui.element );\n     *\t\t\t} )\n     *\t\t\t.catch( err => {\n     *\t\t\t\tconsole.error( err.stack );\n     *\t\t\t} );\n     *\n     * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your\n     * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.\n     *\n     * # Replacing a DOM element (and data provided in `config.initialData`)\n     *\n     * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:\n     *\n     *\t\tClassicEditor\n     *\t\t\t.create( document.querySelector( '#editor' ), {\n     *\t\t\t\tinitialData: '<h2>Initial data</h2><p>Foo bar.</p>'\n     *\t\t\t} )\n     *\t\t\t.then( editor => {\n     *\t\t\t\tconsole.log( 'Editor was initialized', editor );\n     *\t\t\t} )\n     *\t\t\t.catch( err => {\n     *\t\t\t\tconsole.error( err.stack );\n     *\t\t\t} );\n     *\n     * This method can be used to initialize the editor on an existing element with the specified content in case if your integration\n     * makes it difficult to set the content of the source element.\n     *\n     * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.\n     *\n     * # Configuring the editor\n     *\n     * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about\n     * customizing plugins, toolbar and more.\n     *\n     * # Using the editor from source\n     *\n     * The code samples listed in the previous sections of this documentation assume that you are using an\n     * {@glink builds/guides/overview editor build} (for example  `@ckeditor/ckeditor5-build-classic`).\n     *\n     * If you want to use the classic editor from source (`@ckeditor/ckeditor5-editor-classic/src/classiceditor`),\n     * you need to define the list of\n     * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and\n     * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}. Read more about using the editor from\n     * source in the {@glink builds/guides/integration/advanced-setup \"Advanced setup\" guide}.\n     *\n     * @param {HTMLElement|String} sourceElementOrData The DOM element that will be the source for the created editor\n     * or the editor's initial data.\n     *\n     * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization\n     * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element\n     * in the DOM (the original one will be hidden and the editor will be injected next to it).\n     *\n     * Moreover, the editor data will be set back to the original element once the editor is destroyed and when a form, in which\n     * this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration with native\n     * web forms.\n     *\n     * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.\n     * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.\n     *\n     * @param {module:core/editor/editorconfig~EditorConfig} [config] The editor configuration.\n     * @returns {Promise} A promise resolved once the editor is ready. The promise resolves with the created editor instance.\n     */\n\n  }], [{\n    key: \"create\",\n    value: function create(sourceElementOrData) {\n      var _this2 = this;\n\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function (resolve) {\n        var editor = new _this2(sourceElementOrData, config);\n        resolve(editor.initPlugins().then(function () {\n          return editor.ui.init(isElement(sourceElementOrData) ? sourceElementOrData : null);\n        }).then(function () {\n          if (!isElement(sourceElementOrData) && config.initialData) {\n            // Documented in core/editor/editorconfig.jdoc.\n            throw new CKEditorError('editor-create-initial-data: ' + 'The config.initialData option cannot be used together with initial data passed in Editor.create().');\n          }\n\n          var initialData = config.initialData || getInitialData(sourceElementOrData);\n          return editor.data.init(initialData);\n        }).then(function () {\n          return editor.fire('ready');\n        }).then(function () {\n          return editor;\n        }));\n      });\n    }\n  }]);\n\n  return ClassicEditor;\n}(Editor);\n\nexport { ClassicEditor as default };\nmix(ClassicEditor, DataApiMixin);\nmix(ClassicEditor, ElementApiMixin);\n\nfunction getInitialData(sourceElementOrData) {\n  return isElement(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;\n}","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module clipboard/datatransfer\n */\n\n/**\n * Facade over the native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.\n */\nvar DataTransfer =\n/*#__PURE__*/\nfunction () {\n  function DataTransfer(nativeDataTransfer) {\n    _classCallCheck(this, DataTransfer);\n\n    /**\n     * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.\n     *\n     * @readonly\n     * @member {Array.<File>} #files\n     */\n    this.files = getFiles(nativeDataTransfer);\n    /**\n     * The native DataTransfer object.\n     *\n     * @private\n     * @member {DataTransfer} #_native\n     */\n\n    this._native = nativeDataTransfer;\n  }\n  /**\n   * Returns an array of available native content types.\n   *\n   * @returns {Array.<String>}\n   */\n\n\n  _createClass(DataTransfer, [{\n    key: \"getData\",\n\n    /**\n     * Gets data from the data transfer by its mime type.\n     *\n     *\t\tdataTransfer.getData( 'text/plain' );\n     *\n     * @param {String} type The mime type. E.g. `text/html` or `text/plain`.\n     * @returns {String}\n     */\n    value: function getData(type) {\n      return this._native.getData(type);\n    }\n    /**\n     * Sets data in the data transfer.\n     *\n     * @param {String} type The mime type. E.g. `text/html` or `text/plain`.\n     * @param {String} data\n     */\n\n  }, {\n    key: \"setData\",\n    value: function setData(type, data) {\n      this._native.setData(type, data);\n    }\n  }, {\n    key: \"types\",\n    get: function get() {\n      return this._native.types;\n    }\n  }]);\n\n  return DataTransfer;\n}();\n\nexport { DataTransfer as default };\n\nfunction getFiles(nativeDataTransfer) {\n  // DataTransfer.files and items are Array-like and might not have an iterable interface.\n  var files = nativeDataTransfer.files ? Array.from(nativeDataTransfer.files) : [];\n  var items = nativeDataTransfer.items ? Array.from(nativeDataTransfer.items) : [];\n\n  if (files.length) {\n    return files;\n  } // Chrome have empty DataTransfer.files, but let get files through the items interface.\n\n\n  return items.filter(function (item) {\n    return item.kind === 'file';\n  }).map(function (item) {\n    return item.getAsFile();\n  });\n}","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module clipboard/clipboardobserver\n */\nimport DomEventObserver from '@ckeditor/ckeditor5-engine/src/view/observer/domeventobserver';\nimport EventInfo from '@ckeditor/ckeditor5-utils/src/eventinfo';\nimport DataTransfer from \"./datatransfer\";\n/**\n * Clipboard events observer.\n *\n * Fires the following events:\n *\n * * {@link module:engine/view/document~Document#event:clipboardInput}\n * * {@link module:engine/view/document~Document#event:dragover}\n * * {@link module:engine/view/document~Document#event:drop}\n * * {@link module:engine/view/document~Document#event:paste}\n * * {@link module:engine/view/document~Document#event:copy}\n * * {@link module:engine/view/document~Document#event:cut}\n *\n * Note that this observer is not available by default (it is not added by the engine).\n * To make it available it needs to be added to {@link module:engine/view/document~Document} by\n * the {@link module:engine/view/view~View#addObserver `View#addObserver()`} method. You can also load the\n * {@link module:clipboard/clipboard~Clipboard} plugin which adds this observer automatically (because it uses it).\n *\n * @extends module:engine/view/observer/domeventobserver~DomEventObserver\n */\n\nvar ClipboardObserver =\n/*#__PURE__*/\nfunction (_DomEventObserver) {\n  _inherits(ClipboardObserver, _DomEventObserver);\n\n  function ClipboardObserver(view) {\n    var _this;\n\n    _classCallCheck(this, ClipboardObserver);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClipboardObserver).call(this, view));\n    var viewDocument = _this.document;\n    _this.domEventType = ['paste', 'copy', 'cut', 'drop', 'dragover'];\n\n    _this.listenTo(viewDocument, 'paste', handleInput, {\n      priority: 'low'\n    });\n\n    _this.listenTo(viewDocument, 'drop', handleInput, {\n      priority: 'low'\n    });\n\n    function handleInput(evt, data) {\n      data.preventDefault();\n      var targetRanges = data.dropRange ? [data.dropRange] : Array.from(viewDocument.selection.getRanges());\n      var eventInfo = new EventInfo(viewDocument, 'clipboardInput');\n      viewDocument.fire(eventInfo, {\n        dataTransfer: data.dataTransfer,\n        targetRanges: targetRanges\n      }); // If CKEditor handled the input, do not bubble the original event any further.\n      // This helps external integrations recognize that fact and act accordingly.\n      // https://github.com/ckeditor/ckeditor5-upload/issues/92\n\n      if (eventInfo.stop.called) {\n        data.stopPropagation();\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(ClipboardObserver, [{\n    key: \"onDomEvent\",\n    value: function onDomEvent(domEvent) {\n      var evtData = {\n        dataTransfer: new DataTransfer(domEvent.clipboardData ? domEvent.clipboardData : domEvent.dataTransfer)\n      };\n\n      if (domEvent.type == 'drop') {\n        evtData.dropRange = getDropViewRange(this.view, domEvent);\n      }\n\n      this.fire(domEvent.type, domEvent, evtData);\n    }\n  }]);\n\n  return ClipboardObserver;\n}(DomEventObserver);\n\nexport { ClipboardObserver as default };\n\nfunction getDropViewRange(view, domEvent) {\n  var domDoc = domEvent.target.ownerDocument;\n  var x = domEvent.clientX;\n  var y = domEvent.clientY;\n  var domRange; // Webkit & Blink.\n\n  if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x, y)) {\n    domRange = domDoc.caretRangeFromPoint(x, y);\n  } // FF.\n  else if (domEvent.rangeParent) {\n      domRange = domDoc.createRange();\n      domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);\n      domRange.collapse(true);\n    }\n\n  if (domRange) {\n    return view.domConverter.domRangeToView(domRange);\n  } else {\n    return view.document.selection.getFirstRange();\n  }\n}\n/**\n * Fired as a continuation of {@link #event:paste} and {@link #event:drop} events.\n *\n * It is a part of the {@glink framework/guides/deep-dive/clipboard#input-pipeline \"clipboard input pipeline\"}.\n *\n * Fired with a `dataTransfer` which comes from the clipboard and which content should be processed\n * and inserted into the editor.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @see module:clipboard/clipboard~Clipboard\n * @event module:engine/view/document~Document#event:clipboardInput\n * @param {Object} data Event data.\n * @param {module:clipboard/datatransfer~DataTransfer} data.dataTransfer Data transfer instance.\n * @param {Array.<module:engine/view/range~Range>} data.targetRanges Ranges which are the target of the operation\n * (usually  into which the content should be inserted).\n * If clipboard input was triggered by a paste operation, then these are the selection ranges. If by a drop operation,\n * then it's the drop position (which can be different than the selection at the moment of drop).\n */\n\n/**\n * Fired when user drags content over one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:engine/view/document~Document#event:clipboardInput\n * @event module:engine/view/document~Document#event:dragover\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n */\n\n/**\n * Fired when user dropped content into one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:engine/view/document~Document#event:clipboardInput\n * @event module:engine/view/document~Document#event:drop\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n * @param {module:engine/view/range~Range} dropRange The position into which the content is dropped.\n */\n\n/**\n * Fired when user pasted content into one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:engine/view/document~Document#event:clipboardInput\n * @event module:engine/view/document~Document#event:paste\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n */\n\n/**\n * Fired when user copied content from one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @event module:engine/view/document~Document#event:copy\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n */\n\n/**\n * Fired when user cut content from one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @event module:engine/view/document~Document#event:cut\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n */\n\n/**\n * The value of the {@link module:engine/view/document~Document#event:paste},\n * {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut} events.\n *\n * In order to access clipboard data use `dataTransfer` property.\n *\n * @class module:clipboard/clipboardobserver~ClipboardEventData\n * @extends module:engine/view/observer/domeventdata~DomEventData\n */\n\n/**\n * Data transfer instance.\n *\n * @readonly\n * @member {module:clipboard/datatransfer~DataTransfer} module:clipboard/clipboardobserver~ClipboardEventData#dataTransfer\n */","import \"core-js/modules/es6.regexp.replace\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module clipboard/utils/plaintexttohtml\n */\n\n/**\n * Converts plain text to its HTML-ized version.\n *\n * @param {String} text The plain text to convert.\n * @returns {String} HTML generated from the plain text.\n */\nexport default function plainTextToHtml(text) {\n  text = text // Encode <>.\n  .replace(/</g, '&lt;').replace(/>/g, '&gt;') // Creates paragraphs for double line breaks and change single line breaks to <br>s.\n  .replace(/\\n\\n/g, '</p><p>').replace(/\\n/g, '<br>') // Preserve trailing spaces (only the first and last one  the rest is handled below).\n  .replace(/^\\s/, '&nbsp;').replace(/\\s$/, '&nbsp;') // Preserve other subsequent spaces now.\n  .replace(/\\s\\s/g, ' &nbsp;');\n\n  if (text.indexOf('</p><p>') > -1) {\n    // If we created paragraphs above, add the trailing ones.\n    text = \"<p>\".concat(text, \"</p>\");\n  } // TODO:\n  // * What about '\\nfoo' vs ' foo'?\n\n\n  return text;\n}","import \"core-js/modules/es6.regexp.replace\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module clipboard/utils/normalizeclipboarddata\n */\n\n/**\n * Removes some popular browser quirks out of the clipboard data (HTML).\n *\n * @param {String} data The HTML data to normalize.\n * @returns {String} Normalized HTML.\n */\nexport default function normalizeClipboardData(data) {\n  return data.replace(/<span(?: class=\"Apple-converted-space\"|)>(\\s+)<\\/span>/g, function (fullMatch, spaces) {\n    // Handle the most popular and problematic case when even a single space becomes an nbsp;.\n    // Decode those to normal spaces. Read more in https://github.com/ckeditor/ckeditor5-clipboard/issues/2.\n    if (spaces.length == 1) {\n      return ' ';\n    }\n\n    return spaces;\n  });\n}","import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module clipboard/utils/viewtoplaintext\n */\n// Elements which should not have empty-line padding.\n// Most `view.ContainerElement` want to be separate by new-line, but some are creating one structure\n// together (like `<li>`) so it is better to separate them by only one \"\\n\".\nvar smallPaddingElements = ['figcaption', 'li'];\n/**\n * Converts {@link module:engine/view/item~Item view item} and all of its children to plain text.\n *\n * @param {module:engine/view/item~Item} viewItem View item to convert.\n * @returns {String} Plain text representation of `viewItem`.\n */\n\nexport default function viewToPlainText(viewItem) {\n  var text = '';\n\n  if (viewItem.is('text') || viewItem.is('textProxy')) {\n    // If item is `Text` or `TextProxy` simple take its text data.\n    text = viewItem.data;\n  } else if (viewItem.is('img') && viewItem.hasAttribute('alt')) {\n    // Special case for images - use alt attribute if it is provided.\n    text = viewItem.getAttribute('alt');\n  } else {\n    // Other elements are document fragments, attribute elements or container elements.\n    // They don't have their own text value, so convert their children.\n    var prev = null;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = viewItem.getChildren()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var child = _step.value;\n        var childText = viewToPlainText(child); // Separate container element children with one or more new-line characters.\n\n        if (prev && (prev.is('containerElement') || child.is('containerElement'))) {\n          if (smallPaddingElements.includes(prev.name) || smallPaddingElements.includes(child.name)) {\n            text += '\\n';\n          } else {\n            text += '\\n\\n';\n          }\n        }\n\n        text += childText;\n        prev = child;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return text;\n}","import \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module clipboard/clipboard\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ClipboardObserver from \"./clipboardobserver\";\nimport plainTextToHtml from \"./utils/plaintexttohtml\";\nimport normalizeClipboardHtml from \"./utils/normalizeclipboarddata\";\nimport viewToPlainText from \"./utils/viewtoplaintext.js\";\nimport HtmlDataProcessor from '@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor';\n/**\n * The clipboard feature. It is responsible for intercepting the `paste` and `drop` events and\n * passing the pasted content through the clipboard pipeline in order to insert it into the editor's content.\n * It also handles the `cut` and `copy` events to fill the native clipboard with serialized editor's data.\n *\n * Read more about the clipboard integration in {@glink framework/guides/deep-dive/clipboard \"Clipboard\" deep dive} guide.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar Clipboard =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Clipboard, _Plugin);\n\n  function Clipboard() {\n    _classCallCheck(this, Clipboard);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Clipboard).apply(this, arguments));\n  }\n\n  _createClass(Clipboard, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var _this = this;\n\n      var editor = this.editor;\n      var modelDocument = editor.model.document;\n      var view = editor.editing.view;\n      var viewDocument = view.document;\n      /**\n       * Data processor used to convert pasted HTML to a view structure.\n       *\n       * @private\n       * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #_htmlDataProcessor\n       */\n\n      this._htmlDataProcessor = new HtmlDataProcessor();\n      view.addObserver(ClipboardObserver); // The clipboard paste pipeline.\n      // Pasting and dropping is disabled when editor is read-only.\n      // See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.\n\n      this.listenTo(viewDocument, 'clipboardInput', function (evt) {\n        if (editor.isReadOnly) {\n          evt.stop();\n        }\n      }, {\n        priority: 'highest'\n      });\n      this.listenTo(viewDocument, 'clipboardInput', function (evt, data) {\n        var dataTransfer = data.dataTransfer;\n        var content = '';\n\n        if (dataTransfer.getData('text/html')) {\n          content = normalizeClipboardHtml(dataTransfer.getData('text/html'));\n        } else if (dataTransfer.getData('text/plain')) {\n          content = plainTextToHtml(dataTransfer.getData('text/plain'));\n        }\n\n        content = _this._htmlDataProcessor.toView(content);\n\n        _this.fire('inputTransformation', {\n          content: content,\n          dataTransfer: dataTransfer\n        });\n\n        view.scrollToTheSelection();\n      }, {\n        priority: 'low'\n      });\n      this.listenTo(this, 'inputTransformation', function (evt, data) {\n        if (!data.content.isEmpty) {\n          var dataController = _this.editor.data;\n          var model = _this.editor.model; // Convert the pasted content to a model document fragment.\n          // Conversion is contextual, but in this case we need an \"all allowed\" context and for that\n          // we use the $clipboardHolder item.\n\n          var modelFragment = dataController.toModel(data.content, '$clipboardHolder');\n\n          if (modelFragment.childCount == 0) {\n            return;\n          }\n\n          model.insertContent(modelFragment);\n        }\n      }, {\n        priority: 'low'\n      }); // The clipboard copy/cut pipeline.\n\n      function onCopyCut(evt, data) {\n        var dataTransfer = data.dataTransfer;\n        data.preventDefault();\n        var content = editor.data.toView(editor.model.getSelectedContent(modelDocument.selection));\n        viewDocument.fire('clipboardOutput', {\n          dataTransfer: dataTransfer,\n          content: content,\n          method: evt.name\n        });\n      }\n\n      this.listenTo(viewDocument, 'copy', onCopyCut, {\n        priority: 'low'\n      });\n      this.listenTo(viewDocument, 'cut', function (evt, data) {\n        // Cutting is disabled when editor is read-only.\n        // See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.\n        if (editor.isReadOnly) {\n          data.preventDefault();\n        } else {\n          onCopyCut(evt, data);\n        }\n      }, {\n        priority: 'low'\n      });\n      this.listenTo(viewDocument, 'clipboardOutput', function (evt, data) {\n        if (!data.content.isEmpty) {\n          data.dataTransfer.setData('text/html', _this._htmlDataProcessor.toData(data.content));\n          data.dataTransfer.setData('text/plain', viewToPlainText(data.content));\n        }\n\n        if (data.method == 'cut') {\n          editor.model.deleteContent(modelDocument.selection);\n        }\n      }, {\n        priority: 'low'\n      });\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'Clipboard';\n    }\n  }]);\n\n  return Clipboard;\n}(Plugin);\n/**\n * Fired with a `content` and `dataTransfer` objects. The `content` which comes from the clipboard (was pasted or dropped)\n * should be processed in order to be inserted into the editor. The `dataTransfer` object is available\n * in case the transformation functions needs access to a raw clipboard data.\n *\n * It is a part of the {@glink framework/guides/deep-dive/clipboard#input-pipeline \"clipboard input pipeline\"}.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @see module:clipboard/clipboard~Clipboard\n * @event module:clipboard/clipboard~Clipboard#event:inputTransformation\n * @param {Object} data Event data.\n * @param {module:engine/view/documentfragment~DocumentFragment} data.content Event data. Content to be inserted into the editor.\n * It can be modified by the event listeners. Read more about the clipboard pipelines in\n * {@glink framework/guides/deep-dive/clipboard \"Clipboard\" deep dive}.\n * @param {module:clipboard/datatransfer~DataTransfer} data.dataTransfer Data transfer instance.\n */\n\n/**\n * Fired on {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut}\n * with a copy of selected content. The content can be processed before it ends up in the clipboard.\n *\n * It is a part of the {@glink framework/guides/deep-dive/clipboard#output-pipeline \"clipboard output pipeline\"}.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @see module:clipboard/clipboard~Clipboard\n * @event module:engine/view/document~Document#event:clipboardOutput\n * @param {module:clipboard/clipboard~ClipboardOutputEventData} data Event data.\n */\n\n/**\n * The value of the {@link module:engine/view/document~Document#event:clipboardOutput} event.\n *\n * @class module:clipboard/clipboard~ClipboardOutputEventData\n */\n\n/**\n * Data transfer instance.\n *\n * @readonly\n * @member {module:clipboard/datatransfer~DataTransfer} module:clipboard/clipboard~ClipboardOutputEventData#dataTransfer\n */\n\n/**\n * Content to be put into the clipboard. It can be modified by the event listeners.\n * Read more about the clipboard pipelines in {@glink framework/guides/deep-dive/clipboard \"Clipboard\" deep dive}.\n *\n * @member {module:engine/view/documentfragment~DocumentFragment} module:clipboard/clipboard~ClipboardOutputEventData#content\n */\n\n/**\n * Whether the event was triggered by copy or cut operation.\n *\n * @member {'copy'|'cut'} module:clipboard/clipboard~ClipboardOutputEventData#method\n */\n\n\nexport { Clipboard as default };","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/command\n */\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * The base class for CKEditor commands.\n *\n * Commands are the main way to manipulate editor contents and state. They are mostly used by UI elements (or by other\n * commands) to make changes in the model. Commands are available in every part of code that has access to\n * the {@link module:core/editor/editor~Editor editor} instance.\n *\n * Instances of registered commands can be retrieved from {@link module:core/editor/editor~Editor#commands `editor.commands`}.\n * The easiest way to execute a command is through {@link module:core/editor/editor~Editor#execute `editor.execute()`}.\n *\n * By default commands are disabled when the editor is in {@link module:core/editor/editor~Editor#isReadOnly read-only} mode.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Command =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new `Command` instance.\n   *\n   * @param {module:core/editor/editor~Editor} editor Editor on which this command will be used.\n   */\n  function Command(editor) {\n    var _this = this;\n\n    _classCallCheck(this, Command);\n\n    /**\n     * The editor on which this command will be used.\n     *\n     * @readonly\n     * @member {module:core/editor/editor~Editor}\n     */\n    this.editor = editor;\n    /**\n     * The value of the command. A concrete command class should define what it represents for it.\n     *\n     * For example, the `'bold'` command's value indicates whether the selection starts in a bolded text.\n     * And the value of the `'link'` command may be an object with links details.\n     *\n     * It is possible for a command to have no value (e.g. for stateless actions such as `'imageUpload'`).\n     *\n     * A concrete command class should control this value by overriding the {@link #refresh `refresh()`} method.\n     *\n     * @observable\n     * @readonly\n     * @member #value\n     */\n\n    this.set('value', undefined);\n    /**\n     * Flag indicating whether a command is enabled or disabled.\n     * A disabled command will do nothing when executed.\n     *\n     * A concrete command class should control this value by overriding the {@link #refresh `refresh()`} method.\n     *\n     * It is possible to disable a command from \"outside\". For instance, in your integration you may want to disable\n     * a certain set of commands for the time being. To do that, you can use the fact that `isEnabled` is observable\n     * and it fires the `set:isEnabled` event every time anyone tries to modify its value:\n     *\n     *\t\tfunction disableCommand( cmd ) {\n     *\t\t\tcmd.on( 'set:isEnabled', forceDisable, { priority: 'highest' } );\n     *\n     *\t\t\tcmd.isEnabled = false;\n     *\n     *\t\t\t// Make it possible to enable the command again.\n     *\t\t\treturn () => {\n     *\t\t\t\tcmd.off( 'set:isEnabled', forceDisable );\n     *\t\t\t\tcmd.refresh();\n     *\t\t\t};\n     *\n     *\t\t\tfunction forceDisable( evt ) {\n     *\t\t\t\tevt.return = false;\n     *\t\t\t\tevt.stop();\n     *\t\t\t}\n     *\t\t}\n     *\n     *\t\t// Usage:\n     *\n     *\t\t// Disabling the command.\n     *\t\tconst enableBold = disableCommand( editor.commands.get( 'bold' ) );\n     *\n     *\t\t// Enabling the command again.\n     *\t\tenableBold();\n     *\n     * @observable\n     * @readonly\n     * @member {Boolean} #isEnabled\n     */\n\n    this.set('isEnabled', false);\n    /**\n     * Holds identifiers for {@link #forceDisabled} mechanism.\n     *\n     * @type {Set.<String>}\n     * @private\n     */\n\n    this._disableStack = new Set();\n    this.decorate('execute'); // By default every command is refreshed when changes are applied to the model.\n\n    this.listenTo(this.editor.model.document, 'change', function () {\n      _this.refresh();\n    });\n    this.on('execute', function (evt) {\n      if (!_this.isEnabled) {\n        evt.stop();\n      }\n    }, {\n      priority: 'high'\n    }); // By default commands are disabled when the editor is in read-only mode.\n\n    this.listenTo(editor, 'change:isReadOnly', function (evt, name, value) {\n      if (value) {\n        _this.forceDisabled('readOnlyMode');\n      } else {\n        _this.clearForceDisabled('readOnlyMode');\n      }\n    });\n  }\n  /**\n   * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties\n   * in this method.\n   *\n   * This method is automatically called when\n   * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.\n   */\n\n\n  _createClass(Command, [{\n    key: \"refresh\",\n    value: function refresh() {\n      this.isEnabled = true;\n    }\n    /**\n     * Disables the command.\n     *\n     * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed\n     * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.\n     * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.\n     *\n     * Disabling and enabling a command:\n     *\n     *\t\tcommand.isEnabled; // -> true\n     *\t\tcommand.forceDisabled( 'MyFeature' );\n     *\t\tcommand.isEnabled; // -> false\n     *\t\tcommand.clearForceDisabled( 'MyFeature' );\n     *\t\tcommand.isEnabled; // -> true\n     *\n     * Command disabled by multiple features:\n     *\n     *\t\tcommand.forceDisabled( 'MyFeature' );\n     *\t\tcommand.forceDisabled( 'OtherFeature' );\n     *\t\tcommand.clearForceDisabled( 'MyFeature' );\n     *\t\tcommand.isEnabled; // -> false\n     *\t\tcommand.clearForceDisabled( 'OtherFeature' );\n     *\t\tcommand.isEnabled; // -> true\n     *\n     * Multiple disabling with the same identifier is redundant:\n     *\n     *\t\tcommand.forceDisabled( 'MyFeature' );\n     *\t\tcommand.forceDisabled( 'MyFeature' );\n     *\t\tcommand.clearForceDisabled( 'MyFeature' );\n     *\t\tcommand.isEnabled; // -> true\n     *\n     * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,\n     * so the command might be still disabled after {@link #clearForceDisabled} was used.\n     *\n     * @param {String} id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.\n     */\n\n  }, {\n    key: \"forceDisabled\",\n    value: function forceDisabled(id) {\n      this._disableStack.add(id);\n\n      if (this._disableStack.size == 1) {\n        this.on('set:isEnabled', forceDisable, {\n          priority: 'highest'\n        });\n        this.isEnabled = false;\n      }\n    }\n    /**\n     * Clears forced disable previously set through {@link #clearForceDisabled}. See {@link #clearForceDisabled}.\n     *\n     * @param {String} id Unique identifier, equal to the one passed in {@link #forceDisabled} call.\n     */\n\n  }, {\n    key: \"clearForceDisabled\",\n    value: function clearForceDisabled(id) {\n      this._disableStack.delete(id);\n\n      if (this._disableStack.size == 0) {\n        this.off('set:isEnabled', forceDisable);\n        this.refresh();\n      }\n    }\n    /**\n     * Executes the command.\n     *\n     * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}\n     * to the command.\n     *\n     * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).\n     * This behavior is implemented by a high priority listener to the {@link #event:execute} event.\n     *\n     * In order to see how to disable a command from \"outside\" see the {@link #isEnabled} documentation.\n     *\n     * @fires execute\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {}\n    /**\n     * Destroys the command.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stopListening();\n    }\n    /**\n     * Event fired by the {@link #execute} method. The command action is a listener to this event so it's\n     * possible to change/cancel the behavior of the command by listening to this event.\n     *\n     * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n     *\n     * **Note:** This event is fired even if command is disabled. However, it is automatically blocked\n     * by a high priority listener in order to prevent command execution.\n     *\n     * @event execute\n     */\n\n  }]);\n\n  return Command;\n}();\n\nexport { Command as default };\nmix(Command, ObservableMixin); // Helper function that forces command to be disabled.\n\nfunction forceDisable(evt) {\n  evt.return = false;\n  evt.stop();\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module enter/enterobserver\n */\nimport Observer from '@ckeditor/ckeditor5-engine/src/view/observer/observer';\nimport DomEventData from '@ckeditor/ckeditor5-engine/src/view/observer/domeventdata';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n/**\n * Enter observer introduces the {@link module:engine/view/document~Document#event:enter} event.\n *\n * @extends module:engine/view/observer~Observer\n */\n\nvar EnterObserver =\n/*#__PURE__*/\nfunction (_Observer) {\n  _inherits(EnterObserver, _Observer);\n\n  function EnterObserver(view) {\n    var _this;\n\n    _classCallCheck(this, EnterObserver);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EnterObserver).call(this, view));\n    var doc = _this.document;\n    doc.on('keydown', function (evt, data) {\n      if (_this.isEnabled && data.keyCode == keyCodes.enter) {\n        // Save the event object to check later if it was stopped or not.\n        var event;\n        doc.once('enter', function (evt) {\n          return event = evt;\n        }, {\n          priority: 'highest'\n        });\n        doc.fire('enter', new DomEventData(doc, data.domEvent, {\n          isSoft: data.shiftKey\n        })); // Stop `keydown` event if `enter` event was stopped.\n        // https://github.com/ckeditor/ckeditor5/issues/753\n\n        if (event && event.stop.called) {\n          evt.stop();\n        }\n      }\n    });\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(EnterObserver, [{\n    key: \"observe\",\n    value: function observe() {}\n  }]);\n\n  return EnterObserver;\n}(Observer);\n/**\n * Event fired when the user presses the <kbd>Enter</kbd> key.\n *\n * Note: This event is fired by the {@link module:enter/enterobserver~EnterObserver observer}\n * (usually registered by the {@link module:enter/enter~Enter Enter feature} and\n * {@link module:enter/shiftenter~ShiftEnter ShiftEnter feature}).\n *\n * @event module:engine/view/document~Document#event:enter\n * @param {module:engine/view/observer/domeventdata~DomEventData} data\n * @param {Boolean} data.isSoft Whether it's a soft enter (<kbd>Shift</kbd>+<kbd>Enter</kbd>) or hard enter (<kbd>Enter</kbd>).\n */\n\n\nexport { EnterObserver as default };","import \"core-js/modules/es6.string.anchor\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module enter/shiftentercommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\n/**\n * ShiftEnter command. It is used by the {@link module:enter/shiftenter~ShiftEnter ShiftEnter feature} to handle\n * the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke.\n *\n * @extends module:core/command~Command\n */\n\nvar ShiftEnterCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(ShiftEnterCommand, _Command);\n\n  function ShiftEnterCommand() {\n    _classCallCheck(this, ShiftEnterCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ShiftEnterCommand).apply(this, arguments));\n  }\n\n  _createClass(ShiftEnterCommand, [{\n    key: \"execute\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function execute() {\n      var _this = this;\n\n      var model = this.editor.model;\n      var doc = model.document;\n      model.change(function (writer) {\n        softBreakAction(model, writer, doc.selection);\n\n        _this.fire('afterExecute', {\n          writer: writer\n        });\n      });\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var model = this.editor.model;\n      var doc = model.document;\n      this.isEnabled = isEnabled(model.schema, doc.selection);\n    }\n  }]);\n\n  return ShiftEnterCommand;\n}(Command); // Checks whether the ShiftEnter command should be enabled in the specified selection.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\n\nexport { ShiftEnterCommand as default };\n\nfunction isEnabled(schema, selection) {\n  // At this moment it is okay to support single range selections only.\n  // But in the future we may need to change that.\n  if (selection.rangeCount > 1) {\n    return false;\n  }\n\n  var anchorPos = selection.anchor; // Check whether the break element can be inserted in the current selection anchor.\n\n  if (!anchorPos || !schema.checkChild(anchorPos, 'softBreak')) {\n    return false;\n  }\n\n  var range = selection.getFirstRange();\n  var startElement = range.start.parent;\n  var endElement = range.end.parent; // Do not modify the content if selection is cross-limit elements.\n\n  if ((isInsideLimitElement(startElement, schema) || isInsideLimitElement(endElement, schema)) && startElement !== endElement) {\n    return false;\n  }\n\n  return true;\n} // Creates a break in the way that the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke is expected to work.\n//\n// @param {module:engine/model~Model} model\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n// Selection on which the action should be performed.\n\n\nfunction softBreakAction(model, writer, selection) {\n  var isSelectionEmpty = selection.isCollapsed;\n  var range = selection.getFirstRange();\n  var startElement = range.start.parent;\n  var endElement = range.end.parent;\n  var isContainedWithinOneElement = startElement == endElement;\n\n  if (isSelectionEmpty) {\n    insertBreak(writer, range.end);\n  } else {\n    var leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);\n    model.deleteContent(selection, {\n      leaveUnmerged: leaveUnmerged\n    }); // Selection within one element:\n    //\n    // <h>x[xx]x</h>\t\t-> <h>x^x</h>\t\t\t-> <h>x<br>^x</h>\n\n    if (isContainedWithinOneElement) {\n      insertBreak(writer, selection.focus);\n    } // Selection over multiple elements.\n    //\n    // <h>x[x</h><p>y]y<p>\t-> <h>x^</h><p>y</p>\t-> <h>x</h><p>^y</p>\n    //\n    // We chose not to insert a line break in this case because:\n    //\n    // * it's not a very common scenario,\n    // * it actually surprised me when I saw the \"expected behavior\" in real life.\n    //\n    // It's ok if the user will need to be more specific where they want the <br> to be inserted.\n    else {\n        // Move the selection to the 2nd element (last step of the example above).\n        if (leaveUnmerged) {\n          writer.setSelection(endElement, 0);\n        }\n      }\n  }\n}\n\nfunction insertBreak(writer, position) {\n  var breakLineElement = writer.createElement('softBreak');\n  writer.insert(breakLineElement, position);\n  writer.setSelection(breakLineElement, 'after');\n} // Checks whether the specified `element` is a child of the limit element.\n//\n// Checking whether the `<p>` element is inside a limit element:\n//   - <$root><p>Text.</p></$root> => false\n//   - <$root><limitElement><p>Text</p></limitElement></$root> => true\n//\n// @param {module:engine/model/element~Element} element\n// @param {module:engine/schema~Schema} schema\n// @returns {Boolean}\n\n\nfunction isInsideLimitElement(element, schema) {\n  // `$root` is a limit element but in this case is an invalid element.\n  if (element.is('rootElement')) {\n    return false;\n  }\n\n  return schema.isLimit(element) || isInsideLimitElement(element.parent, schema);\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module enter/shiftenter\n */\nimport ShiftEnterCommand from \"./shiftentercommand\";\nimport EnterObserver from \"./enterobserver\";\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n/**\n * This plugin handles the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke (soft line break) in the editor.\n *\n * See also the {@link module:enter/enter~Enter} plugin.\n *\n * For more information about this feature see the {@glink api/enter package page}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ShiftEnter =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ShiftEnter, _Plugin);\n\n  function ShiftEnter() {\n    _classCallCheck(this, ShiftEnter);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ShiftEnter).apply(this, arguments));\n  }\n\n  _createClass(ShiftEnter, [{\n    key: \"init\",\n    value: function init() {\n      var editor = this.editor;\n      var schema = editor.model.schema;\n      var conversion = editor.conversion;\n      var view = editor.editing.view;\n      var viewDocument = view.document; // Configure the schema.\n\n      schema.register('softBreak', {\n        allowWhere: '$text',\n        isInline: true\n      }); // Configure converters.\n\n      conversion.for('upcast').elementToElement({\n        model: 'softBreak',\n        view: 'br'\n      });\n      conversion.for('downcast').elementToElement({\n        model: 'softBreak',\n        view: function view(modelElement, viewWriter) {\n          return viewWriter.createEmptyElement('br');\n        }\n      });\n      view.addObserver(EnterObserver);\n      editor.commands.add('shiftEnter', new ShiftEnterCommand(editor));\n      this.listenTo(viewDocument, 'enter', function (evt, data) {\n        data.preventDefault(); // The hard enter key is handled by the Enter plugin.\n\n        if (!data.isSoft) {\n          return;\n        }\n\n        editor.execute('shiftEnter');\n        view.scrollToTheSelection();\n      }, {\n        priority: 'low'\n      });\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'ShiftEnter';\n    }\n  }]);\n\n  return ShiftEnter;\n}(Plugin);\n\nexport { ShiftEnter as default };","import \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/injectunsafekeystrokeshandling\n */\nimport { getCode } from '@ckeditor/ckeditor5-utils/src/keyboard';\n/**\n * Handles keystrokes which are unsafe for typing. This handler's logic is explained\n * in https://github.com/ckeditor/ckeditor5-typing/issues/83#issuecomment-398690251.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\n\nexport default function injectUnsafeKeystrokesHandling(editor) {\n  var latestCompositionSelection = null;\n  var model = editor.model;\n  var view = editor.editing.view;\n  var inputCommand = editor.commands.get('input');\n  view.document.on('keydown', function (evt, evtData) {\n    return handleKeydown(evtData);\n  }, {\n    priority: 'lowest'\n  });\n  view.document.on('compositionstart', handleCompositionStart, {\n    priority: 'lowest'\n  });\n  view.document.on('compositionend', function () {\n    latestCompositionSelection = model.createSelection(model.document.selection);\n  }, {\n    priority: 'lowest'\n  }); // Handles the keydown event. We need to guess whether such keystroke is going to result\n  // in typing. If so, then before character insertion happens, any selected content needs\n  // to be deleted. Otherwise the default browser deletion mechanism would be\n  // triggered, resulting in:\n  //\n  // * Hundreds of mutations which could not be handled.\n  // * But most importantly, loss of control over how the content is being deleted.\n  //\n  // The method is used in a low-priority listener, hence allowing other listeners (e.g. delete or enter features)\n  // to handle the event.\n  //\n  // @param {module:engine/view/observer/keyobserver~KeyEventData} evtData\n\n  function handleKeydown(evtData) {\n    var doc = model.document;\n    var isComposing = view.document.isComposing;\n    var isSelectionUnchanged = latestCompositionSelection && latestCompositionSelection.isEqual(doc.selection); // Reset stored composition selection.\n\n    latestCompositionSelection = null; // By relying on the state of the input command we allow disabling the entire input easily\n    // by just disabling the input command. We couldve used here the delete command but that\n    // would mean requiring the delete feature which would block loading one without the other.\n    // We could also check the editor.isReadOnly property, but that wouldn't allow to block\n    // the input without blocking other features.\n\n    if (!inputCommand.isEnabled) {\n      return;\n    }\n\n    if (isSafeKeystroke(evtData) || doc.selection.isCollapsed) {\n      return;\n    } // If during composition, deletion should be prevented as it may remove composed sequence (#83).\n\n\n    if (isComposing && evtData.keyCode === 229) {\n      return;\n    } // If there is a `keydown` event fired with '229' keycode it might be related\n    // to recent composition. Check if selection is the same as upon ending recent composition,\n    // if so do not remove selected content as it will remove composed sequence (#83).\n\n\n    if (!isComposing && evtData.keyCode === 229 && isSelectionUnchanged) {\n      return;\n    }\n\n    deleteSelectionContent();\n  } // Handles the `compositionstart` event. It is used only in special cases to remove the contents\n  // of a non-collapsed selection so composition itself does not result in complex mutations.\n  //\n  // The special case mentioned above is a situation in which the `keydown` event is fired after\n  // `compositionstart` event. In such cases {@link #handleKeydown} cannot clear current selection\n  // contents (because it is too late and will break the composition) so the composition handler takes care of it.\n\n\n  function handleCompositionStart() {\n    var doc = model.document;\n    var isFlatSelection = doc.selection.rangeCount === 1 ? doc.selection.getFirstRange().isFlat : true; // If on `compositionstart` there is a non-collapsed selection which start and end have different parents\n    // it means the `handleKeydown()` method did not remove its contents. It happens usually because\n    // of different order of events (`compositionstart` before `keydown` - in Safari). In such cases\n    // we need to remove selection contents on composition start (#83).\n\n    if (doc.selection.isCollapsed || isFlatSelection) {\n      return;\n    }\n\n    deleteSelectionContent();\n  }\n\n  function deleteSelectionContent() {\n    var buffer = inputCommand.buffer;\n    buffer.lock();\n    model.enqueueChange(buffer.batch, function () {\n      model.deleteContent(model.document.selection);\n    });\n    buffer.unlock();\n  }\n}\nvar safeKeycodes = [getCode('arrowUp'), getCode('arrowRight'), getCode('arrowDown'), getCode('arrowLeft'), 9, // Tab\n16, // Shift\n17, // Ctrl\n18, // Alt\n19, // Pause\n20, // CapsLock\n27, // Escape\n33, // PageUp\n34, // PageDown\n35, // Home\n36, // End,\n45, // Insert,\n91, // Windows,\n93, // Menu key,\n144, // NumLock\n145, // ScrollLock,\n173, // Mute/Unmute\n174, // Volume up\n175, // Volume down,\n176, // Next song,\n177, // Previous song,\n178, // Stop,\n179, // Play/Pause,\n255 // Display brightness (increase and decrease)\n]; // Function keys.\n\nfor (var code = 112; code <= 135; code++) {\n  safeKeycodes.push(code);\n} // Returns `true` if a keystroke should not cause any content change caused by \"typing\".\n//\n// Note: This implementation is very simple and will need to be refined with time.\n//\n// @private\n// @param {engine.view.observer.keyObserver.KeyEventData} keyData\n// @returns {Boolean}\n\n\nfunction isSafeKeystroke(keyData) {\n  // Keystrokes which contain Ctrl don't represent typing.\n  if (keyData.ctrlKey) {\n    return true;\n  }\n\n  return safeKeycodes.includes(keyData.keyCode);\n}","import \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/difftochanges\n */\n\n/**\n * Creates a set of changes which need to be applied to the input in order to transform\n * it into the output. This function can be used with strings or arrays.\n *\n *\t\tconst input = Array.from( 'abc' );\n *\t\tconst output = Array.from( 'xaby' );\n *\t\tconst changes = diffToChanges( diff( input, output ), output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput.splice( change.index, 0, ...change.values );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput.splice( change.index, change.howMany );\n *\t\t\t}\n *\t\t} );\n *\n *\t\tinput.join( '' ) == output.join( '' ); // -> true\n *\n * @param {Array.<'equal'|'insert'|'delete'>} diff Result of {@link module:utils/diff~diff}.\n * @param {String|Array} output The string or array which was passed as diff's output.\n * @returns {Array.<Object>} Set of changes (insert or delete) which need to be applied to the input\n * in order to transform it into the output.\n */\nexport default function diffToChanges(diff, output) {\n  var changes = [];\n  var index = 0;\n  var lastOperation;\n  diff.forEach(function (change) {\n    if (change == 'equal') {\n      pushLast();\n      index++;\n    } else if (change == 'insert') {\n      if (isContinuationOf('insert')) {\n        lastOperation.values.push(output[index]);\n      } else {\n        pushLast();\n        lastOperation = {\n          type: 'insert',\n          index: index,\n          values: [output[index]]\n        };\n      }\n\n      index++;\n    } else\n      /* if ( change == 'delete' ) */\n      {\n        if (isContinuationOf('delete')) {\n          lastOperation.howMany++;\n        } else {\n          pushLast();\n          lastOperation = {\n            type: 'delete',\n            index: index,\n            howMany: 1\n          };\n        }\n      }\n  });\n  pushLast();\n  return changes;\n\n  function pushLast() {\n    if (lastOperation) {\n      changes.push(lastOperation);\n      lastOperation = null;\n    }\n  }\n\n  function isContinuationOf(expected) {\n    return lastOperation && lastOperation.type == expected;\n  }\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/utils\n */\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport diffToChanges from '@ckeditor/ckeditor5-utils/src/difftochanges';\n/**\n * Returns true if container children have mutated or more than a single text node was changed.\n *\n * @private\n * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n * @returns {Boolean}\n */\n\nexport function containerChildrenMutated(mutations) {\n  if (mutations.length == 0) {\n    return false;\n  } // Check if there is any mutation of `children` type or any mutation that changes more than one text node.\n\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = mutations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var mutation = _step.value;\n\n      if (mutation.type === 'children' && !getSingleTextNodeChange(mutation)) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Returns change made to a single text node.\n *\n * @private\n * @param {module:engine/view/observer/mutationobserver~MutatedText|\n * module:engine/view/observer/mutationobserver~MutatedChildren} mutation\n * @returns {Object|undefined} Change object (see {@link module:utils/difftochanges~diffToChanges} output)\n * or undefined if more than a single text node was changed.\n */\n\nexport function getSingleTextNodeChange(mutation) {\n  // One new node.\n  if (mutation.newChildren.length - mutation.oldChildren.length != 1) {\n    return;\n  } // Which is text.\n\n\n  var diffResult = diff(mutation.oldChildren, mutation.newChildren, compareChildNodes);\n  var changes = diffToChanges(diffResult, mutation.newChildren); // In case of [ delete, insert, insert ] the previous check will not exit.\n\n  if (changes.length > 1) {\n    return;\n  }\n\n  var change = changes[0]; // Which is text.\n\n  if (!(!!change.values[0] && change.values[0].is('text'))) {\n    return;\n  }\n\n  return change;\n}\n/**\n * Checks whether two view nodes are identical, which means they are the same object\n * or contain exactly same data (in case of text nodes).\n *\n * @private\n * @param {module:engine/view/node~Node} oldChild\n * @param {module:engine/view/node~Node} newChild\n * @returns {Boolean}\n */\n\nexport function compareChildNodes(oldChild, newChild) {\n  if (!!oldChild && oldChild.is('text') && !!newChild && newChild.is('text')) {\n    return oldChild.data === newChild.data;\n  } else {\n    return oldChild === newChild;\n  }\n}","import \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/injecttypingmutationshandling\n */\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport DomConverter from '@ckeditor/ckeditor5-engine/src/view/domconverter';\nimport { getSingleTextNodeChange, containerChildrenMutated } from \"./utils\";\n/**\n * Handles mutations caused by normal typing.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\n\nexport default function injectTypingMutationsHandling(editor) {\n  editor.editing.view.document.on('mutations', function (evt, mutations, viewSelection) {\n    new MutationHandler(editor).handle(mutations, viewSelection);\n  });\n}\n/**\n * Helper class for translating DOM mutations into model changes.\n *\n * @private\n */\n\nvar MutationHandler =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the mutation handler.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   */\n  function MutationHandler(editor) {\n    _classCallCheck(this, MutationHandler);\n\n    /**\n     * Editor instance for which mutations are handled.\n     *\n     * @readonly\n     * @member {module:core/editor/editor~Editor} #editor\n     */\n    this.editor = editor;\n    /**\n     * The editing controller.\n     *\n     * @readonly\n     * @member {module:engine/controller/editingcontroller~EditingController} #editing\n     */\n\n    this.editing = this.editor.editing;\n  }\n  /**\n   * Handles given mutations.\n   *\n   * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n   * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n   * @param {module:engine/view/selection~Selection|null} viewSelection\n   */\n\n\n  _createClass(MutationHandler, [{\n    key: \"handle\",\n    value: function handle(mutations, viewSelection) {\n      if (containerChildrenMutated(mutations)) {\n        this._handleContainerChildrenMutations(mutations, viewSelection);\n      } else {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = mutations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var mutation = _step.value;\n\n            // Fortunately it will never be both.\n            this._handleTextMutation(mutation, viewSelection);\n\n            this._handleTextNodeInsertion(mutation);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Handles situations when container's children mutated during input. This can happen when\n     * the browser is trying to \"fix\" DOM in certain situations. For example, when the user starts to type\n     * in `<p><a href=\"\"><i>Link{}</i></a></p>`, the browser might change the order of elements\n     * to `<p><i><a href=\"\">Link</a>x{}</i></p>`. A similar situation happens when the spell checker\n     * replaces a word wrapped with `<strong>` with a word wrapped with a `<b>` element.\n     *\n     * To handle such situations, the common DOM ancestor of all mutations is converted to the model representation\n     * and then compared with the current model to calculate the proper text change.\n     *\n     * Note: Single text node insertion is handled in {@link #_handleTextNodeInsertion} and text node mutation is handled\n     * in {@link #_handleTextMutation}).\n     *\n     * @private\n     * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n     * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n     * @param {module:engine/view/selection~Selection|null} viewSelection\n     */\n\n  }, {\n    key: \"_handleContainerChildrenMutations\",\n    value: function _handleContainerChildrenMutations(mutations, viewSelection) {\n      // Get common ancestor of all mutations.\n      var mutationsCommonAncestor = getMutationsContainer(mutations); // Quit if there is no common ancestor.\n\n      if (!mutationsCommonAncestor) {\n        return;\n      }\n\n      var domConverter = this.editor.editing.view.domConverter; // Get common ancestor in DOM.\n\n      var domMutationCommonAncestor = domConverter.mapViewToDom(mutationsCommonAncestor); // Create fresh DomConverter so it will not use existing mapping and convert current DOM to model.\n      // This wouldn't be needed if DomConverter would allow to create fresh view without checking any mappings.\n\n      var freshDomConverter = new DomConverter();\n      var modelFromCurrentDom = this.editor.data.toModel(freshDomConverter.domToView(domMutationCommonAncestor)).getChild(0); // Current model.\n\n      var currentModel = this.editor.editing.mapper.toModelElement(mutationsCommonAncestor); // If common ancestor is not mapped, do not do anything. It probably is a parent of another view element.\n      // That means that we would need to diff model elements (see `if` below). Better return early instead of\n      // trying to get a reasonable model ancestor. It will fell into the `if` below anyway.\n      // This situation happens for example for lists. If `<ul>` is a common ancestor, `currentModel` is `undefined`\n      // because `<ul>` is not mapped (`<li>`s are).\n      // See https://github.com/ckeditor/ckeditor5/issues/718.\n\n      if (!currentModel) {\n        return;\n      } // Get children from both ancestors.\n\n\n      var modelFromDomChildren = Array.from(modelFromCurrentDom.getChildren());\n      var currentModelChildren = Array.from(currentModel.getChildren()); // Remove the last `<softBreak>` from the end of `modelFromDomChildren` if there is no `<softBreak>` in current model.\n      // If the described scenario happened, it means that this is a bogus `<br />` added by a browser.\n\n      var lastDomChild = modelFromDomChildren[modelFromDomChildren.length - 1];\n      var lastCurrentChild = currentModelChildren[currentModelChildren.length - 1];\n\n      if (lastDomChild && lastDomChild.is('softBreak') && lastCurrentChild && !lastCurrentChild.is('softBreak')) {\n        modelFromDomChildren.pop();\n      }\n\n      var schema = this.editor.model.schema; // Skip situations when common ancestor has any container elements.\n\n      if (!isSafeForTextMutation(modelFromDomChildren, schema) || !isSafeForTextMutation(currentModelChildren, schema)) {\n        return;\n      } // Replace &nbsp; inserted by the browser with normal space. See comment in `_handleTextMutation`.\n      // Replace non-texts with any character. This is potentially dangerous but passes in manual tests. The thing is\n      // that we need to take care of proper indexes so we cannot simply remove non-text elements from the content.\n      // By inserting a character we keep all the real texts on their indexes.\n\n\n      var newText = modelFromDomChildren.map(function (item) {\n        return item.is('text') ? item.data : '@';\n      }).join('').replace(/\\u00A0/g, ' ');\n      var oldText = currentModelChildren.map(function (item) {\n        return item.is('text') ? item.data : '@';\n      }).join('').replace(/\\u00A0/g, ' '); // Do nothing if mutations created same text.\n\n      if (oldText === newText) {\n        return;\n      }\n\n      var diffResult = diff(oldText, newText);\n\n      var _calculateChanges = calculateChanges(diffResult),\n          firstChangeAt = _calculateChanges.firstChangeAt,\n          insertions = _calculateChanges.insertions,\n          deletions = _calculateChanges.deletions; // Try setting new model selection according to passed view selection.\n\n\n      var modelSelectionRange = null;\n\n      if (viewSelection) {\n        modelSelectionRange = this.editing.mapper.toModelRange(viewSelection.getFirstRange());\n      }\n\n      var insertText = newText.substr(firstChangeAt, insertions);\n      var removeRange = this.editor.model.createRange(this.editor.model.createPositionAt(currentModel, firstChangeAt), this.editor.model.createPositionAt(currentModel, firstChangeAt + deletions));\n      this.editor.execute('input', {\n        text: insertText,\n        range: removeRange,\n        resultRange: modelSelectionRange\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_handleTextMutation\",\n    value: function _handleTextMutation(mutation, viewSelection) {\n      if (mutation.type != 'text') {\n        return;\n      } // Replace &nbsp; inserted by the browser with normal space.\n      // We want only normal spaces in the model and in the view. Renderer and DOM Converter will be then responsible\n      // for rendering consecutive spaces using &nbsp;, but the model and the view has to be clear.\n      // Other feature may introduce inserting non-breakable space on specific key stroke (for example shift + space).\n      // However then it will be handled outside of mutations, like enter key is.\n      // The replacing is here because it has to be done before `diff` and `diffToChanges` functions, as they\n      // take `newText` and compare it to (cleaned up) view.\n      // It could also be done in mutation observer too, however if any outside plugin would like to\n      // introduce additional events for mutations, they would get already cleaned up version (this may be good or not).\n\n\n      var newText = mutation.newText.replace(/\\u00A0/g, ' '); // To have correct `diffResult`, we also compare view node text data with &nbsp; replaced by space.\n\n      var oldText = mutation.oldText.replace(/\\u00A0/g, ' '); // Do nothing if mutations created same text.\n\n      if (oldText === newText) {\n        return;\n      }\n\n      var diffResult = diff(oldText, newText);\n\n      var _calculateChanges2 = calculateChanges(diffResult),\n          firstChangeAt = _calculateChanges2.firstChangeAt,\n          insertions = _calculateChanges2.insertions,\n          deletions = _calculateChanges2.deletions; // Try setting new model selection according to passed view selection.\n\n\n      var modelSelectionRange = null;\n\n      if (viewSelection) {\n        modelSelectionRange = this.editing.mapper.toModelRange(viewSelection.getFirstRange());\n      } // Get the position in view and model where the changes will happen.\n\n\n      var viewPos = this.editing.view.createPositionAt(mutation.node, firstChangeAt);\n      var modelPos = this.editing.mapper.toModelPosition(viewPos);\n      var removeRange = this.editor.model.createRange(modelPos, modelPos.getShiftedBy(deletions));\n      var insertText = newText.substr(firstChangeAt, insertions);\n      this.editor.execute('input', {\n        text: insertText,\n        range: removeRange,\n        resultRange: modelSelectionRange\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_handleTextNodeInsertion\",\n    value: function _handleTextNodeInsertion(mutation) {\n      if (mutation.type != 'children') {\n        return;\n      }\n\n      var change = getSingleTextNodeChange(mutation);\n      var viewPos = this.editing.view.createPositionAt(mutation.node, change.index);\n      var modelPos = this.editing.mapper.toModelPosition(viewPos);\n      var insertedText = change.values[0].data;\n      this.editor.execute('input', {\n        // Replace &nbsp; inserted by the browser with normal space.\n        // See comment in `_handleTextMutation`.\n        // In this case we don't need to do this before `diff` because we diff whole nodes.\n        // Just change &nbsp; in case there are some.\n        text: insertedText.replace(/\\u00A0/g, ' '),\n        range: this.editor.model.createRange(modelPos)\n      });\n    }\n  }]);\n\n  return MutationHandler;\n}(); // Returns first common ancestor of all mutations that is either {@link module:engine/view/containerelement~ContainerElement}\n// or {@link module:engine/view/rootelement~RootElement}.\n//\n// @private\n// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n// @returns {module:engine/view/containerelement~ContainerElement|engine/view/rootelement~RootElement|undefined}\n\n\nfunction getMutationsContainer(mutations) {\n  var lca = mutations.map(function (mutation) {\n    return mutation.node;\n  }).reduce(function (commonAncestor, node) {\n    return commonAncestor.getCommonAncestor(node, {\n      includeSelf: true\n    });\n  });\n\n  if (!lca) {\n    return;\n  } // We need to look for container and root elements only, so check all LCA's\n  // ancestors (starting from itself).\n\n\n  return lca.getAncestors({\n    includeSelf: true,\n    parentFirst: true\n  }).find(function (element) {\n    return element.is('containerElement') || element.is('rootElement');\n  });\n} // Returns true if provided array contains content that won't be problematic during diffing and text mutation handling.\n//\n// @param {Array.<module:engine/model/node~Node>} children\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\n\n\nfunction isSafeForTextMutation(children, schema) {\n  return children.every(function (child) {\n    return schema.isInline(child);\n  });\n} // Calculates first change index and number of characters that should be inserted and deleted starting from that index.\n//\n// @private\n// @param diffResult\n// @returns {{insertions: number, deletions: number, firstChangeAt: *}}\n\n\nfunction calculateChanges(diffResult) {\n  // Index where the first change happens. Used to set the position from which nodes will be removed and where will be inserted.\n  var firstChangeAt = null; // Index where the last change happens. Used to properly count how many characters have to be removed and inserted.\n\n  var lastChangeAt = null; // Get `firstChangeAt` and `lastChangeAt`.\n\n  for (var i = 0; i < diffResult.length; i++) {\n    var change = diffResult[i];\n\n    if (change != 'equal') {\n      firstChangeAt = firstChangeAt === null ? i : firstChangeAt;\n      lastChangeAt = i;\n    }\n  } // How many characters, starting from `firstChangeAt`, should be removed.\n\n\n  var deletions = 0; // How many characters, starting from `firstChangeAt`, should be inserted.\n\n  var insertions = 0;\n\n  for (var _i = firstChangeAt; _i <= lastChangeAt; _i++) {\n    // If there is no change (equal) or delete, the character is existing in `oldText`. We count it for removing.\n    if (diffResult[_i] != 'insert') {\n      deletions++;\n    } // If there is no change (equal) or insert, the character is existing in `newText`. We count it for inserting.\n\n\n    if (diffResult[_i] != 'delete') {\n      insertions++;\n    }\n  }\n\n  return {\n    insertions: insertions,\n    deletions: deletions,\n    firstChangeAt: firstChangeAt\n  };\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/input\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport InputCommand from \"./inputcommand\";\nimport injectUnsafeKeystrokesHandling from \"./utils/injectunsafekeystrokeshandling\";\nimport injectTypingMutationsHandling from \"./utils/injecttypingmutationshandling\";\n/**\n * Handles text input coming from the keyboard or other input methods.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar Input =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Input, _Plugin);\n\n  function Input() {\n    _classCallCheck(this, Input);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Input).apply(this, arguments));\n  }\n\n  _createClass(Input, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var editor = this.editor; // TODO The above default configuration value should be defined using editor.config.define() once it's fixed.\n\n      var inputCommand = new InputCommand(editor, editor.config.get('typing.undoStep') || 20);\n      editor.commands.add('input', inputCommand);\n      injectUnsafeKeystrokesHandling(editor);\n      injectTypingMutationsHandling(editor);\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'Input';\n    }\n  }]);\n\n  return Input;\n}(Plugin);\n\nexport { Input as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/injectandroidbackspacenutationshandling\n */\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport { containerChildrenMutated } from \"./utils\";\n/**\n * Handles mutations triggered by <kbd>Backspace</kbd> on Android.\n * Due to the fact that on Android `keydown` events don't have the `keyCode` set, we are not able\n * to handle backspacing directly. We need to guess that from mutations which the IME\n * on Android caused.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\n\nexport default function injectAndroidBackspaceMutationsHandling(editor) {\n  var model = editor.model;\n  var view = editor.editing.view;\n  var selectionChangeToleranceMs = 200;\n  var previousSelection = null;\n  var currentSelection = model.createSelection(model.document.selection);\n  var latestSelectionChangeMs = Date.now();\n  model.document.selection.on('change', handleSelectionChange);\n  view.document.on('mutations', handleMutations, {\n    priority: 'highest'\n  }); // Saves current and previous selection when it changes. Saved selections are used\n  // to remove correct piece of content when `Backspace` mutations are detected.\n  //\n  // @param {Object} evt\n\n  function handleSelectionChange(evt) {\n    var newSelection = model.createSelection(evt.source);\n\n    if (!currentSelection.isEqual(newSelection)) {\n      previousSelection = currentSelection;\n      currentSelection = newSelection;\n      latestSelectionChangeMs = Date.now();\n    }\n  } // Handles DOM mutations and checks if they should be processed as block elements removal mutations.\n  //\n  // @param {Object} evt\n  // @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n  // module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n\n\n  function handleMutations(evt, mutations) {\n    if (containerChildrenMutated(mutations) && containsContainersRemoval(mutations)) {\n      handleContainerRemovalMutations(); // Stop mutations event propagation so other mutation handlers are not triggered.\n\n      evt.stop();\n    }\n  } // Handles situations when mutations were generated by container removal.\n  // It happens on Android devices where every typing input has `229` key code\n  // and delete observer will not be triggered. In such cases we need to handle\n  // container removal mutations manually.\n\n\n  function handleContainerRemovalMutations() {\n    if (shouldUsePreviousSelection()) {\n      // If previous selection is used, update model selection in order\n      // to use `delete` command and to make `undo` work correctly.\n      model.enqueueChange(function (writer) {\n        writer.setSelection(previousSelection);\n      });\n    }\n\n    editor.execute('delete');\n  } // Whether previously saved selection should be used instead of the current one to remove content.\n  //\n  // On Android devices when pressing backspace on non-collapsed selection, selection like:\n  //\n  //\t\t`<h1>[Foo</h1><p>Bar]</p>`\n  //\n  // is changed to:\n  //\n  //\t\t`<h1>Foo</h1><p>Bar[]</p>`\n  //\n  // even before `keypress` event, so in such cases we have to rely on previous selection to correctly process selected content.\n  //\n  // Previous selection will be used if:\n  //\n  //\t\t* current selection is collapsed (see example above),\n  //\t\t* previous selection exists, is non-collapsed and has same ending (last position) as the current one,\n  //\t\t* change of the selection happened not earlier than X milliseconds ago (see `selectionChangeToleranceMs`).\n  //\n  // The last check is needed, because user can manually collapse the selection on its current end and then press `Backspace`.\n  // In such situations timing determines if the selection change was caused by the user or browser native behaviour.\n  // However, this happens only if selection was collapsed by the user on the beginning of the paragraph (so mutations\n  // still will show container removal).\n  //\n  // @returns {Boolean}\n\n\n  function shouldUsePreviousSelection() {\n    return Date.now() - latestSelectionChangeMs < selectionChangeToleranceMs && previousSelection && !previousSelection.isCollapsed && currentSelection.isCollapsed && currentSelection.getLastPosition().isEqual(previousSelection.getLastPosition());\n  }\n} // Checks whether mutations array contains mutation generated by container/containers removal.\n// For example mutations generated on Android when pressing `backspace` on the beginning of the line:\n//\n//\t\t<h1>Header1</h1>\n//\t\t<p>{}Paragraph</p>\n//\n// are:\n//\n//\t\t[\n//\t\t\t{ newChildren: [], oldChildren: [ 'Paragraph' ], node: P, type: 'children' },\n//\t\t\t{ newChildren: [ ContainerElement ], oldChildren: [ ContainerElement, ContainerElement ], node: Root, type: 'children' },\n//\t\t\t{ newChildren: [ 'Heading 1Paragraph' ], oldChildren: [ 'Heading 1' ], node: H1, type: 'children' }\n//\t\t]\n//\n// The 1st and 3rd mutations are just changes in a text (1st - text in `p` element was removed, 3rd - text in `h2` was changed)\n// and the 2nd one shows that one `ContainerElement` was removed. We have to recognize if mutations like 2nd one are present.\n// Based on that heuristic mutations are treated as the one removing container element.\n//\n// @private\n// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n// @returns {Boolean}\n\nfunction containsContainersRemoval(mutations) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = mutations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var mutation = _step.value;\n\n      if (mutation.type !== 'children') {\n        continue;\n      }\n\n      var childrenBefore = mutation.oldChildren;\n      var childrenAfter = mutation.newChildren; // Check if only containers were present before the mutation.\n\n      if (!hasOnlyContainers(childrenBefore)) {\n        continue;\n      }\n\n      var diffResult = diff(childrenBefore, childrenAfter); // Check if there was only removing in that mutation without any insertions.\n\n      var hasDelete = diffResult.some(function (item) {\n        return item === 'delete';\n      });\n      var hasInsert = diffResult.some(function (item) {\n        return item === 'insert';\n      });\n\n      if (hasDelete && !hasInsert) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return false;\n} // Whether provided array contains only nodes of `containerElement` type.\n//\n// @private\n// @param {Array.<module:engine/view/node~Node>} children\n// @returns {Boolean}\n\n\nfunction hasOnlyContainers(children) {\n  return children.every(function (child) {\n    return child.is('containerElement');\n  });\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/delete\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport DeleteCommand from \"./deletecommand\";\nimport DeleteObserver from \"./deleteobserver\";\nimport injectAndroidBackspaceMutationsHandling from \"./utils/injectandroidbackspacemutationshandling\";\n/**\n * The delete and backspace feature. Handles the <kbd>Delete</kbd> and <kbd>Backspace</kbd> keys in the editor.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar Delete =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Delete, _Plugin);\n\n  function Delete() {\n    _classCallCheck(this, Delete);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Delete).apply(this, arguments));\n  }\n\n  _createClass(Delete, [{\n    key: \"init\",\n    value: function init() {\n      var editor = this.editor;\n      var view = editor.editing.view;\n      var viewDocument = view.document;\n      view.addObserver(DeleteObserver);\n      editor.commands.add('forwardDelete', new DeleteCommand(editor, 'forward'));\n      editor.commands.add('delete', new DeleteCommand(editor, 'backward'));\n      this.listenTo(viewDocument, 'delete', function (evt, data) {\n        editor.execute(data.direction == 'forward' ? 'forwardDelete' : 'delete', {\n          unit: data.unit,\n          sequence: data.sequence\n        });\n        data.preventDefault();\n        view.scrollToTheSelection();\n      });\n      injectAndroidBackspaceMutationsHandling(editor);\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'Delete';\n    }\n  }]);\n\n  return Delete;\n}(Plugin);\n\nexport { Delete as default };","import \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.weak-map\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport InsertOperation from \"./insertoperation\";\nimport AttributeOperation from \"./attributeoperation\";\nimport RenameOperation from \"./renameoperation\";\nimport MarkerOperation from \"./markeroperation\";\nimport MoveOperation from \"./moveoperation\";\nimport RootAttributeOperation from \"./rootattributeoperation\";\nimport MergeOperation from \"./mergeoperation\";\nimport SplitOperation from \"./splitoperation\";\nimport NoOperation from \"./nooperation\";\nimport Range from \"../range\";\nimport Position from \"../position\";\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nvar transformations = new Map();\n/**\n * @module engine/model/operation/transform\n */\n\n/**\n * Sets a transformation function to be be used to transform instances of class `OperationA` by instances of class `OperationB`.\n *\n * The `transformationFunction` is passed three parameters:\n *\n * * `a` - operation to be transformed, an instance of `OperationA`,\n * * `b` - operation to be transformed by, an instance of `OperationB`,\n * * {@link module:engine/model/operation/transform~TransformationContext `context`} - object with additional information about\n * transformation context.\n *\n * The `transformationFunction` should return transformation result, which is an array with one or multiple\n * {@link module:engine/model/operation/operation~Operation operation} instances.\n *\n * @protected\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @param {Function} transformationFunction Function to use for transforming.\n */\n\nfunction setTransformation(OperationA, OperationB, transformationFunction) {\n  var aGroup = transformations.get(OperationA);\n\n  if (!aGroup) {\n    aGroup = new Map();\n    transformations.set(OperationA, aGroup);\n  }\n\n  aGroup.set(OperationB, transformationFunction);\n}\n/**\n * Returns a previously set transformation function for transforming an instance of `OperationA` by an instance of `OperationB`.\n *\n * If no transformation was set for given pair of operations, {@link module:engine/model/operation/transform~noUpdateTransformation}\n * is returned. This means that if no transformation was set, the `OperationA` instance will not change when transformed\n * by the `OperationB` instance.\n *\n * @private\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @returns {Function} Function set to transform an instance of `OperationA` by an instance of `OperationB`.\n */\n\n\nfunction getTransformation(OperationA, OperationB) {\n  var aGroup = transformations.get(OperationA);\n\n  if (aGroup && aGroup.has(OperationB)) {\n    return aGroup.get(OperationB);\n  }\n\n  return noUpdateTransformation;\n}\n/**\n * A transformation function that only clones operation to transform, without changing it.\n *\n * @private\n * @param {module:engine/model/operation/operation~Operation} a Operation to transform.\n * @returns {Array.<module:engine/model/operation/operation~Operation>}\n */\n\n\nfunction noUpdateTransformation(a) {\n  return [a];\n}\n/**\n * Transforms operation `a` by operation `b`.\n *\n * @param {module:engine/model/operation/operation~Operation} a Operation to be transformed.\n * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.\n * @param {module:engine/model/operation/transform~TransformationContext} context Transformation context for this transformation.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} Transformation result.\n */\n\n\nexport function transform(a, b) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var transformationFunction = getTransformation(a.constructor, b.constructor);\n\n  try {\n    a = a.clone();\n    return transformationFunction(a, b, context);\n  } catch (e) {\n    log.error('Error during operation transformation!', e.message);\n    log.error('Transformed operation', a);\n    log.error('Operation transformed by', b);\n    log.error('context.aIsStrong', context.aIsStrong);\n    log.error('context.aWasUndone', context.aWasUndone);\n    log.error('context.bWasUndone', context.bWasUndone);\n    log.error('context.abRelation', context.abRelation);\n    log.error('context.baRelation', context.baRelation);\n    throw e;\n  }\n}\n/**\n * Performs a transformation of two sets of operations - `operationsA` and `operationsB`. The transformation is two-way -\n * both transformed `operationsA` and transformed `operationsB` are returned.\n *\n * Note, that the first operation in each set should base on the same document state (\n * {@link module:engine/model/document~Document#version document version}).\n *\n * It is assumed that `operationsA` are \"more important\" during conflict resolution between two operations.\n *\n * New copies of both passed arrays and operations inside them are returned. Passed arguments are not altered.\n *\n * Base versions of the transformed operations sets are updated accordingly. For example, assume that base versions are `4`\n * and there are `3` operations in `operationsA` and `5` operations in `operationsB`. Then:\n *\n * * transformed `operationsA` will start from base version `9` (`4` base version + `5` operations B),\n * * transformed `operationsB` will start from base version `7` (`4` base version + `3` operations A).\n *\n * If no operation was broken into two during transformation, then both sets will end up with an operation that bases on version `11`:\n *\n * * transformed `operationsA` start from `9` and there are `3` of them, so the last will have `baseVersion` equal to `11`,\n * * transformed `operationsB` start from `7` and there are `5` of them, so the last will have `baseVersion` equal to `11`.\n *\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsA\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsB\n * @param {Object} options Additional transformation options.\n * @param {module:engine/model/document~Document|null} options.document Document which the operations change.\n * @param {Boolean} [options.useRelations=false] Whether during transformation relations should be used (used during undo for\n * better conflict resolution).\n * @param {Boolean} [options.padWithNoOps=false] Whether additional {@link module:engine/model/operation/nooperation~NoOperation}s\n * should be added to the transformation results to force the same last base version for both transformed sets (in case\n * if some operations got broken into multiple operations during transformation).\n * @returns {Object} Transformation result.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsA Transformed `operationsA`.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsB Transformed `operationsB`.\n */\n\nexport function transformSets(operationsA, operationsB, options) {\n  // Create new arrays so the originally passed arguments are not changed.\n  // No need to clone operations, they are cloned as they are transformed.\n  operationsA = operationsA.slice();\n  operationsB = operationsB.slice(); // If one of sets is empty there is simply nothing to transform, so return sets as they are.\n\n  if (operationsA.length == 0 || operationsB.length == 0) {\n    return {\n      operationsA: operationsA,\n      operationsB: operationsB\n    };\n  } //\n  // Following is a description of transformation process:\n  //\n  // There are `operationsA` and `operationsB` to be transformed, both by both.\n  //\n  // So, suppose we have sets of two operations each: `operationsA` = `[ a1, a2 ]`, `operationsB` = `[ b1, b2 ]`.\n  //\n  // Remember, that we can only transform operations that base on the same context. We assert that `a1` and `b1` base on\n  // the same context and we transform them. Then, we get `a1'` and `b1'`. `a2` bases on a context with `a1` -- `a2`\n  // is an operation that followed `a1`. Similarly, `b2` bases on a context with `b1`.\n  //\n  // However, since `a1'` is a result of transformation by `b1`, `a1'` now also has a context with `b1`. This means that\n  // we can safely transform `a1'` by `b2`. As we finish transforming `a1`, we also transformed all `operationsB`.\n  // All `operationsB` also have context including `a1`. Now, we can properly transform `a2` by those operations.\n  //\n  // The transformation process can be visualized on a transformation diagram (\"diamond diagram\"):\n  //\n  //          [the initial state]\n  //         [common for a1 and b1]\n  //\n  //                   *\n  //                  / \\\n  //                 /   \\\n  //               b1     a1\n  //               /       \\\n  //              /         \\\n  //             *           *\n  //            / \\         / \\\n  //           /   \\       /   \\\n  //         b2    a1'   b1'    a2\n  //         /       \\   /       \\\n  //        /         \\ /         \\\n  //       *           *           *\n  //        \\         / \\         /\n  //         \\       /   \\       /\n  //        a1''   b2'   a2'   b1''\n  //           \\   /       \\   /\n  //            \\ /         \\ /\n  //             *           *\n  //              \\         /\n  //               \\       /\n  //              a2''   b2''\n  //                 \\   /\n  //                  \\ /\n  //                   *\n  //\n  //           [the final state]\n  //\n  // The final state can be reached from the initial state by applying `a1`, `a2`, `b1''` and `b2''`, as well as by\n  // applying `b1`, `b2`, `a1''`, `a2''`. Note how the operations get to a proper common state before each pair is\n  // transformed.\n  //\n  // Another thing to consider is that an operation during transformation can be broken into multiple operations.\n  // Suppose that `a1` * `b1` = `[ a11', a12' ]` (instead of `a1'` that we considered previously).\n  //\n  // In that case, we leave `a12'` for later and we continue transforming `a11'` until it is transformed by all `operationsB`\n  // (in our case it is just `b2`). At this point, `b1` is transformed by \"whole\" `a1`, while `b2` is only transformed\n  // by `a11'`. Similarly, `a12'` is only transformed by `b1`. This leads to a conclusion that we need to start transforming `a12'`\n  // from the moment just after it was broken. So, `a12'` is transformed by `b2`. Now, \"the whole\" `a1` is transformed\n  // by `operationsB`, while all `operationsB` are transformed by \"the whole\" `a1`. This means that we can continue with\n  // following `operationsA` (in our case it is just `a2`).\n  //\n  // Of course, also `operationsB` can be broken. However, since we focus on transforming operation `a` to the end,\n  // the only thing to do is to store both pieces of operation `b`, so that the next transformed operation `a` will\n  // be transformed by both of them.\n  //\n  //                       *\n  //                      / \\\n  //                     /   \\\n  //                    /     \\\n  //                  b1       a1\n  //                  /         \\\n  //                 /           \\\n  //                /             \\\n  //               *               *\n  //              / \\             / \\\n  //             /  a11'         /   \\\n  //            /     \\         /     \\\n  //          b2       *      b1'      a2\n  //          /       / \\     /         \\\n  //         /       /  a12' /           \\\n  //        /       /     \\ /             \\\n  //       *       b2'     *               *\n  //        \\     /       / \\             /\n  //       a11'' /     b21'' \\           /\n  //          \\ /       /     \\         /\n  //           *       *      a2'     b1''\n  //            \\     / \\       \\     /\n  //          a12'' b22''\\       \\   /\n  //              \\ /     \\       \\ /\n  //               *      a2''     *\n  //                \\       \\     /\n  //                 \\       \\  b21'''\n  //                  \\       \\ /\n  //                a2'''      *\n  //                    \\     /\n  //                     \\  b22'''\n  //                      \\ /\n  //                       *\n  //\n  // Note, how `a1` is broken and transformed into `a11'` and `a12'`, while `b2'` got broken and transformed into `b21''` and `b22''`.\n  //\n  // Having all that on mind, here is an outline for the transformation process algorithm:\n  //\n  // 1. We have `operationsA` and `operationsB` array, which we dynamically update as the transformation process goes.\n  //\n  // 2. We take next (or first) operation from `operationsA` and check from which operation `b` we need to start transforming it.\n  // All original `operationsA` are set to be transformed starting from the first operation `b`.\n  //\n  // 3. We take operations from `operationsB`, one by one, starting from the correct one, and transform operation `a`\n  // by operation `b` (and vice versa). We update `operationsA` and `operationsB` by replacing the original operations\n  // with the transformation results.\n  //\n  // 4. If operation is broken into multiple operations, we save all the new operations in the place of the\n  // original operation.\n  //\n  // 5. Additionally, if operation `a` was broken, for the \"new\" operation, we remember from which operation `b` it should\n  // be transformed by.\n  //\n  // 6. We continue transforming \"current\" operation `a` until it is transformed by all `operationsB`. Then, go to 2.\n  // unless the last operation `a` was transformed.\n  //\n  // The actual implementation of the above algorithm is slightly different, as only one loop (while) is used.\n  // The difference is that we have \"current\" `a` operation to transform and we store the index of the next `b` operation\n  // to transform by. Each loop operates on two indexes then: index pointing to currently processed `a` operation and\n  // index pointing to next `b` operation. Each loop is just one `a * b` + `b * a` transformation. After each loop\n  // operation `b` index is updated. If all `b` operations were visited for the current `a` operation, we change\n  // current `a` operation index to the next one.\n  //\n  // For each operation `a`, keeps information what is the index in `operationsB` from which the transformation should start.\n\n\n  var nextTransformIndex = new WeakMap(); // For all the original `operationsA`, set that they should be transformed starting from the first of `operationsB`.\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = operationsA[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var op = _step.value;\n      nextTransformIndex.set(op, 0);\n    } // Additional data that is used for some postprocessing after the main transformation process is done.\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var data = {\n    nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,\n    nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,\n    originalOperationsACount: operationsA.length,\n    originalOperationsBCount: operationsB.length\n  };\n  var contextFactory = new ContextFactory(options.document, options.useRelations, options.forceWeakRemove);\n  contextFactory.setOriginalOperations(operationsA);\n  contextFactory.setOriginalOperations(operationsB); // Index of currently transformed operation `a`.\n\n  var i = 0; // While not all `operationsA` are transformed...\n\n  while (i < operationsA.length) {\n    var _operationsA, _operationsB;\n\n    // Get \"current\" operation `a`.\n    var opA = operationsA[i]; // For the \"current\" operation `a`, get the index of the next operation `b` to transform by.\n\n    var indexB = nextTransformIndex.get(opA); // If operation `a` was already transformed by every operation `b`, change \"current\" operation `a` to the next one.\n\n    if (indexB == operationsB.length) {\n      i++;\n      continue;\n    }\n\n    var opB = operationsB[indexB]; // Transform `a` by `b` and `b` by `a`.\n\n    var newOpsA = transform(opA, opB, contextFactory.getContext(opA, opB, true));\n    var newOpsB = transform(opB, opA, contextFactory.getContext(opB, opA, false)); // As a result we get one or more `newOpsA` and one or more `newOpsB` operations.\n    // Update contextual information about operations.\n\n    contextFactory.updateRelation(opA, opB);\n    contextFactory.setOriginalOperations(newOpsA, opA);\n    contextFactory.setOriginalOperations(newOpsB, opB); // For new `a` operations, update their index of the next operation `b` to transform them by.\n    //\n    // This is needed even if there was only one result (`a` was not broken) because that information is used\n    // at the beginning of this loop every time.\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = newOpsA[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var newOpA = _step2.value;\n        // Acknowledge, that operation `b` also might be broken into multiple operations.\n        //\n        // This is why we raise `indexB` not just by 1. If `newOpsB` are multiple operations, they will be\n        // spliced in the place of `opB`. So we need to change `transformBy` accordingly, so that an operation won't\n        // be transformed by the same operation (part of it) again.\n        nextTransformIndex.set(newOpA, indexB + newOpsB.length);\n      } // Update `operationsA` and `operationsB` with the transformed versions.\n\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    (_operationsA = operationsA).splice.apply(_operationsA, [i, 1].concat(_toConsumableArray(newOpsA)));\n\n    (_operationsB = operationsB).splice.apply(_operationsB, [indexB, 1].concat(_toConsumableArray(newOpsB)));\n  }\n\n  if (options.padWithNoOps) {\n    // If no-operations padding is enabled, count how many extra `a` and `b` operations were generated.\n    var brokenOperationsACount = operationsA.length - data.originalOperationsACount;\n    var brokenOperationsBCount = operationsB.length - data.originalOperationsBCount; // Then, if that number is not the same, pad `operationsA` or `operationsB` with correct number of no-ops so\n    // that the base versions are equalled.\n    //\n    // Note that only one array will be updated, as only one of those subtractions can be greater than zero.\n\n    padWithNoOps(operationsA, brokenOperationsBCount - brokenOperationsACount);\n    padWithNoOps(operationsB, brokenOperationsACount - brokenOperationsBCount);\n  } // Finally, update base versions of transformed operations.\n\n\n  updateBaseVersions(operationsA, data.nextBaseVersionB);\n  updateBaseVersions(operationsB, data.nextBaseVersionA);\n  return {\n    operationsA: operationsA,\n    operationsB: operationsB\n  };\n} // Gathers additional data about operations processed during transformation. Can be used to obtain contextual information\n// about two operations that are about to be transformed. This contextual information can be used for better conflict resolution.\n\nvar ContextFactory =\n/*#__PURE__*/\nfunction () {\n  // Creates `ContextFactory` instance.\n  //\n  // @param {module:engine/model/document~Document} document Document which the operations change.\n  // @param {Boolean} useRelations Whether during transformation relations should be used (used during undo for\n  // better conflict resolution).\n  // @param {Boolean} [forceWeakRemove=false] If set to `false`, remove operation will be always stronger than move operation,\n  // so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n  function ContextFactory(document, useRelations) {\n    var forceWeakRemove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, ContextFactory);\n\n    // `model.History` instance which information about undone operations will be taken from.\n    this._history = document.history; // Whether additional context should be used.\n\n    this._useRelations = useRelations;\n    this._forceWeakRemove = !!forceWeakRemove; // For each operation that is created during transformation process, we keep a reference to the original operation\n    // which it comes from. The original operation works as a kind of \"identifier\". Every contextual information\n    // gathered during transformation that we want to save for given operation, is actually saved for the original operation.\n    // This way no matter if operation `a` is cloned, then transformed, even breaks, we still have access to the previously\n    // gathered data through original operation reference.\n\n    this._originalOperations = new Map(); // Relations is a double-map structure (maps in map) where for two operations we store how those operations were related\n    // to each other. Those relations are evaluated during transformation process. For every transformated pair of operations\n    // we keep relations between them.\n\n    this._relations = new Map();\n  } // Sets \"original operation\" for given operations.\n  //\n  // During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two\n  // or multiple operations. When gathering additional data it is important that all operations can be somehow linked\n  // so a cloned and transformed \"version\" still kept track of the data assigned earlier to it.\n  //\n  // The original operation object will be used as such an universal linking id. Throughout the transformation process\n  // all cloned operations will refer to \"the original operation\" when storing and reading additional data.\n  //\n  // If `takeFrom` is not set, each operation from `operations` array will be assigned itself as \"the original operation\".\n  // This should be used as an initialization step.\n  //\n  // If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned\n  // for `takeFrom` operation. This should be used to update original operations. It should be used in a way that\n  // `operations` are the result of `takeFrom` transformation to ensure proper \"original operation propagation\".\n  //\n  // @param {Array.<module:engine/model/operation/operation~Operation>} operations\n  // @param {module:engine/model/operation/operation~Operation|null} [takeFrom=null]\n\n\n  _createClass(ContextFactory, [{\n    key: \"setOriginalOperations\",\n    value: function setOriginalOperations(operations) {\n      var takeFrom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var originalOperation = takeFrom ? this._originalOperations.get(takeFrom) : null;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = operations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var operation = _step3.value;\n\n          this._originalOperations.set(operation, originalOperation || operation);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    } // Saves a relation between operations `opA` and `opB`.\n    //\n    // Relations are then later used to help solve conflicts when operations are transformed.\n    //\n    // @param {module:engine/model/operation/operation~Operation} opA\n    // @param {module:engine/model/operation/operation~Operation} opB\n\n  }, {\n    key: \"updateRelation\",\n    value: function updateRelation(opA, opB) {\n      // The use of relations is described in a bigger detail in transformation functions.\n      //\n      // In brief, this function, for specified pairs of operation types, checks how positions defined in those operations relate.\n      // Then those relations are saved. For example, for two move operations, it is saved if one of those operations target\n      // position is before the other operation source position. This kind of information gives contextual information when\n      // transformation is used during undo. Similar checks are done for other pairs of operations.\n      //\n      switch (opA.constructor) {\n        case MoveOperation:\n          {\n            switch (opB.constructor) {\n              case MergeOperation:\n                {\n                  if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {\n                    this._setRelation(opA, opB, 'insertAtSource');\n                  } else if (opA.targetPosition.isEqual(opB.deletionPosition)) {\n                    this._setRelation(opA, opB, 'insertBetween');\n                  } else if (opA.targetPosition.isAfter(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'moveTargetAfter');\n                  }\n\n                  break;\n                }\n\n              case MoveOperation:\n                {\n                  if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'insertBefore');\n                  } else {\n                    this._setRelation(opA, opB, 'insertAfter');\n                  }\n\n                  break;\n                }\n            }\n\n            break;\n          }\n\n        case SplitOperation:\n          {\n            switch (opB.constructor) {\n              case MergeOperation:\n                {\n                  if (opA.splitPosition.isBefore(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'splitBefore');\n                  }\n\n                  break;\n                }\n\n              case MoveOperation:\n                {\n                  if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'splitBefore');\n                  }\n\n                  break;\n                }\n            }\n\n            break;\n          }\n\n        case MergeOperation:\n          {\n            switch (opB.constructor) {\n              case MergeOperation:\n                {\n                  if (!opA.targetPosition.isEqual(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'mergeTargetNotMoved');\n                  }\n\n                  if (opA.sourcePosition.isEqual(opB.targetPosition)) {\n                    this._setRelation(opA, opB, 'mergeSourceNotMoved');\n                  }\n\n                  if (opA.sourcePosition.isEqual(opB.sourcePosition)) {\n                    this._setRelation(opA, opB, 'mergeSameElement');\n                  }\n\n                  break;\n                }\n\n              case SplitOperation:\n                {\n                  if (opA.sourcePosition.isEqual(opB.splitPosition)) {\n                    this._setRelation(opA, opB, 'splitAtSource');\n                  }\n                }\n            }\n\n            break;\n          }\n\n        case MarkerOperation:\n          {\n            var markerRange = opA.newRange;\n\n            if (!markerRange) {\n              return;\n            }\n\n            switch (opB.constructor) {\n              case MoveOperation:\n                {\n                  var movedRange = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);\n\n                  var affectedLeft = movedRange.containsPosition(markerRange.start) || movedRange.start.isEqual(markerRange.start);\n                  var affectedRight = movedRange.containsPosition(markerRange.end) || movedRange.end.isEqual(markerRange.end);\n\n                  if ((affectedLeft || affectedRight) && !movedRange.containsRange(markerRange)) {\n                    this._setRelation(opA, opB, {\n                      side: affectedLeft ? 'left' : 'right',\n                      path: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()\n                    });\n                  }\n\n                  break;\n                }\n\n              case MergeOperation:\n                {\n                  var wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);\n                  var wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);\n                  var wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);\n                  var wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);\n\n                  if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {\n                    this._setRelation(opA, opB, {\n                      wasInLeftElement: wasInLeftElement,\n                      wasStartBeforeMergedElement: wasStartBeforeMergedElement,\n                      wasEndBeforeMergedElement: wasEndBeforeMergedElement,\n                      wasInRightElement: wasInRightElement\n                    });\n                  }\n\n                  break;\n                }\n            }\n\n            break;\n          }\n      }\n    } // Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.\n    //\n    // @param {module:engine/model/operation/operation~Operation} opA\n    // @param {module:engine/model/operation/operation~Operation} opB\n    // @returns {module:engine/model/operation/transform~TransformationContext}\n\n  }, {\n    key: \"getContext\",\n    value: function getContext(opA, opB, aIsStrong) {\n      return {\n        aIsStrong: aIsStrong,\n        aWasUndone: this._wasUndone(opA),\n        bWasUndone: this._wasUndone(opB),\n        abRelation: this._useRelations ? this._getRelation(opA, opB) : null,\n        baRelation: this._useRelations ? this._getRelation(opB, opA) : null,\n        forceWeakRemove: this._forceWeakRemove\n      };\n    } // Returns whether given operation `op` has already been undone.\n    //\n    // Information whether an operation was undone gives more context when making a decision when two operations are in conflict.\n    //\n    // @param {module:engine/model/operation/operation~Operation} op\n    // @returns {Boolean}\n\n  }, {\n    key: \"_wasUndone\",\n    value: function _wasUndone(op) {\n      // For `op`, get its original operation. After all, if `op` is a clone (or even transformed clone) of another\n      // operation, literally `op` couldn't be undone. It was just generated. If anything, it was the operation it origins\n      // from which was undone. So get that original operation.\n      var originalOp = this._originalOperations.get(op); // And check with the document if the original operation was undone.\n\n\n      return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);\n    } // Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation\n    // was set earlier or `null` if there was no relation between those operations.\n    //\n    // This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.\n    //\n    // When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the\n    // undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,\n    // we look forward in the future and ask if in that future `opB` was undone.\n    //\n    // Relations is a backward process to `wasUndone()`.\n    //\n    // Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing\n    // operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is\n    // a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation\n    // between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make\n    // a better decision when resolving a conflict between two operations, because we know more about the context of\n    // those two operations.\n    //\n    // This is why this function does not return a relation directly between `opA` and `opB` because we need to look\n    // back to search for a meaningful contextual information.\n    //\n    // @param {module:engine/model/operation/operation~Operation} opA\n    // @param {module:engine/model/operation/operation~Operation} opB\n    // @returns {String|null}\n\n  }, {\n    key: \"_getRelation\",\n    value: function _getRelation(opA, opB) {\n      // Get the original operation. Similarly as in `wasUndone()` it is used as an universal identifier for stored data.\n      var origB = this._originalOperations.get(opB);\n\n      var undoneB = this._history.getUndoneOperation(origB); // If `opB` is not undoing any operation, there is no relation.\n\n\n      if (!undoneB) {\n        return null;\n      }\n\n      var origA = this._originalOperations.get(opA);\n\n      var relationsA = this._relations.get(origA); // Get all relations for `opA`, and check if there is a relation with `opB`-undone-counterpart. If so, return it.\n\n\n      if (relationsA) {\n        return relationsA.get(undoneB) || null;\n      }\n\n      return null;\n    } // Helper function for `ContextFactory#updateRelations`.\n    //\n    // @private\n    // @param {module:engine/model/operation/operation~Operation} opA\n    // @param {module:engine/model/operation/operation~Operation} opB\n    // @param {String} relation\n\n  }, {\n    key: \"_setRelation\",\n    value: function _setRelation(opA, opB, relation) {\n      // As always, setting is for original operations, not the clones/transformed operations.\n      var origA = this._originalOperations.get(opA);\n\n      var origB = this._originalOperations.get(opB);\n\n      var relationsA = this._relations.get(origA);\n\n      if (!relationsA) {\n        relationsA = new Map();\n\n        this._relations.set(origA, relationsA);\n      }\n\n      relationsA.set(origB, relation);\n    }\n  }]);\n\n  return ContextFactory;\n}();\n/**\n * Holds additional contextual information about a transformed pair of operations (`a` and `b`). Those information\n * can be used for better conflict resolving.\n *\n * @typedef {Object} module:engine/model/operation/transform~TransformationContext\n *\n * @property {Boolean} aIsStrong Whether `a` is strong operation in this transformation, or weak.\n * @property {Boolean} aWasUndone Whether `a` operation was undone.\n * @property {Boolean} bWasUndone Whether `b` operation was undone.\n * @property {String|null} abRelation The relation between `a` operation and an operation undone by `b` operation.\n * @property {String|null} baRelation The relation between `b` operation and an operation undone by `a` operation.\n */\n\n/**\n * An utility function that updates {@link module:engine/model/operation/operation~Operation#baseVersion base versions}\n * of passed operations.\n *\n * The function simply sets `baseVersion` as a base version of the first passed operation and then increments it for\n * each following operation in `operations`.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations to update.\n * @param {Number} baseVersion Base version to set for the first operation in `operations`.\n */\n\n\nfunction updateBaseVersions(operations, baseVersion) {\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = operations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var operation = _step4.value;\n      operation.baseVersion = baseVersion++;\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n/**\n * Adds `howMany` instances of {@link module:engine/model/operation/nooperation~NoOperation} to `operations` set.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations\n * @param {Number} howMany\n */\n\n\nfunction padWithNoOps(operations, howMany) {\n  for (var i = 0; i < howMany; i++) {\n    operations.push(new NoOperation(0));\n  }\n} // -----------------------\n\n\nsetTransformation(AttributeOperation, AttributeOperation, function (a, b, context) {\n  if (a.key === b.key) {\n    // If operations attributes are in conflict, check if their ranges intersect and manage them properly.\n    // First, we want to apply change to the part of a range that has not been changed by the other operation.\n    var operations = a.range.getDifference(b.range).map(function (range) {\n      return new AttributeOperation(range, a.key, a.oldValue, a.newValue, 0);\n    }); // Then we take care of the common part of ranges.\n\n    var common = a.range.getIntersection(b.range);\n\n    if (common) {\n      // If this operation is more important, we also want to apply change to the part of the\n      // original range that has already been changed by the other operation. Since that range\n      // got changed we also have to update `oldValue`.\n      if (context.aIsStrong) {\n        operations.push(new AttributeOperation(common, b.key, b.newValue, a.newValue, 0));\n      }\n    }\n\n    if (operations.length == 0) {\n      return [new NoOperation(0)];\n    }\n\n    return operations;\n  } else {\n    // If operations don't conflict, simply return an array containing just a clone of this operation.\n    return [a];\n  }\n});\nsetTransformation(AttributeOperation, InsertOperation, function (a, b) {\n  // Case 1:\n  //\n  // The attribute operation range includes the position where nodes were inserted.\n  // There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n  // the inserted nodes were elements and they should not receive attributes.\n  //\n  if (a.range.start.hasSameParentAs(b.position) && a.range.containsPosition(b.position)) {\n    // If new nodes should not receive attributes, two separated ranges will be returned.\n    // Otherwise, one expanded range will be returned.\n    var range = a.range._getTransformedByInsertion(b.position, b.howMany, !b.shouldReceiveAttributes);\n\n    var result = range.map(function (r) {\n      return new AttributeOperation(r, a.key, a.oldValue, a.newValue, a.baseVersion);\n    });\n\n    if (b.shouldReceiveAttributes) {\n      // `AttributeOperation#range` includes some newly inserted text.\n      // The operation should also change the attribute of that text. An example:\n      //\n      // Bold should be applied on the following range:\n      // <p>Fo[zb]ar</p>\n      //\n      // In meantime, new text is typed:\n      // <p>Fozxxbar</p>\n      //\n      // Bold should be applied also on the new text:\n      // <p>Fo[zxxb]ar</p>\n      // <p>Fo<$text bold=\"true\">zxxb</$text>ar</p>\n      //\n      // There is a special case to consider here to consider.\n      //\n      // Consider setting an attribute with multiple possible values, for example `highlight`. The inserted text might\n      // have already an attribute value applied and the `oldValue` property of the attribute operation might be wrong:\n      //\n      // Attribute `highlight=\"yellow\"` should be applied on the following range:\n      // <p>Fo[zb]ar<p>\n      //\n      // In meantime, character `x` with `highlight=\"red\"` is typed:\n      // <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>\n      //\n      // In this case we cannot simply apply operation changing the attribute value from `null` to `\"yellow\"` for the whole range\n      // because that would lead to an exception (`oldValue` is incorrect for `x`).\n      //\n      // We also cannot break the original range as this would mess up a scenario when there are multiple following\n      // insert operations, because then only the first inserted character is included in those ranges:\n      // <p>Fo[z][x][b]ar</p>   -->   <p>Fo[z][x]x[b]ar</p>   -->   <p>Fo[z][x]xx[b]ar</p>\n      //\n      // So, the attribute range needs be expanded, no matter what attributes are set on the inserted nodes:\n      //\n      // <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>      <--- Change from `null` to `yellow`, throwing an exception.\n      //\n      // But before that operation would be applied, we will add an additional attribute operation that will change\n      // attributes on the inserted nodes in a way which would make the original operation correct:\n      //\n      // <p>Fo[z{<$text highlight=\"red\">}x</$text>b]ar</p>    <--- Change range `{}` from `red` to `null`.\n      // <p>Fo[zxb]ar</p>                                     <--- Now change from `null` to `yellow` is completely fine.\n      //\n      // Generate complementary attribute operation. Be sure to add it before the original operation.\n      var op = _getComplementaryAttributeOperations(b, a.key, a.oldValue);\n\n      if (op) {\n        result.unshift(op);\n      }\n    } // If nodes should not receive new attribute, we are done here.\n\n\n    return result;\n  } // If insert operation is not expanding the attribute operation range, simply transform the range.\n\n\n  a.range = a.range._getTransformedByInsertion(b.position, b.howMany, false)[0];\n  return [a];\n});\n/**\n * Helper function for `AttributeOperation` x `InsertOperation` (and reverse) transformation.\n *\n * For given `insertOperation` it checks the inserted node if it has an attribute `key` set to a value different\n * than `newValue`. If so, it generates an `AttributeOperation` which changes the value of `key` attribute to `newValue`.\n *\n * @private\n * @param {module:engine/model/operation/insertoperation~InsertOperation} insertOperation\n * @param {String} key\n * @param {*} newValue\n * @returns {module:engine/model/operation/attributeoperation~AttributeOperation|null}\n */\n\nfunction _getComplementaryAttributeOperations(insertOperation, key, newValue) {\n  var nodes = insertOperation.nodes; // At the beginning we store the attribute value from the first node.\n\n  var insertValue = nodes.getNode(0).getAttribute(key);\n\n  if (insertValue == newValue) {\n    return null;\n  }\n\n  var range = new Range(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));\n  return new AttributeOperation(range, key, insertValue, newValue, 0);\n}\n\nsetTransformation(AttributeOperation, MergeOperation, function (a, b) {\n  var ranges = []; // Case 1:\n  //\n  // Attribute change on the merged element. In this case, the merged element was moved to the graveyard.\n  // An additional attribute operation that will change the (re)moved element needs to be generated.\n  //\n\n  if (a.range.start.hasSameParentAs(b.deletionPosition)) {\n    if (a.range.containsPosition(b.deletionPosition) || a.range.start.isEqual(b.deletionPosition)) {\n      ranges.push(Range._createFromPositionAndShift(b.graveyardPosition, 1));\n    }\n  }\n\n  var range = a.range._getTransformedByMergeOperation(b); // Do not add empty (collapsed) ranges to the result. `range` may be collapsed if it contained only the merged element.\n\n\n  if (!range.isCollapsed) {\n    ranges.push(range);\n  } // Create `AttributeOperation`s out of the ranges.\n\n\n  return ranges.map(function (range) {\n    return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);\n  });\n});\nsetTransformation(AttributeOperation, MoveOperation, function (a, b) {\n  var ranges = _breakRangeByMoveOperation(a.range, b); // Create `AttributeOperation`s out of the ranges.\n\n\n  return ranges.map(function (range) {\n    return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);\n  });\n}); // Helper function for `AttributeOperation` x `MoveOperation` transformation.\n//\n// Takes the passed `range` and transforms it by move operation `moveOp` in a specific way. Only top-level nodes of `range`\n// are considered to be in the range. If move operation moves nodes deep from inside of the range, those nodes won't\n// be included in the result. In other words, top-level nodes of the ranges from the result are exactly the same as\n// top-level nodes of the original `range`.\n//\n// This is important for `AttributeOperation` because, for its range, it changes only the top-level nodes. So we need to\n// track only how those nodes have been affected by `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/operation/moveoperation~MoveOperation} moveOp\n// @returns {Array.<module:engine/model/range~Range>}\n\nfunction _breakRangeByMoveOperation(range, moveOp) {\n  var moveRange = Range._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany); // We are transforming `range` (original range) by `moveRange` (range moved by move operation). As usual when it comes to\n  // transforming a ranges, we may have a common part of the ranges and we may have a difference part (zero to two ranges).\n\n\n  var common = null;\n  var difference = []; // Let's compare the ranges.\n\n  if (moveRange.containsRange(range, true)) {\n    // If the whole original range is moved, treat it whole as a common part. There's also no difference part.\n    common = range;\n  } else if (range.start.hasSameParentAs(moveRange.start)) {\n    // If the ranges are \"on the same level\" (in the same parent) then move operation may move exactly those nodes\n    // that are changed by the attribute operation. In this case we get common part and difference part in the usual way.\n    difference = range.getDifference(moveRange);\n    common = range.getIntersection(moveRange);\n  } else {\n    // In any other situation we assume that original range is different than move range, that is that move operation\n    // moves other nodes that attribute operation change. Even if the moved range is deep inside in the original range.\n    //\n    // Note that this is different than in `.getIntersection` (we would get a common part in that case) and different\n    // than `.getDifference` (we would get two ranges).\n    difference = [range];\n  }\n\n  var result = []; // The default behaviour of `_getTransformedByMove` might get wrong results for difference part, though, so\n  // we do it by hand.\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = difference[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var diff = _step5.value;\n      // First, transform the range by removing moved nodes. Since this is a difference, this is safe, `null` won't be returned\n      // as the range is different than the moved range.\n      diff = diff._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany); // Transform also `targetPosition`.\n\n      var targetPosition = moveOp.getMovedRangeStart(); // Spread the range only if moved nodes are inserted only between the top-level nodes of the `diff` range.\n\n      var spread = diff.start.hasSameParentAs(targetPosition); // Transform by insertion of moved nodes.\n\n      diff = diff._getTransformedByInsertion(targetPosition, moveOp.howMany, spread);\n      result.push.apply(result, _toConsumableArray(diff));\n    } // Common part can be simply transformed by the move operation. This is because move operation will not target to\n    // that common part (the operation would have to target inside its own moved range).\n\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  if (common) {\n    result.push(common._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);\n  }\n\n  return result;\n}\n\nsetTransformation(AttributeOperation, SplitOperation, function (a, b) {\n  // Case 1:\n  //\n  // Split node is the last node in `AttributeOperation#range`.\n  // `AttributeOperation#range` needs to be expanded to include the new (split) node.\n  //\n  // Attribute `type` to be changed to `numbered` but the `listItem` is split.\n  // <listItem type=\"bulleted\">foobar</listItem>\n  //\n  // After split:\n  // <listItem type=\"bulleted\">foo</listItem><listItem type=\"bulleted\">bar</listItem>\n  //\n  // After attribute change:\n  // <listItem type=\"numbered\">foo</listItem><listItem type=\"numbered\">foo</listItem>\n  //\n  if (a.range.end.isEqual(b.insertionPosition)) {\n    if (!b.graveyardPosition) {\n      a.range.end.offset++;\n    }\n\n    return [a];\n  } // Case 2:\n  //\n  // Split position is inside `AttributeOperation#range`, at the same level, so the nodes to change are\n  // not going to make a flat range.\n  //\n  // Content with range-to-change and split position:\n  // <p>Fo[zb^a]r</p>\n  //\n  // After split:\n  // <p>Fozb</p><p>ar</p>\n  //\n  // Make two separate ranges containing all nodes to change:\n  // <p>Fo[zb]</p><p>[a]r</p>\n  //\n\n\n  if (a.range.start.hasSameParentAs(b.splitPosition) && a.range.containsPosition(b.splitPosition)) {\n    var secondPart = a.clone();\n    secondPart.range = new Range(b.moveTargetPosition.clone(), a.range.end._getCombined(b.splitPosition, b.moveTargetPosition));\n    a.range.end = b.splitPosition.clone();\n    a.range.end.stickiness = 'toPrevious';\n    return [a, secondPart];\n  } // The default case.\n  //\n\n\n  a.range = a.range._getTransformedBySplitOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, AttributeOperation, function (a, b) {\n  var result = [a]; // Case 1:\n  //\n  // The attribute operation range includes the position where nodes were inserted.\n  // There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n  // the inserted nodes were elements and they should not receive attributes.\n  //\n  // This is a mirror scenario to the one described in `AttributeOperation` x `InsertOperation` transformation,\n  // although this case is a little less complicated. In this case we simply need to change attributes of the\n  // inserted nodes and that's it.\n  //\n\n  if (a.shouldReceiveAttributes && a.position.hasSameParentAs(b.range.start) && b.range.containsPosition(a.position)) {\n    var op = _getComplementaryAttributeOperations(a, b.key, b.newValue);\n\n    if (op) {\n      result.push(op);\n    }\n  } // The default case is: do nothing.\n  // `AttributeOperation` does not change the model tree structure so `InsertOperation` does not need to be changed.\n  //\n\n\n  return result;\n});\nsetTransformation(InsertOperation, InsertOperation, function (a, b, context) {\n  // Case 1:\n  //\n  // Two insert operations insert nodes at the same position. Since they are the same, it needs to be decided\n  // what will be the order of inserted nodes. However, there is no additional information to help in that\n  // decision. Also, when `b` will be transformed by `a`, the same order must be maintained.\n  //\n  // To achieve that, we will check if the operation is strong.\n  // If it is, it won't get transformed. If it is not, it will be moved.\n  //\n  if (a.position.isEqual(b.position) && context.aIsStrong) {\n    return [a];\n  } // The default case.\n  //\n\n\n  a.position = a.position._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, MoveOperation, function (a, b) {\n  // The default case.\n  //\n  a.position = a.position._getTransformedByMoveOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, SplitOperation, function (a, b) {\n  // The default case.\n  //\n  a.position = a.position._getTransformedBySplitOperation(b);\n  return [a];\n});\nsetTransformation(InsertOperation, MergeOperation, function (a, b) {\n  a.position = a.position._getTransformedByMergeOperation(b);\n  return [a];\n}); // -----------------------\n\nsetTransformation(MarkerOperation, InsertOperation, function (a, b) {\n  if (a.oldRange) {\n    a.oldRange = a.oldRange._getTransformedByInsertOperation(b)[0];\n  }\n\n  if (a.newRange) {\n    a.newRange = a.newRange._getTransformedByInsertOperation(b)[0];\n  }\n\n  return [a];\n});\nsetTransformation(MarkerOperation, MarkerOperation, function (a, b, context) {\n  if (a.name == b.name) {\n    if (context.aIsStrong) {\n      a.oldRange = b.newRange ? b.newRange.clone() : null;\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n\n  return [a];\n});\nsetTransformation(MarkerOperation, MergeOperation, function (a, b) {\n  if (a.oldRange) {\n    a.oldRange = a.oldRange._getTransformedByMergeOperation(b);\n  }\n\n  if (a.newRange) {\n    a.newRange = a.newRange._getTransformedByMergeOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(MarkerOperation, MoveOperation, function (a, b, context) {\n  if (a.oldRange) {\n    a.oldRange = Range._createFromRanges(a.oldRange._getTransformedByMoveOperation(b));\n  }\n\n  if (a.newRange) {\n    if (context.abRelation) {\n      var aNewRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));\n\n      if (context.abRelation.side == 'left' && b.targetPosition.isEqual(a.newRange.start)) {\n        a.newRange.start.path = context.abRelation.path;\n        a.newRange.end = aNewRange.end;\n        return [a];\n      } else if (context.abRelation.side == 'right' && b.targetPosition.isEqual(a.newRange.end)) {\n        a.newRange.start = aNewRange.start;\n        a.newRange.end.path = context.abRelation.path;\n        return [a];\n      }\n    }\n\n    a.newRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));\n  }\n\n  return [a];\n});\nsetTransformation(MarkerOperation, SplitOperation, function (a, b, context) {\n  if (a.oldRange) {\n    a.oldRange = a.oldRange._getTransformedBySplitOperation(b);\n  }\n\n  if (a.newRange) {\n    if (context.abRelation) {\n      var aNewRange = a.newRange._getTransformedBySplitOperation(b);\n\n      if (a.newRange.start.isEqual(b.splitPosition) && context.abRelation.wasStartBeforeMergedElement) {\n        a.newRange.start = Position._createAt(b.insertionPosition);\n      } else if (a.newRange.start.isEqual(b.splitPosition) && !context.abRelation.wasInLeftElement) {\n        a.newRange.start = Position._createAt(b.moveTargetPosition);\n      }\n\n      if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasInRightElement) {\n        a.newRange.end = Position._createAt(b.moveTargetPosition);\n      } else if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {\n        a.newRange.end = Position._createAt(b.insertionPosition);\n      } else {\n        a.newRange.end = aNewRange.end;\n      }\n\n      return [a];\n    }\n\n    a.newRange = a.newRange._getTransformedBySplitOperation(b);\n  }\n\n  return [a];\n}); // -----------------------\n\nsetTransformation(MergeOperation, InsertOperation, function (a, b) {\n  if (a.sourcePosition.hasSameParentAs(b.position)) {\n    a.howMany += b.howMany;\n  }\n\n  a.sourcePosition = a.sourcePosition._getTransformedByInsertOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(MergeOperation, MergeOperation, function (a, b, context) {\n  // Case 1:\n  //\n  // Same merge operations.\n  //\n  // Both operations have same source and target positions. So the element already got merged and there is\n  // theoretically nothing to do.\n  //\n  if (a.sourcePosition.isEqual(b.sourcePosition) && a.targetPosition.isEqual(b.targetPosition)) {\n    // There are two ways that we can provide a do-nothing operation.\n    //\n    // First is simply a NoOperation instance. We will use it if `b` operation was not undone.\n    //\n    // Second is a merge operation that has the source operation in the merged element - in the graveyard -\n    // same target position and `howMany` equal to `0`. So it is basically merging an empty element from graveyard\n    // which is almost the same as NoOperation.\n    //\n    // This way the merge operation can be later transformed by split operation\n    // to provide correct undo. This will be used if `b` operation was undone (only then it is correct).\n    //\n    if (!context.bWasUndone) {\n      return [new NoOperation(0)];\n    } else {\n      var path = b.graveyardPosition.path.slice();\n      path.push(0);\n      a.sourcePosition = new Position(b.graveyardPosition.root, path);\n      a.howMany = 0;\n      return [a];\n    }\n  } // Case 2:\n  //\n  // Same merge source position but different target position.\n  //\n  // This can happen during collaboration. For example, if one client merged a paragraph to the previous paragraph\n  // and the other person removed that paragraph and merged the same paragraph to something before:\n  //\n  // Client A:\n  // <p>Foo</p><p>Bar</p><p>[]Xyz</p>\n  // <p>Foo</p><p>BarXyz</p>\n  //\n  // Client B:\n  // <p>Foo</p>[<p>Bar</p>]<p>Xyz</p>\n  // <p>Foo</p><p>[]Xyz</p>\n  // <p>FooXyz</p>\n  //\n  // In this case we need to decide where finally \"Xyz\" will land:\n  //\n  // <p>FooXyz</p>               graveyard: <p>Bar</p>\n  // <p>Foo</p>                  graveyard: <p>BarXyz</p>\n  //\n  // Let's move it in a way so that a merge operation that does not target to graveyard is more important so that\n  // nodes does not end up in the graveyard. It makes sense. Both for Client A and for Client B \"Xyz\" finally did not\n  // end up in the graveyard (see above).\n  //\n  // If neither or both operations point to graveyard, then let `aIsStrong` decide.\n  //\n\n\n  if (a.sourcePosition.isEqual(b.sourcePosition) && !a.targetPosition.isEqual(b.targetPosition) && !context.bWasUndone && context.abRelation != 'splitAtSource') {\n    var aToGraveyard = a.targetPosition.root.rootName == '$graveyard';\n    var bToGraveyard = b.targetPosition.root.rootName == '$graveyard'; // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\n    var aIsWeak = aToGraveyard && !bToGraveyard; // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\n    var bIsWeak = bToGraveyard && !aToGraveyard; // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\n    var forceMove = bIsWeak || !aIsWeak && context.aIsStrong;\n\n    if (forceMove) {\n      var sourcePosition = b.targetPosition._getTransformedByMergeOperation(b);\n\n      var targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n\n      return [new MoveOperation(sourcePosition, a.howMany, targetPosition, 0)];\n    } else {\n      return [new NoOperation(0)];\n    }\n  } // The default case.\n  //\n\n\n  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {\n    a.howMany += b.howMany;\n  }\n\n  a.sourcePosition = a.sourcePosition._getTransformedByMergeOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b); // Handle positions in graveyard.\n  // If graveyard positions are same and `a` operation is strong - do not transform.\n\n  if (!a.graveyardPosition.isEqual(b.graveyardPosition) || !context.aIsStrong) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(MergeOperation, MoveOperation, function (a, b, context) {\n  // Case 1:\n  //\n  // The element to merge got removed.\n  //\n  // Merge operation does support merging elements which are not siblings. So it would not be a problem\n  // from technical point of view. However, if the element was removed, the intention of the user deleting it\n  // was to have it all deleted, together with its children. From user experience point of view, moving back the\n  // removed nodes might be unexpected. This means that in this scenario we will block the merging.\n  //\n  // The exception of this rule would be if the remove operation was later undone.\n  //\n  var removedRange = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n\n  if (b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {\n    if (a.deletionPosition.hasSameParentAs(b.sourcePosition) && removedRange.containsPosition(a.sourcePosition)) {\n      return [new NoOperation(0)];\n    }\n  } // The default case.\n  //\n\n\n  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {\n    a.howMany += b.howMany;\n  }\n\n  if (a.sourcePosition.hasSameParentAs(b.sourcePosition)) {\n    a.howMany -= b.howMany;\n  }\n\n  a.sourcePosition = a.sourcePosition._getTransformedByMoveOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedByMoveOperation(b); // `MergeOperation` graveyard position is like `MoveOperation` target position. It is a position where element(s) will\n  // be moved. Like in other similar cases, we need to consider the scenario when those positions are same.\n  // Here, we will treat `MergeOperation` like it is always strong (see `InsertOperation` x `InsertOperation` for comparison).\n  // This means that we won't transform graveyard position if it is equal to move operation target position.\n\n  if (!a.graveyardPosition.isEqual(b.targetPosition)) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(MergeOperation, SplitOperation, function (a, b, context) {\n  if (b.graveyardPosition) {\n    // If `b` operation defines graveyard position, a node from graveyard will be moved. This means that we need to\n    // transform `a.graveyardPosition` accordingly.\n    a.graveyardPosition = a.graveyardPosition._getTransformedByDeletion(b.graveyardPosition, 1); // This is a scenario foreseen in `MergeOperation` x `MergeOperation`, with two identical merge operations.\n    //\n    // So, there was `MergeOperation` x `MergeOperation` transformation earlier. Now, `a` is a merge operation which\n    // source position is in graveyard. Interestingly, split operation wants to use the node to be merged by `a`. This\n    // means that `b` is undoing that merge operation from earlier, which caused `a` to be in graveyard.\n    //\n    // If that's the case, at this point, we will only \"fix\" `a.howMany`. It was earlier set to `0` in\n    // `MergeOperation` x `MergeOperation` transformation. Later transformations in this function will change other\n    // properties.\n    //\n\n    if (a.deletionPosition.isEqual(b.graveyardPosition)) {\n      a.howMany = b.howMany;\n    }\n  } // Case 1:\n  //\n  // Merge operation moves nodes to the place where split happens.\n  // This is a classic situation when there are two paragraphs, and there is a split (enter) after the first\n  // paragraph and there is a merge (delete) at the beginning of the second paragraph:\n  //\n  // <p>Foo{}</p><p>[]Bar</p>.\n  //\n  // Split is after `Foo`, while merge is from `Bar` to the end of `Foo`.\n  //\n  // State after split:\n  // <p>Foo</p><p></p><p>Bar</p>\n  //\n  // Now, `Bar` should be merged to the new paragraph:\n  // <p>Foo</p><p>Bar</p>\n  //\n  // Instead of merging it to the original paragraph:\n  // <p>FooBar</p><p></p>\n  //\n  // This means that `targetPosition` needs to be transformed. This is the default case though.\n  // For example, if the split would be after `F`, `targetPosition` should also be transformed.\n  //\n  // There are three exceptions, though, when we want to keep `targetPosition` as it was.\n  //\n  // First exception is when the merge target position is inside an element (not at the end, as usual). This\n  // happens when the merge operation earlier was transformed by \"the same\" merge operation. If merge operation\n  // targets inside the element we want to keep the original target position (and not transform it) because\n  // we have additional context telling us that we want to merge to the original element. We can check if the\n  // merge operation points inside element by checking what is `SplitOperation#howMany`. Since merge target position\n  // is same as split position, if `howMany` is non-zero, it means that the merge target position is inside an element.\n  //\n  // Second exception is when the element to merge is in the graveyard and split operation uses it. In that case\n  // if target position would be transformed, the merge operation would target at the source position:\n  //\n  // root: <p>Foo</p>\t\t\t\tgraveyard: <p></p>\n  //\n  // SplitOperation: root [ 0, 3 ] using graveyard [ 0 ] (howMany = 0)\n  // MergeOperation: graveyard [ 0, 0 ] -> root [ 0, 3 ] (howMany = 0)\n  //\n  // Since split operation moves the graveyard node back to the root, the merge operation source position changes.\n  // We would like to merge from the empty <p> to the \"Foo\" <p>:\n  //\n  // root: <p>Foo</p><p></p>\t\t\tgraveyard:\n  //\n  // MergeOperation#sourcePosition = root [ 1, 0 ]\n  //\n  // If `targetPosition` is transformed, it would become root [ 1, 0 ] as well. It has to be kept as it was.\n  //\n  // Third exception is connected with relations. If this happens during undo and we have explicit information\n  // that target position has not been affected by the operation which is undone by this split then this split should\n  // not move the target position either.\n  //\n\n\n  if (a.targetPosition.isEqual(b.splitPosition)) {\n    var mergeInside = b.howMany != 0;\n    var mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual(b.graveyardPosition);\n\n    if (mergeInside || mergeSplittingElement || context.abRelation == 'mergeTargetNotMoved') {\n      a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n  } // Case 2:\n  //\n  // Merge source is at the same position as split position. This sometimes happen, mostly during undo.\n  // The decision here is mostly to choose whether merge source position should stay where it is (so it will be at the end of the\n  // split element) or should be move to the beginning of the new element.\n  //\n\n\n  if (a.sourcePosition.isEqual(b.splitPosition)) {\n    // Use context to check if `SplitOperation` is not undoing a merge operation, that didn't change the `a` operation.\n    // This scenario happens the undone merge operation moved nodes at the source position of `a` operation.\n    // In that case `a` operation source position should stay where it is.\n    if (context.abRelation == 'mergeSourceNotMoved') {\n      a.howMany = 0;\n      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n      return [a];\n    } // This merge operation might have been earlier transformed by a merge operation which both merged the same element.\n    // See that case in `MergeOperation` x `MergeOperation` transformation. In that scenario, if the merge operation has been undone,\n    // the special case is not applied.\n    //\n    // Now, the merge operation is transformed by the split which has undone that previous merge operation.\n    // So now we are fixing situation which was skipped in `MergeOperation` x `MergeOperation` case.\n    //\n\n\n    if (context.abRelation == 'mergeSameElement' || a.sourcePosition.offset > 0) {\n      a.sourcePosition = b.moveTargetPosition.clone();\n      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n  } // The default case.\n  //\n\n\n  if (a.sourcePosition.hasSameParentAs(b.splitPosition)) {\n    a.howMany = b.splitPosition.offset;\n  }\n\n  a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);\n  a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n  return [a];\n}); // -----------------------\n\nsetTransformation(MoveOperation, InsertOperation, function (a, b) {\n  var moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  var transformed = moveRange._getTransformedByInsertOperation(b, false)[0];\n\n  a.sourcePosition = transformed.start;\n  a.howMany = transformed.end.offset - transformed.start.offset; // See `InsertOperation` x `MoveOperation` transformation for details on this case.\n  //\n  // In summary, both operations point to the same place, so the order of nodes needs to be decided.\n  // `MoveOperation` is considered weaker, so it is always transformed, unless there was a certain relation\n  // between operations.\n  //\n\n  if (!a.targetPosition.isEqual(b.position)) {\n    a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(MoveOperation, MoveOperation, function (a, b, context) {\n  //\n  // Setting and evaluating some variables that will be used in special cases and default algorithm.\n  //\n  // Create ranges from `MoveOperations` properties.\n  var rangeA = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  var rangeB = Range._createFromPositionAndShift(b.sourcePosition, b.howMany); // Assign `context.aIsStrong` to a different variable, because the value may change during execution of\n  // this algorithm and we do not want to override original `context.aIsStrong` that will be used in later transformations.\n\n\n  var aIsStrong = context.aIsStrong; // This will be used to decide the order of nodes if both operations target at the same position.\n  // By default, use strong/weak operation mechanism.\n\n  var insertBefore = !context.aIsStrong; // If the relation is set, then use it to decide nodes order.\n\n  if (context.abRelation == 'insertBefore' || context.baRelation == 'insertAfter') {\n    insertBefore = true;\n  } else if (context.abRelation == 'insertAfter' || context.baRelation == 'insertBefore') {\n    insertBefore = false;\n  } // `a.targetPosition` could be affected by the `b` operation. We will transform it.\n\n\n  var newTargetPosition;\n\n  if (a.targetPosition.isEqual(b.targetPosition) && insertBefore) {\n    newTargetPosition = a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);\n  } else {\n    newTargetPosition = a.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n  } //\n  // Special case #1 + mirror.\n  //\n  // Special case when both move operations' target positions are inside nodes that are\n  // being moved by the other move operation. So in other words, we move ranges into inside of each other.\n  // This case can't be solved reasonably (on the other hand, it should not happen often).\n\n\n  if (_moveTargetIntoMovedRange(a, b) && _moveTargetIntoMovedRange(b, a)) {\n    // Instead of transforming operation, we return a reverse of the operation that we transform by.\n    // So when the results of this \"transformation\" will be applied, `b` MoveOperation will get reversed.\n    return [b.getReversed()];\n  } //\n  // End of special case #1.\n  //\n  //\n  // Special case #2.\n  //\n  // Check if `b` operation targets inside `rangeA`.\n\n\n  var bTargetsToA = rangeA.containsPosition(b.targetPosition); // If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.\n  // You might say that operation `b` is captured inside operation `a`.\n\n  if (bTargetsToA && rangeA.containsRange(rangeB, true)) {\n    // There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why\n    // we need to transform `a` operation anyway.\n    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n  } //\n  // Special case #2 mirror.\n  //\n\n\n  var aTargetsToB = rangeB.containsPosition(a.targetPosition);\n\n  if (aTargetsToB && rangeB.containsRange(rangeA, true)) {\n    // `a` operation is \"moved together\" with `b` operation.\n    // Here, just move `rangeA` \"inside\" `rangeB`.\n    rangeA.start = rangeA.start._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    rangeA.end = rangeA.end._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n  } //\n  // End of special case #2.\n  //\n  //\n  // Special case #3 + mirror.\n  //\n  // `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`\n  // but not on the same tree level. In such case ranges have common part but we have to treat it\n  // differently, because in such case those ranges are not really conflicting and should be treated like\n  // two separate ranges. Also we have to discard two difference parts.\n\n\n  var aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());\n\n  if (aCompB == 'prefix' || aCompB == 'extension') {\n    // Transform `rangeA` by `b` operation and make operation out of it, and that's all.\n    // Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)\n    // like a one difference part.\n    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);\n    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);\n  } //\n  // End of special case #3.\n  //\n  //\n  // Default case - ranges are on the same level or are not connected with each other.\n  //\n  // Modifier for default case.\n  // Modifies `aIsStrong` flag in certain conditions.\n  //\n  // If only one of operations is a remove operation, we force remove operation to be the \"stronger\" one\n  // to provide more expected results.\n\n\n  if (a.type == 'remove' && b.type != 'remove' && !context.aWasUndone && !context.forceWeakRemove) {\n    aIsStrong = true;\n  } else if (a.type != 'remove' && b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {\n    aIsStrong = false;\n  } // Handle operation's source ranges - check how `rangeA` is affected by `b` operation.\n  // This will aggregate transformed ranges.\n\n\n  var ranges = []; // Get the \"difference part\" of `a` operation source range.\n  // This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.\n\n  var difference = rangeA.getDifference(rangeB);\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = difference[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var range = _step6.value;\n      // Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.\n      range.start = range.start._getTransformedByDeletion(b.sourcePosition, b.howMany);\n      range.end = range.end._getTransformedByDeletion(b.sourcePosition, b.howMany); // If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.\n\n      var shouldSpread = compareArrays(range.start.getParentPath(), b.getMovedRangeStart().getParentPath()) == 'same';\n\n      var newRanges = range._getTransformedByInsertion(b.getMovedRangeStart(), b.howMany, shouldSpread);\n\n      ranges.push.apply(ranges, _toConsumableArray(newRanges));\n    } // Then, we have to manage the \"common part\" of both move ranges.\n\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n        _iterator6.return();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n\n  var common = rangeA.getIntersection(rangeB);\n\n  if (common !== null && aIsStrong) {\n    // Calculate the new position of that part of original range.\n    common.start = common.start._getCombined(b.sourcePosition, b.getMovedRangeStart());\n    common.end = common.end._getCombined(b.sourcePosition, b.getMovedRangeStart()); // Take care of proper range order.\n    //\n    // Put `common` at appropriate place. Keep in mind that we are interested in original order.\n    // Basically there are only three cases: there is zero, one or two difference ranges.\n    //\n    // If there is zero difference ranges, just push `common` in the array.\n\n    if (ranges.length === 0) {\n      ranges.push(common);\n    } // If there is one difference range, we need to check whether common part was before it or after it.\n    else if (ranges.length == 1) {\n        if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {\n          ranges.unshift(common);\n        } else {\n          ranges.push(common);\n        }\n      } // If there are more ranges (which means two), put common part between them. This is the only scenario\n      // where there could be two difference ranges so we don't have to make any comparisons.\n      else {\n          ranges.splice(1, 0, common);\n        }\n  }\n\n  if (ranges.length === 0) {\n    // If there are no \"source ranges\", nothing should be changed.\n    // Note that this can happen only if `aIsStrong == false` and `rangeA.isEqual( rangeB )`.\n    return [new NoOperation(a.baseVersion)];\n  }\n\n  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n});\nsetTransformation(MoveOperation, SplitOperation, function (a, b, context) {\n  var newTargetPosition = a.targetPosition.clone(); // Do not transform if target position is same as split insertion position and this split comes from undo.\n  // This should be done on relations but it is too much work for now as it would require relations working in collaboration.\n  // We need to make a decision how we will resolve such conflict and this is less harmful way.\n\n  if (!a.targetPosition.isEqual(b.insertionPosition) || !b.graveyardPosition || context.abRelation == 'moveTargetAfter') {\n    newTargetPosition = a.targetPosition._getTransformedBySplitOperation(b);\n  } // Case 1:\n  //\n  // Last element in the moved range got split.\n  //\n  // In this case the default range transformation will not work correctly as the element created by\n  // split operation would be outside the range. The range to move needs to be fixed manually.\n  //\n\n\n  var moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  if (moveRange.end.isEqual(b.insertionPosition)) {\n    // Do it only if this is a \"natural\" split, not a one that comes from undo.\n    // If this is undo split, only `targetPosition` needs to be changed (if the move is a remove).\n    if (!b.graveyardPosition) {\n      a.howMany++;\n    }\n\n    a.targetPosition = newTargetPosition;\n    return [a];\n  } // Case 2:\n  //\n  // Split happened between the moved nodes. In this case two ranges to move need to be generated.\n  //\n  // Characters `ozba` are moved to the end of paragraph `Xyz` but split happened.\n  // <p>F[oz|ba]r</p><p>Xyz</p>\n  //\n  // After split:\n  // <p>F[oz</p><p>ba]r</p><p>Xyz</p>\n  //\n  // Correct ranges:\n  // <p>F[oz]</p><p>[ba]r</p><p>Xyz</p>\n  //\n  // After move:\n  // <p>F</p><p>r</p><p>Xyzozba</p>\n  //\n\n\n  if (moveRange.start.hasSameParentAs(b.splitPosition) && moveRange.containsPosition(b.splitPosition)) {\n    var rightRange = new Range(b.splitPosition, moveRange.end);\n    rightRange = rightRange._getTransformedBySplitOperation(b);\n    var _ranges = [new Range(moveRange.start, b.splitPosition), rightRange];\n    return _makeMoveOperationsFromRanges(_ranges, newTargetPosition);\n  } // Case 3:\n  //\n  // Move operation targets at the split position. We need to decide if the nodes should be inserted\n  // at the end of the split element or at the beginning of the new element.\n  //\n\n\n  if (a.targetPosition.isEqual(b.splitPosition) && context.abRelation == 'insertAtSource') {\n    newTargetPosition = b.moveTargetPosition;\n  } // Case 4:\n  //\n  // Move operation targets just after the split element. We need to decide if the nodes should be inserted\n  // between two parts of split element, or after the new element.\n  //\n  // Split at `|`, while move operation moves `<p>Xyz</p>` and targets at `^`:\n  // <p>Foo|bar</p>^<p>baz</p>\n  // <p>Foo</p>^<p>bar</p><p>baz</p> or <p>Foo</p><p>bar</p>^<p>baz</p>?\n  //\n  // If there is no contextual information between operations (for example, they come from collaborative\n  // editing), we don't want to put some unrelated content (move) between parts of related content (split parts).\n  // However, if the split is from undo, in the past, the moved content might be targeting between the\n  // split parts, meaning that was exactly user's intention:\n  //\n  // <p>Foo</p>^<p>bar</p>\t\t<--- original situation, in \"past\".\n  // <p>Foobar</p>^\t\t\t\t<--- after merge target position is transformed.\n  // <p>Foo|bar</p>^\t\t\t\t<--- then the merge is undone, and split happens, which leads us to current situation.\n  //\n  // In this case it is pretty clear that the intention was to put new paragraph between those nodes,\n  // so we need to transform accordingly. We can detect this scenario thanks to relations.\n  //\n\n\n  if (a.targetPosition.isEqual(b.insertionPosition) && context.abRelation == 'insertBetween') {\n    newTargetPosition = a.targetPosition;\n  } // The default case.\n  //\n\n\n  var transformed = moveRange._getTransformedBySplitOperation(b);\n\n  var ranges = [transformed]; // Case 5:\n  //\n  // Moved range contains graveyard element used by split operation. Add extra move operation to the result.\n  //\n\n  if (b.graveyardPosition) {\n    var movesGraveyardElement = moveRange.start.isEqual(b.graveyardPosition) || moveRange.containsPosition(b.graveyardPosition);\n\n    if (a.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {\n      ranges.push(Range._createFromPositionAndShift(b.insertionPosition, 1));\n    }\n  }\n\n  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);\n});\nsetTransformation(MoveOperation, MergeOperation, function (a, b, context) {\n  var movedRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  if (b.deletionPosition.hasSameParentAs(a.sourcePosition) && movedRange.containsPosition(b.sourcePosition)) {\n    if (a.type == 'remove' && !context.forceWeakRemove) {\n      // Case 1:\n      //\n      // The element to remove got merged.\n      //\n      // Merge operation does support merging elements which are not siblings. So it would not be a problem\n      // from technical point of view. However, if the element was removed, the intention of the user\n      // deleting it was to have it all deleted. From user experience point of view, moving back the\n      // removed nodes might be unexpected. This means that in this scenario we will reverse merging and remove the element.\n      //\n      if (!context.aWasUndone) {\n        var results = [];\n        var gyMoveSource = b.graveyardPosition.clone();\n\n        var splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation(b);\n\n        if (a.howMany > 1) {\n          results.push(new MoveOperation(a.sourcePosition, a.howMany - 1, a.targetPosition, 0));\n          gyMoveSource = gyMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);\n          splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);\n        }\n\n        var gyMoveTarget = b.deletionPosition._getCombined(a.sourcePosition, a.targetPosition);\n\n        var gyMove = new MoveOperation(gyMoveSource, 1, gyMoveTarget, 0);\n        var splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();\n        splitNodesMoveTargetPath.push(0);\n        var splitNodesMoveTarget = new Position(gyMove.targetPosition.root, splitNodesMoveTargetPath);\n        splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);\n        var splitNodesMove = new MoveOperation(splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0);\n        results.push(gyMove);\n        results.push(splitNodesMove);\n        return results;\n      }\n    } else {\n      // Case 2:\n      //\n      // The element to move got merged and it was the only element to move.\n      // In this case just don't do anything, leave the node in the graveyard. Without special case\n      // it would be a move operation that moves 0 nodes, so maybe it is better just to return no-op.\n      //\n      if (a.howMany == 1) {\n        if (!context.bWasUndone) {\n          return [new NoOperation(0)];\n        } else {\n          a.sourcePosition = b.graveyardPosition.clone();\n          a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n          return [a];\n        }\n      }\n    }\n  } // The default case.\n  //\n\n\n  var moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);\n\n  var transformed = moveRange._getTransformedByMergeOperation(b);\n\n  a.sourcePosition = transformed.start;\n  a.howMany = transformed.end.offset - transformed.start.offset;\n  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);\n  return [a];\n}); // -----------------------\n\nsetTransformation(RenameOperation, InsertOperation, function (a, b) {\n  a.position = a.position._getTransformedByInsertOperation(b);\n  return [a];\n});\nsetTransformation(RenameOperation, MergeOperation, function (a, b) {\n  // Case 1:\n  //\n  // Element to rename got merged, so it was moved to `b.graveyardPosition`.\n  //\n  if (a.position.isEqual(b.deletionPosition)) {\n    a.position = b.graveyardPosition.clone();\n    a.position.stickiness = 'toNext';\n    return [a];\n  }\n\n  a.position = a.position._getTransformedByMergeOperation(b);\n  return [a];\n});\nsetTransformation(RenameOperation, MoveOperation, function (a, b) {\n  a.position = a.position._getTransformedByMoveOperation(b);\n  return [a];\n});\nsetTransformation(RenameOperation, RenameOperation, function (a, b, context) {\n  if (a.position.isEqual(b.position)) {\n    if (context.aIsStrong) {\n      a.oldName = b.newName;\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n\n  return [a];\n});\nsetTransformation(RenameOperation, SplitOperation, function (a, b) {\n  // Case 1:\n  //\n  // The element to rename has been split. In this case, the new element should be also renamed.\n  //\n  // User decides to change the paragraph to a list item:\n  // <paragraph>Foobar</paragraph>\n  //\n  // However, in meantime, split happens:\n  // <paragraph>Foo</paragraph><paragraph>bar</paragraph>\n  //\n  // As a result, rename both elements:\n  // <listItem>Foo</listItem><listItem>bar</listItem>\n  //\n  var renamePath = a.position.path;\n  var splitPath = b.splitPosition.getParentPath();\n\n  if (compareArrays(renamePath, splitPath) == 'same' && !b.graveyardPosition) {\n    var extraRename = new RenameOperation(a.position.getShiftedBy(1), a.oldName, a.newName, 0);\n    return [a, extraRename];\n  } // The default case.\n  //\n\n\n  a.position = a.position._getTransformedBySplitOperation(b);\n  return [a];\n}); // -----------------------\n\nsetTransformation(RootAttributeOperation, RootAttributeOperation, function (a, b, context) {\n  if (a.root === b.root && a.key === b.key) {\n    if (!context.aIsStrong || a.newValue === b.newValue) {\n      return [new NoOperation(0)];\n    } else {\n      a.oldValue = b.newValue;\n    }\n  }\n\n  return [a];\n}); // -----------------------\n\nsetTransformation(SplitOperation, InsertOperation, function (a, b) {\n  // The default case.\n  //\n  if (a.splitPosition.hasSameParentAs(b.position) && a.splitPosition.offset < b.position.offset) {\n    a.howMany += b.howMany;\n  }\n\n  a.splitPosition = a.splitPosition._getTransformedByInsertOperation(b);\n  a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n  return [a];\n});\nsetTransformation(SplitOperation, MergeOperation, function (a, b, context) {\n  // Case 1:\n  //\n  // Split element got merged. If two different elements were merged, clients will have different content.\n  //\n  // Example. Merge at `{}`, split at `[]`:\n  // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n  //\n  // On merge side it will look like this:\n  // <heading>FooB[]ar</heading>\n  // <heading>FooB</heading><heading>ar</heading>\n  //\n  // On split side it will look like this:\n  // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n  // <heading>FooB</heading><paragraph>ar</paragraph>\n  //\n  // Clearly, the second element is different for both clients.\n  //\n  // We could use the removed merge element from graveyard as a split element but then clients would have a different\n  // model state (in graveyard), because the split side client would still have an element in graveyard (removed by merge).\n  //\n  // To overcome this, in `SplitOperation` x `MergeOperation` transformation we will add additional `SplitOperation`\n  // in the graveyard, which will actually clone the merged-and-deleted element. Then, that cloned element will be\n  // used for splitting. Example below.\n  //\n  // Original state:\n  // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n  //\n  // Merge side client:\n  //\n  // After merge:\n  // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph>\n  //\n  // Extra split:\n  // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph><paragraph></paragraph>\n  //\n  // Use the \"cloned\" element from graveyard:\n  // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n  //\n  // Split side client:\n  //\n  // After split:\n  // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n  //\n  // After merge:\n  // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n  //\n  // This special case scenario only applies if the original split operation clones the split element.\n  // If the original split operation has `graveyardPosition` set, it all doesn't have sense because split operation\n  // knows exactly which element it should use. So there would be no original problem with different contents.\n  //\n  // Additionally, the special case applies only if the merge wasn't already undone.\n  //\n  if (!a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs(b.sourcePosition)) {\n    var splitPath = b.graveyardPosition.path.slice();\n    splitPath.push(0);\n    var splitPosition = new Position(b.graveyardPosition.root, splitPath);\n    var insertionPosition = SplitOperation.getInsertionPosition(new Position(b.graveyardPosition.root, splitPath));\n    var additionalSplit = new SplitOperation(splitPosition, 0, null, 0);\n    additionalSplit.insertionPosition = insertionPosition;\n    a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    a.graveyardPosition = additionalSplit.insertionPosition.clone();\n    a.graveyardPosition.stickiness = 'toNext';\n    return [additionalSplit, a];\n  } // The default case.\n  //\n\n\n  if (a.splitPosition.hasSameParentAs(b.deletionPosition) && !a.splitPosition.isAfter(b.deletionPosition)) {\n    a.howMany--;\n  }\n\n  if (a.splitPosition.hasSameParentAs(b.targetPosition)) {\n    a.howMany += b.howMany;\n  }\n\n  a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);\n  a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n\n  if (a.graveyardPosition) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);\n  }\n\n  return [a];\n});\nsetTransformation(SplitOperation, MoveOperation, function (a, b, context) {\n  var rangeToMove = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);\n\n  if (a.graveyardPosition) {\n    // Case 1:\n    //\n    // Split operation graveyard node was moved. In this case move operation is stronger. Since graveyard element\n    // is already moved to the correct position, we need to only move the nodes after the split position.\n    // This will be done by `MoveOperation` instead of `SplitOperation`.\n    //\n    var gyElementMoved = rangeToMove.start.isEqual(a.graveyardPosition) || rangeToMove.containsPosition(a.graveyardPosition);\n\n    if (!context.bWasUndone && gyElementMoved) {\n      var sourcePosition = a.splitPosition._getTransformedByMoveOperation(b);\n\n      var newParentPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n\n      var newTargetPath = newParentPosition.path.slice();\n      newTargetPath.push(0);\n      var newTargetPosition = new Position(newParentPosition.root, newTargetPath);\n      var moveOp = new MoveOperation(sourcePosition, a.howMany, newTargetPosition, 0);\n      return [moveOp];\n    }\n\n    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);\n  } // Case 2:\n  //\n  // If the split position is inside the moved range, we need to shift the split position to a proper place.\n  // The position cannot be moved together with moved range because that would result in splitting of an incorrect element.\n  //\n  // Characters `bc` should be moved to the second paragraph while split position is between them:\n  // <paragraph>A[b|c]d</paragraph><paragraph>Xyz</paragraph>\n  //\n  // After move, new split position is incorrect:\n  // <paragraph>Ad</paragraph><paragraph>Xb|cyz</paragraph>\n  //\n  // Correct split position:\n  // <paragraph>A|d</paragraph><paragraph>Xbcyz</paragraph>\n  //\n  // After split:\n  // <paragraph>A</paragraph><paragraph>d</paragraph><paragraph>Xbcyz</paragraph>\n  //\n\n\n  if (a.splitPosition.hasSameParentAs(b.sourcePosition) && rangeToMove.containsPosition(a.splitPosition)) {\n    var howManyRemoved = b.howMany - (a.splitPosition.offset - b.sourcePosition.offset);\n    a.howMany -= howManyRemoved;\n\n    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {\n      a.howMany += b.howMany;\n    }\n\n    a.splitPosition = b.sourcePosition.clone();\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    return [a];\n  } // Case 3:\n  //\n  // Split is at a position where nodes were moved.\n  //\n  // This is a scenario described in `MoveOperation` x `SplitOperation` transformation but from the\n  // \"split operation point of view\".\n  //\n\n\n  var splitAtTarget = a.splitPosition.isEqual(b.targetPosition);\n\n  if (splitAtTarget && (context.baRelation == 'insertAtSource' || context.abRelation == 'splitBefore')) {\n    a.howMany += b.howMany;\n    a.splitPosition = a.splitPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n    return [a];\n  } // The default case.\n  // Don't change `howMany` if move operation does not really move anything.\n  //\n\n\n  if (!b.sourcePosition.isEqual(b.targetPosition)) {\n    if (a.splitPosition.hasSameParentAs(b.sourcePosition) && a.splitPosition.offset <= b.sourcePosition.offset) {\n      a.howMany -= b.howMany;\n    }\n\n    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {\n      a.howMany += b.howMany;\n    }\n  } // Change position stickiness to force a correct transformation.\n\n\n  a.splitPosition.stickiness = 'toNone';\n  a.splitPosition = a.splitPosition._getTransformedByMoveOperation(b);\n  a.splitPosition.stickiness = 'toNext';\n\n  if (a.graveyardPosition) {\n    a.insertionPosition = a.insertionPosition._getTransformedByMoveOperation(b);\n  } else {\n    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n  }\n\n  return [a];\n});\nsetTransformation(SplitOperation, SplitOperation, function (a, b, context) {\n  // Case 1:\n  //\n  // Split at the same position.\n  //\n  // If there already was a split at the same position as in `a` operation, it means that the intention\n  // conveyed by `a` operation has already been fulfilled and `a` should not do anything (to avoid double split).\n  //\n  // However, there is a difference if these are new splits or splits created by undo. These have different\n  // intentions. Also splits moving back different elements from graveyard have different intentions. They\n  // are just different operations.\n  //\n  // So we cancel split operation only if it was really identical.\n  //\n  // Also, there is additional case, where split operations aren't identical and should not be cancelled, however the\n  // default transformation is incorrect too.\n  //\n  if (a.splitPosition.isEqual(b.splitPosition)) {\n    if (!a.graveyardPosition && !b.graveyardPosition) {\n      return [new NoOperation(0)];\n    }\n\n    if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {\n      return [new NoOperation(0)];\n    } // Use context to know that the `a.splitPosition` should stay where it is.\n    // This happens during undo when first a merge operation moved nodes to `a.splitPosition` and now `b` operation undoes that merge.\n\n\n    if (context.abRelation == 'splitBefore') {\n      // Since split is at the same position, there are no nodes left to split.\n      a.howMany = 0; // Note: there was `if ( a.graveyardPosition )` here but it was uncovered in tests and I couldn't find any scenarios for now.\n      // That would have to be a `SplitOperation` that didn't come from undo but is transformed by operations that were undone.\n      // It could happen if `context` is enabled in collaboration.\n\n      a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);\n      return [a];\n    }\n  } // Case 2:\n  //\n  // Same node is using to split different elements. This happens in undo when previously same element was merged to\n  // two different elements. This is described in `MergeOperation` x `MergeOperation` transformation.\n  //\n  // In this case we will follow the same logic. We will assume that `insertionPosition` is same for both\n  // split operations. This might not always be true but in the real cases that were experienced it was. After all,\n  // if these splits are reverses of merge operations that were merging the same element, then the `insertionPosition`\n  // should be same for both of those splits.\n  //\n  // Again, we will decide which operation is stronger by checking if split happens in graveyard or in non-graveyard root.\n  //\n\n\n  if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {\n    var aInGraveyard = a.splitPosition.root.rootName == '$graveyard';\n    var bInGraveyard = b.splitPosition.root.rootName == '$graveyard'; // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\n    var aIsWeak = aInGraveyard && !bInGraveyard; // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\n    var bIsWeak = bInGraveyard && !aInGraveyard; // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\n    var forceMove = bIsWeak || !aIsWeak && context.aIsStrong;\n\n    if (forceMove) {\n      var result = []; // First we need to move any nodes split by `b` back to where they were.\n      // Do it only if `b` actually moved something.\n\n      if (b.howMany) {\n        result.push(new MoveOperation(b.moveTargetPosition, b.howMany, b.splitPosition, 0));\n      } // Then we need to move nodes from `a` split position to their new element.\n      // Do it only if `a` actually should move something.\n\n\n      if (a.howMany) {\n        result.push(new MoveOperation(a.splitPosition, a.howMany, a.moveTargetPosition, 0));\n      }\n\n      return result;\n    } else {\n      return [new NoOperation(0)];\n    }\n  }\n\n  if (a.graveyardPosition) {\n    a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);\n  } // Case 3:\n  //\n  // Position where operation `b` inserted a new node after split is the same as the operation `a` split position.\n  // As in similar cases, there is ambiguity if the split should be before the new node (created by `b`) or after.\n  //\n\n\n  if (a.splitPosition.isEqual(b.insertionPosition) && context.abRelation == 'splitBefore') {\n    a.howMany++;\n    return [a];\n  } // Case 4:\n  //\n  // This is a mirror to the case 2. above.\n  //\n\n\n  if (b.splitPosition.isEqual(a.insertionPosition) && context.baRelation == 'splitBefore') {\n    var newPositionPath = b.insertionPosition.path.slice();\n    newPositionPath.push(0);\n    var newPosition = new Position(b.insertionPosition.root, newPositionPath);\n    var moveOp = new MoveOperation(a.insertionPosition, 1, newPosition, 0);\n    return [a, moveOp];\n  } // The default case.\n  //\n\n\n  if (a.splitPosition.hasSameParentAs(b.splitPosition) && a.splitPosition.offset < b.splitPosition.offset) {\n    a.howMany -= b.howMany;\n  }\n\n  a.splitPosition = a.splitPosition._getTransformedBySplitOperation(b);\n  a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);\n  return [a];\n}); // Checks whether `MoveOperation` `targetPosition` is inside a node from the moved range of the other `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/operation/moveoperation~MoveOperation} a\n// @param {module:engine/model/operation/moveoperation~MoveOperation} b\n// @returns {Boolean}\n\nfunction _moveTargetIntoMovedRange(a, b) {\n  return a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;\n} // Helper function for `MoveOperation` x `MoveOperation` transformation. Converts given ranges and target position to\n// move operations and returns them.\n//\n// Ranges and target position will be transformed on-the-fly when generating operations.\n//\n// Given `ranges` should be in the order of how they were in the original transformed operation.\n//\n// Given `targetPosition` is the target position of the first range from `ranges`.\n//\n// @private\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @param {module:engine/model/position~Position} targetPosition\n// @returns {Array.<module:engine/model/operation/moveoperation~MoveOperation>}\n\n\nfunction _makeMoveOperationsFromRanges(ranges, targetPosition) {\n  // At this moment we have some ranges and a target position, to which those ranges should be moved.\n  // Order in `ranges` array is the go-to order of after transformation.\n  //\n  // We are almost done. We have `ranges` and `targetPosition` to make operations from.\n  // Unfortunately, those operations may affect each other. Precisely, first operation after move\n  // may affect source range and target position of second and third operation. Same with second\n  // operation affecting third.\n  //\n  // We need to fix those source ranges and target positions once again, before converting `ranges` to operations.\n  var operations = []; // Keep in mind that nothing will be transformed if there is just one range in `ranges`.\n\n  for (var i = 0; i < ranges.length; i++) {\n    // Create new operation out of a range and target position.\n    var range = ranges[i];\n    var op = new MoveOperation(range.start, range.end.offset - range.start.offset, targetPosition, 0);\n    operations.push(op); // Transform other ranges by the generated operation.\n\n    for (var j = i + 1; j < ranges.length; j++) {\n      // All ranges in `ranges` array should be:\n      //\n      // * non-intersecting (these are part of original operation source range), and\n      // * `targetPosition` does not target into them (opposite would mean that transformed operation targets \"inside itself\").\n      //\n      // This means that the transformation will be \"clean\" and always return one result.\n      ranges[j] = ranges[j]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];\n    }\n\n    targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);\n  }\n\n  return operations;\n}","import \"core-js/modules/es6.array.find-index\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module undo/undocommand\n */\nimport BaseCommand from \"./basecommand\";\n/**\n * The undo command stores {@link module:engine/model/batch~Batch batches} applied to the\n * {@link module:engine/model/document~Document document} and is able to undo a batch by reversing it and transforming by\n * batches from {@link module:engine/model/document~Document#history history} that happened after the reversed batch.\n *\n * The undo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.\n *\n * @extends module:undo/basecommand~BaseCommand\n */\n\nvar UndoCommand =\n/*#__PURE__*/\nfunction (_BaseCommand) {\n  _inherits(UndoCommand, _BaseCommand);\n\n  function UndoCommand() {\n    _classCallCheck(this, UndoCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UndoCommand).apply(this, arguments));\n  }\n\n  _createClass(UndoCommand, [{\n    key: \"execute\",\n\n    /**\n     * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms\n     * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.\n     * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.\n     *\n     * @fires execute\n     * @fires revert\n     * @param {module:engine/model/batch~Batch} [batch] A batch that should be undone. If not set, the last added batch will be undone.\n     */\n    value: function execute() {\n      var _this = this;\n\n      var batch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      // If batch is not given, set `batchIndex` to the last index in command stack.\n      var batchIndex = batch ? this._stack.findIndex(function (a) {\n        return a.batch == batch;\n      }) : this._stack.length - 1;\n\n      var item = this._stack.splice(batchIndex, 1)[0];\n\n      var undoingBatch = this.editor.model.createBatch(); // All changes has to be done in one `enqueueChange` callback so other listeners will not\n      // step between consecutive operations, or won't do changes to the document before selection is properly restored.\n\n      this.editor.model.enqueueChange(undoingBatch, function () {\n        _this._undo(item.batch, undoingBatch);\n\n        var operations = _this.editor.model.document.history.getOperations(item.batch.baseVersion);\n\n        _this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);\n\n        _this.fire('revert', item.batch, undoingBatch);\n      });\n      this.refresh();\n    }\n  }]);\n\n  return UndoCommand;\n}(BaseCommand);\n/**\n * Fired when execution of the command reverts some batch.\n *\n * @event revert\n */\n\n\nexport { UndoCommand as default };","import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat/inlineautoformatediting\n */\n\n/**\n * The inline autoformatting engine. It allows to format various inline patterns. For example,\n * it can be configured to make \"foo\" bold when typed `**foo**` (the `**` markers will be removed).\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the constructors documentation to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n */\nvar InlineAutoformatEditing =\n/**\n * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.\n *\n * It formats the matched text by applying the given model attribute or by running the provided formatting callback.\n * On every change applied to the model the autoformatting engine checks the text on the left of the selection\n * and executes the provided action if the text matches given criteria (regular expression or callback).\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n * @param {Function|RegExp} testRegexpOrCallback The regular expression or callback to execute on text.\n * Provided regular expression *must* have three capture groups. The first and the third capture group\n * should match opening and closing delimiters. The second capture group should match the text to format.\n *\n *\t\t// Matches the `**bold text**` pattern.\n *\t\t// There are three capturing groups:\n *\t\t// - The first to match the starting `**` delimiter.\n *\t\t// - The second to match the text to format.\n *\t\t// - The third to match the ending `**` delimiter.\n *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, 'bold' );\n *\n * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.\n * The function should return proper \"ranges\" to delete and format.\n *\n *\t\t{\n *\t\t\tremove: [\n *\t\t\t\t[ 0, 1 ],\t// Remove the first letter from the given text.\n *\t\t\t\t[ 5, 6 ]\t// Remove the 6th letter from the given text.\n *\t\t\t],\n *\t\t\tformat: [\n *\t\t\t\t[ 1, 5 ]\t// Format all letters from 2nd to 5th.\n *\t\t\t]\n *\t\t}\n *\n * @param {Function|String} attributeOrCallback The name of attribute to apply on matching text or a callback for manual\n * formatting. If callback is passed it should return `false` if changes should not be applied (e.g. if a command is disabled).\n *\n *\t\t// Use attribute name:\n *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, 'bold' );\n *\n *\t\t// Use formatting callback:\n *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, ( writer, rangesToFormat ) => {\n *\t\t\tconst command = editor.commands.get( 'bold' );\n *\n *\t\t\tif ( !command.isEnabled ) {\n *\t\t\t\treturn false;\n *\t\t\t}\n *\n *\t\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );\n *\n *\t\t\tfor ( let range of validRanges ) {\n *\t\t\t\twriter.setAttribute( 'bold', true, range );\n *\t\t\t}\n *\t\t} );\n */\nfunction InlineAutoformatEditing(editor, testRegexpOrCallback, attributeOrCallback) {\n  _classCallCheck(this, InlineAutoformatEditing);\n\n  var regExp;\n  var attributeKey;\n  var testCallback;\n  var formatCallback;\n\n  if (testRegexpOrCallback instanceof RegExp) {\n    regExp = testRegexpOrCallback;\n  } else {\n    testCallback = testRegexpOrCallback;\n  }\n\n  if (typeof attributeOrCallback == 'string') {\n    attributeKey = attributeOrCallback;\n  } else {\n    formatCallback = attributeOrCallback;\n  } // A test callback run on changed text.\n\n\n  testCallback = testCallback || function (text) {\n    var result;\n    var remove = [];\n    var format = [];\n\n    while ((result = regExp.exec(text)) !== null) {\n      // There should be full match and 3 capture groups.\n      if (result && result.length < 4) {\n        break;\n      }\n\n      var _result = result,\n          index = _result.index,\n          leftDel = _result['1'],\n          content = _result['2'],\n          rightDel = _result['3']; // Real matched string - there might be some non-capturing groups so we need to recalculate starting index.\n\n      var found = leftDel + content + rightDel;\n      index += result[0].length - found.length; // Start and End offsets of delimiters to remove.\n\n      var delStart = [index, index + leftDel.length];\n      var delEnd = [index + leftDel.length + content.length, index + leftDel.length + content.length + rightDel.length];\n      remove.push(delStart);\n      remove.push(delEnd);\n      format.push([index + leftDel.length, index + leftDel.length + content.length]);\n    }\n\n    return {\n      remove: remove,\n      format: format\n    };\n  }; // A format callback run on matched text.\n\n\n  formatCallback = formatCallback || function (writer, rangesToFormat) {\n    var validRanges = editor.model.schema.getValidRanges(rangesToFormat, attributeKey);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = validRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var range = _step.value;\n        writer.setAttribute(attributeKey, true, range);\n      } // After applying attribute to the text, remove given attribute from the selection.\n      // This way user is able to type a text without attribute used by auto formatter.\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    writer.removeSelectionAttribute(attributeKey);\n  };\n\n  editor.model.document.on('change', function (evt, batch) {\n    if (batch.type == 'transparent') {\n      return;\n    }\n\n    var selection = editor.model.document.selection; // Do nothing if selection is not collapsed.\n\n    if (!selection.isCollapsed) {\n      return;\n    }\n\n    var changes = Array.from(editor.model.document.differ.getChanges());\n    var entry = changes[0]; // Typing is represented by only a single change.\n\n    if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {\n      return;\n    }\n\n    var block = selection.focus.parent;\n    var text = getText(block).slice(0, selection.focus.offset);\n    var testOutput = testCallback(text);\n    var rangesToFormat = testOutputToRanges(block, testOutput.format, editor.model);\n    var rangesToRemove = testOutputToRanges(block, testOutput.remove, editor.model);\n\n    if (!(rangesToFormat.length && rangesToRemove.length)) {\n      return;\n    } // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\n\n    editor.model.enqueueChange(function (writer) {\n      // Apply format.\n      var hasChanged = formatCallback(writer, rangesToFormat); // Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).\n\n      if (hasChanged === false) {\n        return;\n      } // Remove delimiters - use reversed order to not mix the offsets while removing.\n\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = rangesToRemove.reverse()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var range = _step2.value;\n          writer.remove(range);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n  });\n}; // Returns whole text from parent element by adding all data from text nodes together.\n//\n// @private\n// @param {module:engine/model/element~Element} element\n// @returns {String}\n\n\nexport { InlineAutoformatEditing as default };\n\nfunction getText(element) {\n  return Array.from(element.getChildren()).reduce(function (a, b) {\n    return a + b.data;\n  }, '');\n} // Converts output of the test function provided to the InlineAutoformatEditing and converts it to the model ranges\n// inside provided block.\n//\n// @private\n// @param {module:engine/model/element~Element} block\n// @param {Array.<Array>} arrays\n// @param {module:engine/model/model~Model} model\n\n\nfunction testOutputToRanges(block, arrays, model) {\n  return arrays.filter(function (array) {\n    return array[0] !== undefined && array[1] !== undefined;\n  }).map(function (array) {\n    return model.createRange(model.createPositionAt(block, array[0]), model.createPositionAt(block, array[1]));\n  });\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat/autoformat\n */\nimport BlockAutoformatEditing from \"./blockautoformatediting\";\nimport InlineAutoformatEditing from \"./inlineautoformatediting\";\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n/**\n * Enables a set of predefined autoformatting actions.\n *\n * For a detailed overview, check the {@glink features/autoformat Autoformatting feature documentation}\n * and the {@glink api/autoformat package page}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar Autoformat =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Autoformat, _Plugin);\n\n  function Autoformat() {\n    _classCallCheck(this, Autoformat);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Autoformat).apply(this, arguments));\n  }\n\n  _createClass(Autoformat, [{\n    key: \"afterInit\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function afterInit() {\n      this._addListAutoformats();\n\n      this._addBasicStylesAutoformats();\n\n      this._addHeadingAutoformats();\n\n      this._addBlockQuoteAutoformats();\n    }\n    /**\n     * Adds autoformatting related to the {@link module:list/list~List}.\n     *\n     * When typed:\n     * - `* ` or `- ` &ndash; A paragraph will be changed to a bulleted list.\n     * - `1. ` or `1) ` &ndash; A paragraph will be changed to a numbered list (\"1\" can be any digit or a list of digits).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_addListAutoformats\",\n    value: function _addListAutoformats() {\n      var commands = this.editor.commands;\n\n      if (commands.get('bulletedList')) {\n        // eslint-disable-next-line no-new\n        new BlockAutoformatEditing(this.editor, /^[*-]\\s$/, 'bulletedList');\n      }\n\n      if (commands.get('numberedList')) {\n        // eslint-disable-next-line no-new\n        new BlockAutoformatEditing(this.editor, /^1[.|)]\\s$/, 'numberedList');\n      }\n    }\n    /**\n     * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},\n     * {@link module:basic-styles/italic~Italic} and {@link module:basic-styles/code~Code}.\n     *\n     * When typed:\n     * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,\n     * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,\n     * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,\n     * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,\n     * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_addBasicStylesAutoformats\",\n    value: function _addBasicStylesAutoformats() {\n      var commands = this.editor.commands;\n\n      if (commands.get('bold')) {\n        /* eslint-disable no-new */\n        var boldCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'bold');\n        new InlineAutoformatEditing(this.editor, /(\\*\\*)([^*]+)(\\*\\*)$/g, boldCallback);\n        new InlineAutoformatEditing(this.editor, /(__)([^_]+)(__)$/g, boldCallback);\n        /* eslint-enable no-new */\n      }\n\n      if (commands.get('italic')) {\n        /* eslint-disable no-new */\n        var italicCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'italic'); // The italic autoformatter cannot be triggered by the bold markers, so we need to check the\n        // text before the pattern (e.g. `(?:^|[^\\*])`).\n\n        new InlineAutoformatEditing(this.editor, /(?:^|[^*])(\\*)([^*_]+)(\\*)$/g, italicCallback);\n        new InlineAutoformatEditing(this.editor, /(?:^|[^_])(_)([^_]+)(_)$/g, italicCallback);\n        /* eslint-enable no-new */\n      }\n\n      if (commands.get('code')) {\n        /* eslint-disable no-new */\n        var codeCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'code');\n        new InlineAutoformatEditing(this.editor, /(`)([^`]+)(`)$/g, codeCallback);\n        /* eslint-enable no-new */\n      }\n    }\n    /**\n     * Adds autoformatting related to {@link module:heading/heading~Heading}.\n     *\n     * It is using a number at the end of the command name to associate it with the proper trigger:\n     *\n     * * `heading` with value `heading1` will be executed when typing `#`,\n     * * `heading` with value `heading2` will be executed when typing `##`,\n     * * ... up to `heading6` and `######`.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_addHeadingAutoformats\",\n    value: function _addHeadingAutoformats() {\n      var _this = this;\n\n      var command = this.editor.commands.get('heading');\n\n      if (command) {\n        command.modelElements.filter(function (name) {\n          return name.match(/^heading[1-6]$/);\n        }).forEach(function (commandValue) {\n          var level = commandValue[7];\n          var pattern = new RegExp(\"^(#{\".concat(level, \"})\\\\s$\")); // eslint-disable-next-line no-new\n\n          new BlockAutoformatEditing(_this.editor, pattern, function () {\n            if (!command.isEnabled) {\n              return false;\n            }\n\n            _this.editor.execute('heading', {\n              value: commandValue\n            });\n          });\n        });\n      }\n    }\n    /**\n     * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.\n     *\n     * When typed:\n     * * `> ` &ndash; A paragraph will be changed to a block quote.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_addBlockQuoteAutoformats\",\n    value: function _addBlockQuoteAutoformats() {\n      if (this.editor.commands.get('blockQuote')) {\n        // eslint-disable-next-line no-new\n        new BlockAutoformatEditing(this.editor, /^>\\s$/, 'blockQuote');\n      }\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'Autoformat';\n    }\n  }]);\n\n  return Autoformat;\n}(Plugin); // Helper function for getting `InlineAutoformatEditing` callbacks that checks if command is enabled.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {String} attributeKey\n// @returns {Function}\n\n\nexport { Autoformat as default };\n\nfunction getCallbackFunctionForInlineAutoformat(editor, attributeKey) {\n  return function (writer, rangesToFormat) {\n    var command = editor.commands.get(attributeKey);\n\n    if (!command.isEnabled) {\n      return false;\n    }\n\n    var validRanges = editor.model.schema.getValidRanges(rangesToFormat, attributeKey);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = validRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var range = _step.value;\n        writer.setAttribute(attributeKey, true, range);\n      } // After applying attribute to the text, remove given attribute from the selection.\n      // This way user is able to type a text without attribute used by auto formatter.\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    writer.removeSelectionAttribute(attributeKey);\n  };\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module basic-styles/attributecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\n/**\n * An extension of the base {@link module:core/command~Command} class, which provides utilities for a command\n * that toggles a single attribute on a text or an element.\n *\n * `AttributeCommand` uses {@link module:engine/model/document~Document#selection}\n * to decide which nodes (if any) should be changed, and applies or removes the attribute from them.\n *\n * The command checks the {@link module:engine/model/model~Model#schema} to decide if it can be enabled\n * for the current selection and to which nodes the attribute can be applied.\n *\n * @extends module:core/command~Command\n */\n\nvar AttributeCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(AttributeCommand, _Command);\n\n  /**\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {String} attributeKey Attribute that will be set by the command.\n   */\n  function AttributeCommand(editor, attributeKey) {\n    var _this;\n\n    _classCallCheck(this, AttributeCommand);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AttributeCommand).call(this, editor));\n    /**\n     * The attribute that will be set by the command.\n     *\n     * @readonly\n     * @member {String}\n     */\n\n    _this.attributeKey = attributeKey;\n    /**\n     * Flag indicating whether the command is active. The command is active when the\n     * {@link module:engine/model/selection~Selection#hasAttribute selection has the attribute} which means that:\n     *\n     * * If the selection is not empty &ndash; That the attribute is set on the first node in the selection that allows this attribute.\n     * * If the selection is empty &ndash; That the selection has the attribute itself (which means that newly typed\n     * text will have this attribute, too).\n     *\n     * @observable\n     * @readonly\n     * @member {Boolean} #value\n     */\n\n    return _this;\n  }\n  /**\n   * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.\n   */\n\n\n  _createClass(AttributeCommand, [{\n    key: \"refresh\",\n    value: function refresh() {\n      var model = this.editor.model;\n      var doc = model.document;\n      this.value = this._getValueFromFirstAllowedNode();\n      this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);\n    }\n    /**\n     * Executes the command &mdash; applies the attribute to the selection or removes it from the selection.\n     *\n     * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.\n     *\n     * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:\n     *\n     * * If the selection is on a range, the command applies the attribute to all nodes in that range\n     * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).\n     * * If the selection is collapsed in a non-empty node, the command applies the attribute to the\n     * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).\n     * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note\n     * that the selection inherits all attributes from a node if it is in an empty node).\n     *\n     * @fires execute\n     * @param {Object} [options] Command options.\n     * @param {Boolean} [options.forceValue] If set, it will force the command behavior. If `true`, the command will apply the attribute,\n     * otherwise the command will remove the attribute.\n     * If not set, the command will look for its current value to decide what it should do.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var model = this.editor.model;\n      var doc = model.document;\n      var selection = doc.selection;\n      var value = options.forceValue === undefined ? !this.value : options.forceValue;\n      model.change(function (writer) {\n        if (selection.isCollapsed) {\n          if (value) {\n            writer.setSelectionAttribute(_this2.attributeKey, true);\n          } else {\n            writer.removeSelectionAttribute(_this2.attributeKey);\n          }\n        } else {\n          var ranges = model.schema.getValidRanges(selection.getRanges(), _this2.attributeKey);\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var range = _step.value;\n\n              if (value) {\n                writer.setAttribute(_this2.attributeKey, value, range);\n              } else {\n                writer.removeAttribute(_this2.attributeKey, range);\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Checks the attribute value of the first node in the selection that allows the attribute.\n     * For the collapsed selection returns the selection attribute.\n     *\n     * @private\n     * @returns {Boolean} The attribute value.\n     */\n\n  }, {\n    key: \"_getValueFromFirstAllowedNode\",\n    value: function _getValueFromFirstAllowedNode() {\n      var model = this.editor.model;\n      var schema = model.schema;\n      var selection = model.document.selection;\n\n      if (selection.isCollapsed) {\n        return selection.hasAttribute(this.attributeKey);\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = selection.getRanges()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var range = _step2.value;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = range.getItems()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var item = _step3.value;\n\n              if (schema.checkAttribute(item, this.attributeKey)) {\n                return item.hasAttribute(this.attributeKey);\n              }\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return false;\n    }\n  }]);\n\n  return AttributeCommand;\n}(Command);\n\nexport { AttributeCommand as default };","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/first\n */\n\n/**\n * Returns first item of the given `iterable`.\n *\n * @param {Iterable.<*>} iterable\n * @returns {*}\n */\nexport default function first(iterable) {\n  var iteratorItem = iterable.next();\n\n  if (iteratorItem.done) {\n    return null;\n  }\n\n  return iteratorItem.value;\n}","import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module block-quote/blockquotecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n/**\n * The block quote command plugin.\n *\n * @extends module:core/command~Command\n */\n\nvar BlockQuoteCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(BlockQuoteCommand, _Command);\n\n  function BlockQuoteCommand() {\n    _classCallCheck(this, BlockQuoteCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BlockQuoteCommand).apply(this, arguments));\n  }\n\n  _createClass(BlockQuoteCommand, [{\n    key: \"refresh\",\n\n    /**\n     * Whether the selection starts in a block quote.\n     *\n     * @observable\n     * @readonly\n     * @member {Boolean} #value\n     */\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      this.value = this._getValue();\n      this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Executes the command. When the command {@link #value is on}, all top-most block quotes within\n     * the selection will be removed. If it is off, all selected blocks will be wrapped with\n     * a block quote.\n     *\n     * @fires execute\n     * @param {Object} [options] Command options.\n     * @param {Boolean} [options.forceValue] If set, it will force the command behavior. If `true`, the command will apply a block quote,\n     * otherwise the command will remove the block quote. If not set, the command will act basing on its current value.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var model = this.editor.model;\n      var schema = model.schema;\n      var selection = model.document.selection;\n      var blocks = Array.from(selection.getTopMostBlocks());\n      var value = options.forceValue === undefined ? !this.value : options.forceValue;\n      model.change(function (writer) {\n        if (!value) {\n          _this._removeQuote(writer, blocks.filter(findQuote));\n        } else {\n          var blocksToQuote = blocks.filter(function (block) {\n            // Already quoted blocks needs to be considered while quoting too\n            // in order to reuse their <bQ> elements.\n            return findQuote(block) || checkCanBeQuoted(schema, block);\n          });\n\n          _this._applyQuote(writer, blocksToQuote);\n        }\n      });\n    }\n    /**\n     * Checks the command's {@link #value}.\n     *\n     * @private\n     * @returns {Boolean} The current value.\n     */\n\n  }, {\n    key: \"_getValue\",\n    value: function _getValue() {\n      var selection = this.editor.model.document.selection;\n      var firstBlock = first(selection.getTopMostBlocks()); // In the current implementation, the block quote must be an immediate parent of a block element.\n\n      return !!(firstBlock && findQuote(firstBlock));\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @private\n     * @returns {Boolean} Whether the command should be enabled.\n     */\n\n  }, {\n    key: \"_checkEnabled\",\n    value: function _checkEnabled() {\n      if (this.value) {\n        return true;\n      }\n\n      var selection = this.editor.model.document.selection;\n      var schema = this.editor.model.schema;\n      var firstBlock = first(selection.getSelectedBlocks());\n\n      if (!firstBlock) {\n        return false;\n      }\n\n      return checkCanBeQuoted(schema, firstBlock);\n    }\n    /**\n     * Removes the quote from given blocks.\n     *\n     * If blocks which are supposed to be \"unquoted\" are in the middle of a quote,\n     * start it or end it, then the quote will be split (if needed) and the blocks\n     * will be moved out of it, so other quoted blocks remained quoted.\n     *\n     * @private\n     * @param {module:engine/model/writer~Writer} writer\n     * @param {Array.<module:engine/model/element~Element>} blocks\n     */\n\n  }, {\n    key: \"_removeQuote\",\n    value: function _removeQuote(writer, blocks) {\n      // Unquote all groups of block. Iterate in the reverse order to not break following ranges.\n      getRangesOfBlockGroups(writer, blocks).reverse().forEach(function (groupRange) {\n        if (groupRange.start.isAtStart && groupRange.end.isAtEnd) {\n          writer.unwrap(groupRange.start.parent);\n          return;\n        } // The group of blocks are at the beginning of an <bQ> so let's move them left (out of the <bQ>).\n\n\n        if (groupRange.start.isAtStart) {\n          var positionBefore = writer.createPositionBefore(groupRange.start.parent);\n          writer.move(groupRange, positionBefore);\n          return;\n        } // The blocks are in the middle of an <bQ> so we need to split the <bQ> after the last block\n        // so we move the items there.\n\n\n        if (!groupRange.end.isAtEnd) {\n          writer.split(groupRange.end);\n        } // Now we are sure that groupRange.end.isAtEnd is true, so let's move the blocks right.\n\n\n        var positionAfter = writer.createPositionAfter(groupRange.end.parent);\n        writer.move(groupRange, positionAfter);\n      });\n    }\n    /**\n     * Applies the quote to given blocks.\n     *\n     * @private\n     * @param {module:engine/model/writer~Writer} writer\n     * @param {Array.<module:engine/model/element~Element>} blocks\n     */\n\n  }, {\n    key: \"_applyQuote\",\n    value: function _applyQuote(writer, blocks) {\n      var quotesToMerge = []; // Quote all groups of block. Iterate in the reverse order to not break following ranges.\n\n      getRangesOfBlockGroups(writer, blocks).reverse().forEach(function (groupRange) {\n        var quote = findQuote(groupRange.start);\n\n        if (!quote) {\n          quote = writer.createElement('blockQuote');\n          writer.wrap(groupRange, quote);\n        }\n\n        quotesToMerge.push(quote);\n      }); // Merge subsequent <bQ> elements. Reverse the order again because this time we want to go through\n      // the <bQ> elements in the source order (due to how merge works  it moves the right element's content\n      // to the first element and removes the right one. Since we may need to merge a couple of subsequent `<bQ>` elements\n      // we want to keep the reference to the first (furthest left) one.\n\n      quotesToMerge.reverse().reduce(function (currentQuote, nextQuote) {\n        if (currentQuote.nextSibling == nextQuote) {\n          writer.merge(writer.createPositionAfter(currentQuote));\n          return currentQuote;\n        }\n\n        return nextQuote;\n      });\n    }\n  }]);\n\n  return BlockQuoteCommand;\n}(Command);\n\nexport { BlockQuoteCommand as default };\n\nfunction findQuote(elementOrPosition) {\n  return elementOrPosition.parent.name == 'blockQuote' ? elementOrPosition.parent : null;\n} // Returns a minimal array of ranges containing groups of subsequent blocks.\n//\n// content:         abcdefgh\n// blocks:          [ a, b, d, f, g, h ]\n// output ranges:   [ab]c[d]e[fgh]\n//\n// @param {Array.<module:engine/model/element~Element>} blocks\n// @returns {Array.<module:engine/model/range~Range>}\n\n\nfunction getRangesOfBlockGroups(writer, blocks) {\n  var startPosition;\n  var i = 0;\n  var ranges = [];\n\n  while (i < blocks.length) {\n    var block = blocks[i];\n    var nextBlock = blocks[i + 1];\n\n    if (!startPosition) {\n      startPosition = writer.createPositionBefore(block);\n    }\n\n    if (!nextBlock || block.nextSibling != nextBlock) {\n      ranges.push(writer.createRange(startPosition, writer.createPositionAfter(block)));\n      startPosition = null;\n    }\n\n    i++;\n  }\n\n  return ranges;\n} // Checks whether <bQ> can wrap the block.\n\n\nfunction checkCanBeQuoted(schema, block) {\n  // TMP will be replaced with schema.checkWrap().\n  var isBQAllowed = schema.checkChild(block.parent, 'blockQuote');\n  var isBlockAllowedInBQ = schema.checkChild(['$root', 'blockQuote'], block);\n  return isBQAllowed && isBlockAllowedInBQ;\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.string.ends-with\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module block-quote/blockquoteediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport BlockQuoteCommand from \"./blockquotecommand\";\n/**\n * The block quote editing.\n *\n * Introduces the `'blockQuote'` command and the `'blockQuote'` model element.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar BlockQuoteEditing =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(BlockQuoteEditing, _Plugin);\n\n  function BlockQuoteEditing() {\n    _classCallCheck(this, BlockQuoteEditing);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BlockQuoteEditing).apply(this, arguments));\n  }\n\n  _createClass(BlockQuoteEditing, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var editor = this.editor;\n      var schema = editor.model.schema;\n      editor.commands.add('blockQuote', new BlockQuoteCommand(editor));\n      schema.register('blockQuote', {\n        allowWhere: '$block',\n        allowContentOf: '$root'\n      }); // Disallow blockQuote in blockQuote.\n\n      schema.addChildCheck(function (ctx, childDef) {\n        if (ctx.endsWith('blockQuote') && childDef.name == 'blockQuote') {\n          return false;\n        }\n      });\n      editor.conversion.elementToElement({\n        model: 'blockQuote',\n        view: 'blockquote'\n      }); // Postfixer which cleans incorrect model states connected with block quotes.\n\n      editor.model.document.registerPostFixer(function (writer) {\n        var changes = editor.model.document.differ.getChanges();\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var entry = _step.value;\n\n            if (entry.type == 'insert') {\n              var element = entry.position.nodeAfter;\n\n              if (!element) {\n                // We are inside a text node.\n                continue;\n              }\n\n              if (element.is('blockQuote') && element.isEmpty) {\n                // Added an empty blockQuote - remove it.\n                writer.remove(element);\n                return true;\n              } else if (element.is('blockQuote') && !schema.checkChild(entry.position, element)) {\n                // Added a blockQuote in incorrect place - most likely inside another blockQuote. Unwrap it\n                // so the content inside is not lost.\n                writer.unwrap(element);\n                return true;\n              } else if (element.is('element')) {\n                // Just added an element. Check its children to see if there are no nested blockQuotes somewhere inside.\n                var range = writer.createRangeIn(element);\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                  for (var _iterator2 = range.getItems()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var child = _step2.value;\n\n                    if (child.is('blockQuote') && !schema.checkChild(writer.createPositionBefore(child), child)) {\n                      writer.unwrap(child);\n                      return true;\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError2 = true;\n                  _iteratorError2 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                      _iterator2.return();\n                    }\n                  } finally {\n                    if (_didIteratorError2) {\n                      throw _iteratorError2;\n                    }\n                  }\n                }\n              }\n            } else if (entry.type == 'remove') {\n              var parent = entry.position.parent;\n\n              if (parent.is('blockQuote') && parent.isEmpty) {\n                // Something got removed and now blockQuote is empty. Remove the blockQuote as well.\n                writer.remove(parent);\n                return true;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return false;\n      });\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"afterInit\",\n    value: function afterInit() {\n      var _this = this;\n\n      var editor = this.editor;\n      var command = editor.commands.get('blockQuote'); // Overwrite default Enter key behavior.\n      // If Enter key is pressed with selection collapsed in empty block inside a quote, break the quote.\n      // This listener is added in afterInit in order to register it after list's feature listener.\n      // We can't use a priority for this, because 'low' is already used by the enter feature, unless\n      // we'd use numeric priority in this case.\n\n      this.listenTo(this.editor.editing.view.document, 'enter', function (evt, data) {\n        var doc = _this.editor.model.document;\n        var positionParent = doc.selection.getLastPosition().parent;\n\n        if (doc.selection.isCollapsed && positionParent.isEmpty && command.value) {\n          _this.editor.execute('blockQuote');\n\n          _this.editor.editing.view.scrollToTheSelection();\n\n          data.preventDefault();\n          evt.stop();\n        }\n      });\n    }\n  }]);\n\n  return BlockQuoteEditing;\n}(Plugin);\n\nexport { BlockQuoteEditing as default };","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paragraph/paragraph\n */\nimport ParagraphCommand from \"./paragraphcommand\";\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n/**\n * The paragraph feature for the editor.\n *\n * It introduces the `<paragraph>` element in the model which renders as a `<p>` element in the DOM and data.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar Paragraph =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Paragraph, _Plugin);\n\n  function Paragraph() {\n    _classCallCheck(this, Paragraph);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Paragraph).apply(this, arguments));\n  }\n\n  _createClass(Paragraph, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var _this = this;\n\n      var editor = this.editor;\n      var model = editor.model;\n      var data = editor.data;\n      editor.commands.add('paragraph', new ParagraphCommand(editor)); // Schema.\n\n      model.schema.register('paragraph', {\n        inheritAllFrom: '$block'\n      });\n      editor.conversion.elementToElement({\n        model: 'paragraph',\n        view: 'p'\n      }); // Content autoparagraphing. --------------------------------------------------\n      // Handles element which has not been converted by any plugin and checks if it would be converted if\n      // we wrap it in a paragraph or change it to a paragraph.\n\n      editor.conversion.for('upcast').elementToElement({\n        model: function model(viewElement, modelWriter) {\n          if (!Paragraph.paragraphLikeElements.has(viewElement.name)) {\n            return null;\n          } // Do not auto-paragraph empty elements.\n\n\n          if (viewElement.isEmpty) {\n            return null;\n          }\n\n          return modelWriter.createElement('paragraph');\n        },\n        converterPriority: 'low'\n      });\n      data.upcastDispatcher.on('element', function (evt, data, conversionApi) {\n        // Do not try auto-paragraphing if the element was already converted.\n        if (!conversionApi.consumable.test(data.viewItem, {\n          name: data.viewItem.name\n        })) {\n          return;\n        } // If the element is not paragraph-like try wrapping it in a paragraph.\n\n\n        if (isParagraphable(data.viewItem, data.modelCursor, conversionApi.schema)) {\n          Object.assign(data, wrapInParagraph(data.viewItem, data.modelCursor, conversionApi));\n        }\n      }, {\n        priority: 'low'\n      }); // Handles not converted text nodes and checks if would be converted if we wraps then by a paragraph.\n\n      data.upcastDispatcher.on('text', function (evt, data, conversionApi) {\n        // When node is already converted then do nothing.\n        if (data.modelRange) {\n          return;\n        }\n\n        if (isParagraphable(data.viewItem, data.modelCursor, conversionApi.schema)) {\n          Object.assign(data, wrapInParagraph(data.viewItem, data.modelCursor, conversionApi));\n        }\n      }, {\n        priority: 'lowest'\n      }); // Empty roots autoparagraphing. -----------------------------------------------\n      // Post-fixer which takes care of adding empty paragraph elements to empty roots.\n      // Besides fixing content on #changesDone we also need to handle editor.data#ready event because\n      // if initial data is empty or setData() wasn't even called there will be no #change fired.\n\n      model.document.registerPostFixer(function (writer) {\n        return _this._autoparagraphEmptyRoots(writer);\n      });\n      editor.data.on('ready', function () {\n        model.enqueueChange('transparent', function (writer) {\n          return _this._autoparagraphEmptyRoots(writer);\n        });\n      }, {\n        priority: 'lowest'\n      });\n    }\n    /**\n     * Fixes all empty roots.\n     *\n     * @private\n     * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n     */\n\n  }, {\n    key: \"_autoparagraphEmptyRoots\",\n    value: function _autoparagraphEmptyRoots(writer) {\n      var model = this.editor.model;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = model.document.getRootNames()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var rootName = _step.value;\n          var root = model.document.getRoot(rootName);\n\n          if (root.isEmpty && root.rootName != '$graveyard') {\n            // If paragraph element is allowed in the root, create paragraph element.\n            if (model.schema.checkChild(root, 'paragraph')) {\n              writer.insertElement('paragraph', root);\n              return true;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'Paragraph';\n    }\n  }]);\n\n  return Paragraph;\n}(Plugin);\n/**\n * A list of element names which should be treated by the autoparagraphing algorithms as\n * paragraph-like. This means that e.g. the following content:\n *\n *\t\t<h1>Foo</h1>\n *\t\t<table>\n *\t\t\t<tr>\n *\t\t\t\t<td>X</td>\n *\t\t\t\t<td>\n *\t\t\t\t\t<ul>\n *\t\t\t\t\t\t<li>Y</li>\n *\t\t\t\t\t\t<li>Z</li>\n *\t\t\t\t\t</ul>\n *\t\t\t\t</td>\n *\t\t\t</tr>\n *\t\t</table>\n *\n * contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.\n * Hence, if none of the features is going to convert those elements the above content will be automatically handled\n * by the paragraph feature and converted to:\n *\n *\t\t<p>Foo</p>\n *\t\t<p>X</p>\n *\t\t<p>Y</p>\n *\t\t<p>Z</p>\n *\n * Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements\n * have a priority upon conversion.\n *\n * @member {Set.<String>} module:paragraph/paragraph~Paragraph.paragraphLikeElements\n */\n\n\nexport { Paragraph as default };\nParagraph.paragraphLikeElements = new Set(['blockquote', 'dd', 'div', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'p', 'td']);\n\nfunction wrapInParagraph(input, position, conversionApi) {\n  var paragraph = conversionApi.writer.createElement('paragraph');\n  conversionApi.writer.insert(paragraph, position);\n  return conversionApi.convertItem(input, conversionApi.writer.createPositionAt(paragraph, 0));\n}\n\nfunction isParagraphable(node, position, schema) {\n  var context = schema.createContext(position); // When paragraph is allowed in this context...\n\n  if (!schema.checkChild(context, 'paragraph')) {\n    return false;\n  } // And a node would be allowed in this paragraph...\n\n\n  if (!schema.checkChild(context.push('paragraph'), node)) {\n    return false;\n  }\n\n  return true;\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module heading/headingediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Paragraph from '@ckeditor/ckeditor5-paragraph/src/paragraph';\nimport HeadingCommand from \"./headingcommand\";\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\nvar defaultModelElement = 'paragraph';\n/**\n * The headings engine feature. It handles switching between block formats &ndash; headings and paragraph.\n * This class represents the engine part of the heading feature. See also {@link module:heading/heading~Heading}.\n * It introduces `heading1`-`headingN` commands which allow to convert paragraphs into headings.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar HeadingEditing =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(HeadingEditing, _Plugin);\n\n  /**\n   * @inheritDoc\n   */\n  function HeadingEditing(editor) {\n    var _this;\n\n    _classCallCheck(this, HeadingEditing);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HeadingEditing).call(this, editor));\n    editor.config.define('heading', {\n      options: [{\n        model: 'paragraph',\n        title: 'Paragraph',\n        class: 'ck-heading_paragraph'\n      }, {\n        model: 'heading1',\n        view: 'h2',\n        title: 'Heading 1',\n        class: 'ck-heading_heading1'\n      }, {\n        model: 'heading2',\n        view: 'h3',\n        title: 'Heading 2',\n        class: 'ck-heading_heading2'\n      }, {\n        model: 'heading3',\n        view: 'h4',\n        title: 'Heading 3',\n        class: 'ck-heading_heading3'\n      }]\n    });\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(HeadingEditing, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var editor = this.editor;\n      var options = editor.config.get('heading.options');\n      var modelElements = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var option = _step.value;\n\n          // Skip paragraph - it is defined in required Paragraph feature.\n          if (option.model !== defaultModelElement) {\n            // Schema.\n            editor.model.schema.register(option.model, {\n              inheritAllFrom: '$block'\n            });\n            editor.conversion.elementToElement(option);\n            modelElements.push(option.model);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this._addDefaultH1Conversion(editor); // Register the heading command for this option.\n\n\n      editor.commands.add('heading', new HeadingCommand(editor, modelElements));\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"afterInit\",\n    value: function afterInit() {\n      // If the enter command is added to the editor, alter its behavior.\n      // Enter at the end of a heading element should create a paragraph.\n      var editor = this.editor;\n      var enterCommand = editor.commands.get('enter');\n      var options = editor.config.get('heading.options');\n\n      if (enterCommand) {\n        this.listenTo(enterCommand, 'afterExecute', function (evt, data) {\n          var positionParent = editor.model.document.selection.getFirstPosition().parent;\n          var isHeading = options.some(function (option) {\n            return positionParent.is(option.model);\n          });\n\n          if (isHeading && !positionParent.is(defaultModelElement) && positionParent.childCount === 0) {\n            data.writer.rename(positionParent, defaultModelElement);\n          }\n        });\n      }\n    }\n    /**\n     * Adds default conversion for `h1` -> `heading1` with a low priority.\n     *\n     * @private\n     * @param {module:core/editor/editor~Editor} editor Editor instance on which to add the `h1` conversion.\n     */\n\n  }, {\n    key: \"_addDefaultH1Conversion\",\n    value: function _addDefaultH1Conversion(editor) {\n      editor.conversion.for('upcast').elementToElement({\n        model: 'heading1',\n        view: 'h1',\n        // With a `low` priority, `paragraph` plugin autoparagraphing mechanism is executed. Make sure\n        // this listener is called before it. If not, `h1` will be transformed into a paragraph.\n        converterPriority: priorities.get('low') + 1\n      });\n    }\n  }], [{\n    key: \"requires\",\n    get: function get() {\n      return [Paragraph];\n    }\n  }]);\n\n  return HeadingEditing;\n}(Plugin);\n\nexport { HeadingEditing as default };","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/dropdown/dropdownpanelview\n */\nimport View from \"../view\";\n/**\n * The dropdown panel view class.\n *\n * See {@link module:ui/dropdown/dropdownview~DropdownView} to learn about the common usage.\n *\n * @extends module:ui/view~View\n */\n\nvar DropdownPanelView =\n/*#__PURE__*/\nfunction (_View) {\n  _inherits(DropdownPanelView, _View);\n\n  /**\n   * @inheritDoc\n   */\n  function DropdownPanelView(locale) {\n    var _this;\n\n    _classCallCheck(this, DropdownPanelView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropdownPanelView).call(this, locale));\n    var bind = _this.bindTemplate;\n    /**\n     * Controls whether the panel is visible.\n     *\n     * @observable\n     * @member {Boolean} #isVisible\n     */\n\n    _this.set('isVisible', false);\n    /**\n     * The position of the panel, relative to the parent.\n     *\n     * This property is reflected in the CSS class set to {@link #element} that controls\n     * the position of the panel.\n     *\n     * @observable\n     * @default 'se'\n     * @member {'se'|'sw'|'ne'|'nw'} #position\n     */\n\n\n    _this.set('position', 'se');\n    /**\n     * Collection of the child views in this panel.\n     *\n     * A common child type is the {@link module:ui/list/listview~ListView} and {@link module:ui/toolbar/toolbarview~ToolbarView}.\n     * See {@link module:ui/dropdown/utils~addListToDropdown} and\n     * {@link module:ui/dropdown/utils~addToolbarToDropdown} to learn more about child views of dropdowns.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n\n    _this.children = _this.createCollection();\n\n    _this.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-reset', 'ck-dropdown__panel', bind.to('position', function (value) {\n          return \"ck-dropdown__panel_\".concat(value);\n        }), bind.if('isVisible', 'ck-dropdown__panel-visible')]\n      },\n      children: _this.children,\n      on: {\n        // Drag and drop in the panel should not break the selection in the editor.\n        // https://github.com/ckeditor/ckeditor5-ui/issues/228\n        selectstart: bind.to(function (evt) {\n          return evt.preventDefault();\n        })\n      }\n    });\n\n    return _this;\n  }\n  /**\n   * Focuses the view element or first item in view collection on opening dropdown's panel.\n   *\n   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.\n   */\n\n\n  _createClass(DropdownPanelView, [{\n    key: \"focus\",\n    value: function focus() {\n      if (this.children.length) {\n        this.children.first.focus();\n      }\n    }\n    /**\n     * Focuses the view element or last item in view collection on opening dropdown's panel.\n     *\n     * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.\n     */\n\n  }, {\n    key: \"focusLast\",\n    value: function focusLast() {\n      if (this.children.length) {\n        var lastChild = this.children.last;\n\n        if (typeof lastChild.focusLast === 'function') {\n          lastChild.focusLast();\n        } else {\n          lastChild.focus();\n        }\n      }\n    }\n  }]);\n\n  return DropdownPanelView;\n}(View);\n\nexport { DropdownPanelView as default };","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/getpositionedancestor\n */\nimport global from \"./global\";\n/**\n * For a given element, returns the nearest ancestor element which CSS position is not \"static\".\n *\n * @param {HTMLElement} element The native DOM element to be checked.\n * @returns {HTMLElement|null}\n */\n\nexport default function getPositionedAncestor(element) {\n  while (element && element.tagName.toLowerCase() != 'html') {\n    if (global.window.getComputedStyle(element).position != 'static') {\n      return element;\n    }\n\n    element = element.parentElement;\n  }\n\n  return null;\n}","import \"core-js/modules/es6.function.name\";\nimport _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/position\n */\nimport global from \"./global\";\nimport Rect from \"./rect\";\nimport getPositionedAncestor from \"./getpositionedancestor\";\nimport getBorderWidths from \"./getborderwidths\";\nimport { isFunction } from 'lodash-es';\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options Positioning options object.\n * @returns {module:utils/dom/position~Position}\n */\n\nexport function getOptimalPosition(_ref) {\n  var element = _ref.element,\n      target = _ref.target,\n      positions = _ref.positions,\n      limiter = _ref.limiter,\n      fitInViewport = _ref.fitInViewport;\n\n  // If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-utils/issues/157\n  if (isFunction(target)) {\n    target = target();\n  } // If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-ui/issues/260\n\n\n  if (isFunction(limiter)) {\n    limiter = limiter();\n  }\n\n  var positionedElementAncestor = getPositionedAncestor(element.parentElement);\n  var elementRect = new Rect(element);\n  var targetRect = new Rect(target);\n  var bestPosition;\n  var name; // If there are no limits, just grab the very first position and be done with that drama.\n\n  if (!limiter && !fitInViewport) {\n    var _getPosition = getPosition(positions[0], targetRect, elementRect);\n\n    var _getPosition2 = _slicedToArray(_getPosition, 2);\n\n    name = _getPosition2[0];\n    bestPosition = _getPosition2[1];\n  } else {\n    var limiterRect = limiter && new Rect(limiter).getVisible();\n    var viewportRect = fitInViewport && new Rect(global.window);\n\n    var _ref2 = getBestPosition(positions, targetRect, elementRect, limiterRect, viewportRect) || // If there's no best position found, i.e. when all intersections have no area because\n    // rects have no width or height, then just use the first available position.\n    getPosition(positions[0], targetRect, elementRect);\n\n    var _ref3 = _slicedToArray(_ref2, 2);\n\n    name = _ref3[0];\n    bestPosition = _ref3[1];\n  }\n\n  var _getAbsoluteRectCoord = getAbsoluteRectCoordinates(bestPosition),\n      left = _getAbsoluteRectCoord.left,\n      top = _getAbsoluteRectCoord.top;\n\n  if (positionedElementAncestor) {\n    var ancestorPosition = getAbsoluteRectCoordinates(new Rect(positionedElementAncestor));\n    var ancestorBorderWidths = getBorderWidths(positionedElementAncestor); // (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n    // If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n    // consideration. `Rect` is always relative to the viewport while `position: absolute` works\n    // with respect to that positioned ancestor.\n\n    left -= ancestorPosition.left;\n    top -= ancestorPosition.top; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n    // If there's some positioned ancestor of the panel, not only its position must be taken into\n    // consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n    // is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n    // must compensate that scrolling.\n\n    left += positionedElementAncestor.scrollLeft;\n    top += positionedElementAncestor.scrollTop; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n    // If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n    // while `position: absolute` positioning does not consider it.\n    // E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n    // not upper-left corner of its border.\n\n    left -= ancestorBorderWidths.left;\n    top -= ancestorBorderWidths.top;\n  }\n\n  return {\n    left: left,\n    top: top,\n    name: name\n  };\n} // For given position function, returns a corresponding `Rect` instance.\n//\n// @private\n// @param {Function} position A function returning {@link module:utils/dom/position~Position}.\n// @param {utils/dom/rect~Rect} targetRect A rect of the target.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned element.\n// @returns {Array} An array containing position name and its Rect.\n\nfunction getPosition(position, targetRect, elementRect) {\n  var _position = position(targetRect, elementRect),\n      left = _position.left,\n      top = _position.top,\n      name = _position.name;\n\n  return [name, elementRect.clone().moveTo(left, top)];\n} // For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n// @param {module:utils/dom/position~Options#positions} positions Functions returning\n// {@link module:utils/dom/position~Position} to be checked, in the order of preference.\n// @param {utils/dom/rect~Rect} targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} viewportRect A rect of the viewport.\n// @returns {Array} An array containing the name of the position and it's rect.\n\n\nfunction getBestPosition(positions, targetRect, elementRect, limiterRect, viewportRect) {\n  var maxLimiterIntersectArea = 0;\n  var maxViewportIntersectArea = 0;\n  var bestPositionRect;\n  var bestPositionName; // This is when element is fully visible.\n\n  var elementRectArea = elementRect.getArea();\n  positions.some(function (position) {\n    var _getPosition3 = getPosition(position, targetRect, elementRect),\n        _getPosition4 = _slicedToArray(_getPosition3, 2),\n        positionName = _getPosition4[0],\n        positionRect = _getPosition4[1];\n\n    var limiterIntersectArea;\n    var viewportIntersectArea;\n\n    if (limiterRect) {\n      if (viewportRect) {\n        // Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n        var limiterViewportIntersectRect = limiterRect.getIntersection(viewportRect);\n\n        if (limiterViewportIntersectRect) {\n          // If the limiter is within the viewport, then check the intersection between that part of the\n          // limiter and actual position.\n          limiterIntersectArea = limiterViewportIntersectRect.getIntersectionArea(positionRect);\n        } else {\n          limiterIntersectArea = 0;\n        }\n      } else {\n        limiterIntersectArea = limiterRect.getIntersectionArea(positionRect);\n      }\n    }\n\n    if (viewportRect) {\n      viewportIntersectArea = viewportRect.getIntersectionArea(positionRect);\n    } // The only criterion: intersection with the viewport.\n\n\n    if (viewportRect && !limiterRect) {\n      if (viewportIntersectArea > maxViewportIntersectArea) {\n        setBestPosition();\n      }\n    } // The only criterion: intersection with the limiter.\n    else if (!viewportRect && limiterRect) {\n        if (limiterIntersectArea > maxLimiterIntersectArea) {\n          setBestPosition();\n        }\n      } // Two criteria: intersection with the viewport and the limiter visible in the viewport.\n      else {\n          if (viewportIntersectArea > maxViewportIntersectArea && limiterIntersectArea >= maxLimiterIntersectArea) {\n            setBestPosition();\n          } else if (viewportIntersectArea >= maxViewportIntersectArea && limiterIntersectArea > maxLimiterIntersectArea) {\n            setBestPosition();\n          }\n        }\n\n    function setBestPosition() {\n      maxViewportIntersectArea = viewportIntersectArea;\n      maxLimiterIntersectArea = limiterIntersectArea;\n      bestPositionRect = positionRect;\n      bestPositionName = positionName;\n    } // If a such position is found that element is fully container by the limiter then, obviously,\n    // there will be no better one, so finishing.\n\n\n    return limiterIntersectArea === elementRectArea;\n  });\n  return bestPositionRect ? [bestPositionName, bestPositionRect] : null;\n} // DOMRect (also Rect) works in a scrollindependent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.\n\n\nfunction getAbsoluteRectCoordinates(_ref4) {\n  var left = _ref4.left,\n      top = _ref4.top;\n  var _global$window = global.window,\n      scrollX = _global$window.scrollX,\n      scrollY = _global$window.scrollY;\n  return {\n    left: left + scrollX,\n    top: top + scrollY\n  };\n}\n/**\n * The `getOptimalPosition` helper options.\n *\n * @interface module:utils/dom/position~Options\n */\n\n/**\n * Element that is to be positioned.\n *\n * @member {HTMLElement} #element\n */\n\n/**\n * Target with respect to which the `element` is to be positioned.\n *\n * @member {HTMLElement|Range|ClientRect|Rect|Function} #target\n */\n\n/**\n * An array of functions which return {@link module:utils/dom/position~Position} relative\n * to the `target`, in the order of preference.\n *\n * @member {Array.<Function>} #positions\n */\n\n/**\n * When set, the algorithm will chose position which fits the most in the\n * limiter's bounding rect.\n *\n * @member {HTMLElement|Range|ClientRect|Rect|Function} #limiter\n */\n\n/**\n * When set, the algorithm will chose such a position which fits `element`\n * the most inside visible viewport.\n *\n * @member {Boolean} #fitInViewport\n */\n\n/**\n * An object describing a position in `position: absolute` coordinate\n * system, along with position name.\n *\n * @typedef {Object} module:utils/dom/position~Position\n *\n * @property {Number} top Top position offset.\n * @property {Number} left Left position offset.\n * @property {String} name Name of the position.\n */","import \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/dropdown/dropdownview\n */\nimport View from \"../view\";\nimport FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';\nimport KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';\nimport \"../../theme/components/dropdown/dropdown.css\";\nimport { getOptimalPosition } from '@ckeditor/ckeditor5-utils/src/dom/position';\n/**\n * The dropdown view class. It manages the dropdown button and dropdown panel.\n *\n * In most cases, the easiest way to create a dropdown is by using the {@link module:ui/dropdown/utils~createDropdown}\n * util:\n *\n *\t\tconst dropdown = createDropdown( locale );\n *\n *\t\t// Configure dropdown's button properties:\n *\t\tdropdown.buttonView.set( {\n *\t\t\tlabel: 'A dropdown',\n *\t\t\twithText: true\n *\t\t} );\n *\n *\t\tdropdown.render();\n *\n *\t\tdropdown.panelView.element.textContent = 'Content of the panel';\n *\n *\t\t// Will render a dropdown with a panel containing a \"Content of the panel\" text.\n *\t\tdocument.body.appendChild( dropdown.element );\n *\n * If you want to add a richer content to the dropdown panel, you can use the {@link module:ui/dropdown/utils~addListToDropdown}\n * and {@link module:ui/dropdown/utils~addToolbarToDropdown} helpers. See more examples in\n * {@link module:ui/dropdown/utils~createDropdown} documentation.\n *\n * If you want to create a completely custom dropdown, then you can compose it manually:\n *\n *\t\tconst button = new DropdownButtonView( locale );\n *\t\tconst panel = new DropdownPanelView( locale );\n *\t\tconst dropdown = new DropdownView( locale, button, panel );\n *\n *\t\tbutton.set( {\n *\t\t\tlabel: 'A dropdown',\n *\t\t\twithText: true\n *\t\t} );\n *\n *\t\tdropdown.render();\n *\n *\t\tpanel.element.textContent = 'Content of the panel';\n *\n *\t\t// Will render a dropdown with a panel containing a \"Content of the panel\" text.\n *\t\tdocument.body.appendChild( dropdown.element );\n *\n * However, dropdown created this way will contain little behavior. You will need to implement handlers for actions\n * such as {@link module:ui/bindings/clickoutsidehandler~clickOutsideHandler clicking outside an open dropdown}\n * (which should close it) and support for arrow keys inside the panel. Therefore, unless you really know what\n * you do and you really need to do it, it is recommended to use the {@link module:ui/dropdown/utils~createDropdown} helper.\n *\n * @extends module:ui/view~View\n */\n\nvar DropdownView =\n/*#__PURE__*/\nfunction (_View) {\n  _inherits(DropdownView, _View);\n\n  /**\n   * Creates an instance of the dropdown.\n   *\n   * Also see {@link #render}.\n   *\n   * @param {module:utils/locale~Locale} [locale] The localization services instance.\n   * @param {module:ui/dropdown/button/dropdownbutton~DropdownButton} buttonView\n   * @param {module:ui/dropdown/dropdownpanelview~DropdownPanelView} panelView\n   */\n  function DropdownView(locale, buttonView, panelView) {\n    var _this;\n\n    _classCallCheck(this, DropdownView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropdownView).call(this, locale));\n    var bind = _this.bindTemplate;\n    /**\n     * Button of the dropdown view. Clicking the button opens the {@link #panelView}.\n     *\n     * @readonly\n     * @member {module:ui/button/buttonview~ButtonView} #buttonView\n     */\n\n    _this.buttonView = buttonView;\n    /**\n     * Panel of the dropdown. It opens when the {@link #buttonView} is\n     * {@link module:ui/button/buttonview~ButtonView#event:execute executed} (i.e. clicked).\n     *\n     * Child views can be added to the panel's `children` collection:\n     *\n     *\t\tdropdown.panelView.children.add( childView );\n     *\n     * See {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView#children} and\n     * {@link module:ui/viewcollection~ViewCollection#add}.\n     *\n     * @readonly\n     * @member {module:ui/dropdown/dropdownpanelview~DropdownPanelView} #panelView\n     */\n\n    _this.panelView = panelView;\n    /**\n     * Controls whether the dropdown view is open, i.e. shows or hides the {@link #panelView panel}.\n     *\n     * @observable\n     * @member {Boolean} #isOpen\n     */\n\n    _this.set('isOpen', false);\n    /**\n     * Controls whether the dropdown is enabled, i.e. it can be clicked and execute an action.\n     *\n     * See {@link module:ui/button/buttonview~ButtonView#isEnabled}.\n     *\n     * @observable\n     * @member {Boolean} #isEnabled\n     */\n\n\n    _this.set('isEnabled', true);\n    /**\n     * (Optional) The additional CSS class set on the dropdown {@link #element}.\n     *\n     * @observable\n     * @member {String} #class\n     */\n\n\n    _this.set('class');\n    /**\n     * The position of the panel, relative to the dropdown.\n     *\n     * **Note**: When `'auto'`, the panel will use one of the remaining positions to stay\n     * in the viewport, visible to the user. The positions correspond directly to\n     * {@link module:ui/dropdown/dropdownview~DropdownView.defaultPanelPositions default panel positions}.\n     *\n     * **Note**: This value has an impact on the\n     * {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView#position} property\n     * each time the panel becomes {@link #isOpen open}.\n     *\n     * @observable\n     * @default 'auto'\n     * @member {'auto'|'se'|'sw'|'ne'|'nw'} #panelPosition\n     */\n\n\n    _this.set('panelPosition', 'auto');\n    /**\n     * Tracks information about DOM focus in the dropdown.\n     *\n     * @readonly\n     * @member {module:utils/focustracker~FocusTracker}\n     */\n\n\n    _this.focusTracker = new FocusTracker();\n    /**\n     * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages\n     * keystrokes of the dropdown:\n     *\n     * * <kbd></kbd> opens the dropdown,\n     * * <kbd></kbd> and <kbd>Esc</kbd> closes the dropdown.\n     *\n     * @readonly\n     * @member {module:utils/keystrokehandler~KeystrokeHandler}\n     */\n\n    _this.keystrokes = new KeystrokeHandler();\n\n    _this.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-dropdown', bind.to('class'), bind.if('isEnabled', 'ck-disabled', function (value) {\n          return !value;\n        })]\n      },\n      children: [buttonView, panelView]\n    });\n\n    buttonView.extendTemplate({\n      attributes: {\n        class: ['ck-dropdown__button']\n      }\n    });\n    /**\n     * A child {@link module:ui/list/listview~ListView list view} of the dropdown located\n     * in its {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.\n     *\n     * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addListToDropdown}.\n     *\n     * @readonly\n     * @member {module:ui/list/listview~ListView} #listView\n     */\n\n    /**\n     * A child toolbar of the dropdown located in the\n     * {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.\n     *\n     * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addToolbarToDropdown}.\n     *\n     * @readonly\n     * @member {module:ui/toolbar/toolbarview~ToolbarView} #toolbarView\n     */\n\n    /**\n     * Fired when the toolbar button or list item is executed.\n     *\n     * For {@link #listView} It fires when a child of some {@link module:ui/list/listitemview~ListItemView}\n     * fired `execute`.\n     *\n     * For {@link #toolbarView} It fires when one of the buttons has been\n     * {@link module:ui/button/buttonview~ButtonView#event:execute executed}.\n     *\n     * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addListToDropdown}\n     * or {@link module:ui/dropdown/utils~addToolbarToDropdown}.\n     *\n     * @event execute\n     */\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(DropdownView, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(DropdownView.prototype), \"render\", this).call(this); // Toggle the dropdown when its button has been clicked.\n\n\n      this.listenTo(this.buttonView, 'open', function () {\n        _this2.isOpen = !_this2.isOpen;\n      }); // Toggle the visibility of the panel when the dropdown becomes open.\n\n      this.panelView.bind('isVisible').to(this, 'isOpen'); // Let the dropdown control the position of the panel. The position must\n      // be updated every time the dropdown is open.\n\n      this.on('change:isOpen', function () {\n        if (!_this2.isOpen) {\n          return;\n        } // If \"auto\", find the best position of the panel to fit into the viewport.\n        // Otherwise, simply assign the static position.\n\n\n        if (_this2.panelPosition === 'auto') {\n          var defaultPanelPositions = DropdownView.defaultPanelPositions;\n          _this2.panelView.position = getOptimalPosition({\n            element: _this2.panelView.element,\n            target: _this2.buttonView.element,\n            fitInViewport: true,\n            positions: [defaultPanelPositions.southEast, defaultPanelPositions.southWest, defaultPanelPositions.northEast, defaultPanelPositions.northWest]\n          }).name;\n        } else {\n          _this2.panelView.position = _this2.panelPosition;\n        }\n      }); // Listen for keystrokes coming from within #element.\n\n      this.keystrokes.listenTo(this.element); // Register #element in the focus tracker.\n\n      this.focusTracker.add(this.element);\n\n      var closeDropdown = function closeDropdown(data, cancel) {\n        if (_this2.isOpen) {\n          _this2.buttonView.focus();\n\n          _this2.isOpen = false;\n          cancel();\n        }\n      }; // Open the dropdown panel using the arrow down key, just like with return or space.\n\n\n      this.keystrokes.set('arrowdown', function (data, cancel) {\n        // Don't open if the dropdown is disabled or already open.\n        if (_this2.buttonView.isEnabled && !_this2.isOpen) {\n          _this2.isOpen = true;\n          cancel();\n        }\n      }); // Block the right arrow key (until nested dropdowns are implemented).\n\n      this.keystrokes.set('arrowright', function (data, cancel) {\n        if (_this2.isOpen) {\n          cancel();\n        }\n      }); // Close the dropdown using the arrow left/escape key.\n\n      this.keystrokes.set('arrowleft', closeDropdown);\n      this.keystrokes.set('esc', closeDropdown);\n    }\n    /**\n     * Focuses the {@link #buttonView}.\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.buttonView.focus();\n    }\n  }]);\n\n  return DropdownView;\n}(View);\n/**\n * A set of positioning functions used by the dropdown view to determine\n * the optimal position (i.e. fitting into the browser viewport) of its\n * {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel} when\n * {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition} is set to 'auto'`.\n *\n * The available positioning functions are as follow:\n *\n * **South**\n *\n * * `southEast`\n *\n *\t\t[ Button ]\n *\t\t+-----------------+\n *\t\t|      Panel      |\n *\t\t+-----------------+\n *\n * * `southWest`\n *\n *\t\t         [ Button ]\n *\t\t+-----------------+\n *\t\t|      Panel      |\n *\t\t+-----------------+\n *\n * **North**\n *\n * * `northEast`\n *\n *\t\t+-----------------+\n *\t\t|      Panel      |\n *\t\t+-----------------+\n *\t\t[ Button ]\n *\n * * `northWest`\n *\n *\t\t+-----------------+\n *\t\t|      Panel      |\n *\t\t+-----------------+\n *\t\t         [ Button ]\n *\n * Positioning functions are compatible with {@link module:utils/dom/position~Position}.\n *\n * The name that position function returns will be reflected in dropdown panel's class that\n * controls its placement. See {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition}\n * to learn more.\n *\n * @member {Object} module:ui/dropdown/dropdownview~DropdownView.defaultPanelPositions\n */\n\n\nexport { DropdownView as default };\nDropdownView.defaultPanelPositions = {\n  southEast: function southEast(buttonRect) {\n    return {\n      top: buttonRect.bottom,\n      left: buttonRect.left,\n      name: 'se'\n    };\n  },\n  southWest: function southWest(buttonRect, panelRect) {\n    return {\n      top: buttonRect.bottom,\n      left: buttonRect.left - panelRect.width + buttonRect.width,\n      name: 'sw'\n    };\n  },\n  northEast: function northEast(buttonRect, panelRect) {\n    return {\n      top: buttonRect.top - panelRect.height,\n      left: buttonRect.left,\n      name: 'ne'\n    };\n  },\n  northWest: function northWest(buttonRect, panelRect) {\n    return {\n      top: buttonRect.bottom - panelRect.height,\n      left: buttonRect.left - panelRect.width + buttonRect.width,\n      name: 'nw'\n    };\n  }\n};","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/bindings/clickoutsidehandler\n */\n\n/* global document */\n\n/**\n * Handles clicking **outside** of a specified set of elements, then fires an action.\n *\n * **Note**: Actually, the action is executed upon `mousedown`, not `click`. It prevents\n * certain issues when the user keeps holding the mouse button and the UI cannot react\n * properly.\n *\n * @param {Object} options Configuration options.\n * @param {module:utils/dom/emittermixin~Emitter} options.emitter The emitter to which this behavior\n * should be added.\n * @param {Function} options.activator Function returning a `Boolean`, to determine whether the handler is active.\n * @param {Array.<HTMLElement>} options.contextElements HTML elements that determine the scope of the\n * handler. Clicking any of them or their descendants will **not** fire the callback.\n * @param {Function} options.callback An action executed by the handler.\n */\nexport default function clickOutsideHandler(_ref) {\n  var emitter = _ref.emitter,\n      activator = _ref.activator,\n      callback = _ref.callback,\n      contextElements = _ref.contextElements;\n  emitter.listenTo(document, 'mousedown', function (evt, _ref2) {\n    var target = _ref2.target;\n\n    if (!activator()) {\n      return;\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = contextElements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var contextElement = _step.value;\n\n        if (contextElement.contains(target)) {\n          return;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    callback();\n  });\n}","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/dropdown/utils\n */\nimport DropdownPanelView from \"./dropdownpanelview\";\nimport DropdownView from \"./dropdownview\";\nimport DropdownButtonView from \"./button/dropdownbuttonview\";\nimport ToolbarView from \"../toolbar/toolbarview\";\nimport ListView from \"../list/listview\";\nimport ListItemView from \"../list/listitemview\";\nimport ListSeparatorView from \"../list/listseparatorview\";\nimport ButtonView from \"../button/buttonview\";\nimport SwitchButtonView from \"../button/switchbuttonview\";\nimport clickOutsideHandler from \"../bindings/clickoutsidehandler\";\nimport \"../../theme/components/dropdown/toolbardropdown.css\";\nimport \"../../theme/components/dropdown/listdropdown.css\";\n/**\n * A helper for creating dropdowns. It creates an instance of a {@link module:ui/dropdown/dropdownview~DropdownView dropdown},\n * with a {@link module:ui/dropdown/button/dropdownbutton~DropdownButton button},\n * {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView panel} and all standard dropdown's behaviors.\n *\n * # Creating dropdowns\n *\n * By default, the default {@link module:ui/dropdown/button/dropdownbuttonview~DropdownButtonView} class is used as\n * definition of the button:\n *\n *\t\tconst dropdown = createDropdown( model );\n *\n *\t\t// Configure dropdown's button properties:\n *\t\tdropdown.buttonView.set( {\n *\t\t\tlabel: 'A dropdown',\n *\t\t\twithText: true\n *\t\t} );\n *\n *\t\tdropdown.render();\n *\n *\t\t// Will render a dropdown labeled \"A dropdown\" with an empty panel.\n *\t\tdocument.body.appendChild( dropdown.element );\n *\n * You can also provide other button views (they need to implement the\n * {@link module:ui/dropdown/button/dropdownbutton~DropdownButton} interface). For instance, you can use\n * {@link module:ui/dropdown/button/splitbuttonview~SplitButtonView} to create a dropdown with a split button.\n *\n *\t\tconst dropdown = createDropdown( model, SplitButtonView );\n *\n *\t\t// Configure dropdown's button properties:\n *\t\tdropdown.buttonView.set( {\n *\t\t\tlabel: 'A dropdown',\n *\t\t\twithText: true\n *\t\t} );\n *\n *\t\tdropdown.buttonView.on( 'execute', () => {\n *\t\t\t// Add the behavior of the \"action part\" of the split button.\n *\t\t\t// Split button consists of the \"action part\" and \"arrow part\".\n *\t\t\t// The arrow opens the dropdown while the action part can have some other behavior.\n * \t\t} );\n *\n *\t\tdropdown.render();\n *\n *\t\t// Will render a dropdown labeled \"A dropdown\" with an empty panel.\n *\t\tdocument.body.appendChild( dropdown.element );\n *\n * # Adding content to the dropdown's panel\n *\n * The content of the panel can be inserted directly into the `dropdown.panelView.element`:\n *\n *\t\tdropdown.panelView.element.textContent = 'Content of the panel';\n *\n * However, most of the time you will want to add there either a {@link module:ui/list/listview~ListView list of options}\n * or a list of buttons (i.e. a {@link module:ui/toolbar/toolbarview~ToolbarView toolbar}).\n * To simplify the task, you can use, respectively, {@link module:ui/dropdown/utils~addListToDropdown} or\n * {@link module:ui/dropdown/utils~addToolbarToDropdown} utils.\n *\n * @param {module:utils/locale~Locale} locale The locale instance.\n * @param {Function} ButtonClass The dropdown button view class. Needs to implement the\n * {@link module:ui/dropdown/button/dropdownbutton~DropdownButton} interface.\n * @returns {module:ui/dropdown/dropdownview~DropdownView} The dropdown view instance.\n */\n\nexport function createDropdown(locale) {\n  var ButtonClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DropdownButtonView;\n  var buttonView = new ButtonClass(locale);\n  var panelView = new DropdownPanelView(locale);\n  var dropdownView = new DropdownView(locale, buttonView, panelView);\n  buttonView.bind('isEnabled').to(dropdownView);\n\n  if (buttonView instanceof DropdownButtonView) {\n    buttonView.bind('isOn').to(dropdownView, 'isOpen');\n  } else {\n    buttonView.arrowView.bind('isOn').to(dropdownView, 'isOpen');\n  }\n\n  addDefaultBehavior(dropdownView);\n  return dropdownView;\n}\n/**\n * Adds an instance of {@link module:ui/toolbar/toolbarview~ToolbarView} to a dropdown.\n *\n *\t\tconst buttons = [];\n *\n *\t\t// Either create a new ButtonView instance or create existing.\n *\t\tbuttons.push( new ButtonView() );\n *\t\tbuttons.push( editor.ui.componentFactory.get( 'someButton' ) );\n *\n *\t\tconst dropdown = createDropdown( locale );\n *\n *\t\taddToolbarToDropdown( dropdown, buttons );\n *\n *\t\tdropdown.toolbarView.isVertical = true;\n *\n *\t\t// Will render a vertical button dropdown labeled \"A button dropdown\"\n *\t\t// with a button group in the panel containing two buttons.\n *\t\tdropdown.render()\n *\t\tdocument.body.appendChild( dropdown.element );\n *\n * See {@link module:ui/dropdown/utils~createDropdown} and {@link module:ui/toolbar/toolbarview~ToolbarView}.\n *\n * @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView A dropdown instance to which `ToolbarView` will be added.\n * @param {Iterable.<module:ui/button/buttonview~ButtonView>} buttons\n */\n\nexport function addToolbarToDropdown(dropdownView, buttons) {\n  var toolbarView = dropdownView.toolbarView = new ToolbarView();\n  dropdownView.extendTemplate({\n    attributes: {\n      class: ['ck-toolbar-dropdown']\n    }\n  });\n  buttons.map(function (view) {\n    return toolbarView.items.add(view);\n  });\n  dropdownView.panelView.children.add(toolbarView);\n  toolbarView.items.delegate('execute').to(dropdownView);\n}\n/**\n * Adds an instance of {@link module:ui/list/listview~ListView} to a dropdown.\n *\n *\t\tconst items = new Collection();\n *\n *\t\titems.add( {\n *\t\t\ttype: 'button',\n *\t\t\tmodel: new Model( {\n *\t\t\t\twithText: true,\n *\t\t\t\tlabel: 'First item',\n *\t\t\t\tlabelStyle: 'color: red'\n *\t\t\t} )\n *\t\t} );\n *\n *\t\titems.add( {\n *\t\t\t type: 'button',\n *\t\t\t model: new Model( {\n *\t\t\t\twithText: true,\n *\t\t\t\tlabel: 'Second item',\n *\t\t\t\tlabelStyle: 'color: green',\n *\t\t\t\tclass: 'foo'\n *\t\t\t} )\n *\t\t} );\n *\n *\t\tconst dropdown = createDropdown( locale );\n *\n *\t\taddListToDropdown( dropdown, items );\n *\n *\t\t// Will render a dropdown with a list in the panel containing two items.\n *\t\tdropdown.render()\n *\t\tdocument.body.appendChild( dropdown.element );\n *\n * The `items` collection passed to this methods controls the presence and attributes of respective\n * {@link module:ui/list/listitemview~ListItemView list items}.\n *\n *\n * See {@link module:ui/dropdown/utils~createDropdown} and {@link module:list/list~List}.\n *\n * @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView A dropdown instance to which `ListVIew` will be added.\n * @param {Iterable.<module:ui/dropdown/utils~ListDropdownItemDefinition>} items\n * A collection of the list item definitions to populate the list.\n */\n\nexport function addListToDropdown(dropdownView, items) {\n  var locale = dropdownView.locale;\n  var listView = dropdownView.listView = new ListView(locale);\n  listView.items.bindTo(items).using(function (_ref) {\n    var type = _ref.type,\n        model = _ref.model;\n\n    if (type === 'separator') {\n      return new ListSeparatorView(locale);\n    } else if (type === 'button' || type === 'switchbutton') {\n      var _buttonView;\n\n      var listItemView = new ListItemView(locale);\n      var buttonView;\n\n      if (type === 'button') {\n        buttonView = new ButtonView(locale);\n      } else {\n        buttonView = new SwitchButtonView(locale);\n      } // Bind all model properties to the button view.\n\n\n      (_buttonView = buttonView).bind.apply(_buttonView, _toConsumableArray(Object.keys(model))).to(model);\n\n      buttonView.delegate('execute').to(listItemView);\n      listItemView.children.add(buttonView);\n      return listItemView;\n    }\n  });\n  dropdownView.panelView.children.add(listView);\n  listView.items.delegate('execute').to(dropdownView);\n} // Add a set of default behaviors to dropdown view.\n//\n// @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView\n\nfunction addDefaultBehavior(dropdownView) {\n  closeDropdownOnBlur(dropdownView);\n  closeDropdownOnExecute(dropdownView);\n  focusDropdownContentsOnArrows(dropdownView);\n} // Adds a behavior to a dropdownView that closes opened dropdown when user clicks outside the dropdown.\n//\n// @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView\n\n\nfunction closeDropdownOnBlur(dropdownView) {\n  dropdownView.on('render', function () {\n    clickOutsideHandler({\n      emitter: dropdownView,\n      activator: function activator() {\n        return dropdownView.isOpen;\n      },\n      callback: function callback() {\n        dropdownView.isOpen = false;\n      },\n      contextElements: [dropdownView.element]\n    });\n  });\n} // Adds a behavior to a dropdownView that closes the dropdown view on \"execute\" event.\n//\n// @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView\n\n\nfunction closeDropdownOnExecute(dropdownView) {\n  // Close the dropdown when one of the list items has been executed.\n  dropdownView.on('execute', function (evt) {\n    // Toggling a switch button view should not close the dropdown.\n    if (evt.source instanceof SwitchButtonView) {\n      return;\n    }\n\n    dropdownView.isOpen = false;\n  });\n} // Adds a behavior to a dropdownView that focuses the dropdown's panel view contents on keystrokes.\n//\n// @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView\n\n\nfunction focusDropdownContentsOnArrows(dropdownView) {\n  // If the dropdown panel is already open, the arrow down key should focus the first child of the #panelView.\n  dropdownView.keystrokes.set('arrowdown', function (data, cancel) {\n    if (dropdownView.isOpen) {\n      dropdownView.panelView.focus();\n      cancel();\n    }\n  }); // If the dropdown panel is already open, the arrow up key should focus the last child of the #panelView.\n\n  dropdownView.keystrokes.set('arrowup', function (data, cancel) {\n    if (dropdownView.isOpen) {\n      dropdownView.panelView.focusLast();\n      cancel();\n    }\n  });\n}\n/**\n * A definition of the list item used by the {@link module:ui/dropdown/utils~addListToDropdown}\n * utility.\n *\n * @typedef {Object} module:ui/dropdown/utils~ListDropdownItemDefinition\n *\n * @property {String} type Either `'separator'`, `'button'` or `'switchbutton'`.\n * @property {module:ui/model~Model} [model] Model of the item (when **not** `'separator'`).\n * Its properties fuel the newly created list item (or its children, depending on the `type`).\n */","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Returns heading options as defined in `config.heading.options` but processed to consider\n * editor localization, i.e. to display {@link module:heading/heading~HeadingOption}\n * in the correct language.\n *\n * Note: The reason behind this method is that there's no way to use {@link module:utils/locale~Locale#t}\n * when the user config is defined because the editor does not exist yet.\n *\n * @param {module:core/editor/editor~Editor} editor\n * @returns {Array.<module:heading/heading~HeadingOption>}.\n */\nexport function getLocalizedOptions(editor) {\n    var t = editor.t;\n    var localizedTitles = {\n        Paragraph: t('be'),\n        'Heading 1': t('bf'),\n        'Heading 2': t('bg'),\n        'Heading 3': t('bh'),\n        'Heading 4': t('bi'),\n        'Heading 5': t('bj'),\n        'Heading 6': t('bk')\n    };\n    return editor.config.get('heading.options').map(function (option) {\n        var title = localizedTitles[option.title];\n        if (title && title != option.title) {\n            option.title = title;\n        }\n        return option;\n    });\n}","import 'core-js/modules/es7.symbol.async-iterator';\nimport 'core-js/modules/es6.symbol';\nimport 'core-js/modules/web.dom.iterable';\nimport _classCallCheck from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck';\nimport _createClass from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass';\nimport _possibleConstructorReturn from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn';\nimport _getPrototypeOf from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf';\nimport _inherits from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits';\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module heading/headingui\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Model from '@ckeditor/ckeditor5-ui/src/model';\nimport {\n    createDropdown,\n    addListToDropdown\n} from '@ckeditor/ckeditor5-ui/src/dropdown/utils';\nimport { getLocalizedOptions } from './utils';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport '../theme/heading.css';\n/**\n * The headings UI feature. It introduces the `headings` dropdown.\n *\n * @extends module:core/plugin~Plugin\n */\nvar HeadingUI = /*#__PURE__*/\nfunction (_Plugin) {\n    _inherits(HeadingUI, _Plugin);\n    function HeadingUI() {\n        _classCallCheck(this, HeadingUI);\n        return _possibleConstructorReturn(this, _getPrototypeOf(HeadingUI).apply(this, arguments));\n    }\n    _createClass(HeadingUI, [{\n            key: 'init',\n            /**\n     * @inheritDoc\n     */\n            value: function init() {\n                var _this = this;\n                var editor = this.editor;\n                var t = editor.t;\n                var options = getLocalizedOptions(editor);\n                var defaultTitle = t('g');\n                var dropdownTooltip = t('h');\n                // Register UI component.\n                editor.ui.componentFactory.add('heading', function (locale) {\n                    var titles = {};\n                    var itemDefinitions = new Collection();\n                    var headingCommand = editor.commands.get('heading');\n                    var paragraphCommand = editor.commands.get('paragraph');\n                    var commands = [headingCommand];\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n                    try {\n                        var _loop = function _loop() {\n                            var option = _step.value;\n                            var def = {\n                                type: 'button',\n                                model: new Model({\n                                    label: option.title,\n                                    class: option.class,\n                                    withText: true\n                                })\n                            };\n                            if (option.model === 'paragraph') {\n                                def.model.bind('isOn').to(paragraphCommand, 'value');\n                                def.model.set('commandName', 'paragraph');\n                                commands.push(paragraphCommand);\n                            } else {\n                                def.model.bind('isOn').to(headingCommand, 'value', function (value) {\n                                    return value === option.model;\n                                });\n                                def.model.set({\n                                    commandName: 'heading',\n                                    commandValue: option.model\n                                });\n                            }\n                            // Add the option to the collection.\n                            itemDefinitions.add(def);\n                            titles[option.model] = option.title;\n                        };\n                        for (var _iterator = options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                            _loop();\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                _iterator.return();\n                            }\n                        } finally {\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                    var dropdownView = createDropdown(locale);\n                    addListToDropdown(dropdownView, itemDefinitions);\n                    dropdownView.buttonView.set({\n                        isOn: false,\n                        withText: true,\n                        tooltip: dropdownTooltip\n                    });\n                    dropdownView.extendTemplate({ attributes: { class: ['ck-heading-dropdown'] } });\n                    dropdownView.bind('isEnabled').toMany(commands, 'isEnabled', function () {\n                        for (var _len = arguments.length, areEnabled = new Array(_len), _key = 0; _key < _len; _key++) {\n                            areEnabled[_key] = arguments[_key];\n                        }\n                        return areEnabled.some(function (isEnabled) {\n                            return isEnabled;\n                        });\n                    });\n                    dropdownView.buttonView.bind('label').to(headingCommand, 'value', paragraphCommand, 'value', function (value, para) {\n                        var whichModel = value || para && 'paragraph';\n                        // If none of the commands is active, display default title.\n                        return titles[whichModel] ? titles[whichModel] : defaultTitle;\n                    });\n                    // Execute command when an item from the dropdown is selected.\n                    _this.listenTo(dropdownView, 'execute', function (evt) {\n                        editor.execute(evt.source.commandName, evt.source.commandValue ? { value: evt.source.commandValue } : undefined);\n                        editor.editing.view.focus();\n                    });\n                    return dropdownView;\n                });\n            }\n        }]);\n    return HeadingUI;\n}(Plugin);\nexport {\n    HeadingUI as default\n};","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module alignment/alignmentcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\nimport { isDefault } from \"./utils\";\nvar ALIGNMENT = 'alignment';\n/**\n * The alignment command plugin.\n *\n * @extends module:core/command~Command\n */\n\nvar AlignmentCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(AlignmentCommand, _Command);\n\n  function AlignmentCommand() {\n    _classCallCheck(this, AlignmentCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AlignmentCommand).apply(this, arguments));\n  }\n\n  _createClass(AlignmentCommand, [{\n    key: \"refresh\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      var firstBlock = first(this.editor.model.document.selection.getSelectedBlocks()); // As first check whether to enable or disable the command as the value will always be false if the command cannot be enabled.\n\n      this.isEnabled = !!firstBlock && this._canBeAligned(firstBlock);\n      /**\n       * A value of the current block's alignment.\n       *\n       * @observable\n       * @readonly\n       * @member {String} #value\n       */\n\n      this.value = this.isEnabled && firstBlock.hasAttribute('alignment') ? firstBlock.getAttribute('alignment') : 'left';\n    }\n    /**\n     * Executes the command. Applies the alignment `value` to the selected blocks.\n     * If no `value` is passed, the `value` is the default one or it is equal to the currently selected block's alignment attribute,\n     * the command will remove the attribute from the selected blocks.\n     *\n     * @param {Object} [options] Options for the executed command.\n     * @param {String} [options.value] The value to apply.\n     * @fires execute\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var editor = this.editor;\n      var model = editor.model;\n      var doc = model.document;\n      var value = options.value;\n      model.change(function (writer) {\n        // Get only those blocks from selected that can have alignment set\n        var blocks = Array.from(doc.selection.getSelectedBlocks()).filter(function (block) {\n          return _this._canBeAligned(block);\n        });\n        var currentAlignment = blocks[0].getAttribute('alignment'); // Remove alignment attribute if current alignment is:\n        // - default (should not be stored in model as it will bloat model data)\n        // - equal to currently set\n        // - or no value is passed - denotes default alignment.\n\n        var removeAlignment = isDefault(value) || currentAlignment === value || !value;\n\n        if (removeAlignment) {\n          removeAlignmentFromSelection(blocks, writer);\n        } else {\n          setAlignmentOnSelection(blocks, writer, value);\n        }\n      });\n    }\n    /**\n     * Checks whether a block can have alignment set.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} block The block to be checked.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_canBeAligned\",\n    value: function _canBeAligned(block) {\n      return this.editor.model.schema.checkAttribute(block, ALIGNMENT);\n    }\n  }]);\n\n  return AlignmentCommand;\n}(Command); // Removes the alignment attribute from blocks.\n// @private\n\n\nexport { AlignmentCommand as default };\n\nfunction removeAlignmentFromSelection(blocks, writer) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = blocks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var block = _step.value;\n      writer.removeAttribute(ALIGNMENT, block);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n} // Sets the alignment attribute on blocks.\n// @private\n\n\nfunction setAlignmentOnSelection(blocks, writer, alignment) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = blocks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var block = _step2.value;\n      writer.setAttribute(ALIGNMENT, alignment, block);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module alignment/alignmentediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport AlignmentCommand from \"./alignmentcommand\";\nimport { isDefault, isSupported, supportedOptions } from \"./utils\";\n/**\n * The alignment editing feature. It introduces the {@link module:alignment/alignmentcommand~AlignmentCommand command} and adds\n * the `alignment` attribute for block elements in the {@link module:engine/model/model~Model model}.\n * @extends module:core/plugin~Plugin\n */\n\nvar AlignmentEditing =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(AlignmentEditing, _Plugin);\n\n  /**\n   * @inheritDoc\n   */\n  function AlignmentEditing(editor) {\n    var _this;\n\n    _classCallCheck(this, AlignmentEditing);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AlignmentEditing).call(this, editor));\n    editor.config.define('alignment', {\n      options: _toConsumableArray(supportedOptions)\n    });\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(AlignmentEditing, [{\n    key: \"init\",\n    value: function init() {\n      var editor = this.editor;\n      var schema = editor.model.schema; // Filter out unsupported options.\n\n      var enabledOptions = editor.config.get('alignment.options').filter(isSupported); // Allow alignment attribute on all blocks.\n\n      schema.extend('$block', {\n        allowAttributes: 'alignment'\n      });\n      editor.model.schema.setAttributeProperties('alignment', {\n        isFormatting: true\n      });\n\n      var definition = _buildDefinition(enabledOptions.filter(function (option) {\n        return !isDefault(option);\n      }));\n\n      editor.conversion.attributeToAttribute(definition);\n      editor.commands.add('alignment', new AlignmentCommand(editor));\n    }\n  }]);\n\n  return AlignmentEditing;\n}(Plugin); // Utility function responsible for building converter definition.\n// @private\n\n\nexport { AlignmentEditing as default };\n\nfunction _buildDefinition(options) {\n  var definition = {\n    model: {\n      key: 'alignment',\n      values: options.slice()\n    },\n    view: {}\n  };\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var option = _step.value;\n      definition.view[option] = {\n        key: 'style',\n        value: {\n          'text-align': option\n        }\n      };\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return definition;\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/findlinkrange\n */\n\n/**\n * Returns a range containing the entire link in which the given `position` is placed.\n *\n * It can be used e.g. to get the entire range on which the `linkHref` attribute needs to be changed when having a\n * selection inside a link.\n *\n * @param {module:engine/model/position~Position} position The start position.\n * @param {String} value The `linkHref` attribute value.\n * @returns {module:engine/model/range~Range} The link range.\n */\nexport default function findLinkRange(position, value, model) {\n  return model.createRange(_findBound(position, value, true, model), _findBound(position, value, false, model));\n} // Walks forward or backward (depends on the `lookBack` flag), node by node, as long as they have the same `linkHref` attribute value\n// and returns a position just before or after (depends on the `lookBack` flag) the last matched node.\n//\n// @param {module:engine/model/position~Position} position The start position.\n// @param {String} value The `linkHref` attribute value.\n// @param {Boolean} lookBack Whether the walk direction is forward (`false`) or backward (`true`).\n// @returns {module:engine/model/position~Position} The position just before the last matched node.\n\nfunction _findBound(position, value, lookBack, model) {\n  // Get node before or after position (depends on `lookBack` flag).\n  // When position is inside text node then start searching from text node.\n  var node = position.textNode || (lookBack ? position.nodeBefore : position.nodeAfter);\n  var lastNode = null;\n\n  while (node && node.getAttribute('linkHref') == value) {\n    lastNode = node;\n    node = lookBack ? node.previousSibling : node.nextSibling;\n  }\n\n  return lastNode ? model.createPositionAt(lastNode, lookBack ? 'before' : 'after') : position;\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport findLinkRange from \"./findlinkrange\";\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\n/**\n * The link command. It is used by the {@link module:link/link~Link link feature}.\n *\n * @extends module:core/command~Command\n */\n\nvar LinkCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(LinkCommand, _Command);\n\n  function LinkCommand() {\n    _classCallCheck(this, LinkCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LinkCommand).apply(this, arguments));\n  }\n\n  _createClass(LinkCommand, [{\n    key: \"refresh\",\n\n    /**\n     * The value of the `'linkHref'` attribute if the start of the selection is located in a node with this attribute.\n     *\n     * @observable\n     * @readonly\n     * @member {Object|undefined} #value\n     */\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      var model = this.editor.model;\n      var doc = model.document;\n      this.value = doc.selection.getAttribute('linkHref');\n      this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, 'linkHref');\n    }\n    /**\n     * Executes the command.\n     *\n     * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to\n     * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).\n     *\n     * When the selection is collapsed and is not inside the text with the `linkHref` attribute, the\n     * new {@link module:engine/model/text~Text Text node} with the `linkHref` attribute will be inserted in place of caret, but\n     * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.\n     * The selection will be updated to wrap the just inserted text node.\n     *\n     * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.\n     *\n     * @fires execute\n     * @param {String} href Link destination.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(href) {\n      var model = this.editor.model;\n      var selection = model.document.selection;\n      model.change(function (writer) {\n        // If selection is collapsed then update selected link or insert new one at the place of caret.\n        if (selection.isCollapsed) {\n          var position = selection.getFirstPosition(); // When selection is inside text with `linkHref` attribute.\n\n          if (selection.hasAttribute('linkHref')) {\n            // Then update `linkHref` value.\n            var linkRange = findLinkRange(selection.getFirstPosition(), selection.getAttribute('linkHref'), model);\n            writer.setAttribute('linkHref', href, linkRange); // Create new range wrapping changed link.\n\n            writer.setSelection(linkRange);\n          } // If not then insert text node with `linkHref` attribute in place of caret.\n          // However, since selection in collapsed, attribute value will be used as data for text node.\n          // So, if `href` is empty, do not create text node.\n          else if (href !== '') {\n              var attributes = toMap(selection.getAttributes());\n              attributes.set('linkHref', href);\n              var node = writer.createText(href, attributes);\n              model.insertContent(node, position); // Create new range wrapping created node.\n\n              writer.setSelection(writer.createRangeOn(node));\n            }\n        } else {\n          // If selection has non-collapsed ranges, we change attribute on nodes inside those ranges\n          // omitting nodes where `linkHref` attribute is disallowed.\n          var ranges = model.schema.getValidRanges(selection.getRanges(), 'linkHref');\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var range = _step.value;\n              writer.setAttribute('linkHref', href, range);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      });\n    }\n  }]);\n\n  return LinkCommand;\n}(Command);\n\nexport { LinkCommand as default };","import \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.regexp.replace\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/utils\n */\nvar ATTRIBUTE_WHITESPACES = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n\nvar SAFE_URL = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;\n/**\n * Returns `true` if a given view node is the link element.\n *\n * @param {module:engine/view/node~Node} node\n * @returns {Boolean}\n */\n\nexport function isLinkElement(node) {\n  return node.is('attributeElement') && !!node.getCustomProperty('link');\n}\n/**\n * Creates link {@link module:engine/view/attributeelement~AttributeElement} with provided `href` attribute.\n *\n * @param {String} href\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\n\nexport function createLinkElement(href, writer) {\n  // Priority 5 - https://github.com/ckeditor/ckeditor5-link/issues/121.\n  var linkElement = writer.createAttributeElement('a', {\n    href: href\n  }, {\n    priority: 5\n  });\n  writer.setCustomProperty('link', true, linkElement);\n  return linkElement;\n}\n/**\n * Returns a safe URL based on a given value.\n *\n * An URL is considered safe if it is safe for the user (does not contain any malicious code).\n *\n * If URL is considered unsafe, a simple `\"#\"` is returned.\n *\n * @protected\n * @param {*} url\n * @returns {String} Safe URL.\n */\n\nexport function ensureSafeUrl(url) {\n  url = String(url);\n  return isSafeUrl(url) ? url : '#';\n} // Checks whether the given URL is safe for the user (does not contain any malicious code).\n//\n// @param {String} url URL to check.\n\nfunction isSafeUrl(url) {\n  var normalizedUrl = url.replace(ATTRIBUTE_WHITESPACES, '');\n  return normalizedUrl.match(SAFE_URL);\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/utils/bindtwostepcarettoattribute\n */\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\n/**\n * This helper enabled the two-step caret (phantom) movement behavior for the given {@link module:engine/model/model~Model}\n * attribute on arrow right (<kbd></kbd>) and left (<kbd></kbd>) key press.\n *\n * Thanks to this (phantom) caret movement the user is able to type before/after as well as at the\n * beginning/end of an attribute.\n *\n * # Forward movement\n *\n * ## \"Entering\" an attribute:\n *\n * When this behavior is enabled for the `a` attribute and the selection is right before it\n * (at the attribute boundary), pressing the right arrow key will not move the selection but update its\n * attributes accordingly:\n *\n * * When enabled:\n *\n *   \t\tfoo{}<$text a=\"true\">bar</$text>\n *\n *    <kbd></kbd>\n *\n *   \t\tfoo<$text a=\"true\">{}bar</$text>\n *\n * * When disabled:\n *\n *   \t\tfoo{}<$text a=\"true\">bar</$text>\n *\n *   <kbd></kbd>\n *\n *   \t\tfoo<$text a=\"true\">b{}ar</$text>\n *\n *\n * ## \"Leaving\" an attribute:\n *\n * * When enabled:\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n *    <kbd></kbd>\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n * * When disabled:\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n *   <kbd></kbd>\n *\n *   \t\t<$text a=\"true\">bar</$text>b{}az\n *\n * # Backward movement\n *\n * * When enabled:\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n *    <kbd></kbd>\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n * * When disabled:\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n *   <kbd></kbd>\n *\n *   \t\t<$text a=\"true\">ba{}r</$text>b{}az\n *\n * @param {module:engine/view/view~View} view View controller instance.\n * @param {module:engine/model/model~Model} model Data model instance.\n * @param {module:utils/dom/emittermixin~Emitter} emitter The emitter to which this behavior should be added\n * (e.g. a plugin instance).\n * @param {String} attribute Attribute for which this behavior will be added.\n */\n\nexport default function bindTwoStepCaretToAttribute(view, model, emitter, attribute) {\n  var twoStepCaretHandler = new TwoStepCaretHandler(model, emitter, attribute);\n  var modelSelection = model.document.selection; // Listen to keyboard events and handle the caret movement according to the 2-step caret logic.\n  //\n  // Note: This listener has the \"high+1\" priority:\n  // * \"high\" because of the filler logic implemented in the renderer which also engages on #keydown.\n  // When the gravity is overridden the attributes of the (model) selection attributes are reset.\n  // It may end up with the filler kicking in and breaking the selection.\n  // * \"+1\" because we would like to avoid collisions with other features (like Widgets), which\n  // take over the keydown events with the \"high\" priority. Two-step caret movement takes precedence\n  // over Widgets in that matter.\n  //\n  // Find out more in https://github.com/ckeditor/ckeditor5-engine/issues/1301.\n\n  emitter.listenTo(view.document, 'keydown', function (evt, data) {\n    // This implementation works only for collapsed selection.\n    if (!modelSelection.isCollapsed) {\n      return;\n    } // When user tries to expand the selection or jump over the whole word or to the beginning/end then\n    // two-steps movement is not necessary.\n\n\n    if (data.shiftKey || data.altKey || data.ctrlKey) {\n      return;\n    }\n\n    var arrowRightPressed = data.keyCode == keyCodes.arrowright;\n    var arrowLeftPressed = data.keyCode == keyCodes.arrowleft; // When neither left or right arrow has been pressed then do noting.\n\n    if (!arrowRightPressed && !arrowLeftPressed) {\n      return;\n    }\n\n    var position = modelSelection.getFirstPosition();\n    var isMovementHandled;\n\n    if (arrowRightPressed) {\n      isMovementHandled = twoStepCaretHandler.handleForwardMovement(position, data);\n    } else {\n      isMovementHandled = twoStepCaretHandler.handleBackwardMovement(position, data);\n    } // Stop the keydown event if the two-step arent movement handled it. Avoid collisions\n    // with other features which may also take over the caret movement (e.g. Widget).\n\n\n    if (isMovementHandled) {\n      evt.stop();\n    }\n  }, {\n    priority: priorities.get('high') + 1\n  });\n}\n/**\n * This is a private helperclass for {@link module:engine/utils/bindtwostepcarettoattribute}.\n * It handles the state of the 2-step caret movement for a single {@link module:engine/model/model~Model}\n * attribute upon the `keypress` in the {@link module:engine/view/view~View}.\n *\n * @private\n */\n\nvar TwoStepCaretHandler =\n/*#__PURE__*/\nfunction () {\n  /*\n   * Creates two step handler instance.\n   *\n   * @param {module:engine/model/model~Model} model Data model instance.\n   * @param {module:utils/dom/emittermixin~Emitter} emitter The emitter to which this behavior should be added\n   * (e.g. a plugin instance).\n   * @param {String} attribute Attribute for which the behavior will be added.\n   */\n  function TwoStepCaretHandler(model, emitter, attribute) {\n    var _this = this;\n\n    _classCallCheck(this, TwoStepCaretHandler);\n\n    /**\n     * The model instance this class instance operates on.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model#schema}\n     */\n    this.model = model;\n    /**\n     * The Attribute this class instance operates on.\n     *\n     * @readonly\n     * @member {String}\n     */\n\n    this.attribute = attribute;\n    /**\n     * A reference to the document selection.\n     *\n     * @private\n     * @member {module:engine/model/selection~Selection}\n     */\n\n    this._modelSelection = model.document.selection;\n    /**\n     * The current UID of the overridden gravity, as returned by\n     * {@link module:engine/model/writer~Writer#overrideSelectionGravity}.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._overrideUid = null;\n    /**\n     * A flag indicating that the automatic gravity restoration for this attribute\n     * should not happen upon the next\n     * {@link module:engine/model/selection~Selection#event:change:range} event.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._isNextGravityRestorationSkipped = false; // The automatic gravity restoration logic.\n\n    emitter.listenTo(this._modelSelection, 'change:range', function (evt, data) {\n      // Skipping the automatic restoration is needed if the selection should change\n      // but the gravity must remain overridden afterwards. See the #handleBackwardMovement\n      // to learn more.\n      if (_this._isNextGravityRestorationSkipped) {\n        _this._isNextGravityRestorationSkipped = false;\n        return;\n      } // Skip automatic restore when the gravity is not overridden  simply, there's nothing to restore\n      // at this moment.\n\n\n      if (!_this._isGravityOverridden) {\n        return;\n      } // Skip automatic restore when the change is indirect AND the selection is at the attribute boundary.\n      // It means that e.g. if the change was external (collaboration) and the user had their\n      // selection around the link, its gravity should remain intact in this change:range event.\n\n\n      if (!data.directChange && isAtBoundary(_this._modelSelection.getFirstPosition(), attribute)) {\n        return;\n      }\n\n      _this._restoreGravity();\n    });\n  }\n  /**\n   * Updates the document selection and the view according to the twostep caret movement state\n   * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n   *\n   * @param {module:engine/model/position~Position} position The model position at the moment of the key press.\n   * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.\n   * @returns {Boolean} `true` when the handler prevented caret movement\n   */\n\n\n  _createClass(TwoStepCaretHandler, [{\n    key: \"handleForwardMovement\",\n    value: function handleForwardMovement(position, data) {\n      var attribute = this.attribute; // DON'T ENGAGE 2-SCM if gravity is already overridden. It means that we just entered\n      //\n      // \t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n      //\n      // or left the attribute\n      //\n      // \t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n      //\n      // and the gravity will be restored automatically.\n\n      if (this._isGravityOverridden) {\n        return;\n      } // DON'T ENGAGE 2-SCM when the selection is at the beginning of the block AND already has the\n      // attribute:\n      // * when the selection was initially set there using the mouse,\n      // * when the editor has just started\n      //\n      //\t\t<paragraph><$text attribute>{}bar</$text>baz</paragraph>\n      //\n\n\n      if (position.isAtStart && this._hasSelectionAttribute) {\n        return;\n      } // ENGAGE 2-SCM when about to leave one attribute value and enter another:\n      //\n      // \t\t<paragraph><$text attribute=\"1\">foo{}</$text><$text attribute=\"2\">bar</$text></paragraph>\n      //\n      // but DON'T when already in between of them (no attribute selection):\n      //\n      // \t\t<paragraph><$text attribute=\"1\">foo</$text>{}<$text attribute=\"2\">bar</$text></paragraph>\n      //\n\n\n      if (isBetweenDifferentValues(position, attribute) && this._hasSelectionAttribute) {\n        this._preventCaretMovement(data);\n\n        this._removeSelectionAttribute();\n\n        return true;\n      } // ENGAGE 2-SCM when entering an attribute:\n      //\n      // \t\t<paragraph>foo{}<$text attribute>bar</$text>baz</paragraph>\n      //\n\n\n      if (isAtStartBoundary(position, attribute)) {\n        this._preventCaretMovement(data);\n\n        this._overrideGravity();\n\n        return true;\n      } // ENGAGE 2-SCM when leaving an attribute:\n      //\n      //\t\t<paragraph>foo<$text attribute>bar{}</$text>baz</paragraph>\n      //\n\n\n      if (isAtEndBoundary(position, attribute) && this._hasSelectionAttribute) {\n        this._preventCaretMovement(data);\n\n        this._overrideGravity();\n\n        return true;\n      }\n    }\n    /**\n     * Updates the document selection and the view according to the twostep caret movement state\n     * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n     *\n     * @param {module:engine/model/position~Position} position The model position at the moment of the key press.\n     * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.\n     * @returns {Boolean} `true` when the handler prevented caret movement\n     */\n\n  }, {\n    key: \"handleBackwardMovement\",\n    value: function handleBackwardMovement(position, data) {\n      var attribute = this.attribute; // When the gravity is already overridden...\n\n      if (this._isGravityOverridden) {\n        // ENGAGE 2-SCM & REMOVE SELECTION ATTRIBUTE\n        // when about to leave one attribute value and enter another:\n        //\n        // \t\t<paragraph><$text attribute=\"1\">foo</$text><$text attribute=\"2\">{}bar</$text></paragraph>\n        //\n        // but DON'T when already in between of them (no attribute selection):\n        //\n        // \t\t<paragraph><$text attribute=\"1\">foo</$text>{}<$text attribute=\"2\">bar</$text></paragraph>\n        //\n        if (isBetweenDifferentValues(position, attribute) && this._hasSelectionAttribute) {\n          this._preventCaretMovement(data);\n\n          this._restoreGravity();\n\n          this._removeSelectionAttribute();\n\n          return true;\n        } // ENGAGE 2-SCM when at any boundary of the attribute:\n        //\n        // \t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n        // \t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n        //\n        else {\n            this._preventCaretMovement(data);\n\n            this._restoreGravity(); // REMOVE SELECTION ATRIBUTE at the beginning of the block.\n            // It's like restoring gravity but towards a non-existent content when\n            // the gravity is overridden:\n            //\n            // \t\t<paragraph><$text attribute>{}bar</$text></paragraph>\n            //\n            // becomes:\n            //\n            // \t\t<paragraph>{}<$text attribute>bar</$text></paragraph>\n            //\n\n\n            if (position.isAtStart) {\n              this._removeSelectionAttribute();\n            }\n\n            return true;\n          }\n      } else {\n        // ENGAGE 2-SCM when between two different attribute values but selection has no attribute:\n        //\n        // \t\t<paragraph><$text attribute=\"1\">foo</$text>{}<$text attribute=\"2\">bar</$text></paragraph>\n        //\n        if (isBetweenDifferentValues(position, attribute) && !this._hasSelectionAttribute) {\n          this._preventCaretMovement(data);\n\n          this._setSelectionAttributeFromTheNodeBefore(position);\n\n          return true;\n        } // End of block boundary cases:\n        //\n        // \t\t<paragraph><$text attribute>bar{}</$text></paragraph>\n        // \t\t<paragraph><$text attribute>bar</$text>{}</paragraph>\n        //\n\n\n        if (position.isAtEnd && isAtEndBoundary(position, attribute)) {\n          // DON'T ENGAGE 2-SCM if the selection has the attribute already.\n          // This is a common selection if set using the mouse.\n          //\n          // \t\t<paragraph><$text attribute>bar{}</$text></paragraph>\n          //\n          if (this._hasSelectionAttribute) {\n            // DON'T ENGAGE 2-SCM if the attribute at the end of the block which has length == 1.\n            // Make sure the selection will not the attribute after it moves backwards.\n            //\n            // \t\t<paragraph>foo<$text attribute>b{}</$text></paragraph>\n            //\n            if (isStepAfterTheAttributeBoundary(position, attribute)) {\n              // Skip the automatic gravity restore upon the next selection#change:range event.\n              // If not skipped, it would automatically restore the gravity, which should remain\n              // overridden.\n              this._skipNextAutomaticGravityRestoration();\n\n              this._overrideGravity(); // Don't return \"true\" here because we didn't call _preventCaretMovement.\n              // Returning here will destabilize the filler logic, which also listens to\n              // keydown (and the event would be stopped).\n\n            }\n\n            return;\n          } // ENGAGE 2-SCM if the selection has no attribute. This may happen when the user\n          // left the attribute using a FORWARD 2-SCM.\n          //\n          // \t\t<paragraph><$text attribute>bar</$text>{}</paragraph>\n          //\n          else {\n              this._preventCaretMovement(data);\n\n              this._setSelectionAttributeFromTheNodeBefore(position);\n\n              return true;\n            }\n        } // REMOVE SELECTION ATRIBUTE when restoring gravity towards a non-existent content at the\n        // beginning of the block.\n        //\n        // \t\t<paragraph>{}<$text attribute>bar</$text></paragraph>\n        //\n\n\n        if (position.isAtStart) {\n          if (this._hasSelectionAttribute) {\n            this._removeSelectionAttribute();\n\n            this._preventCaretMovement(data);\n\n            return true;\n          }\n\n          return;\n        } // DON'T ENGAGE 2-SCM when about to enter of leave an attribute.\n        // We need to check if the caret is a one position before the attribute boundary:\n        //\n        // \t\t<paragraph>foo<$text attribute>b{}ar</$text>baz</paragraph>\n        // \t\t<paragraph>foo<$text attribute>bar</$text>b{}az</paragraph>\n        //\n\n\n        if (isStepAfterTheAttributeBoundary(position, attribute)) {\n          // Skip the automatic gravity restore upon the next selection#change:range event.\n          // If not skipped, it would automatically restore the gravity, which should remain\n          // overridden.\n          this._skipNextAutomaticGravityRestoration();\n\n          this._overrideGravity(); // Don't return \"true\" here because we didn't call _preventCaretMovement.\n          // Returning here will destabilize the filler logic, which also listens to\n          // keydown (and the event would be stopped).\n\n        }\n      }\n    }\n    /**\n     * `true` when the gravity is overridden for the {@link #attribute}.\n     *\n     * @readonly\n     * @private\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"_overrideGravity\",\n\n    /**\n     * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}\n     * and stores the information about this fact in the {@link #_overrideUid}.\n     *\n     * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.\n     *\n     * @private\n     */\n    value: function _overrideGravity() {\n      this._overrideUid = this.model.change(function (writer) {\n        return writer.overrideSelectionGravity();\n      });\n    }\n    /**\n     * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.\n     *\n     * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_restoreGravity\",\n    value: function _restoreGravity() {\n      var _this2 = this;\n\n      this.model.change(function (writer) {\n        writer.restoreSelectionGravity(_this2._overrideUid);\n        _this2._overrideUid = null;\n      });\n    }\n    /**\n     * Prevents the caret movement in the view by calling `preventDefault` on the event data.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_preventCaretMovement\",\n    value: function _preventCaretMovement(data) {\n      data.preventDefault();\n    }\n    /**\n     * Removes the {@link #attribute} from the selection using using the\n     * {@link module:engine/model/writer~Writer model writer}.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_removeSelectionAttribute\",\n    value: function _removeSelectionAttribute() {\n      var _this3 = this;\n\n      this.model.change(function (writer) {\n        writer.removeSelectionAttribute(_this3.attribute);\n      });\n    }\n    /**\n     * Applies the {@link #attribute} to the current selection using using the\n     * value from the node before the current position. Uses\n     * the {@link module:engine/model/writer~Writer model writer}.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position\n     */\n\n  }, {\n    key: \"_setSelectionAttributeFromTheNodeBefore\",\n    value: function _setSelectionAttributeFromTheNodeBefore(position) {\n      var _this4 = this;\n\n      var attribute = this.attribute;\n      this.model.change(function (writer) {\n        writer.setSelectionAttribute(_this4.attribute, position.nodeBefore.getAttribute(attribute));\n      });\n    }\n    /**\n     * Skips the next automatic selection gravity restoration upon the\n     * {@link module:engine/model/selection~Selection#event:change:range} event.\n     *\n     * See {@link #_isNextGravityRestorationSkipped}.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_skipNextAutomaticGravityRestoration\",\n    value: function _skipNextAutomaticGravityRestoration() {\n      this._isNextGravityRestorationSkipped = true;\n    }\n  }, {\n    key: \"_isGravityOverridden\",\n    get: function get() {\n      return !!this._overrideUid;\n    }\n    /**\n     * `true` when the {@link module:engine/model/selection~Selection} has the {@link #attribute}.\n     *\n     * @readonly\n     * @private\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"_hasSelectionAttribute\",\n    get: function get() {\n      return this._modelSelection.hasAttribute(this.attribute);\n    }\n  }]);\n\n  return TwoStepCaretHandler;\n}(); // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n// @returns {Boolean} `true` when position between the nodes sticks to the bound of text with given attribute.\n\n\nfunction isAtBoundary(position, attribute) {\n  return isAtStartBoundary(position, attribute) || isAtEndBoundary(position, attribute);\n} // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n\n\nfunction isAtStartBoundary(position, attribute) {\n  var nodeBefore = position.nodeBefore,\n      nodeAfter = position.nodeAfter;\n  var isAttrBefore = nodeBefore ? nodeBefore.hasAttribute(attribute) : false;\n  var isAttrAfter = nodeAfter ? nodeAfter.hasAttribute(attribute) : false;\n  return isAttrAfter && (!isAttrBefore || nodeBefore.getAttribute(attribute) !== nodeAfter.getAttribute(attribute));\n} // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n\n\nfunction isAtEndBoundary(position, attribute) {\n  var nodeBefore = position.nodeBefore,\n      nodeAfter = position.nodeAfter;\n  var isAttrBefore = nodeBefore ? nodeBefore.hasAttribute(attribute) : false;\n  var isAttrAfter = nodeAfter ? nodeAfter.hasAttribute(attribute) : false;\n  return isAttrBefore && (!isAttrAfter || nodeBefore.getAttribute(attribute) !== nodeAfter.getAttribute(attribute));\n} // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n\n\nfunction isBetweenDifferentValues(position, attribute) {\n  var nodeBefore = position.nodeBefore,\n      nodeAfter = position.nodeAfter;\n  var isAttrBefore = nodeBefore ? nodeBefore.hasAttribute(attribute) : false;\n  var isAttrAfter = nodeAfter ? nodeAfter.hasAttribute(attribute) : false;\n\n  if (!isAttrAfter || !isAttrBefore) {\n    return;\n  }\n\n  return nodeAfter.getAttribute(attribute) !== nodeBefore.getAttribute(attribute);\n} // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n\n\nfunction isStepAfterTheAttributeBoundary(position, attribute) {\n  return isAtBoundary(position.getShiftedBy(-1), attribute);\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport LinkCommand from \"./linkcommand\";\nimport UnlinkCommand from \"./unlinkcommand\";\nimport { createLinkElement, ensureSafeUrl } from \"./utils\";\nimport bindTwoStepCaretToAttribute from '@ckeditor/ckeditor5-engine/src/utils/bindtwostepcarettoattribute';\nimport findLinkRange from \"./findlinkrange\";\nimport \"../theme/link.css\";\nvar HIGHLIGHT_CLASS = 'ck-link_selected';\n/**\n * The link engine feature.\n *\n * It introduces the `linkHref=\"url\"` attribute in the model which renders to the view as a `<a href=\"url\">` element\n * as well as `'link'` and `'unlink'` commands.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar LinkEditing =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(LinkEditing, _Plugin);\n\n  function LinkEditing() {\n    _classCallCheck(this, LinkEditing);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LinkEditing).apply(this, arguments));\n  }\n\n  _createClass(LinkEditing, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var editor = this.editor; // Allow link attribute on all inline nodes.\n\n      editor.model.schema.extend('$text', {\n        allowAttributes: 'linkHref'\n      });\n      editor.conversion.for('dataDowncast').attributeToElement({\n        model: 'linkHref',\n        view: createLinkElement\n      });\n      editor.conversion.for('editingDowncast').attributeToElement({\n        model: 'linkHref',\n        view: function view(href, writer) {\n          return createLinkElement(ensureSafeUrl(href), writer);\n        }\n      });\n      editor.conversion.for('upcast').elementToAttribute({\n        view: {\n          name: 'a',\n          attributes: {\n            href: true\n          }\n        },\n        model: {\n          key: 'linkHref',\n          value: function value(viewElement) {\n            return viewElement.getAttribute('href');\n          }\n        }\n      }); // Create linking commands.\n\n      editor.commands.add('link', new LinkCommand(editor));\n      editor.commands.add('unlink', new UnlinkCommand(editor)); // Enable two-step caret movement for `linkHref` attribute.\n\n      bindTwoStepCaretToAttribute(editor.editing.view, editor.model, this, 'linkHref'); // Setup highlight over selected link.\n\n      this._setupLinkHighlight();\n    }\n    /**\n     * Adds a visual highlight style to a link in which the selection is anchored.\n     * Together with two-step caret movement, they indicate that the user is typing inside the link.\n     *\n     * Highlight is turned on by adding `.ck-link_selected` class to the link in the view:\n     *\n     * * the class is removed before conversion has started, as callbacks added with `'highest'` priority\n     * to {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} events,\n     * * the class is added in the view post fixer, after other changes in the model tree were converted to the view.\n     *\n     * This way, adding and removing highlight does not interfere with conversion.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupLinkHighlight\",\n    value: function _setupLinkHighlight() {\n      var editor = this.editor;\n      var view = editor.editing.view;\n      var highlightedLinks = new Set(); // Adding the class.\n\n      view.document.registerPostFixer(function (writer) {\n        var selection = editor.model.document.selection;\n\n        if (selection.hasAttribute('linkHref')) {\n          var modelRange = findLinkRange(selection.getFirstPosition(), selection.getAttribute('linkHref'), editor.model);\n          var viewRange = editor.editing.mapper.toViewRange(modelRange); // There might be multiple `a` elements in the `viewRange`, for example, when the `a` element is\n          // broken by a UIElement.\n\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = viewRange.getItems()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var item = _step.value;\n\n              if (item.is('a')) {\n                writer.addClass(HIGHLIGHT_CLASS, item);\n                highlightedLinks.add(item);\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }); // Removing the class.\n\n      editor.conversion.for('editingDowncast').add(function (dispatcher) {\n        // Make sure the highlight is removed on every possible event, before conversion is started.\n        dispatcher.on('insert', removeHighlight, {\n          priority: 'highest'\n        });\n        dispatcher.on('remove', removeHighlight, {\n          priority: 'highest'\n        });\n        dispatcher.on('attribute', removeHighlight, {\n          priority: 'highest'\n        });\n        dispatcher.on('selection', removeHighlight, {\n          priority: 'highest'\n        });\n\n        function removeHighlight() {\n          view.change(function (writer) {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = highlightedLinks.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var item = _step2.value;\n                writer.removeClass(HIGHLIGHT_CLASS, item);\n                highlightedLinks.delete(item);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n  }]);\n\n  return LinkEditing;\n}(Plugin);\n\nexport { LinkEditing as default };","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/bindings/submithandler\n */\n\n/**\n * A handler useful for {@link module:ui/view~View views} working as HTML forms. It intercepts a native DOM\n * `submit` event, prevents the default web browser behavior (navigation and page reload) and\n * fires the `submit` event on a view instead. Such a custom event can be then used by any\n * {@link module:utils/dom/emittermixin~Emitter emitter}, e.g. to serialize the form data.\n *\n *\t\timport submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';\n *\n *\t\t// ...\n *\n *\t\tclass AnyFormView extends View {\n *\t\t\tconstructor() {\n *\t\t\t\tsuper();\n *\n *\t\t\t\t// ...\n *\n *\t\t\t\tsubmitHandler( {\n *\t\t\t\t\tview: this\n *\t\t\t\t} );\n *\t\t\t}\n *\t\t}\n *\n *\t\t// ...\n *\n *\t\tconst view = new AnyFormView();\n *\n *\t\t// A sample listener attached by an emitter working with the view.\n *\t\tthis.listenTo( view, 'submit', () => {\n *\t\t\tsaveTheFormData();\n *\t\t\thideTheForm();\n *\t\t} );\n *\n * @param {Object} [options] Configuration options.\n * @param {module:ui/view~View} options.view The view which DOM `submit` events should be handled.\n */\nexport default function submitHandler(_ref) {\n  var view = _ref.view;\n  view.listenTo(view.element, 'submit', function (evt, domEvt) {\n    domEvt.preventDefault();\n    view.fire('submit');\n  }, {\n    useCapture: true\n  });\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/link\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport LinkEditing from \"./linkediting\";\nimport LinkUI from \"./linkui\";\n/**\n * The link plugin.\n *\n * This is a \"glue\" plugin which loads the {@link module:link/linkediting~LinkEditing link editing feature}\n * and {@link module:link/linkui~LinkUI link UI feature}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar Link =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Link, _Plugin);\n\n  function Link() {\n    _classCallCheck(this, Link);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Link).apply(this, arguments));\n  }\n\n  _createClass(Link, null, [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [LinkEditing, LinkUI];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'Link';\n    }\n  }]);\n\n  return Link;\n}(Plugin);\n\nexport { Link as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.number.constructor\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/listcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n/**\n * The list command. It is used by the {@link module:list/list~List list feature}.\n *\n * @extends module:core/command~Command\n */\n\nvar ListCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(ListCommand, _Command);\n\n  /**\n   * Creates an instance of the command.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor instance.\n   * @param {'numbered'|'bulleted'} type List type that will be handled by this command.\n   */\n  function ListCommand(editor, type) {\n    var _this;\n\n    _classCallCheck(this, ListCommand);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ListCommand).call(this, editor));\n    /**\n     * The type of the list created by the command.\n     *\n     * @readonly\n     * @member {'numbered'|'bulleted'}\n     */\n\n    _this.type = type == 'bulleted' ? 'bulleted' : 'numbered';\n    /**\n     * A flag indicating whether the command is active, which means that the selection starts in a list of the same type.\n     *\n     * @observable\n     * @readonly\n     * @member {Boolean} #value\n     */\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(ListCommand, [{\n    key: \"refresh\",\n    value: function refresh() {\n      this.value = this._getValue();\n      this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Executes the command.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this2 = this;\n\n      var model = this.editor.model;\n      var document = model.document;\n      var blocks = Array.from(document.selection.getSelectedBlocks()).filter(function (block) {\n        return checkCanBecomeListItem(block, model.schema);\n      }); // Whether we are turning off some items.\n\n      var turnOff = this.value === true; // If we are turning off items, we are going to rename them to paragraphs.\n\n      model.change(function (writer) {\n        // If part of a list got turned off, we need to handle (outdent) all of sub-items of the last turned-off item.\n        // To be sure that model is all the time in a good state, we first fix items below turned-off item.\n        if (turnOff) {\n          // Start from the model item that is just after the last turned-off item.\n          var next = blocks[blocks.length - 1].nextSibling;\n          var currentIndent = Number.POSITIVE_INFINITY;\n          var changes = []; // Correct indent of all items after the last turned off item.\n          // Rules that should be followed:\n          // 1. All direct sub-items of turned-off item should become indent 0, because the first item after it\n          //    will be the first item of a new list. Other items are at the same level, so should have same 0 index.\n          // 2. All items with indent lower than indent of turned-off item should become indent 0, because they\n          //    should not end up as a child of any of list items that they were not children of before.\n          // 3. All other items should have their indent changed relatively to it's parent.\n          //\n          // For example:\n          // 1  * --------\n          // 2     * --------\n          // 3        * --------\t\t\t<-- this is turned off.\n          // 4           * --------\t\t<-- this has to become indent = 0, because it will be first item on a new list.\n          // 5              * --------\t<-- this should be still be a child of item above, so indent = 1.\n          // 6        * --------\t\t\t<-- this has to become indent = 0, because it should not be a child of any of items above.\n          // 7           * --------\t\t<-- this should be still be a child of item above, so indent = 1.\n          // 8     * --------\t\t\t\t<-- this has to become indent = 0.\n          // 9        * --------\t\t\t<-- this should still be a child of item above, so indent = 1.\n          // 10          * --------\t\t<-- this should still be a child of item above, so indent = 2.\n          // 11          * --------\t\t<-- this should still be at the same level as item above, so indent = 2.\n          // 12 * --------\t\t\t\t<-- this and all below are left unchanged.\n          // 13    * --------\n          // 14       * --------\n          //\n          // After turning off 3 the list becomes:\n          //\n          // 1  * --------\n          // 2     * --------\n          //\n          // 3  --------\n          //\n          // 4  * --------\n          // 5     * --------\n          // 6  * --------\n          // 7     * --------\n          // 8  * --------\n          // 9     * --------\n          // 10       * --------\n          // 11       * --------\n          // 12 * --------\n          // 13    * --------\n          // 14       * --------\n          //\n          // Thanks to this algorithm no lists are mismatched and no items get unexpected children/parent, while\n          // those parent-child connection which are possible to maintain are still maintained. It's worth noting\n          // that this is the same effect that we would be get by multiple use of outdent command. However doing\n          // it like this is much more efficient because it's less operation (less memory usage, easier OT) and\n          // less conversion (faster).\n\n          while (next && next.name == 'listItem' && next.getAttribute('listIndent') !== 0) {\n            // Check each next list item, as long as its indent is bigger than 0.\n            // If the indent is 0 we are not going to change anything anyway.\n            var indent = next.getAttribute('listIndent'); // We check if that's item indent is lower as current relative indent.\n\n            if (indent < currentIndent) {\n              // If it is, current relative indent becomes that indent.\n              currentIndent = indent;\n            } // Fix indent relatively to current relative indent.\n            // Note, that if we just changed the current relative indent, the newIndent will be equal to 0.\n\n\n            var newIndent = indent - currentIndent; // Save the entry in changes array. We do not apply it at the moment, because we will need to\n            // reverse the changes so the last item is changed first.\n            // This is to keep model in correct state all the time.\n\n            changes.push({\n              element: next,\n              listIndent: newIndent\n            }); // Find next item.\n\n            next = next.nextSibling;\n          }\n\n          changes = changes.reverse();\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var item = _step.value;\n              writer.setAttribute('listIndent', item.listIndent, item.element);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        } // If we are turning on, we might change some items that are already `listItem`s but with different type.\n        // Changing one nested list item to other type should also trigger changing all its siblings so the\n        // whole nested list is of the same type.\n        // Example (assume changing to numbered list):\n        // * ------\t\t\t\t<-- do not fix, top level item\n        //   * ------\t\t\t<-- fix, because latter list item of this item's list is changed\n        //      * ------\t\t<-- do not fix, item is not affected (different list)\n        //   * ------\t\t\t<-- fix, because latter list item of this item's list is changed\n        //      * ------\t\t<-- fix, because latter list item of this item's list is changed\n        //      * ---[--\t\t<-- already in selection\n        //   * ------\t\t\t<-- already in selection\n        //   * ------\t\t\t<-- already in selection\n        // * ------\t\t\t\t<-- already in selection, but does not cause other list items to change because is top-level\n        //   * ---]--\t\t\t<-- already in selection\n        //   * ------\t\t\t<-- fix, because preceding list item of this item's list is changed\n        //      * ------\t\t<-- do not fix, item is not affected (different list)\n        // * ------\t\t\t\t<-- do not fix, top level item\n\n\n        if (!turnOff) {\n          // Find lowest indent among selected items. This will be indicator what is the indent of\n          // top-most list affected by the command.\n          var lowestIndent = Number.POSITIVE_INFINITY;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = blocks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _item = _step2.value;\n\n              if (_item.is('listItem') && _item.getAttribute('listIndent') < lowestIndent) {\n                lowestIndent = _item.getAttribute('listIndent');\n              }\n            } // Do not execute the fix for top-level lists.\n\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          lowestIndent = lowestIndent === 0 ? 1 : lowestIndent; // Fix types of list items that are \"before\" the selected blocks.\n\n          _fixType(blocks, true, lowestIndent); // Fix types of list items that are \"after\" the selected blocks.\n\n\n          _fixType(blocks, false, lowestIndent);\n        } // Phew! Now it will be easier :).\n        // For each block element that was in the selection, we will either: turn it to list item,\n        // turn it to paragraph, or change it's type. Or leave it as it is.\n        // Do it in reverse as there might be multiple blocks (same as with changing indents).\n\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = blocks.reverse()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var element = _step3.value;\n\n            if (turnOff && element.name == 'listItem') {\n              // We are turning off and the element is a `listItem` - it should be converted to `paragraph`.\n              // List item specific attributes are removed by post fixer.\n              writer.rename(element, 'paragraph');\n            } else if (!turnOff && element.name != 'listItem') {\n              // We are turning on and the element is not a `listItem` - it should be converted to `listItem`.\n              // The order of operations is important to keep model in correct state.\n              writer.setAttributes({\n                listType: _this2.type,\n                listIndent: 0\n              }, element);\n              writer.rename(element, 'listItem');\n            } else if (!turnOff && element.name == 'listItem' && element.getAttribute('listType') != _this2.type) {\n              // We are turning on and the element is a `listItem` but has different type - change it's type and\n              // type of it's all siblings that have same indent.\n              writer.setAttribute('listType', _this2.type, element);\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Checks the command's {@link #value}.\n     *\n     * @private\n     * @returns {Boolean} The current value.\n     */\n\n  }, {\n    key: \"_getValue\",\n    value: function _getValue() {\n      // Check whether closest `listItem` ancestor of the position has a correct type.\n      var listItem = first(this.editor.model.document.selection.getSelectedBlocks());\n      return !!listItem && listItem.is('listItem') && listItem.getAttribute('listType') == this.type;\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @private\n     * @returns {Boolean} Whether the command should be enabled.\n     */\n\n  }, {\n    key: \"_checkEnabled\",\n    value: function _checkEnabled() {\n      // If command value is true it means that we are in list item, so the command should be enabled.\n      if (this.value) {\n        return true;\n      }\n\n      var selection = this.editor.model.document.selection;\n      var schema = this.editor.model.schema;\n      var firstBlock = first(selection.getSelectedBlocks());\n\n      if (!firstBlock) {\n        return false;\n      } // Otherwise, check if list item can be inserted at the position start.\n\n\n      return checkCanBecomeListItem(firstBlock, schema);\n    }\n  }]);\n\n  return ListCommand;\n}(Command); // Helper function used when one or more list item have their type changed. Fixes type of other list items\n// that are affected by the change (are in same lists) but are not directly in selection. The function got extracted\n// not to duplicated code, as same fix has to be performed before and after selection.\n//\n// @param {Array.<module:engine/model/node~Node>} blocks Blocks that are in selection.\n// @param {Boolean} isBackward Specified whether fix will be applied for blocks before first selected block (`true`)\n// or blocks after last selected block (`false`).\n// @param {Number} lowestIndent Lowest indent among selected blocks.\n\n\nexport { ListCommand as default };\n\nfunction _fixType(blocks, isBackward, lowestIndent) {\n  // We need to check previous sibling of first changed item and next siblings of last changed item.\n  var startingItem = isBackward ? blocks[0] : blocks[blocks.length - 1];\n\n  if (startingItem.is('listItem')) {\n    var item = startingItem[isBackward ? 'previousSibling' : 'nextSibling']; // During processing items, keeps the lowest indent of already processed items.\n    // This saves us from changing too many items.\n    // Following example is for going forward as it is easier to read, however same applies to going backward.\n    // * ------\n    //   * ------\n    //     * --[---\n    //   * ------\t\t<-- `lowestIndent` should be 1\n    //     * --]---\t\t<-- `startingItem`, `currentIndent` = 2, `lowestIndent` == 1\n    //     * ------\t\t<-- should be fixed, `indent` == 2 == `currentIndent`\n    //   * ------\t\t<-- should be fixed, set `currentIndent` to 1, `indent` == 1 == `currentIndent`\n    //     * ------\t\t<-- should not be fixed, item is in different list, `indent` = 2, `indent` != `currentIndent`\n    //   * ------\t\t<-- should be fixed, `indent` == 1 == `currentIndent`\n    // * ------\t\t\t<-- break loop (`indent` < `lowestIndent`)\n\n    var currentIndent = startingItem.getAttribute('listIndent'); // Look back until a list item with indent lower than reference `lowestIndent`.\n    // That would be the parent of nested sublist which contains item having `lowestIndent`.\n\n    while (item && item.is('listItem') && item.getAttribute('listIndent') >= lowestIndent) {\n      if (currentIndent > item.getAttribute('listIndent')) {\n        currentIndent = item.getAttribute('listIndent');\n      } // Found an item that is in the same nested sublist.\n\n\n      if (item.getAttribute('listIndent') == currentIndent) {\n        // Just add the item to selected blocks like it was selected by the user.\n        blocks[isBackward ? 'unshift' : 'push'](item);\n      }\n\n      item = item[isBackward ? 'previousSibling' : 'nextSibling'];\n    }\n  }\n} // Checks whether the given block can be replaced by a listItem.\n//\n// @private\n// @param {module:engine/model/element~Element} block A block to be tested.\n// @param {module:engine/model/schema~Schema} schema The schema of the document.\n// @returns {Boolean}\n\n\nfunction checkCanBecomeListItem(block, schema) {\n  return schema.checkChild(block.parent, 'listItem') && !schema.isObject(block);\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/indentcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n/**\n * The list indent command. It is used by the {@link module:list/list~List list feature}.\n *\n * @extends module:core/command~Command\n */\n\nvar IndentCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(IndentCommand, _Command);\n\n  /**\n   * Creates an instance of the command.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor instance.\n   * @param {'forward'|'backward'} indentDirection The direction of indent. If it is equal to `backward`, the command\n   * will outdent a list item.\n   */\n  function IndentCommand(editor, indentDirection) {\n    var _this;\n\n    _classCallCheck(this, IndentCommand);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(IndentCommand).call(this, editor));\n    /**\n     * Determines by how much the command will change the list item's indent attribute.\n     *\n     * @readonly\n     * @private\n     * @member {Number}\n     */\n\n    _this._indentBy = indentDirection == 'forward' ? 1 : -1;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(IndentCommand, [{\n    key: \"refresh\",\n    value: function refresh() {\n      this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Indents or outdents (depends on the {@link #constructor}'s `indentDirection` parameter) selected list items.\n     *\n     * @fires execute\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this2 = this;\n\n      var model = this.editor.model;\n      var doc = model.document;\n      var itemsToChange = Array.from(doc.selection.getSelectedBlocks());\n      model.change(function (writer) {\n        var lastItem = itemsToChange[itemsToChange.length - 1]; // Indenting a list item should also indent all the items that are already sub-items of indented item.\n\n        var next = lastItem.nextSibling; // Check all items after last indented item, as long as their indent is bigger than indent of that item.\n\n        while (next && next.name == 'listItem' && next.getAttribute('listIndent') > lastItem.getAttribute('listIndent')) {\n          itemsToChange.push(next);\n          next = next.nextSibling;\n        } // We need to be sure to keep model in correct state after each small change, because converters\n        // bases on that state and assumes that model is correct.\n        // Because of that, if the command outdents items, we will outdent them starting from the last item, as\n        // it is safer.\n\n\n        if (_this2._indentBy < 0) {\n          itemsToChange = itemsToChange.reverse();\n        }\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = itemsToChange[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var item = _step.value;\n\n            var indent = item.getAttribute('listIndent') + _this2._indentBy; // If indent is lower than 0, it means that the item got outdented when it was not indented.\n            // This means that we need to convert that list item to paragraph.\n\n\n            if (indent < 0) {\n              // To keep the model as correct as possible, first rename listItem, then remove attributes,\n              // as listItem without attributes is very incorrect and will cause problems in converters.\n              // No need to remove attributes, will be removed by post fixer.\n              writer.rename(item, 'paragraph');\n            } // If indent is >= 0, change the attribute value.\n            else {\n                writer.setAttribute('listIndent', indent, item);\n              }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @private\n     * @returns {Boolean} Whether the command should be enabled.\n     */\n\n  }, {\n    key: \"_checkEnabled\",\n    value: function _checkEnabled() {\n      // Check whether any of position's ancestor is a list item.\n      var listItem = first(this.editor.model.document.selection.getSelectedBlocks()); // If selection is not in a list item, the command is disabled.\n\n      if (!listItem || !listItem.is('listItem')) {\n        return false;\n      }\n\n      if (this._indentBy > 0) {\n        // Cannot indent first item in it's list. Check if before `listItem` is a list item that is in same list.\n        // To be in the same list, the item has to have same attributes and cannot be \"split\" by an item with lower indent.\n        var indent = listItem.getAttribute('listIndent');\n        var type = listItem.getAttribute('listType');\n        var prev = listItem.previousSibling;\n\n        while (prev && prev.is('listItem') && prev.getAttribute('listIndent') >= indent) {\n          if (prev.getAttribute('listIndent') == indent) {\n            // The item is on the same level.\n            // If it has same type, it means that we found a preceding sibling from the same list.\n            // If it does not have same type, it means that `listItem` is on different list (this can happen only\n            // on top level lists, though).\n            return prev.getAttribute('listType') == type;\n          }\n\n          prev = prev.previousSibling;\n        } // Could not find similar list item, this means that `listItem` is first in its list.\n\n\n        return false;\n      } // If we are outdenting it is enough to be in list item. Every list item can always be outdented.\n\n\n      return true;\n    }\n  }]);\n\n  return IndentCommand;\n}(Command);\n\nexport { IndentCommand as default };","import \"core-js/modules/es6.function.name\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/utils\n */\nimport { getFillerOffset } from '@ckeditor/ckeditor5-engine/src/view/containerelement';\n/**\n * Creates list item {@link module:engine/view/containerelement~ContainerElement}.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer The writer instance.\n * @returns {module:engine/view/containerelement~ContainerElement}\n */\n\nexport function createViewListItemElement(writer) {\n  var viewItem = writer.createContainerElement('li');\n  viewItem.getFillerOffset = getListItemFillerOffset;\n  return viewItem;\n} // Implementation of getFillerOffset for view list item element.\n//\n// @returns {Number|null} Block filler offset or `null` if block filler is not needed.\n\nfunction getListItemFillerOffset() {\n  var hasOnlyLists = !this.isEmpty && (this.getChild(0).name == 'ul' || this.getChild(0).name == 'ol');\n\n  if (this.isEmpty || hasOnlyLists) {\n    return 0;\n  }\n\n  return getFillerOffset.call(this);\n}","import _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es6.map\";\nimport \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/converters\n */\nimport { createViewListItemElement } from \"./utils\";\nimport TreeWalker from '@ckeditor/ckeditor5-engine/src/model/treewalker';\n/**\n * A model-to-view converter for `listItem` model element insertion.\n *\n * It creates a `<ul><li></li><ul>` (or `<ol>`) view structure out of a `listItem` model element, inserts it at the correct\n * position, and merges the list with surrounding lists (if available).\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function modelViewInsertion(model) {\n  return function (evt, data, conversionApi) {\n    var consumable = conversionApi.consumable;\n\n    if (!consumable.test(data.item, 'insert') || !consumable.test(data.item, 'attribute:listType') || !consumable.test(data.item, 'attribute:listIndent')) {\n      return;\n    }\n\n    consumable.consume(data.item, 'insert');\n    consumable.consume(data.item, 'attribute:listType');\n    consumable.consume(data.item, 'attribute:listIndent');\n    var modelItem = data.item;\n    var viewItem = generateLiInUl(modelItem, conversionApi);\n    injectViewList(modelItem, viewItem, conversionApi, model);\n  };\n}\n/**\n * A model-to-view converter for `listItem` model element removal.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function modelViewRemove(model) {\n  return function (evt, data, conversionApi) {\n    var viewStart = conversionApi.mapper.toViewPosition(data.position).getLastMatchingPosition(function (value) {\n      return !value.item.is('li');\n    });\n    var viewItem = viewStart.nodeAfter;\n    var viewWriter = conversionApi.writer; // 1. Break the container after and before the list item.\n    // This will create a view list with one view list item - the one to remove.\n\n    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // 2. Remove the list with the item to remove.\n\n    var viewList = viewItem.parent;\n    var viewListPrev = viewList.previousSibling;\n    var removeRange = viewWriter.createRangeOn(viewList);\n    var removed = viewWriter.remove(removeRange); // 3. Merge the whole created by breaking and removing the list.\n\n    if (viewListPrev && viewListPrev.nextSibling) {\n      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);\n    } // 4. Bring back nested list that was in the removed <li>.\n\n\n    var modelItem = conversionApi.mapper.toModelElement(viewItem);\n    hoistNestedLists(modelItem.getAttribute('listIndent') + 1, data.position, removeRange.start, viewItem, conversionApi, model); // 5. Unbind removed view item and all children.\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = viewWriter.createRangeIn(removed).getItems()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var child = _step.value;\n        conversionApi.mapper.unbindViewElement(child);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    evt.stop();\n  };\n}\n/**\n * A model-to-view converter for `type` attribute change on `listItem` model element.\n *\n * This change means that `<li>` elements parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished\n * by breaking view elements, changing their name and merging them.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewChangeType(evt, data, conversionApi) {\n  if (!conversionApi.consumable.consume(data.item, 'attribute:listType')) {\n    return;\n  }\n\n  var viewItem = conversionApi.mapper.toViewElement(data.item);\n  var viewWriter = conversionApi.writer; // 1. Break the container after and before the list item.\n  // This will create a view list with one view list item -- the one that changed type.\n\n  viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n  viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // 2. Change name of the view list that holds the changed view item.\n  // We cannot just change name property, because that would not render properly.\n\n  var viewList = viewItem.parent;\n  var listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';\n  viewList = viewWriter.rename(listName, viewList); // 3. Merge the changed view list with other lists, if possible.\n\n  mergeViewLists(viewWriter, viewList, viewList.nextSibling);\n  mergeViewLists(viewWriter, viewList.previousSibling, viewList); // 4. Consumable insertion of children inside the item. They are already handled by re-building the item in view.\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = data.item.getChildren()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var child = _step2.value;\n      conversionApi.consumable.consume(child, 'insert');\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n/**\n * A model-to-view converter for `listIndent` attribute change on `listItem` model element.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function modelViewChangeIndent(model) {\n  return function (evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, 'attribute:listIndent')) {\n      return;\n    }\n\n    var viewItem = conversionApi.mapper.toViewElement(data.item);\n    var viewWriter = conversionApi.writer; // 1. Break the container after and before the list item.\n    // This will create a view list with one view list item -- the one that changed type.\n\n    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // 2. Extract view list with changed view list item and merge \"hole\" possibly created by breaking and removing elements.\n\n    var viewList = viewItem.parent;\n    var viewListPrev = viewList.previousSibling;\n    var removeRange = viewWriter.createRangeOn(viewList);\n    viewWriter.remove(removeRange);\n\n    if (viewListPrev && viewListPrev.nextSibling) {\n      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);\n    } // 3. Bring back nested list that was in the removed <li>.\n\n\n    hoistNestedLists(data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model); // 4. Inject view list like it is newly inserted.\n\n    injectViewList(data.item, viewItem, conversionApi, model); // 5. Consume insertion of children inside the item. They are already handled by re-building the item in view.\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = data.item.getChildren()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var child = _step3.value;\n        conversionApi.consumable.consume(child, 'insert');\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  };\n}\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter is fired for\n * insert change of every model item, and should be fired before the actual converter. The converter checks whether the inserted\n * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the\n * list so the model element is inserted to the view parent element corresponding to its model parent element.\n *\n * The converter prevents such situations:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>\n *\t\t<paragraph>xxx</paragraph>       // Instead of this wrong view state:\n *\t\t<listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewSplitOnInsert(evt, data, conversionApi) {\n  if (data.item.name != 'listItem') {\n    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    var viewWriter = conversionApi.writer;\n    var lists = []; // Break multiple ULs/OLs if there are.\n    //\n    // Imagine following list:\n    //\n    // 1 --------\n    //   1.1 --------\n    //     1.1.1 --------\n    //     1.1.2 --------\n    //     1.1.3 --------\n    //       1.1.3.1 --------\n    //   1.2 --------\n    //     1.2.1 --------\n    // 2 --------\n    //\n    // Insert paragraph after item 1.1.1:\n    //\n    // 1 --------\n    //   1.1 --------\n    //     1.1.1 --------\n    //\n    // Lorem ipsum.\n    //\n    //     1.1.2 --------\n    //     1.1.3 --------\n    //       1.1.3.1 --------\n    //   1.2 --------\n    //     1.2.1 --------\n    // 2 --------\n    //\n    // In this case 1.1.2 has to become beginning of a new list.\n    // We need to break list before 1.1.2 (obvious), then we need to break list also before 1.2.\n    // Then we need to move those broken pieces one after another and merge:\n    //\n    // 1 --------\n    //   1.1 --------\n    //     1.1.1 --------\n    //\n    // Lorem ipsum.\n    //\n    // 1.1.2 --------\n    //   1.1.3 --------\n    //     1.1.3.1 --------\n    // 1.2 --------\n    //   1.2.1 --------\n    // 2 --------\n    //\n\n    while (viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol') {\n      viewPosition = viewWriter.breakContainer(viewPosition);\n\n      if (viewPosition.parent.name != 'li') {\n        break;\n      } // Remove lists that are after inserted element.\n      // They will be brought back later, below the inserted element.\n\n\n      var removeStart = viewPosition;\n      var removeEnd = viewWriter.createPositionAt(viewPosition.parent, 'end'); // Don't remove if there is nothing to remove.\n\n      if (!removeStart.isEqual(removeEnd)) {\n        var removed = viewWriter.remove(viewWriter.createRange(removeStart, removeEnd));\n        lists.push(removed);\n      }\n\n      viewPosition = viewWriter.createPositionAfter(viewPosition.parent);\n    } // Bring back removed lists.\n\n\n    if (lists.length > 0) {\n      for (var i = 0; i < lists.length; i++) {\n        var previousList = viewPosition.nodeBefore;\n        var insertedRange = viewWriter.insert(viewPosition, lists[i]);\n        viewPosition = insertedRange.end; // Don't merge first list! We want a split in that place (this is why this converter is introduced).\n\n        if (i > 0) {\n          var mergePos = mergeViewLists(viewWriter, previousList, previousList.nextSibling); // If `mergePos` is in `previousList` it means that the lists got merged.\n          // In this case, we need to fix insert position.\n\n          if (mergePos && mergePos.parent == previousList) {\n            viewPosition.offset--;\n          }\n        }\n      } // Merge last inserted list with element after it.\n\n\n      mergeViewLists(viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter);\n    }\n  }\n}\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter takes care of\n * merging view lists after something is removed or moved from near them.\n *\n * Example:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul>\n *\t\t<paragraph>xxx</paragraph>       <p>xxx</p>\n *\t\t<listItem>bar</listItem>         <ul><li>bar</li></ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewMergeAfter(evt, data, conversionApi) {\n  var viewPosition = conversionApi.mapper.toViewPosition(data.position);\n  var viewItemPrev = viewPosition.nodeBefore;\n  var viewItemNext = viewPosition.nodeAfter; // Merge lists if something (remove, move) was done from inside of list.\n  // Merging will be done only if both items are view lists of the same type.\n  // The check is done inside the helper function.\n\n  mergeViewLists(conversionApi.writer, viewItemPrev, viewItemNext);\n}\n/**\n * A view-to-model converter that converts `<li>` view elements into `listItem` model elements.\n *\n * To set correct values of the `listType` and `listIndent` attributes the converter:\n * * checks `<li>`'s parent,\n * * stores and increases the `conversionApi.store.indent` value when `<li>`'s sub-items are converted.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\n\nexport function viewModelConverter(evt, data, conversionApi) {\n  if (conversionApi.consumable.consume(data.viewItem, {\n    name: true\n  })) {\n    var writer = conversionApi.writer;\n    var conversionStore = this.conversionApi.store; // 1. Create `listItem` model element.\n\n    var listItem = writer.createElement('listItem'); // 2. Handle `listItem` model element attributes.\n\n    conversionStore.indent = conversionStore.indent || 0;\n    writer.setAttribute('listIndent', conversionStore.indent, listItem); // Set 'bulleted' as default. If this item is pasted into a context,\n\n    var type = data.viewItem.parent && data.viewItem.parent.name == 'ol' ? 'numbered' : 'bulleted';\n    writer.setAttribute('listType', type, listItem); // `listItem`s created recursively should have bigger indent.\n\n    conversionStore.indent++; // Try to find allowed parent for list item.\n\n    var splitResult = conversionApi.splitToAllowedParent(listItem, data.modelCursor); // When there is no allowed parent it means that list item cannot be converted at current model position\n    // and in any of position ancestors.\n\n    if (!splitResult) {\n      return;\n    }\n\n    writer.insert(listItem, splitResult.position);\n    var nextPosition = viewToModelListItemChildrenConverter(listItem, data.viewItem.getChildren(), conversionApi);\n    conversionStore.indent--; // Result range starts before the first item and ends after the last.\n\n    data.modelRange = writer.createRange(data.modelCursor, nextPosition); // When `data.modelCursor` parent had to be split to insert list item...\n\n    if (splitResult.cursorParent) {\n      // Continue conversion in the split element.\n      data.modelCursor = writer.createPositionAt(splitResult.cursorParent, 0);\n    } else {\n      // Otherwise continue conversion after the last list item.\n      data.modelCursor = data.modelRange.end;\n    }\n  }\n}\n/**\n * A view-to-model converter for `<ul>` and `<ol>` view elements that cleans the input view of garbage.\n * This is mostly to clean whitespaces from between `<li>` view elements inside the view list element, however, also\n * incorrect data can be cleared if the view was incorrect.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\n\nexport function cleanList(evt, data, conversionApi) {\n  if (conversionApi.consumable.test(data.viewItem, {\n    name: true\n  })) {\n    // Caching children because when we start removing them iterating fails.\n    var children = Array.from(data.viewItem.getChildren());\n\n    for (var _i = 0, _children = children; _i < _children.length; _i++) {\n      var child = _children[_i];\n\n      if (!child.is('li')) {\n        child._remove();\n      }\n    }\n  }\n}\n/**\n * A view-to-model converter for `<li>` elements that cleans whitespace formatting from the input view.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\n\nexport function cleanListItem(evt, data, conversionApi) {\n  if (conversionApi.consumable.test(data.viewItem, {\n    name: true\n  })) {\n    if (data.viewItem.childCount === 0) {\n      return;\n    }\n\n    var children = _toConsumableArray(data.viewItem.getChildren());\n\n    var foundList = false;\n    var firstNode = true;\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var child = _step4.value;\n\n        if (foundList && !child.is('ul') && !child.is('ol')) {\n          child._remove();\n        }\n\n        if (child.is('text')) {\n          // If this is the first node and it's a text node, left-trim it.\n          if (firstNode) {\n            child._data = child.data.replace(/^\\s+/, '');\n          } // If this is the last text node before <ul> or <ol>, right-trim it.\n\n\n          if (!child.nextSibling || child.nextSibling.is('ul') || child.nextSibling.is('ol')) {\n            child._data = child.data.replace(/\\s+$/, '');\n          }\n        } else if (child.is('ul') || child.is('ol')) {\n          // If this is a <ul> or <ol>, do not process it, just mark that we already visited list element.\n          foundList = true;\n        }\n\n        firstNode = false;\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  }\n}\n/**\n * Returns callback for model position to view position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between `listItem` elements that would be incorrectly mapped because of how list items are represented in model\n * and view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:modelToViewPosition\n * @param {module:engine/view/view~View} view A view instance.\n * @returns {Function}\n */\n\nexport function modelToViewPosition(view) {\n  return function (evt, data) {\n    if (data.isPhantom) {\n      return;\n    }\n\n    var modelItem = data.modelPosition.nodeBefore;\n\n    if (modelItem && modelItem.is('listItem')) {\n      var viewItem = data.mapper.toViewElement(modelItem);\n      var topmostViewList = viewItem.getAncestors().find(function (element) {\n        return element.is('ul') || element.is('ol');\n      });\n      var walker = view.createPositionAt(viewItem, 0).getWalker();\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = walker[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var value = _step5.value;\n\n          if (value.type == 'elementStart' && value.item.is('li')) {\n            data.viewPosition = value.previousPosition;\n            break;\n          } else if (value.type == 'elementEnd' && value.item == topmostViewList) {\n            data.viewPosition = value.nextPosition;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    }\n  };\n}\n/**\n * The callback for view position to model position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between `<li>` elements that would be incorrectly mapped because of how list items are represented in model\n * and view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:viewToModelPosition\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function viewToModelPosition(model) {\n  return function (evt, data) {\n    var viewPos = data.viewPosition;\n    var viewParent = viewPos.parent;\n    var mapper = data.mapper;\n\n    if (viewParent.name == 'ul' || viewParent.name == 'ol') {\n      // Position is directly in <ul> or <ol>.\n      if (!viewPos.isAtEnd) {\n        // If position is not at the end, it must be before <li>.\n        // Get that <li>, map it to `listItem` and set model position before that `listItem`.\n        var modelNode = mapper.toModelElement(viewPos.nodeAfter);\n        data.modelPosition = model.createPositionBefore(modelNode);\n      } else {\n        // Position is at the end of <ul> or <ol>, so there is no <li> after it to be mapped.\n        // There is <li> before the position, but we cannot just map it to `listItem` and set model position after it,\n        // because that <li> may contain nested items.\n        // We will check \"model length\" of that <li>, in other words - how many `listItem`s are in that <li>.\n        var _modelNode = mapper.toModelElement(viewPos.nodeBefore);\n\n        var modelLength = mapper.getModelLength(viewPos.nodeBefore); // Then we get model position before mapped `listItem` and shift it accordingly.\n\n        data.modelPosition = model.createPositionBefore(_modelNode).getShiftedBy(modelLength);\n      }\n\n      evt.stop();\n    } else if (viewParent.name == 'li' && viewPos.nodeBefore && (viewPos.nodeBefore.name == 'ul' || viewPos.nodeBefore.name == 'ol')) {\n      // In most cases when view position is in <li> it is in text and this is a correct position.\n      // However, if position is after <ul> or <ol> we have to fix it -- because in model <ul>/<ol> are not in the `listItem`.\n      var _modelNode2 = mapper.toModelElement(viewParent); // Check all <ul>s and <ol>s that are in the <li> but before mapped position.\n      // Get model length of those elements and then add it to the offset of `listItem` mapped to the original <li>.\n\n\n      var _modelLength = 1; // Starts from 1 because the original <li> has to be counted in too.\n\n      var viewList = viewPos.nodeBefore;\n\n      while (viewList && (viewList.is('ul') || viewList.is('ol'))) {\n        _modelLength += mapper.getModelLength(viewList);\n        viewList = viewList.previousSibling;\n      }\n\n      data.modelPosition = model.createPositionBefore(_modelNode2).getShiftedBy(_modelLength);\n      evt.stop();\n    }\n  };\n}\n/**\n * Post-fixer that reacts to changes on document and fixes incorrect model states.\n *\n * In an example below, there is a correct list structure.\n * Then the middle element will be removed so the list structure will become incorrect:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 2</listItem>   <--- this is removed.\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * List structure after the middle element removed:\n *\n * \t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 3</listItem>   <--- note that indent got post-fixed.\n *\n * @param {module:engine/model/model~Model} model The data model.\n * @param {module:engine/model/writer~Writer} writer The writer to do changes with.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\n\nexport function modelChangePostFixer(model, writer) {\n  var changes = model.document.differ.getChanges();\n  var itemToListHead = new Map();\n  var applied = false;\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = changes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var entry = _step6.value;\n\n      if (entry.type == 'insert' && entry.name == 'listItem') {\n        _addListToFix(entry.position);\n      } else if (entry.type == 'insert' && entry.name != 'listItem') {\n        if (entry.name != '$text') {\n          // In case of renamed element.\n          var item = entry.position.nodeAfter;\n\n          if (item.hasAttribute('listIndent')) {\n            writer.removeAttribute('listIndent', item);\n            applied = true;\n          }\n\n          if (item.hasAttribute('listType')) {\n            writer.removeAttribute('listType', item);\n            applied = true;\n          }\n        }\n\n        var posAfter = entry.position.getShiftedBy(entry.length);\n\n        _addListToFix(posAfter);\n      } else if (entry.type == 'remove' && entry.name == 'listItem') {\n        _addListToFix(entry.position);\n      } else if (entry.type == 'attribute' && entry.attributeKey == 'listIndent') {\n        _addListToFix(entry.range.start);\n      } else if (entry.type == 'attribute' && entry.attributeKey == 'listType') {\n        _addListToFix(entry.range.start);\n      }\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n        _iterator6.return();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = itemToListHead.values()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var listHead = _step7.value;\n\n      _fixListIndents(listHead);\n\n      _fixListTypes(listHead);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n\n  return applied;\n\n  function _addListToFix(position) {\n    var prev = position.nodeBefore;\n\n    if (!prev || !prev.is('listItem')) {\n      var item = position.nodeAfter;\n\n      if (item && item.is('listItem')) {\n        itemToListHead.set(item, item);\n      }\n    } else {\n      var listHead = prev;\n\n      if (itemToListHead.has(listHead)) {\n        return;\n      }\n\n      while (listHead.previousSibling && listHead.previousSibling.is('listItem')) {\n        listHead = listHead.previousSibling;\n\n        if (itemToListHead.has(listHead)) {\n          return;\n        }\n      }\n\n      itemToListHead.set(position.nodeBefore, listHead);\n    }\n  }\n\n  function _fixListIndents(item) {\n    var maxIndent = 0;\n    var fixBy = null;\n\n    while (item && item.is('listItem')) {\n      var itemIndent = item.getAttribute('listIndent');\n\n      if (itemIndent > maxIndent) {\n        var newIndent = void 0;\n\n        if (fixBy === null) {\n          fixBy = itemIndent - maxIndent;\n          newIndent = maxIndent;\n        } else {\n          if (fixBy > itemIndent) {\n            fixBy = itemIndent;\n          }\n\n          newIndent = itemIndent - fixBy;\n        }\n\n        writer.setAttribute('listIndent', newIndent, item);\n        applied = true;\n      } else {\n        fixBy = null;\n        maxIndent = item.getAttribute('listIndent') + 1;\n      }\n\n      item = item.nextSibling;\n    }\n  }\n\n  function _fixListTypes(item) {\n    var typesStack = [];\n    var prev = null;\n\n    while (item && item.is('listItem')) {\n      var itemIndent = item.getAttribute('listIndent');\n\n      if (prev && prev.getAttribute('listIndent') > itemIndent) {\n        typesStack = typesStack.slice(0, itemIndent + 1);\n      }\n\n      if (itemIndent != 0) {\n        if (typesStack[itemIndent]) {\n          var type = typesStack[itemIndent];\n\n          if (item.getAttribute('listType') != type) {\n            writer.setAttribute('listType', type, item);\n            applied = true;\n          }\n        } else {\n          typesStack[itemIndent] = item.getAttribute('listType');\n        }\n      }\n\n      prev = item;\n      item = item.nextSibling;\n    }\n  }\n}\n/**\n * A fixer for pasted content that includes list items.\n *\n * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.\n *\n * Example:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>B^</listItem>\n *\t\t// At ^ paste:  <listItem listType=\"bulleted\" listIndent=4>X</listItem>\n *\t\t//              <listItem listType=\"bulleted\" listIndent=5>Y</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>BX</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Y/listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Array} args Arguments of {@link module:engine/model/model~Model#insertContent}.\n */\n\nexport function modelIndentPasteFixer(evt, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      content = _ref2[0],\n      selectable = _ref2[1];\n\n  // Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other\n  // elements before it and there is no need to fix indents, because even if we insert that content into a list,\n  // that list will be broken.\n  // Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2\n  // would create incorrect model.\n  var item = content.is('documentFragment') ? content.getChild(0) : content;\n  var selection;\n\n  if (!selectable) {\n    selection = this.document.selection;\n  } else {\n    selection = this.createSelection(selectable);\n  }\n\n  if (item && item.is('listItem')) {\n    // Get a reference list item. Inserted list items will be fixed according to that item.\n    var pos = selection.getFirstPosition();\n    var refItem = null;\n\n    if (pos.parent.is('listItem')) {\n      refItem = pos.parent;\n    } else if (pos.nodeBefore && pos.nodeBefore.is('listItem')) {\n      refItem = pos.nodeBefore;\n    } // If there is `refItem` it means that we do insert list items into an existing list.\n\n\n    if (refItem) {\n      // First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal\n      // to the indent of reference item. We have to fix the first item and all of it's children and following siblings.\n      // Indent of all those items has to be adjusted to reference item.\n      var indentChange = refItem.getAttribute('listIndent'); // Fix only if there is anything to fix.\n\n      if (indentChange > 0) {\n        // Adjust indent of all \"first\" list items in inserted data.\n        while (item && item.is('listItem')) {\n          item._setAttribute('listIndent', item.getAttribute('listIndent') + indentChange);\n\n          item = item.nextSibling;\n        }\n      }\n    }\n  }\n} // Helper function that creates a `<ul><li></li></ul>` or (`<ol>`) structure out of given `modelItem` model `listItem` element.\n// Then, it binds created view list item (<li>) with model `listItem` element.\n// The function then returns created view list item (<li>).\n\nfunction generateLiInUl(modelItem, conversionApi) {\n  var mapper = conversionApi.mapper;\n  var viewWriter = conversionApi.writer;\n  var listType = modelItem.getAttribute('listType') == 'numbered' ? 'ol' : 'ul';\n  var viewItem = createViewListItemElement(viewWriter);\n  var viewList = viewWriter.createContainerElement(listType, null);\n  viewWriter.insert(viewWriter.createPositionAt(viewList, 0), viewItem);\n  mapper.bindElements(modelItem, viewItem);\n  return viewItem;\n} // Helper function that converts children of a given `<li>` view element into corresponding model elements.\n// The function maintains proper order of elements if model `listItem` is split during the conversion\n// due to block children conversion.\n//\n// @param {module:engine/model/element~Element} listItemModel List item model element to which converted children will be inserted.\n// @param {Iterable.<module:engine/view/node~Node>} viewChildren View elements which will be converted.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n// @returns {module:engine/model/position~Position} Position on which next elements should be inserted after children conversion.\n\n\nfunction viewToModelListItemChildrenConverter(listItemModel, viewChildren, conversionApi) {\n  var writer = conversionApi.writer,\n      schema = conversionApi.schema; // A position after the last inserted `listItem`.\n\n  var nextPosition = writer.createPositionAfter(listItemModel); // Check all children of the converted `<li>`. At this point we assume there are no \"whitespace\" view text nodes\n  // in view list, between view list items. This should be handled by `<ul>` and `<ol>` converters.\n\n  var _iteratorNormalCompletion8 = true;\n  var _didIteratorError8 = false;\n  var _iteratorError8 = undefined;\n\n  try {\n    for (var _iterator8 = viewChildren[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n      var child = _step8.value;\n\n      if (child.name == 'ul' || child.name == 'ol') {\n        // If the children is a list, we will insert its conversion result after currently handled `listItem`.\n        // Then, next insertion position will be set after all the new list items (and maybe other elements if\n        // something split list item).\n        //\n        // If this is a list, we expect that some `listItem`s and possibly other blocks will be inserted, however `.modelCursor`\n        // should be set after last `listItem` (or block). This is why it feels safe to use it as `nextPosition`\n        nextPosition = conversionApi.convertItem(child, nextPosition).modelCursor;\n      } else {\n        // If this is not a list, try inserting content at the end of the currently handled `listItem`.\n        var result = conversionApi.convertItem(child, writer.createPositionAt(listItemModel, 'end')); // It may end up that the current `listItem` becomes split (if that content cannot be inside `listItem`). For example:\n        //\n        // <li><p>Foo</p></li>\n        //\n        // will be converted to:\n        //\n        // <listItem></listItem><paragraph>Foo</paragraph><listItem></listItem>\n        //\n\n        var convertedChild = result.modelRange.start.nodeAfter;\n        var wasSplit = convertedChild && convertedChild.is('element') && !schema.checkChild(listItemModel, convertedChild.name);\n\n        if (wasSplit) {\n          // As `lastListItem` got split, we need to update it to the second part of the split `listItem` element.\n          //\n          // `modelCursor` should be set to a position where the conversion should continue. There are multiple possible scenarios\n          // that may happen. Usually, `modelCursor` (marked as `#` below) would point to the second list item after conversion:\n          //\n          //\t\t`<li><p>Foo</p></li>` -> `<listItem></listItem><paragraph>Foo</paragraph><listItem>#</listItem>`\n          //\n          // However, in some cases, like auto-paragraphing, the position is placed at the end of the block element:\n          //\n          //\t\t`<li><div>Foo</div></li>` -> `<listItem></listItem><paragraph>Foo#</paragraph><listItem></listItem>`\n          //\n          // or after an element if another element broken auto-paragraphed element:\n          //\n          //\t\t`<li><div><h2>Foo</h2></div></li>` -> `<listItem></listItem><heading1>Foo</heading1>#<listItem></listItem>`\n          //\n          // We need to check for such cases and use proper list item and position based on it.\n          //\n          if (result.modelCursor.parent.is('listItem')) {\n            // (1).\n            listItemModel = result.modelCursor.parent;\n          } else {\n            // (2), (3).\n            listItemModel = findNextListItem(result.modelCursor);\n          }\n\n          nextPosition = writer.createPositionAfter(listItemModel);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError8 = true;\n    _iteratorError8 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n        _iterator8.return();\n      }\n    } finally {\n      if (_didIteratorError8) {\n        throw _iteratorError8;\n      }\n    }\n  }\n\n  return nextPosition;\n} // Helper function that seeks for a next list item starting from given `startPosition`.\n\n\nfunction findNextListItem(startPosition) {\n  var treeWalker = new TreeWalker({\n    startPosition: startPosition\n  });\n  var value;\n\n  do {\n    value = treeWalker.next();\n  } while (!value.value.item.is('listItem'));\n\n  return value.value.item;\n} // Helper function that seeks for a previous list item sibling of given model item which meets given criteria.\n// `options` object may contain one or more of given values (by default they are `false`):\n// `options.sameIndent` - whether sought sibling should have same indent (default = no),\n// `options.smallerIndent` - whether sought sibling should have smaller indent (default = no).\n// `options.listIndent` - the reference indent.\n// Either `options.sameIndent` or `options.smallerIndent` should be set to `true`.\n\n\nfunction getSiblingListItem(modelItem, options) {\n  var sameIndent = !!options.sameIndent;\n  var smallerIndent = !!options.smallerIndent;\n  var indent = options.listIndent;\n  var item = modelItem;\n\n  while (item && item.name == 'listItem') {\n    var itemIndent = item.getAttribute('listIndent');\n\n    if (sameIndent && indent == itemIndent || smallerIndent && indent > itemIndent) {\n      return item;\n    }\n\n    item = item.previousSibling;\n  }\n\n  return null;\n} // Helper function that takes two parameters, that are expected to be view list elements, and merges them.\n// The merge happen only if both parameters are UL or OL elements.\n\n\nfunction mergeViewLists(viewWriter, firstList, secondList) {\n  if (firstList && secondList && (firstList.name == 'ul' || firstList.name == 'ol') && firstList.name == secondList.name) {\n    return viewWriter.mergeContainers(viewWriter.createPositionAfter(firstList));\n  }\n\n  return null;\n} // Helper function that takes model list item element `modelItem`, corresponding view list item element `injectedItem`\n// that is not added to the view and is inside a view list element (`ul` or `ol`) and is that's list only child.\n// The list is inserted at correct position (element breaking may be needed) and then merged with it's siblings.\n// See comments below to better understand the algorithm.\n\n\nfunction injectViewList(modelItem, injectedItem, conversionApi, model) {\n  var injectedList = injectedItem.parent;\n  var mapper = conversionApi.mapper;\n  var viewWriter = conversionApi.writer; // Position where view list will be inserted.\n\n  var insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem)); // 1. Find previous list item that has same or smaller indent. Basically we are looking for a first model item\n  // that is \"parent\" or \"sibling\" of injected model item.\n  // If there is no such list item, it means that injected list item is the first item in \"its list\".\n\n  var refItem = getSiblingListItem(modelItem.previousSibling, {\n    sameIndent: true,\n    smallerIndent: true,\n    listIndent: modelItem.getAttribute('listIndent')\n  });\n  var prevItem = modelItem.previousSibling;\n\n  if (refItem && refItem.getAttribute('listIndent') == modelItem.getAttribute('listIndent')) {\n    // There is a list item with same indent - we found same-level sibling.\n    // Break the list after it. Inserted view item will be inserted in the broken space.\n    var viewItem = mapper.toViewElement(refItem);\n    insertPosition = viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));\n  } else {\n    // There is no list item with same indent. Check previous model item.\n    if (prevItem && prevItem.name == 'listItem') {\n      // If it is a list item, it has to have lower indent.\n      // It means that inserted item should be added to it as its nested item.\n      insertPosition = mapper.toViewPosition(model.createPositionAt(prevItem, 'end'));\n    } else {\n      // Previous item is not a list item (or does not exist at all).\n      // Just map the position and insert the view item at mapped position.\n      insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem));\n    }\n  }\n\n  insertPosition = positionAfterUiElements(insertPosition); // Insert the view item.\n\n  viewWriter.insert(insertPosition, injectedList); // 2. Handle possible children of injected model item.\n\n  if (prevItem && prevItem.name == 'listItem') {\n    var prevView = mapper.toViewElement(prevItem);\n    var walkerBoundaries = viewWriter.createRange(viewWriter.createPositionAt(prevView, 0), insertPosition);\n    var walker = walkerBoundaries.getWalker({\n      ignoreElementEnd: true\n    });\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      for (var _iterator9 = walker[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var value = _step9.value;\n\n        if (value.item.is('li')) {\n          var breakPosition = viewWriter.breakContainer(viewWriter.createPositionBefore(value.item));\n          var viewList = value.item.parent;\n          var targetPosition = viewWriter.createPositionAt(injectedItem, 'end');\n          mergeViewLists(viewWriter, targetPosition.nodeBefore, targetPosition.nodeAfter);\n          viewWriter.move(viewWriter.createRangeOn(viewList), targetPosition);\n          walker.position = breakPosition;\n        }\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n  } else {\n    var nextViewList = injectedList.nextSibling;\n\n    if (nextViewList && (nextViewList.is('ul') || nextViewList.is('ol'))) {\n      var lastSubChild = null;\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = nextViewList.getChildren()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var child = _step10.value;\n          var modelChild = mapper.toModelElement(child);\n\n          if (modelChild && modelChild.getAttribute('listIndent') > modelItem.getAttribute('listIndent')) {\n            lastSubChild = child;\n          } else {\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      if (lastSubChild) {\n        viewWriter.breakContainer(viewWriter.createPositionAfter(lastSubChild));\n        viewWriter.move(viewWriter.createRangeOn(lastSubChild.parent), viewWriter.createPositionAt(injectedItem, 'end'));\n      }\n    }\n  } // Merge inserted view list with its possible neighbour lists.\n\n\n  mergeViewLists(viewWriter, injectedList, injectedList.nextSibling);\n  mergeViewLists(viewWriter, injectedList.previousSibling, injectedList);\n} // Helper function that takes all children of given `viewRemovedItem` and moves them in a correct place, according\n// to other given parameters.\n\n\nfunction hoistNestedLists(nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model) {\n  // Find correct previous model list item element.\n  // The element has to have either same or smaller indent than given reference indent.\n  // This will be the model element which will get nested items (if it has smaller indent) or sibling items (if it has same indent).\n  // Keep in mind that such element might not be found, if removed item was the first item.\n  var prevModelItem = getSiblingListItem(modelRemoveStartPosition.nodeBefore, {\n    sameIndent: true,\n    smallerIndent: true,\n    listIndent: nextIndent,\n    foo: 'b'\n  });\n  var mapper = conversionApi.mapper;\n  var viewWriter = conversionApi.writer; // Indent of found element or `null` if the element has not been found.\n\n  var prevIndent = prevModelItem ? prevModelItem.getAttribute('listIndent') : null;\n  var insertPosition;\n\n  if (!prevModelItem) {\n    // If element has not been found, simply insert lists at the position where the removed item was:\n    //\n    // Lorem ipsum.\n    // 1 --------           <--- this is removed, no previous list item, put nested items in place of removed item.\n    //   1.1 --------       <--- this is reference indent.\n    //     1.1.1 --------\n    //     1.1.2 --------\n    //   1.2 --------\n    //\n    // Becomes:\n    //\n    // Lorem ipsum.\n    // 1.1 --------\n    //   1.1.1 --------\n    //   1.1.2 --------\n    // 1.2 --------\n    insertPosition = viewRemoveStartPosition;\n  } else if (prevIndent == nextIndent) {\n    // If element has been found and has same indent as reference indent it means that nested items should\n    // become siblings of found element:\n    //\n    // 1 --------\n    //   1.1 --------\n    //   1.2 --------       <--- this is `prevModelItem`.\n    // 2 --------           <--- this is removed, previous list item has indent same as reference indent.\n    //   2.1 --------       <--- this is reference indent, this and 2.2 should become siblings of 1.2.\n    //   2.2 --------\n    //\n    // Becomes:\n    //\n    // 1 --------\n    //   1.1 --------\n    //   1.2 --------\n    //   2.1 --------\n    //   2.2 --------\n    var prevViewList = mapper.toViewElement(prevModelItem).parent;\n    insertPosition = viewWriter.createPositionAfter(prevViewList);\n  } else {\n    // If element has been found and has smaller indent as reference indent it means that nested items\n    // should become nested items of found item:\n    //\n    // 1 --------           <--- this is `prevModelItem`.\n    //   1.1 --------       <--- this is removed, previous list item has indent smaller than reference indent.\n    //     1.1.1 --------   <--- this is reference indent, this and 1.1.1 should become nested items of 1.\n    //     1.1.2 --------\n    //   1.2 --------\n    //\n    // Becomes:\n    //\n    // 1 --------\n    //   1.1.1 --------\n    //   1.1.2 --------\n    //   1.2 --------\n    //\n    // Note: in this case 1.1.1 have indent 2 while 1 have indent 0. In model that should not be possible,\n    // because following item may have indent bigger only by one. But this is fixed by postfixer.\n    var modelPosition = model.createPositionAt(prevModelItem, 'end');\n    insertPosition = mapper.toViewPosition(modelPosition);\n  }\n\n  insertPosition = positionAfterUiElements(insertPosition); // Handle multiple lists. This happens if list item has nested numbered and bulleted lists. Following lists\n  // are inserted after the first list (no need to recalculate insertion position for them).\n\n  for (var _i2 = 0, _arr = _toConsumableArray(viewRemovedItem.getChildren()); _i2 < _arr.length; _i2++) {\n    var child = _arr[_i2];\n\n    if (child.is('ul') || child.is('ol')) {\n      insertPosition = viewWriter.move(viewWriter.createRangeOn(child), insertPosition).end;\n      mergeViewLists(viewWriter, child, child.nextSibling);\n      mergeViewLists(viewWriter, child.previousSibling, child);\n    }\n  }\n} // Helper function that for given `view.Position`, returns a `view.Position` that is after all `view.UIElement`s that\n// are after given position.\n// For example:\n// <container:p>foo^<ui:span></ui:span><ui:span></ui:span>bar</contain:p>\n// For position ^, a position before \"bar\" will be returned.\n\n\nfunction positionAfterUiElements(viewPosition) {\n  return viewPosition.getLastMatchingPosition(function (value) {\n    return value.item.is('uiElement');\n  });\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/listediting\n */\nimport ListCommand from \"./listcommand\";\nimport IndentCommand from \"./indentcommand\";\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Paragraph from '@ckeditor/ckeditor5-paragraph/src/paragraph';\nimport { cleanList, cleanListItem, modelViewInsertion, modelViewChangeType, modelViewMergeAfter, modelViewRemove, modelViewSplitOnInsert, modelViewChangeIndent, modelChangePostFixer, modelIndentPasteFixer, viewModelConverter, modelToViewPosition, viewToModelPosition } from \"./converters\";\n/**\n * The engine of the list feature. It handles creating, editing and removing lists and list items.\n *\n * It registers the `'numberedList'`, `'bulletedList'`, `'indentList'` and `'outdentList'` commands.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ListEditing =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ListEditing, _Plugin);\n\n  function ListEditing() {\n    _classCallCheck(this, ListEditing);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ListEditing).apply(this, arguments));\n  }\n\n  _createClass(ListEditing, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var _this = this;\n\n      var editor = this.editor; // Schema.\n      // Note: in case `$block` will ever be allowed in `listItem`, keep in mind that this feature\n      // uses `Selection#getSelectedBlocks()` without any additional processing to obtain all selected list items.\n      // If there are blocks allowed inside list item, algorithms using `getSelectedBlocks()` will have to be modified.\n\n      editor.model.schema.register('listItem', {\n        inheritAllFrom: '$block',\n        allowAttributes: ['listType', 'listIndent']\n      }); // Converters.\n\n      var data = editor.data;\n      var editing = editor.editing;\n      editor.model.document.registerPostFixer(function (writer) {\n        return modelChangePostFixer(editor.model, writer);\n      });\n      editing.mapper.registerViewToModelLength('li', getViewListItemLength);\n      data.mapper.registerViewToModelLength('li', getViewListItemLength);\n      editing.mapper.on('modelToViewPosition', modelToViewPosition(editing.view));\n      editing.mapper.on('viewToModelPosition', viewToModelPosition(editor.model));\n      data.mapper.on('modelToViewPosition', modelToViewPosition(editing.view));\n      editing.downcastDispatcher.on('insert', modelViewSplitOnInsert, {\n        priority: 'high'\n      });\n      editing.downcastDispatcher.on('insert:listItem', modelViewInsertion(editor.model));\n      data.downcastDispatcher.on('insert', modelViewSplitOnInsert, {\n        priority: 'high'\n      });\n      data.downcastDispatcher.on('insert:listItem', modelViewInsertion(editor.model));\n      editing.downcastDispatcher.on('attribute:listType:listItem', modelViewChangeType);\n      data.downcastDispatcher.on('attribute:listType:listItem', modelViewChangeType);\n      editing.downcastDispatcher.on('attribute:listIndent:listItem', modelViewChangeIndent(editor.model));\n      data.downcastDispatcher.on('attribute:listIndent:listItem', modelViewChangeIndent(editor.model));\n      editing.downcastDispatcher.on('remove:listItem', modelViewRemove(editor.model));\n      editing.downcastDispatcher.on('remove', modelViewMergeAfter, {\n        priority: 'low'\n      });\n      data.downcastDispatcher.on('remove:listItem', modelViewRemove(editor.model));\n      data.downcastDispatcher.on('remove', modelViewMergeAfter, {\n        priority: 'low'\n      });\n      data.upcastDispatcher.on('element:ul', cleanList, {\n        priority: 'high'\n      });\n      data.upcastDispatcher.on('element:ol', cleanList, {\n        priority: 'high'\n      });\n      data.upcastDispatcher.on('element:li', cleanListItem, {\n        priority: 'high'\n      });\n      data.upcastDispatcher.on('element:li', viewModelConverter); // Fix indentation of pasted items.\n\n      editor.model.on('insertContent', modelIndentPasteFixer, {\n        priority: 'high'\n      }); // Register commands for numbered and bulleted list.\n\n      editor.commands.add('numberedList', new ListCommand(editor, 'numbered'));\n      editor.commands.add('bulletedList', new ListCommand(editor, 'bulleted')); // Register commands for indenting.\n\n      editor.commands.add('indentList', new IndentCommand(editor, 'forward'));\n      editor.commands.add('outdentList', new IndentCommand(editor, 'backward'));\n      var viewDocument = this.editor.editing.view.document; // Overwrite default Enter key behavior.\n      // If Enter key is pressed with selection collapsed in empty list item, outdent it instead of breaking it.\n\n      this.listenTo(viewDocument, 'enter', function (evt, data) {\n        var doc = _this.editor.model.document;\n        var positionParent = doc.selection.getLastPosition().parent;\n\n        if (doc.selection.isCollapsed && positionParent.name == 'listItem' && positionParent.isEmpty) {\n          _this.editor.execute('outdentList');\n\n          data.preventDefault();\n          evt.stop();\n        }\n      }); // Overwrite default Backspace key behavior.\n      // If Backspace key is pressed with selection collapsed on first position in first list item, outdent it. #83\n\n      this.listenTo(viewDocument, 'delete', function (evt, data) {\n        // Check conditions from those that require less computations like those immediately available.\n        if (data.direction !== 'backward') {\n          return;\n        }\n\n        var selection = _this.editor.model.document.selection;\n\n        if (!selection.isCollapsed) {\n          return;\n        }\n\n        var firstPosition = selection.getFirstPosition();\n\n        if (!firstPosition.isAtStart) {\n          return;\n        }\n\n        var positionParent = firstPosition.parent;\n\n        if (positionParent.name !== 'listItem') {\n          return;\n        }\n\n        var previousIsAListItem = positionParent.previousSibling && positionParent.previousSibling.name === 'listItem';\n\n        if (previousIsAListItem) {\n          return;\n        }\n\n        _this.editor.execute('outdentList');\n\n        data.preventDefault();\n        evt.stop();\n      }, {\n        priority: 'high'\n      });\n\n      var getCommandExecuter = function getCommandExecuter(commandName) {\n        return function (data, cancel) {\n          var command = _this.editor.commands.get(commandName);\n\n          if (command.isEnabled) {\n            _this.editor.execute(commandName);\n\n            cancel();\n          }\n        };\n      };\n\n      this.editor.keystrokes.set('Tab', getCommandExecuter('indentList'));\n      this.editor.keystrokes.set('Shift+Tab', getCommandExecuter('outdentList'));\n    }\n  }], [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [Paragraph];\n    }\n  }]);\n\n  return ListEditing;\n}(Plugin);\n\nexport { ListEditing as default };\n\nfunction getViewListItemLength(element) {\n  var length = 1;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = element.getChildren()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var child = _step.value;\n\n      if (child.name == 'ul' || child.name == 'ol') {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = child.getChildren()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var item = _step2.value;\n            length += getViewListItemLength(item);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return length;\n}","import \"core-js/modules/es6.function.name\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/utils\n */\n\n/**\n * Returns the parent element of given name. Returns undefined if position is not inside desired parent.\n *\n * @param {String} parentName Name of parent element to find.\n * @param {module:engine/model/position~Position|module:engine/model/position~Position} position Position to start searching.\n * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n */\nexport function findAncestor(parentName, position) {\n  var parent = position.parent;\n\n  while (parent) {\n    if (parent.name === parentName) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n}\n/**\n * A common method to update the numeric value. If a value is the default one, it will be unset.\n *\n * @param {String} key Attribute key.\n * @param {*} value The new attribute value.\n * @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\n * @param {module:engine/model/writer~Writer} writer\n * @param {*} defaultValue Default attribute value. If a value is lower or equal, it will be unset.\n */\n\nexport function updateNumericAttribute(key, value, item, writer) {\n  var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n\n  if (value > defaultValue) {\n    writer.setAttribute(key, value, item);\n  } else {\n    writer.removeAttribute(key, item);\n  }\n}\n/**\n * Common method to create empty table cell - it will create proper model structure as table cell must have at least one block inside.\n *\n * @param {module:engine/model/writer~Writer} writer Model writer.\n * @param {module:engine/model/position~Position} insertPosition Position at which table cell should be inserted.\n * @param {Object} attributes Element's attributes.\n */\n\nexport function createEmptyTableCell(writer, insertPosition) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var tableCell = writer.createElement('tableCell', attributes);\n  writer.insertElement('paragraph', tableCell);\n  writer.insert(tableCell, insertPosition);\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/upcasttable\n */\nimport { createEmptyTableCell } from \"../commands/utils\";\n/**\n * View table element to model table element conversion helper.\n *\n * This conversion helper converts the table element as well as table rows.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport default function upcastTable() {\n  return function (dispatcher) {\n    dispatcher.on('element:table', function (evt, data, conversionApi) {\n      var viewTable = data.viewItem; // When element was already consumed then skip it.\n\n      if (!conversionApi.consumable.test(viewTable, {\n        name: true\n      })) {\n        return;\n      }\n\n      var _scanTable = scanTable(viewTable),\n          rows = _scanTable.rows,\n          headingRows = _scanTable.headingRows,\n          headingColumns = _scanTable.headingColumns; // Only set attributes if values is greater then 0.\n\n\n      var attributes = {};\n\n      if (headingColumns) {\n        attributes.headingColumns = headingColumns;\n      }\n\n      if (headingRows) {\n        attributes.headingRows = headingRows;\n      }\n\n      var table = conversionApi.writer.createElement('table', attributes); // Insert element on allowed position.\n\n      var splitResult = conversionApi.splitToAllowedParent(table, data.modelCursor); // When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\n      if (!splitResult) {\n        return;\n      }\n\n      conversionApi.writer.insert(table, splitResult.position);\n      conversionApi.consumable.consume(viewTable, {\n        name: true\n      });\n\n      if (rows.length) {\n        // Upcast table rows in proper order (heading rows first).\n        rows.forEach(function (row) {\n          return conversionApi.convertItem(row, conversionApi.writer.createPositionAt(table, 'end'));\n        });\n      } else {\n        // Create one row and one table cell for empty table.\n        var row = conversionApi.writer.createElement('tableRow');\n        conversionApi.writer.insert(row, conversionApi.writer.createPositionAt(table, 'end'));\n        createEmptyTableCell(conversionApi.writer, conversionApi.writer.createPositionAt(row, 'end'));\n      } // Set conversion result range.\n\n\n      data.modelRange = conversionApi.writer.createRange( // Range should start before inserted element\n      conversionApi.writer.createPositionBefore(table), // Should end after but we need to take into consideration that children could split our\n      // element, so we need to move range after parent of the last converted child.\n      // before: <allowed>[]</allowed>\n      // after: <allowed>[<converted><child></child></converted><child></child><converted>]</converted></allowed>\n      conversionApi.writer.createPositionAfter(table)); // Now we need to check where the modelCursor should be.\n      // If we had to split parent to insert our element then we want to continue conversion inside split parent.\n      //\n      // before: <allowed><notAllowed>[]</notAllowed></allowed>\n      // after:  <allowed><notAllowed></notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>\n\n      if (splitResult.cursorParent) {\n        data.modelCursor = conversionApi.writer.createPositionAt(splitResult.cursorParent, 0); // Otherwise just continue after inserted element.\n      } else {\n        data.modelCursor = data.modelRange.end;\n      }\n    });\n  };\n}\nexport function upcastTableCell(elementName) {\n  return function (dispatcher) {\n    dispatcher.on(\"element:\".concat(elementName), function (evt, data, conversionApi) {\n      var viewTableCell = data.viewItem; // When element was already consumed then skip it.\n\n      if (!conversionApi.consumable.test(viewTableCell, {\n        name: true\n      })) {\n        return;\n      }\n\n      var tableCell = conversionApi.writer.createElement('tableCell'); // Insert element on allowed position.\n\n      var splitResult = conversionApi.splitToAllowedParent(tableCell, data.modelCursor); // When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\n      if (!splitResult) {\n        return;\n      }\n\n      conversionApi.writer.insert(tableCell, splitResult.position);\n      conversionApi.consumable.consume(viewTableCell, {\n        name: true\n      });\n      var modelCursor = conversionApi.writer.createPositionAt(tableCell, 0);\n      conversionApi.convertChildren(viewTableCell, modelCursor); // Ensure a paragraph in the model for empty table cells.\n\n      if (!tableCell.childCount) {\n        conversionApi.writer.insertElement('paragraph', modelCursor);\n      } // Set conversion result range.\n\n\n      data.modelRange = conversionApi.writer.createRange( // Range should start before inserted element\n      conversionApi.writer.createPositionBefore(tableCell), // Should end after but we need to take into consideration that children could split our\n      // element, so we need to move range after parent of the last converted child.\n      // before: <allowed>[]</allowed>\n      // after: <allowed>[<converted><child></child></converted><child></child><converted>]</converted></allowed>\n      conversionApi.writer.createPositionAfter(tableCell)); // Continue after inserted element.\n\n      data.modelCursor = data.modelRange.end;\n    });\n  };\n} // Scans table rows and extracts required metadata from the table:\n//\n// headingRows    - the number of rows that goes as table header.\n// headingColumns - max number of row headings.\n// rows           - sorted `<tr>`s as they should go into the model - ie. if `<thead>` is inserted after `<tbody>` in the view.\n//\n// @param {module:engine/view/element~Element} viewTable\n// @returns {{headingRows, headingColumns, rows}}\n\nfunction scanTable(viewTable) {\n  var tableMeta = {\n    headingRows: 0,\n    headingColumns: 0\n  }; // The `<tbody>` and <thead> sections in the DOM do not have to be in order `<thead>` -> `<tbody>` and there might be more then one of\n  // them.\n  // As the model does not have those sections, rows from different sections must be sorted.\n  // For example, below is a valid HTML table:\n  //\n  //\t\t<table>\n  //\t\t\t<tbody><tr><td>2</td></tr></tbody>\n  //\t\t\t<thead><tr><td>1</td></tr></thead>\n  //\t\t\t<tbody><tr><td>3</td></tr></tbody>\n  //\t\t</table>\n  //\n  // But browsers will render rows in order as: 1 as heading and 2 and 3 as (body).\n\n  var headRows = [];\n  var bodyRows = []; // Currently the editor does not support more then one <thead> section.\n  // Only the first <thead> from the view will be used as heading rows and others will be converted to body rows.\n\n  var firstTheadElement;\n\n  for (var _i = 0, _Array$from = Array.from(viewTable.getChildren()); _i < _Array$from.length; _i++) {\n    var tableChild = _Array$from[_i];\n\n    // Only <thead>, <tbody> & <tfoot> from allowed table children can have <tr>s.\n    // The else is for future purposes (mainly <caption>).\n    if (tableChild.name === 'tbody' || tableChild.name === 'thead' || tableChild.name === 'tfoot') {\n      // Save the first <thead> in the table as table header - all other ones will be converted to table body rows.\n      if (tableChild.name === 'thead' && !firstTheadElement) {\n        firstTheadElement = tableChild;\n      } // There might be some extra empty text nodes between the `tr`s.\n      // Make sure further code operates on `tr`s only. (#145)\n\n\n      var trs = Array.from(tableChild.getChildren()).filter(function (el) {\n        return el.is('element', 'tr');\n      });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = trs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var tr = _step.value;\n\n          // This <tr> is a child of a first <thead> element.\n          if (tr.parent.name === 'thead' && tr.parent === firstTheadElement) {\n            tableMeta.headingRows++;\n            headRows.push(tr);\n          } else {\n            bodyRows.push(tr); // For other rows check how many column headings this row has.\n\n            var headingCols = scanRowForHeadingColumns(tr, tableMeta, firstTheadElement);\n\n            if (headingCols > tableMeta.headingColumns) {\n              tableMeta.headingColumns = headingCols;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }\n\n  tableMeta.rows = [].concat(headRows, bodyRows);\n  return tableMeta;\n} // Scans `<tr>` and its children for metadata:\n// - For heading row:\n//     - either adds this row to heading or body rows.\n//     - updates number of heading rows.\n// - For body rows:\n//     - calculates the number of column headings.\n//\n// @param {module:engine/view/element~Element} tr\n// @returns {Number}\n\n\nfunction scanRowForHeadingColumns(tr) {\n  var headingColumns = 0;\n  var index = 0; // Filter out empty text nodes from tr children.\n\n  var children = Array.from(tr.getChildren()).filter(function (child) {\n    return child.name === 'th' || child.name === 'td';\n  }); // Count starting adjacent <th> elements of a <tr>.\n\n  while (index < children.length && children[index].name === 'th') {\n    var th = children[index]; // Adjust columns calculation by the number of spanned columns.\n\n    var colspan = parseInt(th.getAttribute('colspan') || 1);\n    headingColumns = headingColumns + colspan;\n    index++;\n  }\n\n  return headingColumns;\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.map\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablewalker\n */\n\n/**\n * Table iterator class. It allows to iterate over table cells. For each cell the iterator yields\n * {@link module:table/tablewalker~TableWalkerValue} with proper table cell attributes.\n */\nvar TableWalker =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the table walker.\n   *\n   *\n   * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.\n   * It walks row by row and column by column in order to output values defined in the constructor.\n   * By default it will output only those locations that are occupied by a cell. To include also spanned rows and columns,\n   * pass the `includeSpanned` option to the constructor.\n   *\n   * The most important values of the iterator are column and row indexes of a cell.\n   *\n   * To iterate over a given row:\n   *\n   *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );\n   *\n   *\t\tfor ( const cellInfo of tableWalker ) {\n   *\t\t\tconsole.log( 'A cell at row ' + cellInfo.row + ' and column ' + cellInfo.column );\n   *\t\t}\n   *\n   * For instance the code above for the following table:\n   *\n   *\t\t+----+----+----+----+----+----+\n   *\t\t| 00      | 02 | 03 | 04 | 05 |\n   *\t\t|         +----+----+----+----+\n   *\t\t|         | 12      | 14 | 15 |\n   *\t\t|         +----+----+----+    +\n   *\t\t|         | 22           |    |\n   *\t\t|----+----+----+----+----+    +\n   *\t\t| 30 | 31 | 32 | 33 | 34 |    |\n   *\t\t+----+----+----+----+----+----+\n   *\n   * will log in the console:\n   *\n   *\t\t'A cell at row 1 and column 2'\n   *\t\t'A cell at row 1 and column 4'\n   *\t\t'A cell at row 1 and column 5'\n   *\t\t'A cell at row 2 and column 2'\n   *\n   * To also iterate over spanned cells:\n   *\n   *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 1, includeSpanned: true } );\n   *\n   *\t\tfor ( const cellInfo of tableWalker ) {\n   *\t\t\tconsole.log( 'Cell at ' + cellInfo.row + ' x ' + cellInfo.column + ' : ' + ( cellInfo.cell ? 'has data' : 'is spanned' ) );\n   *\t\t}\n   *\n   * will log in the console for the table from previous example:\n   *\n   *\t\t'Cell at 1 x 0 : is spanned'\n   *\t\t'Cell at 1 x 1 : is spanned'\n   *\t\t'Cell at 1 x 2 : has data'\n   *\t\t'Cell at 1 x 3 : is spanned'\n   *\t\t'Cell at 1 x 4 : has data'\n   *\t\t'Cell at 1 x 5 : has data'\n   *\n   * @constructor\n   * @param {module:engine/model/element~Element} table A table over which the walker iterates.\n   * @param {Object} [options={}] An object with configuration.\n   * @param {Number} [options.column] A column index for which this iterator will output cells.\n   * @param {Number} [options.startRow=0] A row index for which this iterator should start.\n   * @param {Number} [options.endRow] A row index for which this iterator should end.\n   * @param {Boolean} [options.includeSpanned] Also return values for spanned cells.\n   */\n  function TableWalker(table) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TableWalker);\n\n    /**\n     * The walker's table element.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element}\n     */\n    this.table = table;\n    /**\n     * A row index on which this iterator will start.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.startRow = options.startRow || 0;\n    /**\n     * A row index on which this iterator will end.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.endRow = typeof options.endRow == 'number' ? options.endRow : undefined;\n    /**\n     * Enables output of spanned cells that are normally not yielded.\n     *\n     * @readonly\n     * @member {Boolean}\n     */\n\n    this.includeSpanned = !!options.includeSpanned;\n    /**\n     * If set, the table walker will only output cells of a given column or cells that overlap it.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.column = typeof options.column == 'number' ? options.column : undefined;\n    /**\n     * Row indexes to skip from the iteration.\n     *\n     * @readonly\n     * @member {Set<Number>}\n     * @private\n     */\n\n    this._skipRows = new Set();\n    /**\n     * The current row index.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._row = 0;\n    /**\n     * The current column index.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._column = 0;\n    /**\n     * The cell index in a parent row. For spanned cells when {@link #includeSpanned} is set to `true`,\n     * this represents the index of the next table cell.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._cell = 0;\n    /**\n     * Holds a map of spanned cells in a table.\n     *\n     * @readonly\n     * @member {Map<Number, Map.<Number, Number>>}\n     * @private\n     */\n\n    this._spannedCells = new Map();\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<module:table/tablewalker~TableWalkerValue>}\n   */\n\n\n  _createClass(TableWalker, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this;\n    }\n    /**\n     * Gets the next table walker's value.\n     *\n     * @returns {module:table/tablewalker~TableWalkerValue} The next table walker's value.\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      var row = this.table.getChild(this._row); // Iterator is done when no row (table end) or the row is after #endRow.\n\n      if (!row || this._isOverEndRow()) {\n        return {\n          done: true\n        };\n      } // Spanned cell location handling.\n\n\n      if (this._isSpanned(this._row, this._column)) {\n        // Current column must be kept as it will be updated before returning current value.\n        var _currentColumn = this._column;\n\n        var _outValue = this._formatOutValue(undefined, _currentColumn); // Advance to next column - always.\n\n\n        this._column++;\n\n        var _skipCurrentValue = !this.includeSpanned || this._shouldSkipRow() || this._shouldSkipColumn(_currentColumn, 1); // The current value will be returned only if #includedSpanned=true and also current row and column are not skipped.\n\n\n        return _skipCurrentValue ? this.next() : _outValue;\n      } // The cell location is not spanned by other cells.\n\n\n      var cell = row.getChild(this._cell);\n\n      if (!cell) {\n        // If there are no more cells left in row advance to next row.\n        this._row++; // And reset column & cell indexes.\n\n        this._column = 0;\n        this._cell = 0; // Return next value.\n\n        return this.next();\n      } // Read table cell attributes.\n\n\n      var colspan = parseInt(cell.getAttribute('colspan') || 1);\n      var rowspan = parseInt(cell.getAttribute('rowspan') || 1); // Record this cell spans if it's not 1x1 cell.\n\n      if (colspan > 1 || rowspan > 1) {\n        this._recordSpans(this._row, this._column, rowspan, colspan);\n      } // Current column must be kept as it will be updated before returning current value.\n\n\n      var currentColumn = this._column;\n\n      var outValue = this._formatOutValue(cell, currentColumn, rowspan, colspan); // Advance to next column before returning value.\n\n\n      this._column++; // Advance to next cell in a parent row before returning value.\n\n      this._cell++;\n\n      var skipCurrentValue = this._shouldSkipRow() || this._shouldSkipColumn(currentColumn, colspan); // The current value will be returned only if current row & column are not skipped.\n\n\n      return skipCurrentValue ? this.next() : outValue;\n    }\n    /**\n     * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row\n     * to output.\n     *\n     * @param {Number} row Row index to skip.\n     */\n\n  }, {\n    key: \"skipRow\",\n    value: function skipRow(row) {\n      this._skipRows.add(row);\n    }\n    /**\n     * Checks if the current row is over {@link #endRow}.\n     *\n     * @returns {Boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_isOverEndRow\",\n    value: function _isOverEndRow() {\n      // If {@link #endRow) is defined skip all rows above it.\n      return this.endRow !== undefined && this._row > this.endRow;\n    }\n    /**\n     * A common method for formatting the iterator's output value.\n     *\n     * @param {module:engine/model/element~Element|undefined} cell The table cell to output. It might be undefined for spanned cell\n     * locations.\n     * @param {Number} column Column index (use the cached value)\n     * @param {Number} rowspan Rowspan of the current cell.\n     * @param {Number} colspan Colspan of the current cell.\n     * @returns {{done: boolean, value: {cell: *, row: Number, column: *, rowspan: *, colspan: *, cellIndex: Number}}}\n     * @private\n     */\n\n  }, {\n    key: \"_formatOutValue\",\n    value: function _formatOutValue(cell, column) {\n      var rowspan = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var colspan = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      return {\n        done: false,\n        value: {\n          cell: cell,\n          row: this._row,\n          column: column,\n          rowspan: rowspan,\n          colspan: colspan,\n          cellIndex: this._cell\n        }\n      };\n    }\n    /**\n     * Checks if the current row should be skipped.\n     *\n     * @returns {Boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_shouldSkipRow\",\n    value: function _shouldSkipRow() {\n      var rowIsBelowStartRow = this._row < this.startRow;\n\n      var rowIsMarkedAsSkipped = this._skipRows.has(this._row);\n\n      return rowIsBelowStartRow || rowIsMarkedAsSkipped;\n    }\n    /**\n     * Checks if the current column should be skipped.\n     *\n     * @param {Number} column\n     * @param {Number} colspan\n     * @returns {Boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_shouldSkipColumn\",\n    value: function _shouldSkipColumn(column, colspan) {\n      if (this.column === undefined) {\n        // The {@link #column} is not defined so output all columns.\n        return false;\n      } // When outputting cells from given column we skip:\n      // - Cells that are not on that column.\n\n\n      var isCurrentColumn = column === this.column; // - CSells that are before given column and they overlaps given column.\n\n      var isPreviousThatOverlapsColumn = column < this.column && column + colspan > this.column;\n      return !isCurrentColumn && !isPreviousThatOverlapsColumn;\n    }\n    /**\n     * Checks if the current cell location (row x column) is spanned by another cell.\n     *\n     * @param {Number} row Row index of a cell location to check.\n     * @param {Number} column Column index of a cell location to check.\n     * @returns {Boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_isSpanned\",\n    value: function _isSpanned(row, column) {\n      if (!this._spannedCells.has(row)) {\n        // No spans for given row.\n        return false;\n      }\n\n      var rowSpans = this._spannedCells.get(row); // If spans for given rows has entry for column it means that this location if spanned by other cell.\n\n\n      return rowSpans.has(column);\n    }\n    /**\n     * Updates spanned cells map relative to the current cell location and its span dimensions.\n     *\n     * @param {Number} row Row index of a cell.\n     * @param {Number} column Column index of a cell.\n     * @param {Number} rowspan Cell height.\n     * @param {Number} colspan Cell width.\n     * @private\n     */\n\n  }, {\n    key: \"_recordSpans\",\n    value: function _recordSpans(row, column, rowspan, colspan) {\n      // This will update all cell locations after current column - ie a cell has colspan set.\n      for (var columnToUpdate = column + 1; columnToUpdate <= column + colspan - 1; columnToUpdate++) {\n        this._markSpannedCell(row, columnToUpdate);\n      } // This will update all rows below current up to row's height.\n\n\n      for (var rowToUpdate = row + 1; rowToUpdate < row + rowspan; rowToUpdate++) {\n        for (var _columnToUpdate = column; _columnToUpdate <= column + colspan - 1; _columnToUpdate++) {\n          this._markSpannedCell(rowToUpdate, _columnToUpdate);\n        }\n      }\n    }\n    /**\n     * Marks the cell location as spanned by another cell.\n     *\n     * @param {Number} row Row index of the cell location.\n     * @param {Number} column Column index of the cell location.\n     * @private\n     */\n\n  }, {\n    key: \"_markSpannedCell\",\n    value: function _markSpannedCell(row, column) {\n      if (!this._spannedCells.has(row)) {\n        this._spannedCells.set(row, new Map());\n      }\n\n      var rowSpans = this._spannedCells.get(row);\n\n      rowSpans.set(column, true);\n    }\n  }]);\n\n  return TableWalker;\n}();\n/**\n * An object returned by {@link module:table/tablewalker~TableWalker} when traversing table cells.\n *\n * @typedef {Object} module:table/tablewalker~TableWalkerValue\n * @property {module:engine/model/element~Element} [cell] The current table cell. Might be empty if\n * {@link module:table/tablewalker~TableWalker#includeSpanned} is set to `true`.\n * @property {Number} row The row index of a cell.\n * @property {Number} column The column index of a cell. Column index is adjusted to widths and heights of previous cells.\n * @property {Number} [colspan] The `colspan` attribute of a cell. It is always defined even if the model attribute is not present. Not\n * set if {@link module:table/tablewalker~TableWalker#includeSpanned} is set to `true`.\n * @property {Number} [rowspan] The `rowspan` attribute of a cell. It is always defined even if the model attribute is not present. Not\n * set if {@link module:table/tablewalker~TableWalker#includeSpanned} is set to `true`.\n * @property {Number} cellIndex The index of the current cell in a parent row. When using the `includeSpanned` option it will indicate the\n * next child index if #cell is empty (which indicates that the cell is spanned by another cell).\n */\n\n\nexport { TableWalker as default };","import \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.array.find-index\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/highlightstack\n */\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Class used to handle correct order of highlights on elements.\n *\n * When different highlights are applied to same element correct order should be preserved:\n *\n * * highlight with highest priority should be applied,\n * * if two highlights have same priority - sort by CSS class provided in\n * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n *\n * This way, highlight will be applied with the same rules it is applied on texts.\n */\n\nvar HighlightStack =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates class instance.\n   */\n  function HighlightStack() {\n    _classCallCheck(this, HighlightStack);\n\n    this._stack = [];\n  }\n  /**\n   * Adds highlight descriptor to the stack.\n   *\n   * @fires change:top\n   * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n   */\n\n\n  _createClass(HighlightStack, [{\n    key: \"add\",\n    value: function add(descriptor, writer) {\n      var stack = this._stack; // Save top descriptor and insert new one. If top is changed - fire event.\n\n      var oldTop = stack[0];\n\n      this._insertDescriptor(descriptor);\n\n      var newTop = stack[0]; // When new object is at the top and stores different information.\n\n      if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {\n        this.fire('change:top', {\n          oldDescriptor: oldTop,\n          newDescriptor: newTop,\n          writer: writer\n        });\n      }\n    }\n    /**\n     * Removes highlight descriptor from the stack.\n     *\n     * @fires change:top\n     * @param {String} id Id of the descriptor to remove.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(id, writer) {\n      var stack = this._stack;\n      var oldTop = stack[0];\n\n      this._removeDescriptor(id);\n\n      var newTop = stack[0]; // When new object is at the top and stores different information.\n\n      if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {\n        this.fire('change:top', {\n          oldDescriptor: oldTop,\n          newDescriptor: newTop,\n          writer: writer\n        });\n      }\n    }\n    /**\n     * Inserts given descriptor in correct place in the stack. It also takes care about updating information when\n     * descriptor with same id is already present.\n     *\n     * @private\n     * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n     */\n\n  }, {\n    key: \"_insertDescriptor\",\n    value: function _insertDescriptor(descriptor) {\n      var stack = this._stack;\n      var index = stack.findIndex(function (item) {\n        return item.id === descriptor.id;\n      }); // Inserting exact same descriptor - do nothing.\n\n      if (compareDescriptors(descriptor, stack[index])) {\n        return;\n      } // If descriptor with same id but with different information is on the stack - remove it.\n\n\n      if (index > -1) {\n        stack.splice(index, 1);\n      } // Find correct place to insert descriptor in the stack.\n      // It have different information (for example priority) so it must be re-inserted in correct place.\n\n\n      var i = 0;\n\n      while (stack[i] && shouldABeBeforeB(stack[i], descriptor)) {\n        i++;\n      }\n\n      stack.splice(i, 0, descriptor);\n    }\n    /**\n     * Removes descriptor with given id from the stack.\n     *\n     * @private\n     * @param {String} id Descriptor's id.\n     */\n\n  }, {\n    key: \"_removeDescriptor\",\n    value: function _removeDescriptor(id) {\n      var stack = this._stack;\n      var index = stack.findIndex(function (item) {\n        return item.id === id;\n      }); // If descriptor with same id is on the list - remove it.\n\n      if (index > -1) {\n        stack.splice(index, 1);\n      }\n    }\n  }]);\n\n  return HighlightStack;\n}();\n\nexport { HighlightStack as default };\nmix(HighlightStack, EmitterMixin); // Compares two descriptors by checking their priority and class list.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} a\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} b\n// @returns {Boolean} Returns true if both descriptors are defined and have same priority and classes.\n\nfunction compareDescriptors(a, b) {\n  return a && b && a.priority == b.priority && classesToString(a.classes) == classesToString(b.classes);\n} // Checks whenever first descriptor should be placed in the stack before second one.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} a\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} b\n// @returns {Boolean}\n\n\nfunction shouldABeBeforeB(a, b) {\n  if (a.priority > b.priority) {\n    return true;\n  } else if (a.priority < b.priority) {\n    return false;\n  } // When priorities are equal and names are different - use classes to compare.\n\n\n  return classesToString(a.classes) > classesToString(b.classes);\n} // Converts CSS classes passed with {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} to\n// sorted string.\n//\n// @param {String|Array<String>} descriptor\n// @returns {String}\n\n\nfunction classesToString(classes) {\n  return Array.isArray(classes) ? classes.sort().join(',') : classes;\n}\n/**\n * Fired when top element on {@link module:widget/highlightstack~HighlightStack} has been changed\n *\n * @event change:top\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} [data.newDescriptor] New highlight\n * descriptor. It will be `undefined` when last descriptor is removed from the stack.\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} [data.oldDescriptor] Old highlight\n * descriptor. It will be `undefined` when first descriptor is added to the stack.\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that can be used to modify element.\n */","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/utils\n */\nimport HighlightStack from \"./highlightstack\";\nimport IconView from '@ckeditor/ckeditor5-ui/src/icon/iconview';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport dragHandlerIcon from \"../theme/icons/drag-handler.svg\";\n/**\n * CSS class added to each widget element.\n *\n * @const {String}\n */\n\nexport var WIDGET_CLASS_NAME = 'ck-widget';\n/**\n * CSS class added to currently selected widget element.\n *\n * @const {String}\n */\n\nexport var WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n *\n * @param {module:engine/view/node~Node} node\n * @returns {Boolean}\n */\n\nexport function isWidget(node) {\n  if (!node.is('element')) {\n    return false;\n  }\n\n  return !!node.getCustomProperty('widget');\n}\n/* eslint-disable max-len */\n\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"true\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n *\t\t\t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options={}]\n * @param {String|Function} [options.label] Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param {Boolean} [options.hasSelectionHandler=false] If `true`, the widget will have a selection handler added.\n * @returns {module:engine/view/element~Element} Returns the same element.\n */\n\n/* eslint-enable max-len */\n\nexport function toWidget(element, writer) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // The selection on Edge behaves better when the whole editor contents is in a single contenteditable element.\n  // https://github.com/ckeditor/ckeditor5/issues/1079\n  if (!env.isEdge) {\n    writer.setAttribute('contenteditable', 'false', element);\n  }\n\n  writer.addClass(WIDGET_CLASS_NAME, element);\n  writer.setCustomProperty('widget', true, element);\n  element.getFillerOffset = getFillerOffset;\n\n  if (options.label) {\n    setLabel(element, options.label, writer);\n  }\n\n  if (options.hasSelectionHandler) {\n    addSelectionHandler(element, writer);\n  }\n\n  setHighlightHandling(element, writer, function (element, descriptor, writer) {\n    return writer.addClass(normalizeToArray(descriptor.classes), element);\n  }, function (element, descriptor, writer) {\n    return writer.removeClass(normalizeToArray(descriptor.classes), element);\n  });\n  return element; // Normalizes CSS class in descriptor that can be provided in form of an array or a string.\n\n  function normalizeToArray(classes) {\n    return Array.isArray(classes) ? classes : [classes];\n  }\n}\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Function} add\n * @param {Function} remove\n */\n\nexport function setHighlightHandling(element, writer, add, remove) {\n  var stack = new HighlightStack();\n  stack.on('change:top', function (evt, data) {\n    if (data.oldDescriptor) {\n      remove(element, data.oldDescriptor, data.writer);\n    }\n\n    if (data.newDescriptor) {\n      add(element, data.newDescriptor, data.writer);\n    }\n  });\n  writer.setCustomProperty('addHighlight', function (element, descriptor, writer) {\n    return stack.add(descriptor, writer);\n  }, element);\n  writer.setCustomProperty('removeHighlight', function (element, id, writer) {\n    return stack.remove(id, writer);\n  }, element);\n}\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n *\n * @param {module:engine/view/element~Element} element\n * @param {String|Function} labelOrCreator\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n */\n\nexport function setLabel(element, labelOrCreator, writer) {\n  writer.setCustomProperty('widgetLabel', labelOrCreator, element);\n}\n/**\n * Returns the label of the provided element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {String}\n */\n\nexport function getLabel(element) {\n  var labelCreator = element.getCustomProperty('widgetLabel');\n\n  if (!labelCreator) {\n    return '';\n  }\n\n  return typeof labelCreator == 'function' ? labelCreator() : labelCreator;\n}\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `dataDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n *\t\t\t\t\treturn toWidgetEditable( nested, writer );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/editableelement~EditableElement} editable\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @returns {module:engine/view/editableelement~EditableElement} Returns the same element that was provided in the `editable` parameter\n */\n\nexport function toWidgetEditable(editable, writer) {\n  writer.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], editable); // The selection on Edge behaves better when the whole editor contents is in a single contentedible element.\n  // https://github.com/ckeditor/ckeditor5/issues/1079\n\n  if (!env.isEdge) {\n    // Set initial contenteditable value.\n    writer.setAttribute('contenteditable', editable.isReadOnly ? 'false' : 'true', editable); // Bind the contenteditable property to element#isReadOnly.\n\n    editable.on('change:isReadOnly', function (evt, property, is) {\n      writer.setAttribute('contenteditable', is ? 'false' : 'true', editable);\n    });\n  }\n\n  editable.on('change:isFocused', function (evt, property, is) {\n    if (is) {\n      writer.addClass('ck-editor__nested-editable_focused', editable);\n    } else {\n      writer.removeClass('ck-editor__nested-editable_focused', editable);\n    }\n  });\n  return editable;\n}\n/**\n * Returns a model position which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the position before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the position after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, that block will be returned. If that position\n * is then passed to {@link module:engine/model/model~Model#insertContent},\n * the block will be fully replaced by the image.\n *\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection based on which the insertion position should be calculated.\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {module:engine/model/position~Position} The optimal position.\n */\n\nexport function findOptimalInsertionPosition(selection, model) {\n  var selectedElement = selection.getSelectedElement();\n\n  if (selectedElement && model.schema.isBlock(selectedElement)) {\n    return model.createPositionAfter(selectedElement);\n  }\n\n  var firstBlock = selection.getSelectedBlocks().next().value;\n\n  if (firstBlock) {\n    // If inserting into an empty block  return position in that block. It will get\n    // replaced with the image by insertContent(). #42.\n    if (firstBlock.isEmpty) {\n      return model.createPositionAt(firstBlock, 0);\n    }\n\n    var positionAfter = model.createPositionAfter(firstBlock); // If selection is at the end of the block - return position after the block.\n\n    if (selection.focus.isTouching(positionAfter)) {\n      return positionAfter;\n    } // Otherwise return position before the block.\n\n\n    return model.createPositionBefore(firstBlock);\n  }\n\n  return selection.focus;\n}\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n *\t\t// Model:\n *\t\t<placeholder type=\"name\"></placeholder>\n *\n *\t\t// View:\n *\t\t<span class=\"placeholder\">name</span>\n *\n * In such case, view positions inside `<span>` cannot be correct mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n *\t\teditor.editing.mapper.on(\n *\t\t\t'viewToModelPosition',\n *\t\t\tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n *\t\t);\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n *\n * @param {module:engine/model/model~Model} model Model instance on which the callback operates.\n * @param {Function} viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n * @return {Function}\n */\n\nexport function viewToModelPositionOutsideModelElement(model, viewElementMatcher) {\n  return function (evt, data) {\n    var mapper = data.mapper,\n        viewPosition = data.viewPosition;\n    var viewParent = mapper.findMappedViewAncestor(viewPosition);\n\n    if (!viewElementMatcher(viewParent)) {\n      return;\n    }\n\n    var modelParent = mapper.toModelElement(viewParent);\n    data.modelPosition = model.createPositionAt(modelParent, viewPosition.isAtStart ? 'before' : 'after');\n  };\n} // Default filler offset function applied to all widget elements.\n//\n// @returns {null}\n\nfunction getFillerOffset() {\n  return null;\n} // Adds a drag handler to the widget.\n//\n// @param {module:engine/view/containerelement~ContainerElement}\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\n\nfunction addSelectionHandler(widgetElement, writer) {\n  var selectionHandler = writer.createUIElement('div', {\n    class: 'ck ck-widget__selection-handler'\n  }, function (domDocument) {\n    var domElement = this.toDomElement(domDocument); // Use the IconView from the ui library.\n\n    var icon = new IconView();\n    icon.set('content', dragHandlerIcon); // Render the icon view right away to append its #element to the selectionHandler DOM element.\n\n    icon.render();\n    domElement.appendChild(icon.element);\n    return domElement;\n  }); // Append the selection handler into the widget wrapper.\n\n  writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandler);\n  writer.addClass(['ck-widget_with-selection-handler'], widgetElement);\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/utils\n */\nimport { isWidget, toWidget } from '@ckeditor/ckeditor5-widget/src/utils';\nimport { findAncestor } from \"./commands/utils\";\n/**\n * Converts a given {@link module:engine/view/element~Element} to a table widget:\n * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the table widget element.\n * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.\n * @param {String} label The element's label. It will be concatenated with the table `alt` attribute if one is present.\n * @returns {module:engine/view/element~Element}\n */\n\nexport function toTableWidget(viewElement, writer) {\n  writer.setCustomProperty('table', true, viewElement);\n  return toWidget(viewElement, writer, {\n    hasSelectionHandler: true\n  });\n}\n/**\n * Checks if a given view element is a table widget.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @returns {Boolean}\n */\n\nexport function isTableWidget(viewElement) {\n  return !!viewElement.getCustomProperty('table') && isWidget(viewElement);\n}\n/**\n * Returns a table widget editing view element if one is selected.\n *\n * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection\n * @returns {module:engine/view/element~Element|null}\n */\n\nexport function getSelectedTableWidget(selection) {\n  var viewElement = selection.getSelectedElement();\n\n  if (viewElement && isTableWidget(viewElement)) {\n    return viewElement;\n  }\n\n  return null;\n}\n/**\n * Returns a table widget editing view element if one is among selection's ancestors.\n *\n * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection\n * @returns {module:engine/view/element~Element|null}\n */\n\nexport function getTableWidgetAncestor(selection) {\n  var parentTable = findAncestor('table', selection.getFirstPosition());\n\n  if (parentTable && isTableWidget(parentTable.parent)) {\n    return parentTable.parent;\n  }\n\n  return null;\n}","import _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/downcast\n */\nimport TableWalker from \"./../tablewalker\";\nimport { toWidgetEditable } from '@ckeditor/ckeditor5-widget/src/utils';\nimport { toTableWidget } from \"../utils\";\n/**\n * Model table element to view table element conversion helper.\n *\n * This conversion helper creates the whole table element with child elements.\n *\n * @param {Object} options\n * @param {Boolean} options.asWidget If set to `true`, the downcast conversion will produce a widget.\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastInsertTable() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (dispatcher) {\n    return dispatcher.on('insert:table', function (evt, data, conversionApi) {\n      var table = data.item;\n\n      if (!conversionApi.consumable.consume(table, 'insert')) {\n        return;\n      } // Consume attributes if present to not fire attribute change downcast\n\n\n      conversionApi.consumable.consume(table, 'attribute:headingRows:table');\n      conversionApi.consumable.consume(table, 'attribute:headingColumns:table');\n      var asWidget = options && options.asWidget;\n      var figureElement = conversionApi.writer.createContainerElement('figure', {\n        class: 'table'\n      });\n      var tableElement = conversionApi.writer.createContainerElement('table');\n      conversionApi.writer.insert(conversionApi.writer.createPositionAt(figureElement, 0), tableElement);\n      var tableWidget;\n\n      if (asWidget) {\n        tableWidget = toTableWidget(figureElement, conversionApi.writer);\n      }\n\n      var tableWalker = new TableWalker(table);\n      var tableAttributes = {\n        headingRows: table.getAttribute('headingRows') || 0,\n        headingColumns: table.getAttribute('headingColumns') || 0\n      }; // Cache for created table rows.\n\n      var viewRows = new Map();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = tableWalker[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var tableWalkerValue = _step.value;\n          var row = tableWalkerValue.row,\n              cell = tableWalkerValue.cell;\n          var tableSection = getOrCreateTableSection(getSectionName(row, tableAttributes), tableElement, conversionApi);\n          var tableRow = table.getChild(row);\n          var trElement = viewRows.get(row) || createTr(tableRow, row, tableSection, conversionApi);\n          viewRows.set(row, trElement); // Consume table cell - it will be always consumed as we convert whole table at once.\n\n          conversionApi.consumable.consume(cell, 'insert');\n          var insertPosition = conversionApi.writer.createPositionAt(trElement, 'end');\n          createViewTableCellElement(tableWalkerValue, tableAttributes, insertPosition, conversionApi, options);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n      conversionApi.mapper.bindElements(table, asWidget ? tableWidget : figureElement);\n      conversionApi.writer.insert(viewPosition, asWidget ? tableWidget : figureElement);\n    });\n  };\n}\n/**\n * Model row element to view `<tr>` element conversion helper.\n *\n * This conversion helper creates the whole `<tr>` element with child elements.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastInsertRow() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (dispatcher) {\n    return dispatcher.on('insert:tableRow', function (evt, data, conversionApi) {\n      var tableRow = data.item;\n\n      if (!conversionApi.consumable.consume(tableRow, 'insert')) {\n        return;\n      }\n\n      var table = tableRow.parent;\n      var figureElement = conversionApi.mapper.toViewElement(table);\n      var tableElement = getViewTable(figureElement);\n      var row = table.getChildIndex(tableRow);\n      var tableWalker = new TableWalker(table, {\n        startRow: row,\n        endRow: row\n      });\n      var tableAttributes = {\n        headingRows: table.getAttribute('headingRows') || 0,\n        headingColumns: table.getAttribute('headingColumns') || 0\n      }; // Cache for created table rows.\n\n      var viewRows = new Map();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = tableWalker[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var tableWalkerValue = _step2.value;\n          var tableSection = getOrCreateTableSection(getSectionName(row, tableAttributes), tableElement, conversionApi);\n          var trElement = viewRows.get(row) || createTr(tableRow, row, tableSection, conversionApi);\n          viewRows.set(row, trElement); // Consume table cell - it will be always consumed as we convert whole row at once.\n\n          conversionApi.consumable.consume(tableWalkerValue.cell, 'insert');\n          var insertPosition = conversionApi.writer.createPositionAt(trElement, 'end');\n          createViewTableCellElement(tableWalkerValue, tableAttributes, insertPosition, conversionApi, options);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n  };\n}\n/**\n * Model table cell element to view `<td>` or `<th>` element conversion helper.\n *\n * This conversion helper will create proper `<th>` elements for table cells that are in the heading section (heading row or column)\n * and `<td>` otherwise.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastInsertCell() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (dispatcher) {\n    return dispatcher.on('insert:tableCell', function (evt, data, conversionApi) {\n      var tableCell = data.item;\n\n      if (!conversionApi.consumable.consume(tableCell, 'insert')) {\n        return;\n      }\n\n      var tableRow = tableCell.parent;\n      var table = tableRow.parent;\n      var rowIndex = table.getChildIndex(tableRow);\n      var tableWalker = new TableWalker(table, {\n        startRow: rowIndex,\n        endRow: rowIndex\n      });\n      var tableAttributes = {\n        headingRows: table.getAttribute('headingRows') || 0,\n        headingColumns: table.getAttribute('headingColumns') || 0\n      }; // We need to iterate over a table in order to get proper row & column values from a walker\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = tableWalker[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var tableWalkerValue = _step3.value;\n\n          if (tableWalkerValue.cell === tableCell) {\n            var trElement = conversionApi.mapper.toViewElement(tableRow);\n            var insertPosition = conversionApi.writer.createPositionAt(trElement, tableRow.getChildIndex(tableCell));\n            createViewTableCellElement(tableWalkerValue, tableAttributes, insertPosition, conversionApi, options); // No need to iterate further.\n\n            return;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    });\n  };\n}\n/**\n * Conversion helper that acts on heading rows table attribute change.\n *\n * This converter will:\n *\n * * Rename `<td>` to `<th>` elements or vice versa depending on headings.\n * * Create `<thead>` or `<tbody>` elements if needed.\n * * Remove empty `<thead>` or `<tbody>` if needed.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastTableHeadingRowsChange() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var asWidget = !!options.asWidget;\n  return function (dispatcher) {\n    return dispatcher.on('attribute:headingRows:table', function (evt, data, conversionApi) {\n      var table = data.item;\n\n      if (!conversionApi.consumable.consume(data.item, evt.name)) {\n        return;\n      }\n\n      var figureElement = conversionApi.mapper.toViewElement(table);\n      var viewTable = getViewTable(figureElement);\n      var oldRows = data.attributeOldValue;\n      var newRows = data.attributeNewValue; // The head section has grown so move rows from <tbody> to <thead>.\n\n      if (newRows > oldRows) {\n        // Filter out only those rows that are in wrong section.\n        var rowsToMove = Array.from(table.getChildren()).filter(function (_ref) {\n          var index = _ref.index;\n          return isBetween(index, oldRows - 1, newRows);\n        });\n        var viewTableHead = getOrCreateTableSection('thead', viewTable, conversionApi);\n        moveViewRowsToTableSection(rowsToMove, viewTableHead, conversionApi, 'end'); // Rename all table cells from moved rows to 'th' as they lands in <thead>.\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = rowsToMove[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var tableRow = _step4.value;\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n              for (var _iterator5 = tableRow.getChildren()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var tableCell = _step5.value;\n                renameViewTableCell(tableCell, 'th', conversionApi, asWidget);\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                  _iterator5.return();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n          } // Cleanup: this will remove any empty section from the view which may happen when moving all rows from a table section.\n\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        removeTableSectionIfEmpty('tbody', viewTable, conversionApi);\n      } // The head section has shrunk so move rows from <thead> to <tbody>.\n      else {\n          // Filter out only those rows that are in wrong section.\n          var _rowsToMove = Array.from(table.getChildren()).filter(function (_ref2) {\n            var index = _ref2.index;\n            return isBetween(index, newRows - 1, oldRows);\n          }).reverse(); // The rows will be moved from <thead> to <tbody> in reverse order at the beginning of a <tbody>.\n\n\n          var viewTableBody = getOrCreateTableSection('tbody', viewTable, conversionApi);\n          moveViewRowsToTableSection(_rowsToMove, viewTableBody, conversionApi, 0); // Check if cells moved from <thead> to <tbody> requires renaming to <td> as this depends on current heading columns attribute.\n\n          var tableWalker = new TableWalker(table, {\n            startRow: newRows ? newRows - 1 : newRows,\n            endRow: oldRows - 1\n          });\n          var tableAttributes = {\n            headingRows: table.getAttribute('headingRows') || 0,\n            headingColumns: table.getAttribute('headingColumns') || 0\n          };\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = tableWalker[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var tableWalkerValue = _step6.value;\n              renameViewTableCellIfRequired(tableWalkerValue, tableAttributes, conversionApi, asWidget);\n            } // Cleanup: this will remove any empty section from the view which may happen when moving all rows from a table section.\n\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n\n          removeTableSectionIfEmpty('thead', viewTable, conversionApi);\n        }\n\n      function isBetween(index, lower, upper) {\n        return index > lower && index < upper;\n      }\n    });\n  };\n}\n/**\n * Conversion helper that acts on heading columns table attribute change.\n *\n * Depending on changed attributes this converter will rename `<td` to `<th>` elements or vice versa depending of the cell column index.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastTableHeadingColumnsChange() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var asWidget = !!options.asWidget;\n  return function (dispatcher) {\n    return dispatcher.on('attribute:headingColumns:table', function (evt, data, conversionApi) {\n      var table = data.item;\n\n      if (!conversionApi.consumable.consume(data.item, evt.name)) {\n        return;\n      }\n\n      var tableAttributes = {\n        headingRows: table.getAttribute('headingRows') || 0,\n        headingColumns: table.getAttribute('headingColumns') || 0\n      };\n      var oldColumns = data.attributeOldValue;\n      var newColumns = data.attributeNewValue;\n      var lastColumnToCheck = (oldColumns > newColumns ? oldColumns : newColumns) - 1;\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = new TableWalker(table)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var tableWalkerValue = _step7.value;\n\n          // Skip cells that were not in heading section before and after the change.\n          if (tableWalkerValue.column > lastColumnToCheck) {\n            continue;\n          }\n\n          renameViewTableCellIfRequired(tableWalkerValue, tableAttributes, conversionApi, asWidget);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    });\n  };\n}\n/**\n * Conversion helper that acts on a removed row.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastRemoveRow() {\n  return function (dispatcher) {\n    return dispatcher.on('remove:tableRow', function (evt, data, conversionApi) {\n      // Prevent default remove converter.\n      evt.stop();\n      var viewWriter = conversionApi.writer;\n      var mapper = conversionApi.mapper;\n      var viewStart = mapper.toViewPosition(data.position).getLastMatchingPosition(function (value) {\n        return !value.item.is('tr');\n      });\n      var viewItem = viewStart.nodeAfter;\n      var tableSection = viewItem.parent; // Remove associated <tr> from the view.\n\n      var removeRange = viewWriter.createRangeOn(viewItem);\n      var removed = viewWriter.remove(removeRange);\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = viewWriter.createRangeIn(removed).getItems()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var child = _step8.value;\n          mapper.unbindViewElement(child);\n        } // Check if table section has any children left - if not remove it from the view.\n\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      if (!tableSection.childCount) {\n        // No need to unbind anything as table section is not represented in the model.\n        viewWriter.remove(viewWriter.createRangeOn(tableSection));\n      }\n    }, {\n      priority: 'higher'\n    });\n  };\n} // Renames an existing table cell in the view to a given element name.\n//\n// **Note** This method will not do anything if a view table cell was not yet converted.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} desiredCellElementName\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Boolean} asWidget\n\nfunction renameViewTableCell(tableCell, desiredCellElementName, conversionApi, asWidget) {\n  var viewWriter = conversionApi.writer;\n  var viewCell = conversionApi.mapper.toViewElement(tableCell); // View cell might be not yet converted - skip it as it will be properly created by cell converter later on.\n\n  if (!viewCell) {\n    return;\n  }\n\n  var renamedCell;\n\n  if (asWidget) {\n    var editable = viewWriter.createEditableElement(desiredCellElementName, viewCell.getAttributes());\n    renamedCell = toWidgetEditable(editable, viewWriter);\n    viewWriter.insert(viewWriter.createPositionAfter(viewCell), renamedCell);\n    viewWriter.move(viewWriter.createRangeIn(viewCell), viewWriter.createPositionAt(renamedCell, 0));\n    viewWriter.remove(viewWriter.createRangeOn(viewCell));\n  } else {\n    renamedCell = viewWriter.rename(desiredCellElementName, viewCell);\n  }\n\n  conversionApi.mapper.bindElements(tableCell, renamedCell);\n} // Renames a table cell element in the view according to its location in the table.\n//\n// @param {module:table/tablewalker~TableWalkerValue} tableWalkerValue\n// @param {{headingColumns, headingRows}} tableAttributes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Boolean} asWidget\n\n\nfunction renameViewTableCellIfRequired(tableWalkerValue, tableAttributes, conversionApi, asWidget) {\n  var cell = tableWalkerValue.cell; // Check whether current columnIndex is overlapped by table cells from previous rows.\n\n  var desiredCellElementName = getCellElementName(tableWalkerValue, tableAttributes);\n  var viewCell = conversionApi.mapper.toViewElement(cell); // If in single change we're converting attribute changes and inserting cell the table cell might not be inserted into view\n  // because of child conversion is done after parent.\n\n  if (viewCell && viewCell.name !== desiredCellElementName) {\n    renameViewTableCell(cell, desiredCellElementName, conversionApi, asWidget);\n  }\n} // Creates a table cell element in the view.\n//\n// @param {module:table/tablewalker~TableWalkerValue} tableWalkerValue\n// @param {module:engine/view/position~Position} insertPosition\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction createViewTableCellElement(tableWalkerValue, tableAttributes, insertPosition, conversionApi, options) {\n  var asWidget = options && options.asWidget;\n  var cellElementName = getCellElementName(tableWalkerValue, tableAttributes);\n  var cellElement = asWidget ? toWidgetEditable(conversionApi.writer.createEditableElement(cellElementName), conversionApi.writer) : conversionApi.writer.createContainerElement(cellElementName);\n  var tableCell = tableWalkerValue.cell;\n  var firstChild = tableCell.getChild(0);\n  var isSingleParagraph = tableCell.childCount === 1 && firstChild.name === 'paragraph';\n  conversionApi.writer.insert(insertPosition, cellElement);\n\n  if (isSingleParagraph && !hasAnyAttribute(firstChild)) {\n    var innerParagraph = tableCell.getChild(0);\n    var paragraphInsertPosition = conversionApi.writer.createPositionAt(cellElement, 'end');\n    conversionApi.consumable.consume(innerParagraph, 'insert');\n\n    if (options.asWidget) {\n      var fakeParagraph = conversionApi.writer.createContainerElement('span');\n      conversionApi.mapper.bindElements(innerParagraph, fakeParagraph);\n      conversionApi.writer.insert(paragraphInsertPosition, fakeParagraph);\n      conversionApi.mapper.bindElements(tableCell, cellElement);\n    } else {\n      conversionApi.mapper.bindElements(tableCell, cellElement);\n      conversionApi.mapper.bindElements(innerParagraph, cellElement);\n    }\n  } else {\n    conversionApi.mapper.bindElements(tableCell, cellElement);\n  }\n} // Creates `<tr>` view element.\n//\n// @param {module:engine/view/element~Element} tableRow\n// @param {Number} rowIndex\n// @param {module:engine/view/element~Element} tableSection\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/element~Element}\n\n\nfunction createTr(tableRow, rowIndex, tableSection, conversionApi) {\n  // Will always consume since we're converting <tableRow> element from a parent <table>.\n  conversionApi.consumable.consume(tableRow, 'insert');\n  var trElement = conversionApi.writer.createContainerElement('tr');\n  conversionApi.mapper.bindElements(tableRow, trElement);\n  var headingRows = tableRow.parent.getAttribute('headingRows') || 0;\n  var offset = headingRows > 0 && rowIndex >= headingRows ? rowIndex - headingRows : rowIndex;\n  var position = conversionApi.writer.createPositionAt(tableSection, offset);\n  conversionApi.writer.insert(position, trElement);\n  return trElement;\n} // Returns `th` for heading cells and `td` for other cells for the current table walker value.\n//\n// @param {module:table/tablewalker~TableWalkerValue} tableWalkerValue\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\n\n\nfunction getCellElementName(tableWalkerValue, tableAttributes) {\n  var row = tableWalkerValue.row,\n      column = tableWalkerValue.column;\n  var headingColumns = tableAttributes.headingColumns,\n      headingRows = tableAttributes.headingRows; // Column heading are all tableCells in the first `columnHeading` rows.\n\n  var isColumnHeading = headingRows && headingRows > row; // So a whole row gets <th> element.\n\n  if (isColumnHeading) {\n    return 'th';\n  } // Row heading are tableCells which columnIndex is lower then headingColumns.\n\n\n  var isRowHeading = headingColumns && headingColumns > column;\n  return isRowHeading ? 'th' : 'td';\n} // Returns the table section name for the current table walker value.\n//\n// @param {Number} row\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\n\n\nfunction getSectionName(row, tableAttributes) {\n  return row < tableAttributes.headingRows ? 'thead' : 'tbody';\n} // Creates or returns an existing `<tbody>` or `<thead>` element witch caching.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} viewTable\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} cachedTableSection An object that stores cached elements.\n// @returns {module:engine/view/containerelement~ContainerElement}\n\n\nfunction getOrCreateTableSection(sectionName, viewTable, conversionApi) {\n  var viewTableSection = getExistingTableSectionElement(sectionName, viewTable);\n  return viewTableSection ? viewTableSection : createTableSection(sectionName, viewTable, conversionApi);\n} // Finds an existing `<tbody>` or `<thead>` element or returns undefined.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction getExistingTableSectionElement(sectionName, tableElement) {\n  var _iteratorNormalCompletion9 = true;\n  var _didIteratorError9 = false;\n  var _iteratorError9 = undefined;\n\n  try {\n    for (var _iterator9 = tableElement.getChildren()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n      var tableSection = _step9.value;\n\n      if (tableSection.name == sectionName) {\n        return tableSection;\n      }\n    }\n  } catch (err) {\n    _didIteratorError9 = true;\n    _iteratorError9 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n        _iterator9.return();\n      }\n    } finally {\n      if (_didIteratorError9) {\n        throw _iteratorError9;\n      }\n    }\n  }\n} // Creates a table section at the end of the table.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/containerelement~ContainerElement}\n\n\nfunction createTableSection(sectionName, tableElement, conversionApi) {\n  var tableChildElement = conversionApi.writer.createContainerElement(sectionName);\n  var insertPosition = conversionApi.writer.createPositionAt(tableElement, sectionName == 'tbody' ? 'end' : 0);\n  conversionApi.writer.insert(insertPosition, tableChildElement);\n  return tableChildElement;\n} // Removes an existing `<tbody>` or `<thead>` element if it is empty.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction removeTableSectionIfEmpty(sectionName, tableElement, conversionApi) {\n  var tableSection = getExistingTableSectionElement(sectionName, tableElement);\n\n  if (tableSection && tableSection.childCount === 0) {\n    conversionApi.writer.remove(conversionApi.writer.createRangeOn(tableSection));\n  }\n} // Moves view table rows associated with passed model rows to the provided table section element.\n//\n// **Note** This method will skip not converted table rows.\n//\n// @param {Array.<module:engine/model/element~Element>} rowsToMove\n// @param {module:engine/view/element~Element} viewTableSection\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Number|'end'|'before'|'after'} offset Offset or one of the flags.\n\n\nfunction moveViewRowsToTableSection(rowsToMove, viewTableSection, conversionApi, offset) {\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = rowsToMove[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var tableRow = _step10.value;\n      var viewTableRow = conversionApi.mapper.toViewElement(tableRow); // View table row might be not yet converted - skip it as it will be properly created by cell converter later on.\n\n      if (viewTableRow) {\n        conversionApi.writer.move(conversionApi.writer.createRangeOn(viewTableRow), conversionApi.writer.createPositionAt(viewTableSection, offset));\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n} // Properly finds '<table>' element inside `<figure>` widget.\n//\n// @param {module:engine/view/element~Element} viewFigure\n\n\nfunction getViewTable(viewFigure) {\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = viewFigure.getChildren()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var child = _step11.value;\n\n      if (child.name === 'table') {\n        return child;\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n} // Checks if element has any attribute set.\n//\n// @param {module:engine/model/element~Element element\n// @returns {Boolean}\n\n\nfunction hasAnyAttribute(element) {\n  return !!_toConsumableArray(element.getAttributeKeys()).length;\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/inserttablecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { findOptimalInsertionPosition } from '@ckeditor/ckeditor5-widget/src/utils';\n/**\n * The insert table command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'insertTable'` editor command.\n *\n * To insert a table at the current selection, execute the command and specify the dimensions:\n *\n *\t\teditor.execute( 'insertTable', { rows: 20, columns: 5 } );\n *\n * @extends module:core/command~Command\n */\n\nvar InsertTableCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(InsertTableCommand, _Command);\n\n  function InsertTableCommand() {\n    _classCallCheck(this, InsertTableCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(InsertTableCommand).apply(this, arguments));\n  }\n\n  _createClass(InsertTableCommand, [{\n    key: \"refresh\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      var model = this.editor.model;\n      var selection = model.document.selection;\n      var schema = model.schema;\n      var validParent = getInsertTableParent(selection.getFirstPosition());\n      this.isEnabled = schema.checkChild(validParent, 'table');\n    }\n    /**\n     * Executes the command.\n     *\n     * Inserts a table with the given number of rows and columns into the editor.\n     *\n     * @param {Object} options\n     * @param {Number} [options.rows=2] The number of rows to create in the inserted table.\n     * @param {Number} [options.columns=2] The number of columns to create in the inserted table.\n     * @fires execute\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var model = this.editor.model;\n      var selection = model.document.selection;\n      var tableUtils = this.editor.plugins.get('TableUtils');\n      var rows = parseInt(options.rows) || 2;\n      var columns = parseInt(options.columns) || 2;\n      var insertPosition = findOptimalInsertionPosition(selection, model);\n      model.change(function (writer) {\n        var table = tableUtils.createTable(writer, rows, columns);\n        model.insertContent(table, insertPosition);\n        writer.setSelection(writer.createPositionAt(table.getNodeByPath([0, 0, 0]), 0));\n      });\n    }\n  }]);\n\n  return InsertTableCommand;\n}(Command); // Returns valid parent to insert table\n//\n// @param {module:engine/model/position} position\n\n\nexport { InsertTableCommand as default };\n\nfunction getInsertTableParent(position) {\n  var parent = position.parent;\n  return parent === parent.root ? parent : parent.parent;\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/insertrowcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { findAncestor } from \"./utils\";\n/**\n * The insert row command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'insertTableRowBelow'` and\n * `'insertTableRowAbove'` editor commands.\n *\n * To insert a row below the selected cell, execute the following command:\n *\n *\t\teditor.execute( 'insertTableRowBelow' );\n *\n * To insert a row above the selected cell, execute the following command:\n *\n *\t\teditor.execute( 'insertTableRowAbove' );\n *\n * @extends module:core/command~Command\n */\n\nvar InsertRowCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(InsertRowCommand, _Command);\n\n  /**\n   * Creates a new `InsertRowCommand` instance.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor on which this command will be used.\n   * @param {Object} options\n   * @param {String} [options.order=\"below\"] The order of insertion relative to the row in which the caret is located.\n   * Possible values: `\"above\"` and `\"below\"`.\n   */\n  function InsertRowCommand(editor) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, InsertRowCommand);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InsertRowCommand).call(this, editor));\n    /**\n     * The order of insertion relative to the row in which the caret is located.\n     *\n     * @readonly\n     * @member {String} module:table/commands/insertrowcommand~InsertRowCommand#order\n     */\n\n    _this.order = options.order || 'below';\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(InsertRowCommand, [{\n    key: \"refresh\",\n    value: function refresh() {\n      var selection = this.editor.model.document.selection;\n      var tableParent = findAncestor('table', selection.getFirstPosition());\n      this.isEnabled = !!tableParent;\n    }\n    /**\n     * Executes the command.\n     *\n     * Depending on the command's {@link #order} value, it inserts a row `'below'` or `'above'` the row in which selection is set.\n     *\n     * @fires execute\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var editor = this.editor;\n      var selection = editor.model.document.selection;\n      var tableUtils = editor.plugins.get('TableUtils');\n      var tableCell = findAncestor('tableCell', selection.getFirstPosition());\n      var tableRow = tableCell.parent;\n      var table = tableRow.parent;\n      var row = table.getChildIndex(tableRow);\n      var insertAt = this.order === 'below' ? row + 1 : row;\n      tableUtils.insertRows(table, {\n        rows: 1,\n        at: insertAt\n      });\n    }\n  }]);\n\n  return InsertRowCommand;\n}(Command);\n\nexport { InsertRowCommand as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.find\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/mergecellcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport TableWalker from \"../tablewalker\";\nimport { findAncestor, updateNumericAttribute } from \"./utils\";\n/**\n * The merge cell command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'mergeTableCellRight'`, `'mergeTableCellLeft'`,\n * `'mergeTableCellUp'` and `'mergeTableCellDown'` editor commands.\n *\n * To merge a table cell at the current selection with another cell, execute the command corresponding with the preferred direction.\n *\n * For example, to merge with a cell to the right:\n *\n *\t\teditor.execute( 'mergeTableCellRight' );\n *\n * **Note**: If a table cell has a different [`rowspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-rowspan)\n * (for `'mergeTableCellRight'` and `'mergeTableCellLeft'`) or [`colspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-colspan)\n * (for `'mergeTableCellUp'` and `'mergeTableCellDown'`), the command will be disabled.\n *\n * @extends module:core/command~Command\n */\n\nvar MergeCellCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(MergeCellCommand, _Command);\n\n  /**\n   * Creates a new `MergeCellCommand` instance.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor on which this command will be used.\n   * @param {Object} options\n   * @param {String} options.direction Indicates which cell to merge with the currently selected one.\n   * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.\n   */\n  function MergeCellCommand(editor, options) {\n    var _this;\n\n    _classCallCheck(this, MergeCellCommand);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MergeCellCommand).call(this, editor));\n    /**\n     * The direction that indicates which cell will be merged with the currently selected one.\n     *\n     * @readonly\n     * @member {String} #direction\n     */\n\n    _this.direction = options.direction;\n    /**\n     * Whether the merge is horizontal (left/right) or vertical (up/down).\n     *\n     * @readonly\n     * @member {Boolean} #isHorizontal\n     */\n\n    _this.isHorizontal = _this.direction == 'right' || _this.direction == 'left';\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(MergeCellCommand, [{\n    key: \"refresh\",\n    value: function refresh() {\n      var cellToMerge = this._getMergeableCell();\n\n      this.isEnabled = !!cellToMerge; // In order to check if currently selected cell can be merged with one defined by #direction some computation are done beforehand.\n      // As such we can cache it as a command's value.\n\n      this.value = cellToMerge;\n    }\n    /**\n     * Executes the command.\n     *\n     * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.\n     *\n     * @fires execute\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this2 = this;\n\n      var model = this.editor.model;\n      var doc = model.document;\n      var tableCell = findAncestor('tableCell', doc.selection.getFirstPosition());\n      var cellToMerge = this.value;\n      var direction = this.direction;\n      model.change(function (writer) {\n        var isMergeNext = direction == 'right' || direction == 'down'; // The merge mechanism is always the same so sort cells to be merged.\n\n        var cellToExpand = isMergeNext ? tableCell : cellToMerge;\n        var cellToRemove = isMergeNext ? cellToMerge : tableCell; // Cache the parent of cell to remove for later check.\n\n        var removedTableCellRow = cellToRemove.parent;\n        mergeTableCells(cellToRemove, cellToExpand, writer);\n        var spanAttribute = _this2.isHorizontal ? 'colspan' : 'rowspan';\n        var cellSpan = parseInt(tableCell.getAttribute(spanAttribute) || 1);\n        var cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || 1); // Update table cell span attribute and merge set selection on merged contents.\n\n        writer.setAttribute(spanAttribute, cellSpan + cellToMergeSpan, cellToExpand);\n        writer.setSelection(writer.createRangeIn(cellToExpand)); // Remove empty row after merging.\n\n        if (!removedTableCellRow.childCount) {\n          removeEmptyRow(removedTableCellRow, writer);\n        }\n      });\n    }\n    /**\n     * Returns a cell that can be merged with the current cell depending on the command's direction.\n     *\n     * @returns {module:engine/model/element|undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_getMergeableCell\",\n    value: function _getMergeableCell() {\n      var model = this.editor.model;\n      var doc = model.document;\n      var tableCell = findAncestor('tableCell', doc.selection.getFirstPosition());\n\n      if (!tableCell) {\n        return;\n      }\n\n      var tableUtils = this.editor.plugins.get('TableUtils'); // First get the cell on proper direction.\n\n      var cellToMerge = this.isHorizontal ? getHorizontalCell(tableCell, this.direction, tableUtils) : getVerticalCell(tableCell, this.direction);\n\n      if (!cellToMerge) {\n        return;\n      } // If found check if the span perpendicular to merge direction is equal on both cells.\n\n\n      var spanAttribute = this.isHorizontal ? 'rowspan' : 'colspan';\n      var span = parseInt(tableCell.getAttribute(spanAttribute) || 1);\n      var cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || 1);\n\n      if (cellToMergeSpan === span) {\n        return cellToMerge;\n      }\n    }\n  }]);\n\n  return MergeCellCommand;\n}(Command); // Returns the cell that can be merged horizontally.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @returns {module:engine/model/node~Node|null}\n\n\nexport { MergeCellCommand as default };\n\nfunction getHorizontalCell(tableCell, direction, tableUtils) {\n  var horizontalCell = direction == 'right' ? tableCell.nextSibling : tableCell.previousSibling;\n\n  if (!horizontalCell) {\n    return;\n  } // Sort cells:\n\n\n  var cellOnLeft = direction == 'right' ? tableCell : horizontalCell;\n  var cellOnRight = direction == 'right' ? horizontalCell : tableCell; // Get their column indexes:\n\n  var _tableUtils$getCellLo = tableUtils.getCellLocation(cellOnLeft),\n      leftCellColumn = _tableUtils$getCellLo.column;\n\n  var _tableUtils$getCellLo2 = tableUtils.getCellLocation(cellOnRight),\n      rightCellColumn = _tableUtils$getCellLo2.column;\n\n  var leftCellSpan = parseInt(cellOnLeft.getAttribute('colspan') || 1); // The cell on the right must have index that is distant to the cell on the left by the left cell's width (colspan).\n\n  var cellsAreTouching = leftCellColumn + leftCellSpan === rightCellColumn; // If the right cell's column index is different it means that there are rowspanned cells between them.\n\n  return cellsAreTouching ? horizontalCell : undefined;\n} // Returns the cell that can be merged vertically.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @returns {module:engine/model/node~Node|null}\n\n\nfunction getVerticalCell(tableCell, direction) {\n  var tableRow = tableCell.parent;\n  var table = tableRow.parent;\n  var rowIndex = table.getChildIndex(tableRow); // Don't search for mergeable cell if direction points out of the table.\n\n  if (direction == 'down' && rowIndex === table.childCount - 1 || direction == 'up' && rowIndex === 0) {\n    return;\n  }\n\n  var rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n  var headingRows = table.getAttribute('headingRows') || 0;\n  var isMergeWithBodyCell = direction == 'down' && rowIndex + rowspan === headingRows;\n  var isMergeWithHeadCell = direction == 'up' && rowIndex === headingRows; // Don't search for mergeable cell if direction points out of the current table section.\n\n  if (headingRows && (isMergeWithBodyCell || isMergeWithHeadCell)) {\n    return;\n  }\n\n  var currentCellRowSpan = parseInt(tableCell.getAttribute('rowspan') || 1);\n  var rowOfCellToMerge = direction == 'down' ? rowIndex + currentCellRowSpan : rowIndex;\n\n  var tableMap = _toConsumableArray(new TableWalker(table, {\n    endRow: rowOfCellToMerge\n  }));\n\n  var currentCellData = tableMap.find(function (value) {\n    return value.cell === tableCell;\n  });\n  var mergeColumn = currentCellData.column;\n  var cellToMergeData = tableMap.find(function (_ref) {\n    var row = _ref.row,\n        rowspan = _ref.rowspan,\n        column = _ref.column;\n\n    if (column !== mergeColumn) {\n      return false;\n    }\n\n    if (direction == 'down') {\n      // If merging a cell below the mergeRow is already calculated.\n      return row === rowOfCellToMerge;\n    } else {\n      // If merging a cell above calculate if it spans to mergeRow.\n      return rowOfCellToMerge === row + rowspan;\n    }\n  });\n  return cellToMergeData && cellToMergeData.cell;\n} // Properly removes empty row from a table. Will update `rowspan` attribute of cells that overlaps removed row.\n//\n// @param {module:engine/model/element~Element} removedTableCellRow\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction removeEmptyRow(removedTableCellRow, writer) {\n  var table = removedTableCellRow.parent;\n  var removedRowIndex = table.getChildIndex(removedTableCellRow);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = new TableWalker(table, {\n      endRow: removedRowIndex\n    })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _step$value = _step.value,\n          cell = _step$value.cell,\n          row = _step$value.row,\n          rowspan = _step$value.rowspan;\n      var overlapsRemovedRow = row + rowspan - 1 >= removedRowIndex;\n\n      if (overlapsRemovedRow) {\n        updateNumericAttribute('rowspan', rowspan - 1, cell, writer);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  writer.remove(removedTableCellRow);\n} // Merges two table cells - will ensure that after merging cells with empty paragraph the result table cell will only have one paragraph.\n// If one of the merged table cell is empty the merged table cell will have contents of the non-empty table cell.\n// If both are empty the merged table cell will have only one empty paragraph.\n//\n// @param {module:engine/model/element~Element} cellToRemove\n// @param {module:engine/model/element~Element} cellToExpand\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction mergeTableCells(cellToRemove, cellToExpand, writer) {\n  if (!isEmpty(cellToRemove)) {\n    if (isEmpty(cellToExpand)) {\n      writer.remove(writer.createRangeIn(cellToExpand));\n    }\n\n    writer.move(writer.createRangeIn(cellToRemove), writer.createPositionAt(cellToExpand, 'end'));\n  } // Remove merged table cell.\n\n\n  writer.remove(cellToRemove);\n} // Checks if passed table cell contains empty paragraph.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @returns {Boolean}\n\n\nfunction isEmpty(tableCell) {\n  return tableCell.childCount == 1 && tableCell.getChild(0).is('paragraph') && tableCell.getChild(0).isEmpty;\n}","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/removerowcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport TableWalker from \"../tablewalker\";\nimport { findAncestor, updateNumericAttribute } from \"./utils\";\n/**\n * The remove row command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'removeTableRow'` editor command.\n *\n * To remove the row containing the selected cell, execute the command:\n *\n *\t\teditor.execute( 'removeTableRow' );\n *\n * @extends module:core/command~Command\n */\n\nvar RemoveRowCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(RemoveRowCommand, _Command);\n\n  function RemoveRowCommand() {\n    _classCallCheck(this, RemoveRowCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RemoveRowCommand).apply(this, arguments));\n  }\n\n  _createClass(RemoveRowCommand, [{\n    key: \"refresh\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      var model = this.editor.model;\n      var doc = model.document;\n      var tableCell = findAncestor('tableCell', doc.selection.getFirstPosition());\n      this.isEnabled = !!tableCell && tableCell.parent.parent.childCount > 1;\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var model = this.editor.model;\n      var selection = model.document.selection;\n      var firstPosition = selection.getFirstPosition();\n      var tableCell = findAncestor('tableCell', firstPosition);\n      var tableRow = tableCell.parent;\n      var table = tableRow.parent;\n      var currentRow = table.getChildIndex(tableRow);\n      var headingRows = table.getAttribute('headingRows') || 0;\n      model.change(function (writer) {\n        if (headingRows && currentRow <= headingRows) {\n          updateNumericAttribute('headingRows', headingRows - 1, table, writer, 0);\n        }\n\n        var tableMap = _toConsumableArray(new TableWalker(table, {\n          endRow: currentRow\n        }));\n\n        var cellsToMove = new Map(); // Get cells from removed row that are spanned over multiple rows.\n\n        tableMap.filter(function (_ref) {\n          var row = _ref.row,\n              rowspan = _ref.rowspan;\n          return row === currentRow && rowspan > 1;\n        }).forEach(function (_ref2) {\n          var column = _ref2.column,\n              cell = _ref2.cell,\n              rowspan = _ref2.rowspan;\n          return cellsToMove.set(column, {\n            cell: cell,\n            rowspanToSet: rowspan - 1\n          });\n        }); // Reduce rowspan on cells that are above removed row and overlaps removed row.\n\n        tableMap.filter(function (_ref3) {\n          var row = _ref3.row,\n              rowspan = _ref3.rowspan;\n          return row <= currentRow - 1 && row + rowspan > currentRow;\n        }).forEach(function (_ref4) {\n          var cell = _ref4.cell,\n              rowspan = _ref4.rowspan;\n          return updateNumericAttribute('rowspan', rowspan - 1, cell, writer);\n        }); // Move cells to another row.\n\n        var targetRow = currentRow + 1;\n        var tableWalker = new TableWalker(table, {\n          includeSpanned: true,\n          startRow: targetRow,\n          endRow: targetRow\n        });\n        var previousCell;\n\n        for (var _i = 0, _arr = _toConsumableArray(tableWalker); _i < _arr.length; _i++) {\n          var _arr$_i = _arr[_i],\n              row = _arr$_i.row,\n              column = _arr$_i.column,\n              cell = _arr$_i.cell;\n\n          if (cellsToMove.has(column)) {\n            var _cellsToMove$get = cellsToMove.get(column),\n                cellToMove = _cellsToMove$get.cell,\n                rowspanToSet = _cellsToMove$get.rowspanToSet;\n\n            var targetPosition = previousCell ? writer.createPositionAfter(previousCell) : writer.createPositionAt(table.getChild(row), 0);\n            writer.move(writer.createRangeOn(cellToMove), targetPosition);\n            updateNumericAttribute('rowspan', rowspanToSet, cellToMove, writer);\n            previousCell = cellToMove;\n          } else {\n            previousCell = cell;\n          }\n        }\n\n        writer.remove(tableRow);\n      });\n    }\n  }]);\n\n  return RemoveRowCommand;\n}(Command);\n\nexport { RemoveRowCommand as default };","import _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/setheaderrowcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { createEmptyTableCell, findAncestor, updateNumericAttribute } from \"./utils\";\nimport TableWalker from \"../tablewalker\";\n/**\n * The header row command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'setTableColumnHeader'` editor command.\n *\n * You can make the row containing the selected cell a [header](https://www.w3.org/TR/html50/tabular-data.html#the-th-element) by executing:\n *\n *\t\teditor.execute( 'setTableRowHeader' );\n *\n * **Note:** All preceding rows will also become headers. If the current row is already a header, executing this command\n * will make it a regular row back again (including the following rows).\n *\n * @extends module:core/command~Command\n */\n\nvar SetHeaderRowCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(SetHeaderRowCommand, _Command);\n\n  function SetHeaderRowCommand() {\n    _classCallCheck(this, SetHeaderRowCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SetHeaderRowCommand).apply(this, arguments));\n  }\n\n  _createClass(SetHeaderRowCommand, [{\n    key: \"refresh\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      var model = this.editor.model;\n      var doc = model.document;\n      var selection = doc.selection;\n      var position = selection.getFirstPosition();\n      var tableCell = findAncestor('tableCell', position);\n      var isInTable = !!tableCell;\n      this.isEnabled = isInTable;\n      /**\n       * Flag indicating whether the command is active. The command is active when the\n       * {@link module:engine/model/selection~Selection} is in a header row.\n       *\n       * @observable\n       * @readonly\n       * @member {Boolean} #value\n       */\n\n      this.value = isInTable && this._isInHeading(tableCell, tableCell.parent.parent);\n    }\n    /**\n     * Executes the command.\n     *\n     * When the selection is in a non-header row, the command will set the `headingRows` table attribute to cover that row.\n     *\n     * When the selection is already in a header row, it will set `headingRows` so the heading section will end before that row.\n     *\n     * @fires execute\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var model = this.editor.model;\n      var doc = model.document;\n      var selection = doc.selection;\n      var position = selection.getFirstPosition();\n      var tableCell = findAncestor('tableCell', position);\n      var tableRow = tableCell.parent;\n      var table = tableRow.parent;\n      var currentHeadingRows = table.getAttribute('headingRows') || 0;\n      var selectionRow = tableRow.index;\n      var headingRowsToSet = currentHeadingRows > selectionRow ? selectionRow : selectionRow + 1;\n      model.change(function (writer) {\n        if (headingRowsToSet) {\n          // Changing heading rows requires to check if any of a heading cell is overlapping vertically the table head.\n          // Any table cell that has a rowspan attribute > 1 will not exceed the table head so we need to fix it in rows below.\n          var cellsToSplit = getOverlappingCells(table, headingRowsToSet, currentHeadingRows);\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = cellsToSplit[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var cell = _step.value;\n              splitHorizontally(cell, headingRowsToSet, writer);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        updateNumericAttribute('headingRows', headingRowsToSet, table, writer, 0);\n      });\n    }\n    /**\n     * Checks if a table cell is in the heading section.\n     *\n     * @param {module:engine/model/element~Element} tableCell\n     * @param {module:engine/model/element~Element} table\n     * @returns {Boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_isInHeading\",\n    value: function _isInHeading(tableCell, table) {\n      var headingRows = parseInt(table.getAttribute('headingRows') || 0);\n      return !!headingRows && tableCell.parent.index < headingRows;\n    }\n  }]);\n\n  return SetHeaderRowCommand;\n}(Command); // Returns cells that span beyond the new heading section.\n//\n// @param {module:engine/model/element~Element} table The table to check.\n// @param {Number} headingRowsToSet New heading rows attribute.\n// @param {Number} currentHeadingRows Current heading rows attribute.\n// @returns {Array.<module:engine/model/element~Element>}\n\n\nexport { SetHeaderRowCommand as default };\n\nfunction getOverlappingCells(table, headingRowsToSet, currentHeadingRows) {\n  var cellsToSplit = [];\n  var startAnalysisRow = headingRowsToSet > currentHeadingRows ? currentHeadingRows : 0; // We're analyzing only when headingRowsToSet > 0.\n\n  var endAnalysisRow = headingRowsToSet - 1;\n  var tableWalker = new TableWalker(table, {\n    startRow: startAnalysisRow,\n    endRow: endAnalysisRow\n  });\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = tableWalker[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _step2$value = _step2.value,\n          row = _step2$value.row,\n          rowspan = _step2$value.rowspan,\n          cell = _step2$value.cell;\n\n      if (rowspan > 1 && row + rowspan > headingRowsToSet) {\n        cellsToSplit.push(cell);\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return cellsToSplit;\n} // Splits the table cell horizontally.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {Number} headingRows\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction splitHorizontally(tableCell, headingRows, writer) {\n  var tableRow = tableCell.parent;\n  var table = tableRow.parent;\n  var rowIndex = tableRow.index;\n  var rowspan = parseInt(tableCell.getAttribute('rowspan'));\n  var newRowspan = headingRows - rowIndex;\n  var attributes = {};\n  var spanToSet = rowspan - newRowspan;\n\n  if (spanToSet > 1) {\n    attributes.rowspan = spanToSet;\n  }\n\n  var startRow = table.getChildIndex(tableRow);\n  var endRow = startRow + newRowspan;\n\n  var tableMap = _toConsumableArray(new TableWalker(table, {\n    startRow: startRow,\n    endRow: endRow,\n    includeSpanned: true\n  }));\n\n  var columnIndex;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = tableMap[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _step3$value = _step3.value,\n          row = _step3$value.row,\n          column = _step3$value.column,\n          cell = _step3$value.cell,\n          colspan = _step3$value.colspan,\n          cellIndex = _step3$value.cellIndex;\n\n      if (cell === tableCell) {\n        columnIndex = column;\n\n        if (colspan > 1) {\n          attributes.colspan = colspan;\n        }\n      }\n\n      if (columnIndex !== undefined && columnIndex === column && row === endRow) {\n        var _tableRow = table.getChild(row);\n\n        var tableCellPosition = writer.createPositionAt(_tableRow, cellIndex);\n        createEmptyTableCell(writer, tableCellPosition, attributes);\n      }\n    } // Update the rowspan attribute after updating table.\n\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  updateNumericAttribute('rowspan', newRowspan, tableCell, writer);\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/setheadercolumncommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { findAncestor, updateNumericAttribute } from \"./utils\";\n/**\n * The header column command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'setTableColumnHeader'` editor command.\n *\n * You can make the column containing the selected cell a [header](https://www.w3.org/TR/html50/tabular-data.html#the-th-element)\n * by executing:\n *\n *\t\teditor.execute( 'setTableColumnHeader' );\n *\n * **Note:** All preceding columns will also become headers. If the current column is already a header, executing this command\n * will make it a regular column back again (including the following columns).\n *\n * @extends module:core/command~Command\n */\n\nvar SetHeaderColumnCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(SetHeaderColumnCommand, _Command);\n\n  function SetHeaderColumnCommand() {\n    _classCallCheck(this, SetHeaderColumnCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SetHeaderColumnCommand).apply(this, arguments));\n  }\n\n  _createClass(SetHeaderColumnCommand, [{\n    key: \"refresh\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      var model = this.editor.model;\n      var doc = model.document;\n      var selection = doc.selection;\n      var position = selection.getFirstPosition();\n      var tableCell = findAncestor('tableCell', position);\n      var isInTable = !!tableCell;\n      this.isEnabled = isInTable;\n      /**\n       * Flag indicating whether the command is active. The command is active when the\n       * {@link module:engine/model/selection~Selection} is in a header column.\n       *\n       * @observable\n       * @readonly\n       * @member {Boolean} #value\n       */\n\n      this.value = isInTable && this._isInHeading(tableCell, tableCell.parent.parent);\n    }\n    /**\n     * Executes the command.\n     *\n     * When the selection is in a non-header column, the command will set the `headingColumns` table attribute to cover that column.\n     *\n     * When the selection is already in a header column, it will set `headingColumns` so the heading section will end before that column.\n     *\n     * @fires execute\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var model = this.editor.model;\n      var doc = model.document;\n      var selection = doc.selection;\n      var tableUtils = this.editor.plugins.get('TableUtils');\n      var position = selection.getFirstPosition();\n      var tableCell = findAncestor('tableCell', position.parent);\n      var tableRow = tableCell.parent;\n      var table = tableRow.parent;\n      var currentHeadingColumns = parseInt(table.getAttribute('headingColumns') || 0);\n\n      var _tableUtils$getCellLo = tableUtils.getCellLocation(tableCell),\n          selectionColumn = _tableUtils$getCellLo.column;\n\n      var headingColumnsToSet = currentHeadingColumns > selectionColumn ? selectionColumn : selectionColumn + 1;\n      model.change(function (writer) {\n        updateNumericAttribute('headingColumns', headingColumnsToSet, table, writer, 0);\n      });\n    }\n    /**\n     * Checks if a table cell is in the heading section.\n     *\n     * @param {module:engine/model/element~Element} tableCell\n     * @param {module:engine/model/element~Element} table\n     * @returns {Boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_isInHeading\",\n    value: function _isInHeading(tableCell, table) {\n      var headingColumns = parseInt(table.getAttribute('headingColumns') || 0);\n      var tableUtils = this.editor.plugins.get('TableUtils');\n\n      var _tableUtils$getCellLo2 = tableUtils.getCellLocation(tableCell),\n          column = _tableUtils$getCellLo2.column;\n\n      return !!headingColumns && column < headingColumns;\n    }\n  }]);\n\n  return SetHeaderColumnCommand;\n}(Command);\n\nexport { SetHeaderColumnCommand as default };","import \"core-js/modules/es6.array.find\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableutils\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport TableWalker from \"./tablewalker\";\nimport { createEmptyTableCell, updateNumericAttribute } from \"./commands/utils\";\n/**\n * The table utilities plugin.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar TableUtils =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(TableUtils, _Plugin);\n\n  function TableUtils() {\n    _classCallCheck(this, TableUtils);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TableUtils).apply(this, arguments));\n  }\n\n  _createClass(TableUtils, [{\n    key: \"getCellLocation\",\n\n    /**\n     * Returns the table cell location as an object with table row and table column indexes.\n     *\n     * For instance in the table below:\n     *\n     *\t\t    0   1   2   3\n     *\t\t  +---+---+---+---+\n     *\t\t0 | a     | b | c |\n     *\t\t  +       +   +---+\n     *\t\t1 |       |   | d |\n     *\t\t  +---+---+   +---+\n     *\t\t2 | e     |   | f |\n     *\t\t  +---+---+---+---+\n     *\n     * the method will return:\n     *\n     *\t\tconst cellA = table.getNodeByPath( [ 0, 0 ] );\n     *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellA );\n     *\t\t// will return { row: 0, column: 0 }\n     *\n     *\t\tconst cellD = table.getNodeByPath( [ 1, 0 ] );\n     *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellD );\n     *\t\t// will return { row: 1, column: 3 }\n     *\n     * @param {module:engine/model/element~Element} tableCell\n     * @returns {Object} Returns a `{row, column}` object.\n     */\n    value: function getCellLocation(tableCell) {\n      var tableRow = tableCell.parent;\n      var table = tableRow.parent;\n      var rowIndex = table.getChildIndex(tableRow);\n      var tableWalker = new TableWalker(table, {\n        startRow: rowIndex,\n        endRow: rowIndex\n      });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = tableWalker[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _step.value,\n              cell = _step$value.cell,\n              row = _step$value.row,\n              column = _step$value.column;\n\n          if (cell === tableCell) {\n            return {\n              row: row,\n              column: column\n            };\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Creates an empty table with proper structure. The table needs to be inserted into the model,\n     * ie. using {@link module:engine/model/model~Model#insertContent} function.\n     *\n     *\t\tmodel.change( ( writer ) => {\n     *\t\t\t// Create a table of 2 rows and 7 columns:\n     *\t\t\tconst table = tableUtils.createTable( writer, 2, 7);\n     *\n     *\t\t\t// Insert table to the model at the best position taking current selection:\n     *\t\t\tmodel.insertContent( table );\n     *\t\t}\n     *\n     * @param {module:engine/model/writer~Writer} writer The model writer.\n     * @param {Number} rows The number of rows to create.\n     * @param {Number} columns The number of columns to create.\n     * @returns {module:engine/model/element~Element} The created table element.\n     */\n\n  }, {\n    key: \"createTable\",\n    value: function createTable(writer, rows, columns) {\n      var table = writer.createElement('table');\n      createEmptyRows(writer, table, 0, rows, columns);\n      return table;\n    }\n    /**\n     * Inserts rows into a table.\n     *\n     *\t\teditor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );\n     *\n     * Assuming the table on the left, the above code will transform it to the table on the right:\n     *\n     *\t\trow index\n     *\t\t  0 +---+---+---+       `at` = 1,      +---+---+---+ 0\n     *\t\t    | a | b | c |       `rows` = 2,    | a | b | c |\n     *\t\t  1 +   +---+---+   <-- insert here    +   +---+---+ 1\n     *\t\t    |   | d | e |                      |   |   |   |\n     *\t\t  2 +   +---+---+       will give:     +   +---+---+ 2\n     *\t\t    |   | f | g |                      |   |   |   |\n     *\t\t  3 +---+---+---+                      +   +---+---+ 3\n     *\t\t                                       |   | d | e |\n     *\t\t                                       +---+---+---+ 4\n     *\t\t                                       +   + f | g |\n     *\t\t                                       +---+---+---+ 5\n     *\n     * @param {module:engine/model/element~Element} table The table model element where the rows will be inserted.\n     * @param {Object} options\n     * @param {Number} [options.at=0] Row index at which the rows will be inserted.\n     * @param {Number} [options.rows=1] The number of rows to insert.\n     */\n\n  }, {\n    key: \"insertRows\",\n    value: function insertRows(table) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var model = this.editor.model;\n      var insertAt = options.at || 0;\n      var rowsToInsert = options.rows || 1;\n      model.change(function (writer) {\n        var headingRows = table.getAttribute('headingRows') || 0; // Inserting rows inside heading section requires to update `headingRows` attribute as the heading section will grow.\n\n        if (headingRows > insertAt) {\n          writer.setAttribute('headingRows', headingRows + rowsToInsert, table);\n        } // Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\n\n        if (insertAt === 0 || insertAt === table.childCount) {\n          createEmptyRows(writer, table, insertAt, rowsToInsert, _this.getColumns(table));\n          return;\n        } // Iterate over all rows above inserted rows in order to check for rowspanned cells.\n\n\n        var tableIterator = new TableWalker(table, {\n          endRow: insertAt\n        }); // Will hold number of cells needed to insert in created rows.\n        // The number might be different then table cell width when there are rowspanned cells.\n\n        var cellsToInsert = 0;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = tableIterator[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _step2$value = _step2.value,\n                row = _step2$value.row,\n                rowspan = _step2$value.rowspan,\n                colspan = _step2$value.colspan,\n                cell = _step2$value.cell;\n            var isBeforeInsertedRow = row < insertAt;\n            var overlapsInsertedRow = row + rowspan > insertAt;\n\n            if (isBeforeInsertedRow && overlapsInsertedRow) {\n              // This cell overlaps inserted rows so we need to expand it further.\n              writer.setAttribute('rowspan', rowspan + rowsToInsert, cell);\n            } // Calculate how many cells to insert based on the width of cells in a row at insert position.\n            // It might be lower then table width as some cells might overlaps inserted row.\n            // In the table above the cell 'a' overlaps inserted row so only two empty cells are need to be created.\n\n\n            if (row === insertAt) {\n              cellsToInsert += colspan;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        createEmptyRows(writer, table, insertAt, rowsToInsert, cellsToInsert);\n      });\n    }\n    /**\n     * Inserts columns into a table.\n     *\n     *\t\teditor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );\n     *\n     * Assuming the table on the left, the above code will transform it to the table on the right:\n     *\n     *\t\t0   1   2   3                   0   1   2   3   4   5\n     *\t\t+---+---+---+                   +---+---+---+---+---+\n     *\t\t| a     | b |                   | a             | b |\n     *\t\t+       +---+                   +               +---+\n     *\t\t|       | c |                   |               | c |\n     *\t\t+---+---+---+     will give:    +---+---+---+---+---+\n     *\t\t| d | e | f |                   | d |   |   | e | f |\n     *\t\t+---+   +---+                   +---+---+---+  +---+\n     *\t\t| g |   | h |                   | g |   |   |   | h |\n     *\t\t+---+---+---+                   +---+---+---+---+---+\n     *\t\t| i         |                   | i                 |\n     *\t\t+---+---+---+                   +---+---+---+---+---+\n     *\t\t    ^---- insert here, `at` = 1, `columns` = 2\n     *\n     * @param {module:engine/model/element~Element} table The table model element where the columns will be inserted.\n     * @param {Object} options\n     * @param {Number} [options.at=0] Column index at which the columns will be inserted.\n     * @param {Number} [options.columns=1] The number of columns to insert.\n     */\n\n  }, {\n    key: \"insertColumns\",\n    value: function insertColumns(table) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var model = this.editor.model;\n      var insertAt = options.at || 0;\n      var columnsToInsert = options.columns || 1;\n      model.change(function (writer) {\n        var headingColumns = table.getAttribute('headingColumns'); // Inserting columns inside heading section requires to update `headingColumns` attribute as the heading section will grow.\n\n        if (insertAt < headingColumns) {\n          writer.setAttribute('headingColumns', headingColumns + columnsToInsert, table);\n        }\n\n        var tableColumns = _this2.getColumns(table); // Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\n\n        if (insertAt === 0 || tableColumns === insertAt) {\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = table.getChildren()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var tableRow = _step3.value;\n              createCells(columnsToInsert, writer, writer.createPositionAt(tableRow, insertAt ? 'end' : 0));\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n\n          return;\n        }\n\n        var tableWalker = new TableWalker(table, {\n          column: insertAt,\n          includeSpanned: true\n        });\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = tableWalker[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _step4$value = _step4.value,\n                row = _step4$value.row,\n                column = _step4$value.column,\n                cell = _step4$value.cell,\n                colspan = _step4$value.colspan,\n                rowspan = _step4$value.rowspan,\n                cellIndex = _step4$value.cellIndex;\n\n            // When iterating over column the table walker outputs either:\n            // - cells at given column index (cell \"e\" from method docs),\n            // - spanned columns (spanned cell from row between cells \"g\" and \"h\" - spanned by \"e\", only if `includeSpanned: true`),\n            // - or a cell from the same row which spans over this column (cell \"a\").\n            if (column !== insertAt) {\n              // If column is different than `insertAt`, it is a cell that spans over an inserted column (cell \"a\" & \"i\").\n              // For such cells expand them by a number of columns inserted.\n              writer.setAttribute('colspan', colspan + columnsToInsert, cell); // The `includeSpanned` option will output the \"empty\"/spanned column so skip this row already.\n\n              tableWalker.skipRow(row); // This cell will overlap cells in rows below so skip them also (because of `includeSpanned` option) - (cell \"a\")\n\n              if (rowspan > 1) {\n                for (var i = row + 1; i < row + rowspan; i++) {\n                  tableWalker.skipRow(i);\n                }\n              }\n            } else {\n              // It's either cell at this column index or spanned cell by a rowspanned cell from row above.\n              // In table above it's cell \"e\" and a spanned position from row below (empty cell between cells \"g\" and \"h\")\n              var insertPosition = writer.createPositionAt(table.getChild(row), cellIndex);\n              createCells(columnsToInsert, writer, insertPosition);\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Divides a table cell vertically into several ones.\n     *\n     * The cell will be visually split into more cells by updating colspans of other cells in a column\n     * and inserting cells (columns) after that cell.\n     *\n     * In the table below, if cell \"a\" is split to 3 cells:\n     *\n     *\t\t+---+---+---+\n     *\t\t| a | b | c |\n     *\t\t+---+---+---+\n     *\t\t| d | e | f |\n     *\t\t+---+---+---+\n     *\n     * it will result in the table below:\n     *\n     *\t\t+---+---+---+---+---+\n     *\t\t| a |   |   | b | c |\n     *\t\t+---+---+---+---+---+\n     *\t\t| d         | e | f |\n     *\t\t+---+---+---+---+---+\n     *\n     * So cell \"d\" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).\n     *\n     * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder\n     * will be left to the original cell:\n     *\n     *\t\t+---+---+---+\n     *\t\t| a         |\n     *\t\t+---+---+---+\n     *\t\t| b | c | d |\n     *\t\t+---+---+---+\n     *\n     * Splitting cell \"a\" with `colspan=3` to 2 cells will create 1 cell with a `colspan=a` and cell \"a\" that will have `colspan=2`:\n     *\n     *\t\t+---+---+---+\n     *\t\t| a     |   |\n     *\t\t+---+---+---+\n     *\t\t| b | c | d |\n     *\t\t+---+---+---+\n     *\n     * @param {module:engine/model/element~Element} tableCell\n     * @param {Number} numberOfCells\n     */\n\n  }, {\n    key: \"splitCellVertically\",\n    value: function splitCellVertically(tableCell) {\n      var numberOfCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var model = this.editor.model;\n      var tableRow = tableCell.parent;\n      var table = tableRow.parent;\n      var rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n      var colspan = parseInt(tableCell.getAttribute('colspan') || 1);\n      model.change(function (writer) {\n        // First check - the cell spans over multiple rows so before doing anything else just split this cell.\n        if (colspan > 1) {\n          // Get spans of new (inserted) cells and span to update of split cell.\n          var _breakSpanEvenly = breakSpanEvenly(colspan, numberOfCells),\n              newCellsSpan = _breakSpanEvenly.newCellsSpan,\n              updatedSpan = _breakSpanEvenly.updatedSpan;\n\n          updateNumericAttribute('colspan', updatedSpan, tableCell, writer); // Each inserted cell will have the same attributes:\n\n          var newCellsAttributes = {}; // Do not store default value in the model.\n\n          if (newCellsSpan > 1) {\n            newCellsAttributes.colspan = newCellsSpan;\n          } // Copy rowspan of split cell.\n\n\n          if (rowspan > 1) {\n            newCellsAttributes.rowspan = rowspan;\n          }\n\n          var cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;\n          createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);\n        } // Second check - the cell has colspan of 1 or we need to create more cells then the currently one spans over.\n\n\n        if (colspan < numberOfCells) {\n          var _cellsToInsert = numberOfCells - colspan; // First step: expand cells on the same column as split cell.\n\n\n          var tableMap = _toConsumableArray(new TableWalker(table)); // Get the column index of split cell.\n\n\n          var _tableMap$find = tableMap.find(function (_ref) {\n            var cell = _ref.cell;\n            return cell === tableCell;\n          }),\n              splitCellColumn = _tableMap$find.column; // Find cells which needs to be expanded vertically - those on the same column or those that spans over split cell's column.\n\n\n          var cellsToUpdate = tableMap.filter(function (_ref2) {\n            var cell = _ref2.cell,\n                colspan = _ref2.colspan,\n                column = _ref2.column;\n            var isOnSameColumn = cell !== tableCell && column === splitCellColumn;\n            var spansOverColumn = column < splitCellColumn && column + colspan > splitCellColumn;\n            return isOnSameColumn || spansOverColumn;\n          }); // Expand cells vertically.\n\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = cellsToUpdate[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var _step5$value = _step5.value,\n                  cell = _step5$value.cell,\n                  _colspan = _step5$value.colspan;\n              writer.setAttribute('colspan', _colspan + _cellsToInsert, cell);\n            } // Second step: create columns after split cell.\n            // Each inserted cell will have the same attributes:\n\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n\n          var _newCellsAttributes = {}; // Do not store default value in the model.\n          // Copy rowspan of split cell.\n\n          if (rowspan > 1) {\n            _newCellsAttributes.rowspan = rowspan;\n          }\n\n          createCells(_cellsToInsert, writer, writer.createPositionAfter(tableCell), _newCellsAttributes);\n          var headingColumns = table.getAttribute('headingColumns') || 0; // Update heading section if split cell is in heading section.\n\n          if (headingColumns > splitCellColumn) {\n            updateNumericAttribute('headingColumns', headingColumns + _cellsToInsert, table, writer);\n          }\n        }\n      });\n    }\n    /**\n     * Divides a table cell horizontally into several ones.\n     *\n     * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell\n     * below.\n     *\n     * If in the table below cell \"b\" is split to 3 cells:\n     *\n     *\t\t+---+---+---+\n     *\t\t| a | b | c |\n     *\t\t+---+---+---+\n     *\t\t| d | e | f |\n     *\t\t+---+---+---+\n     *\n     * It will result in the table below:\n     *\n     *\t\t+---+---+---+\n     *\t\t| a | b | c |\n     *\t\t+   +---+   +\n     *\t\t|   |   |   |\n     *\t\t+   +---+   +\n     *\t\t|   |   |   |\n     *\t\t+---+---+---+\n     *\t\t| d | e | f |\n     *\t\t+---+---+---+\n     *\n     * So cells \"a\" and \"b\" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.\n     *\n     * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder\n     * will be left to the original cell:\n     *\n     *\t\t+---+---+---+\n     *\t\t| a | b | c |\n     *\t\t+   +---+---+\n     *\t\t|   | d | e |\n     *\t\t+   +---+---+\n     *\t\t|   | f | g |\n     *\t\t+   +---+---+\n     *\t\t|   | h | i |\n     *\t\t+---+---+---+\n     *\n     * Splitting cell \"a\" with `rowspan=4` to 3 cells will create 2 cells with a `rowspan=1` and cell \"a\" will have `rowspan=2`:\n     *\n     *\t\t+---+---+---+\n     *\t\t| a | b | c |\n     *\t\t+   +---+---+\n     *\t\t|   | d | e |\n     *\t\t+---+---+---+\n     *\t\t|   | f | g |\n     *\t\t+---+---+---+\n     *\t\t|   | h | i |\n     *\t\t+---+---+---+\n     *\n     * @param {module:engine/model/element~Element} tableCell\n     * @param {Number} numberOfCells\n     */\n\n  }, {\n    key: \"splitCellHorizontally\",\n    value: function splitCellHorizontally(tableCell) {\n      var numberOfCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var model = this.editor.model;\n      var tableRow = tableCell.parent;\n      var table = tableRow.parent;\n      var splitCellRow = table.getChildIndex(tableRow);\n      var rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n      var colspan = parseInt(tableCell.getAttribute('colspan') || 1);\n      model.change(function (writer) {\n        // First check - the cell spans over multiple rows so before doing anything else just split this cell.\n        if (rowspan > 1) {\n          // Cache table map before updating table.\n          var tableMap = _toConsumableArray(new TableWalker(table, {\n            startRow: splitCellRow,\n            endRow: splitCellRow + rowspan - 1,\n            includeSpanned: true\n          })); // Get spans of new (inserted) cells and span to update of split cell.\n\n\n          var _breakSpanEvenly2 = breakSpanEvenly(rowspan, numberOfCells),\n              newCellsSpan = _breakSpanEvenly2.newCellsSpan,\n              updatedSpan = _breakSpanEvenly2.updatedSpan;\n\n          updateNumericAttribute('rowspan', updatedSpan, tableCell, writer);\n\n          var _tableMap$find2 = tableMap.find(function (_ref3) {\n            var cell = _ref3.cell;\n            return cell === tableCell;\n          }),\n              cellColumn = _tableMap$find2.column; // Each inserted cell will have the same attributes:\n\n\n          var newCellsAttributes = {}; // Do not store default value in the model.\n\n          if (newCellsSpan > 1) {\n            newCellsAttributes.rowspan = newCellsSpan;\n          } // Copy colspan of split cell.\n\n\n          if (colspan > 1) {\n            newCellsAttributes.colspan = colspan;\n          }\n\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = tableMap[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var _step6$value = _step6.value,\n                  column = _step6$value.column,\n                  row = _step6$value.row,\n                  cellIndex = _step6$value.cellIndex;\n              // As both newly created cells and the split cell might have rowspan,\n              // the insertion of new cells must go to appropriate rows:\n              //\n              // 1. It's a row after split cell + it's height.\n              var isAfterSplitCell = row >= splitCellRow + updatedSpan; // 2. Is on the same column.\n\n              var isOnSameColumn = column === cellColumn; // 3. And it's row index is after previous cell height.\n\n              var isInEvenlySplitRow = (row + splitCellRow + updatedSpan) % newCellsSpan === 0;\n\n              if (isAfterSplitCell && isOnSameColumn && isInEvenlySplitRow) {\n                var position = writer.createPositionAt(table.getChild(row), cellIndex);\n                createCells(1, writer, position, newCellsAttributes);\n              }\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n        } // Second check - the cell has rowspan of 1 or we need to create more cells than the current cell spans over.\n\n\n        if (rowspan < numberOfCells) {\n          // We already split the cell in check one so here we split to the remaining number of cells only.\n          var cellsToInsert = numberOfCells - rowspan; // This check is needed since we need to check if there are any cells from previous rows than spans over this cell's row.\n\n          var _tableMap = _toConsumableArray(new TableWalker(table, {\n            startRow: 0,\n            endRow: splitCellRow\n          })); // First step: expand cells.\n\n\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = _tableMap[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var _step7$value = _step7.value,\n                  cell = _step7$value.cell,\n                  _rowspan = _step7$value.rowspan,\n                  row = _step7$value.row;\n\n              // Expand rowspan of cells that are either:\n              // - on the same row as current cell,\n              // - or are below split cell row and overlaps that row.\n              if (cell !== tableCell && row + _rowspan > splitCellRow) {\n                var rowspanToSet = _rowspan + cellsToInsert;\n                writer.setAttribute('rowspan', rowspanToSet, cell);\n              }\n            } // Second step: create rows with single cell below split cell.\n\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n\n          var _newCellsAttributes2 = {}; // Copy colspan of split cell.\n\n          if (colspan > 1) {\n            _newCellsAttributes2.colspan = colspan;\n          }\n\n          createEmptyRows(writer, table, splitCellRow + 1, cellsToInsert, 1, _newCellsAttributes2); // Update heading section if split cell is in heading section.\n\n          var headingRows = table.getAttribute('headingRows') || 0;\n\n          if (headingRows > splitCellRow) {\n            updateNumericAttribute('headingRows', headingRows + cellsToInsert, table, writer);\n          }\n        }\n      });\n    }\n    /**\n     * Returns the number of columns for a given table.\n     *\n     *\t\teditor.plugins.get( 'TableUtils' ).getColumns( table );\n     *\n     * @param {module:engine/model/element~Element} table The table to analyze.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getColumns\",\n    value: function getColumns(table) {\n      // Analyze first row only as all the rows should have the same width.\n      var row = table.getChild(0);\n      return _toConsumableArray(row.getChildren()).reduce(function (columns, row) {\n        var columnWidth = parseInt(row.getAttribute('colspan') || 1);\n        return columns + columnWidth;\n      }, 0);\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'TableUtils';\n    }\n  }]);\n\n  return TableUtils;\n}(Plugin); // Creates empty rows at the given index in an existing table.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/element~Element} table\n// @param {Number} insertAt Row index of row insertion.\n// @param {Number} rows Number of rows to create.\n// @param {Number} tableCellToInsert Number of cells to insert in each row.\n\n\nexport { TableUtils as default };\n\nfunction createEmptyRows(writer, table, insertAt, rows, tableCellToInsert) {\n  var attributes = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  for (var i = 0; i < rows; i++) {\n    var tableRow = writer.createElement('tableRow');\n    writer.insert(tableRow, table, insertAt);\n    createCells(tableCellToInsert, writer, writer.createPositionAt(tableRow, 'end'), attributes);\n  }\n} // Creates cells at a given position.\n//\n// @param {Number} columns Number of columns to create\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/position~Position} insertPosition\n\n\nfunction createCells(cells, writer, insertPosition) {\n  var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  for (var i = 0; i < cells; i++) {\n    createEmptyTableCell(writer, insertPosition, attributes);\n  }\n} // Evenly distributes the span of a cell to a number of provided cells.\n// The resulting spans will always be integer values.\n//\n// For instance breaking a span of 7 into 3 cells will return:\n//\n//\t\t{ newCellsSpan: 2, updatedSpan: 3 }\n//\n// as two cells will have a span of 2 and the remainder will go the first cell so its span will change to 3.\n//\n// @param {Number} span Span value do break.\n// @param {Number} numberOfCells Number of resulting spans.\n// @returns {{newCellsSpan: Number, updatedSpan: Number}}\n\n\nfunction breakSpanEvenly(span, numberOfCells) {\n  if (span < numberOfCells) {\n    return {\n      newCellsSpan: 1,\n      updatedSpan: 1\n    };\n  }\n\n  var newCellsSpan = Math.floor(span / numberOfCells);\n  var updatedSpan = span - newCellsSpan * numberOfCells + newCellsSpan;\n  return {\n    newCellsSpan: newCellsSpan,\n    updatedSpan: updatedSpan\n  };\n}","import _slicedToArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.object.entries\";\nimport \"core-js/modules/es7.object.values\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.set\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-layout-post-fixer\n */\nimport { createEmptyTableCell, findAncestor, updateNumericAttribute } from \"./../commands/utils\";\nimport TableWalker from \"./../tablewalker\";\n/**\n * Injects a table layout post-fixer into the model.\n *\n * The role of the table layout post-fixer is to ensure that the table rows have the correct structure\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct structure means that:\n *\n * * All table rows have the same size.\n * * None of a table cells that extend vertically beyond their section (either header or body).\n * * A table cell has always at least one element as child.\n *\n * If the table structure is not correct, the post-fixer will automatically correct it in two steps:\n *\n * 1. It will clip table cells that extends beyond it section.\n * 2. It will add empty table cells to those rows which are narrower then the widest table row.\n *\n * ## Clipping overlapping table cells\n *\n * Such situation may occur when pasting a table (or part of a table) to the editor from external sources.\n *\n * For example, see the following table which has the cell (FOO) with the rowspan attribute (2):\n *\n *\t\t<table headingRows=\"1\">\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell rowspan=\"2\"><paragraph>FOO</paragraph></tableCell>\n *\t\t\t\t<tableCell colspan=\"2\"><paragraph>BAR</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph>BAZ</paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph>XYZ</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * will be rendered in the view as:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * In the above example the table will be rendered as a table with two rows - one in the header and second one in the body.\n * The table cell (FOO) cannot span over multiple rows as it would expand from the header to the body section.\n * The `rowspan` attribute must be changed to (1). The value (1) is a default value of the `rowspan` attribute\n * so the `rowspan` attribute will be removed from the model.\n *\n * The table cell with BAZ contents will be in the first column of the table.\n *\n * ## Adding missing table cells\n *\n * The table post-fixer will insert empty table cells to equalize table rows sizes (number of columns).\n * The size of a table row is calculated by counting column spans of table cells - both horizontal (from the same row) and\n * vertical (from rows above).\n *\n * In the above example, the table row in the body section of the table is narrower then the row from the header - it has two cells\n * with the default colspan (1). The header row has one cell with colspan (1) and second with colspan (2).\n * The table cell (FOO) does not expand beyond the head section (and as such will be fixed in the first step of this post-fixer).\n * The post-fixer will add a missing table cell to the row in the body section of the table.\n *\n * The table from the above example will be fixed and rendered to the view as below:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * ## Collaboration & Undo - Expectations vs post-fixer results\n *\n * The table post-fixer only ensures proper structure without deeper analysis of the nature of a change. As such, it might lead\n * to a structure which was not intended by the user changes. In particular, it will also fix undo steps (in conjunction with collaboration)\n * in which editor content might not return to the original state.\n *\n * This will usually happen when one or more users changes size of the table.\n *\n * As en example see a table below:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * and user actions:\n *\n * 1. Both user have table with two rows and two columns.\n * 2. User A adds a column at the end of the table - this will insert empty table cells to two rows.\n * 3. User B adds a row at the end of the table- this will insert a row with two empty table cells.\n * 4. Both users will have a table as below:\n *\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * The last row is shorter then others so table post-fixer will add empty row to tha last row:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * Unfortunately undo doesn't know the nature of changes and depending which user will apply post-fixer changes undoing them might lead to\n * broken table. If User B will undo inserting column to a table the undo engine will undo only operations of\n * inserting empty cells to rows from initial table state (row 1 & 2) but the cell in post-fixed row will remain:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * After undo the table post-fixer will detect that two rows are shorter then other and will fix table to:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n * @param {module:engine/model/model~Model} model\n */\n\nexport default function injectTableLayoutPostFixer(model) {\n  model.document.registerPostFixer(function (writer) {\n    return tableLayoutPostFixer(writer, model);\n  });\n} // The table layout post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n\nfunction tableLayoutPostFixer(writer, model) {\n  var changes = model.document.differ.getChanges();\n  var wasFixed = false; // Do not analyze the same table more then once - may happen for multiple changes in the same table.\n\n  var analyzedTables = new Set();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var entry = _step.value;\n      var table = void 0;\n\n      if (entry.name == 'table' && entry.type == 'insert') {\n        table = entry.position.nodeAfter;\n      } // Fix table on adding/removing table cells and rows.\n\n\n      if (entry.name == 'tableRow' || entry.name == 'tableCell') {\n        table = findAncestor('table', entry.position);\n      } // Fix table on any table's attribute change - including attributes of table cells.\n\n\n      if (isTableAttributeEntry(entry)) {\n        table = findAncestor('table', entry.range.start);\n      }\n\n      if (table && !analyzedTables.has(table)) {\n        // Step 1: correct rowspans of table cells if necessary.\n        // The wasFixed flag should be true if any of tables in batch was fixed - might be more then one.\n        wasFixed = fixTableCellsRowspan(table, writer) || wasFixed; // Step 2: fix table rows sizes.\n\n        wasFixed = fixTableRowsSizes(table, writer) || wasFixed;\n        analyzedTables.add(table);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return wasFixed;\n} // Fixes the invalid value of the rowspan attribute because a table cell cannot vertically extend beyond the table section it belongs to.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns true if table was fixed.\n\n\nfunction fixTableCellsRowspan(table, writer) {\n  var wasFixed = false;\n  var cellsToTrim = findCellsToTrim(table);\n\n  if (cellsToTrim.length) {\n    wasFixed = true;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = cellsToTrim[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var data = _step2.value;\n        updateNumericAttribute('rowspan', data.rowspan, data.cell, writer, 1);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  return wasFixed;\n} // Makes all table rows in a table the same size.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns true if table was fixed.\n\n\nfunction fixTableRowsSizes(table, writer) {\n  var wasFixed = false;\n  var rowsLengths = getRowsLengths(table);\n  var tableSize = rowsLengths[0];\n  var isValid = Object.values(rowsLengths).every(function (length) {\n    return length === tableSize;\n  });\n\n  if (!isValid) {\n    var maxColumns = Object.values(rowsLengths).reduce(function (prev, current) {\n      return current > prev ? current : prev;\n    }, 0);\n\n    for (var _i = 0, _Object$entries = Object.entries(rowsLengths); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          rowIndex = _Object$entries$_i[0],\n          size = _Object$entries$_i[1];\n\n      var columnsToInsert = maxColumns - size;\n\n      if (columnsToInsert) {\n        for (var i = 0; i < columnsToInsert; i++) {\n          createEmptyTableCell(writer, writer.createPositionAt(table.getChild(rowIndex), 'end'));\n        }\n\n        wasFixed = true;\n      }\n    }\n  }\n\n  return wasFixed;\n} // Searches for the table cells that extends beyond the table section to which they belong to. It will return an array of objects\n// that holds table cells to be trimmed and correct value of a rowspan attribute to set.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Array.<{{cell, rowspan}}>}\n\n\nfunction findCellsToTrim(table) {\n  var headingRows = parseInt(table.getAttribute('headingRows') || 0);\n  var maxRows = table.childCount;\n  var cellsToTrim = [];\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = new TableWalker(table)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _step3$value = _step3.value,\n          row = _step3$value.row,\n          rowspan = _step3$value.rowspan,\n          cell = _step3$value.cell;\n\n      // Skip cells that do not expand over its row.\n      if (rowspan < 2) {\n        continue;\n      }\n\n      var isInHeader = row < headingRows; // Row limit is either end of header section or whole table as table body is after the header.\n\n      var rowLimit = isInHeader ? headingRows : maxRows; // If table cell expands over its limit reduce it height to proper value.\n\n      if (row + rowspan > rowLimit) {\n        var newRowspan = rowLimit - row;\n        cellsToTrim.push({\n          cell: cell,\n          rowspan: newRowspan\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return cellsToTrim;\n} // Returns an object with lengths of rows assigned to the corresponding row index.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Object}\n\n\nfunction getRowsLengths(table) {\n  var lengths = {};\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = new TableWalker(table, {\n      includeSpanned: true\n    })[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var row = _step4.value.row;\n\n      if (!lengths[row]) {\n        lengths[row] = 0;\n      }\n\n      lengths[row] += 1;\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return lengths;\n} // Checks if the differ entry for an attribute change is one of table's attributes.\n//\n// @param entry\n// @returns {Boolean}\n\n\nfunction isTableAttributeEntry(entry) {\n  var isAttributeType = entry.type === 'attribute';\n  var key = entry.attributeKey;\n  return isAttributeType && (key === 'headingRows' || key === 'colspan' || key === 'rowspan');\n}","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-cell-content-post-fixer\n */\n\n/**\n * Injects a table cell post-fixer into the model.\n *\n * The role of the table post-fixer is to ensure that the table cells have the correct content\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * A table cells must contains at least one block as a child. The empty table cell will have empty `<paragraph>` as a child.\n *\n *        <table>\n *            <tableRow>\n *                <tableCell></tableCell>\n *            </tableRow>\n *        </table>\n *\n * Will be fixed to:\n *\n *        <table>\n *            <tableRow>\n *                <tableCell><paragraph></paragraph></tableCell>\n *            </tableRow>\n *        </table>\n *\n * @param {module:engine/model/model~Model} model\n */\nexport default function injectTableCellContentPostFixer(model) {\n  model.document.registerPostFixer(function (writer) {\n    return tableCellContentsPostFixer(writer, model);\n  });\n} // The table cell contents post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n\nfunction tableCellContentsPostFixer(writer, model) {\n  var changes = model.document.differ.getChanges();\n  var wasFixed = false;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var entry = _step.value;\n\n      // Enforce paragraph in tableCell even after other feature remove its contents.\n      if (entry.type == 'remove' && entry.position.parent.is('tableCell')) {\n        wasFixed = fixTableCellContent(entry.position.parent, writer) || wasFixed;\n      } // Analyze table cells on insertion.\n\n\n      if (entry.type == 'insert') {\n        if (entry.name == 'table') {\n          wasFixed = fixTable(entry.position.nodeAfter, writer) || wasFixed;\n        }\n\n        if (entry.name == 'tableRow') {\n          wasFixed = fixTableRow(entry.position.nodeAfter, writer) || wasFixed;\n        }\n\n        if (entry.name == 'tableCell') {\n          wasFixed = fixTableCellContent(entry.position.nodeAfter, writer) || wasFixed;\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return wasFixed;\n} // Fixes all table cells in a table.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction fixTable(table, writer) {\n  var wasFixed = false;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = table.getChildren()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var row = _step2.value;\n      wasFixed = fixTableRow(row, writer) || wasFixed;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return wasFixed;\n} // Fixes all table cells in a table row.\n//\n// @param {module:engine/model/element~Element} tableRow\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction fixTableRow(tableRow, writer) {\n  var wasFixed = false;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = tableRow.getChildren()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var tableCell = _step3.value;\n      wasFixed = fixTableCellContent(tableCell, writer) || wasFixed;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return wasFixed;\n} // Fixes all table cell content by:\n// - adding paragraph to a table cell without any child.\n// - wrapping direct $text in <paragraph>.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean}\n\n\nfunction fixTableCellContent(tableCell, writer) {\n  // Insert paragraph to an empty table cell.\n  if (tableCell.childCount == 0) {\n    writer.insertElement('paragraph', tableCell);\n    return true;\n  } // Check table cell children for directly placed $text nodes.\n  // Temporary solution. See https://github.com/ckeditor/ckeditor5/issues/1464.\n\n\n  var textNodes = Array.from(tableCell.getChildren()).filter(function (child) {\n    return child.is('text');\n  });\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = textNodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var child = _step4.value;\n      writer.wrap(writer.createRangeOn(child), 'paragraph');\n    } // Return true when there were text nodes to fix.\n\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return !!textNodes.length;\n}","import \"core-js/modules/es6.string.anchor\";\nimport \"core-js/modules/es6.function.name\";\nimport _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/tablecell-post-fixer\n */\n\n/**\n * Injects a table cell post-fixer into the editing controller.\n *\n * The role of the table cell post-fixer is to ensure that the table cell contents in the editing view are properly converted.\n *\n * This post-fixer will ensure that after model changes in the editing view:\n * * single paragraphs are rendered as `<span>\n * * single paragraphs with one or more attributes are rendered as `<p>`\n * * single paragraphs in table cell with other block elements are rendered as `<p>`\n * * paragraphs in table cells with other block elements (including other paragraphs) are rendered as `<p>`.\n *\n * In the model each table cell has always at least one block element inside. If no other block was defined (empty table cell) the table\n * feature will insert empty `<paragraph>`. Similarly text nodes will be wrapped in paragraphs. Rendering in the data pipeline differs\n * from rendering in the editing pipeline - text nodes in single `<paragraph>` are rendered in the data pipeline as direct children\n * of the `<td>` or `<th>` elements. In other cases `<paragraph>` elements are rendered as `<p>` blocks.\n *\n * To ensure proper mappings between model and view elements and positions in the editing pipeline the table feature will always render\n * an element in the view: `<span>` for single or empty `<paragraph>` and `<p>` otherwise.\n *\n * Example:\n *\n *\t\t<table>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph></paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph>foo</paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph baz=\"bar\">foo</paragraph></tableCell>\n *\t\t\t\t<tableCell><heading2>bar</heading2><paragraph>baz</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * The editor will render in the data pipeline:\n *\n *\t\t<figure>\n *\t\t\t<table>\n *\t\t\t\t<tbody>\n *\t\t\t\t\t<tr>\n *\t\t\t\t\t\t<td></td>\n *\t\t\t\t\t\t<td>foo</td>\n *\t\t\t\t\t\t<td><p baz=\"bar\">foo</p></td>\n *\t\t\t\t\t\t<td><h3>bar</h3><p>baz</p></td>\n *\t\t\t\t\t</tr>\n *\t\t\t\t</tbody>\n *\t\t\t</table>\n *\t\t</figure>\n *\n * and in the editing view (without widget markup):\n *\n *\t\t<figure>\n *\t\t\t<table>\n *\t\t\t\t<tbody>\n *\t\t\t\t\t<tr>\n *\t\t\t\t\t\t<td><span></span></td>\n *\t\t\t\t\t\t<td><span>foo</span></td>\n *\t\t\t\t\t\t<td><p baz=\"bar\">foo</p></td>\n *\t\t\t\t\t\t<td><h3>bar</h3><p>baz</p></td>\n *\t\t\t\t\t</tr>\n *\t\t\t\t</tbody>\n *\t\t\t</table>\n *\t\t</figure>\n *\n * @param {module:engine/model/model~Model} model\n * @param {module:engine/controller/editingcontroller~EditingController} editing\n */\nexport default function injectTableCellPostFixer(model, editing) {\n  editing.view.document.registerPostFixer(function (writer) {\n    return tableCellPostFixer(writer, model, editing.mapper, editing.view);\n  });\n} // The table cell post-fixer.\n//\n// @param {module:engine/view/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/conversion/mapper~Mapper} mapper\n\nfunction tableCellPostFixer(writer, model, mapper, view) {\n  var wasFixed = false;\n  var elementsToCheck = getElementsToCheck(view);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = elementsToCheck[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var element = _step.value;\n      wasFixed = ensureProperElementName(element, mapper, writer) || wasFixed;\n    } // Selection in the view might not be updated to renamed elements. Happens mostly when other feature inserts paragraph to the table cell\n    // (ie. when deleting table cell contents) and sets selection to it while table-post fixer changes view <p> to <span> element.\n    // The view.selection would have outdated nodes.\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (wasFixed && selectionNeedsFix(view.document.selection, mapper)) {\n    updateRangesInViewSelection(model.document.selection, mapper, writer);\n  }\n\n  return wasFixed;\n} // Returns view elements changed in current view.change() block.\n//\n// **Note**: Currently it uses private property of the view: _renderer to get changed view elements to check.\n//\n// @param {module:engine/view/view~View} view\n\n\nfunction getElementsToCheck(view) {\n  var elementsWithChangedAttributes = Array.from(view._renderer.markedAttributes).filter(function (el) {\n    return !!el.parent;\n  }).filter(isSpanOrP).filter(function (el) {\n    return isTdOrTh(el.parent);\n  });\n  var changedChildren = Array.from(view._renderer.markedChildren).filter(function (el) {\n    return !!el.parent;\n  }).filter(isTdOrTh).reduce(function (prev, element) {\n    var childrenToCheck = Array.from(element.getChildren()).filter(isSpanOrP);\n    return [].concat(_toConsumableArray(prev), _toConsumableArray(childrenToCheck));\n  }, []);\n  return [].concat(_toConsumableArray(elementsWithChangedAttributes), _toConsumableArray(changedChildren));\n} // This method checks if view element for model's <paragraph> was properly converter.\n// Paragraph should be either\n// - span: for single paragraph with no attributes.\n// - p   : in other cases.\n\n\nfunction ensureProperElementName(currentViewElement, mapper, writer) {\n  // This situation may happen if a view element was changed and removed at the same time.\n  // In this case, the view element is already unbound so the post-fixer would crash.\n  if (!currentViewElement.root.is('rootElement')) {\n    return false;\n  }\n\n  var modelParagraph = mapper.toModelElement(currentViewElement);\n  var expectedViewElementName = getExpectedElementName(modelParagraph.parent, modelParagraph);\n\n  if (currentViewElement.name !== expectedViewElementName) {\n    // Unbind current view element as it should be cleared from mapper.\n    mapper.unbindViewElement(currentViewElement);\n    var renamedViewElement = writer.rename(expectedViewElementName, currentViewElement); // Bind paragraph inside table cell to the renamed view element.\n\n    mapper.bindElements(modelParagraph, renamedViewElement);\n    return true;\n  }\n\n  return false;\n} // Expected view element name depends on model elements:\n// - <paragraph> with any attribute set should be rendered as <p>\n// - all <paragraphs> in <tableCell> that has more then one children should be rendered as <p>\n// - an only <paragraph> child with no attributes should be rendered as <span>\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {module:engine/model/element~Element} paragraph\n// @returns {String}\n\n\nfunction getExpectedElementName(tableCell, paragraph) {\n  var isOnlyChild = tableCell.childCount > 1;\n  var hasAttributes = !!_toConsumableArray(paragraph.getAttributes()).length;\n  return isOnlyChild || hasAttributes ? 'p' : 'span';\n} // Method to filter out <span> and <p> elements.\n//\n// @param {module:engine/view/element~Element} element\n\n\nfunction isSpanOrP(element) {\n  return element.is('p') || element.is('span');\n} // Method to filter out <td> and <th> elements.\n//\n// @param {module:engine/view/element~Element} element\n\n\nfunction isTdOrTh(element) {\n  return element.is('td') || element.is('th');\n} // Resets view selections based on model selection.\n\n\nfunction updateRangesInViewSelection(selection, mapper, writer) {\n  var fixedRanges = Array.from(selection.getRanges()).map(function (range) {\n    return mapper.toViewRange(range);\n  });\n  writer.setSelection(fixedRanges, {\n    backward: selection.isBackward\n  });\n} // Checks if selection needs to be fixed by ensuring that current view selection position's parents are present in the editable view.\n//\n// @param {module:engine/view/selection~Selection} viewSelection\n\n\nfunction selectionNeedsFix(viewSelection) {\n  var anchor = viewSelection.anchor;\n  var focus = viewSelection.focus;\n  return viewSelection.rangeCount && (!anchor.root.is('rootElement') || !focus.root.is('rootElement'));\n}","import \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.function.name\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport upcastTable, { upcastTableCell } from \"./converters/upcasttable\";\nimport { downcastInsertCell, downcastInsertRow, downcastInsertTable, downcastRemoveRow, downcastTableHeadingColumnsChange, downcastTableHeadingRowsChange } from \"./converters/downcast\";\nimport InsertTableCommand from \"./commands/inserttablecommand\";\nimport InsertRowCommand from \"./commands/insertrowcommand\";\nimport InsertColumnCommand from \"./commands/insertcolumncommand\";\nimport SplitCellCommand from \"./commands/splitcellcommand\";\nimport MergeCellCommand from \"./commands/mergecellcommand\";\nimport RemoveRowCommand from \"./commands/removerowcommand\";\nimport RemoveColumnCommand from \"./commands/removecolumncommand\";\nimport SetHeaderRowCommand from \"./commands/setheaderrowcommand\";\nimport SetHeaderColumnCommand from \"./commands/setheadercolumncommand\";\nimport { findAncestor } from \"./commands/utils\";\nimport TableUtils from \"../src/tableutils\";\nimport injectTableLayoutPostFixer from \"./converters/table-layout-post-fixer\";\nimport injectTableCellContentsPostFixer from \"./converters/table-cell-content-post-fixer\";\nimport injectTableCellPostFixer from \"./converters/tablecell-post-fixer\";\nimport \"../theme/tableediting.css\";\n/**\n * The table editing feature.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar TableEditing =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(TableEditing, _Plugin);\n\n  function TableEditing() {\n    _classCallCheck(this, TableEditing);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TableEditing).apply(this, arguments));\n  }\n\n  _createClass(TableEditing, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var _this = this;\n\n      var editor = this.editor;\n      var model = editor.model;\n      var schema = model.schema;\n      var conversion = editor.conversion;\n      schema.register('table', {\n        allowWhere: '$block',\n        allowAttributes: ['headingRows', 'headingColumns'],\n        isLimit: true,\n        isObject: true,\n        isBlock: true\n      });\n      schema.register('tableRow', {\n        allowIn: 'table',\n        isLimit: true\n      });\n      schema.register('tableCell', {\n        allowIn: 'tableRow',\n        allowAttributes: ['colspan', 'rowspan'],\n        isLimit: true\n      }); // Allow all $block content inside table cell.\n\n      schema.extend('$block', {\n        allowIn: 'tableCell'\n      }); // Disallow table in table.\n\n      schema.addChildCheck(function (context, childDefinition) {\n        if (childDefinition.name == 'table' && Array.from(context.getNames()).includes('table')) {\n          return false;\n        }\n      }); // Table conversion.\n\n      conversion.for('upcast').add(upcastTable());\n      conversion.for('editingDowncast').add(downcastInsertTable({\n        asWidget: true\n      }));\n      conversion.for('dataDowncast').add(downcastInsertTable()); // Table row conversion.\n\n      conversion.for('upcast').elementToElement({\n        model: 'tableRow',\n        view: 'tr'\n      });\n      conversion.for('editingDowncast').add(downcastInsertRow({\n        asWidget: true\n      }));\n      conversion.for('dataDowncast').add(downcastInsertRow());\n      conversion.for('downcast').add(downcastRemoveRow()); // Table cell conversion.\n\n      conversion.for('upcast').add(upcastTableCell('td'));\n      conversion.for('upcast').add(upcastTableCell('th'));\n      conversion.for('editingDowncast').add(downcastInsertCell({\n        asWidget: true\n      }));\n      conversion.for('dataDowncast').add(downcastInsertCell()); // Table attributes conversion.\n\n      conversion.attributeToAttribute({\n        model: 'colspan',\n        view: 'colspan'\n      });\n      conversion.attributeToAttribute({\n        model: 'rowspan',\n        view: 'rowspan'\n      }); // Table heading rows and cols conversion.\n\n      conversion.for('editingDowncast').add(downcastTableHeadingColumnsChange({\n        asWidget: true\n      }));\n      conversion.for('dataDowncast').add(downcastTableHeadingColumnsChange());\n      conversion.for('editingDowncast').add(downcastTableHeadingRowsChange({\n        asWidget: true\n      }));\n      conversion.for('dataDowncast').add(downcastTableHeadingRowsChange());\n      injectTableCellPostFixer(editor.model, editor.editing); // Define all the commands.\n\n      editor.commands.add('insertTable', new InsertTableCommand(editor));\n      editor.commands.add('insertTableRowAbove', new InsertRowCommand(editor, {\n        order: 'above'\n      }));\n      editor.commands.add('insertTableRowBelow', new InsertRowCommand(editor, {\n        order: 'below'\n      }));\n      editor.commands.add('insertTableColumnLeft', new InsertColumnCommand(editor, {\n        order: 'left'\n      }));\n      editor.commands.add('insertTableColumnRight', new InsertColumnCommand(editor, {\n        order: 'right'\n      }));\n      editor.commands.add('removeTableRow', new RemoveRowCommand(editor));\n      editor.commands.add('removeTableColumn', new RemoveColumnCommand(editor));\n      editor.commands.add('splitTableCellVertically', new SplitCellCommand(editor, {\n        direction: 'vertically'\n      }));\n      editor.commands.add('splitTableCellHorizontally', new SplitCellCommand(editor, {\n        direction: 'horizontally'\n      }));\n      editor.commands.add('mergeTableCellRight', new MergeCellCommand(editor, {\n        direction: 'right'\n      }));\n      editor.commands.add('mergeTableCellLeft', new MergeCellCommand(editor, {\n        direction: 'left'\n      }));\n      editor.commands.add('mergeTableCellDown', new MergeCellCommand(editor, {\n        direction: 'down'\n      }));\n      editor.commands.add('mergeTableCellUp', new MergeCellCommand(editor, {\n        direction: 'up'\n      }));\n      editor.commands.add('setTableColumnHeader', new SetHeaderColumnCommand(editor));\n      editor.commands.add('setTableRowHeader', new SetHeaderRowCommand(editor));\n      injectTableLayoutPostFixer(model);\n      injectTableCellContentsPostFixer(model); // Handle tab key navigation.\n\n      this.editor.keystrokes.set('Tab', function () {\n        return _this._handleTabOnSelectedTable.apply(_this, arguments);\n      }, {\n        priority: 'low'\n      });\n      this.editor.keystrokes.set('Tab', this._getTabHandler(true), {\n        priority: 'low'\n      });\n      this.editor.keystrokes.set('Shift+Tab', this._getTabHandler(false), {\n        priority: 'low'\n      });\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_handleTabOnSelectedTable\",\n\n    /**\n     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events for the <kbd>Tab</kbd> key executed\n     * when the table widget is selected.\n     *\n     * @private\n     * @param {module:utils/eventinfo~EventInfo} eventInfo\n     * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n     */\n    value: function _handleTabOnSelectedTable(domEventData, cancel) {\n      var editor = this.editor;\n      var selection = editor.model.document.selection;\n\n      if (!selection.isCollapsed && selection.rangeCount === 1 && selection.getFirstRange().isFlat) {\n        var selectedElement = selection.getSelectedElement();\n\n        if (!selectedElement || !selectedElement.is('table')) {\n          return;\n        }\n\n        cancel();\n        editor.model.change(function (writer) {\n          writer.setSelection(writer.createRangeIn(selectedElement.getChild(0).getChild(0)));\n        });\n      }\n    }\n    /**\n     * Returns a handler for {@link module:engine/view/document~Document#event:keydown keydown} events for the <kbd>Tab</kbd> key executed\n     * inside table cell.\n     *\n     * @private\n     * @param {Boolean} isForward Whether this handler will move selection to the next cell or previous.\n     */\n\n  }, {\n    key: \"_getTabHandler\",\n    value: function _getTabHandler(isForward) {\n      var editor = this.editor;\n      return function (domEventData, cancel) {\n        var selection = editor.model.document.selection;\n        var firstPosition = selection.getFirstPosition();\n        var tableCell = findAncestor('tableCell', firstPosition);\n\n        if (!tableCell) {\n          return;\n        }\n\n        cancel();\n        var tableRow = tableCell.parent;\n        var table = tableRow.parent;\n        var currentRowIndex = table.getChildIndex(tableRow);\n        var currentCellIndex = tableRow.getChildIndex(tableCell);\n        var isFirstCellInRow = currentCellIndex === 0;\n\n        if (!isForward && isFirstCellInRow && currentRowIndex === 0) {\n          // It's the first cell of a table - don't do anything (stay in current position).\n          return;\n        }\n\n        var isLastCellInRow = currentCellIndex === tableRow.childCount - 1;\n        var isLastRow = currentRowIndex === table.childCount - 1;\n\n        if (isForward && isLastRow && isLastCellInRow) {\n          editor.execute('insertTableRowBelow'); // Check if the command actually added a row. If `insertTableRowBelow` execution didn't add a row (because it was disabled\n          // or it got overwritten) do not change the selection.\n\n          if (currentRowIndex === table.childCount - 1) {\n            return;\n          }\n        }\n\n        var cellToFocus; // Move to first cell in next row.\n\n        if (isForward && isLastCellInRow) {\n          var nextRow = table.getChild(currentRowIndex + 1);\n          cellToFocus = nextRow.getChild(0);\n        } // Move to last cell in a previous row.\n        else if (!isForward && isFirstCellInRow) {\n            var previousRow = table.getChild(currentRowIndex - 1);\n            cellToFocus = previousRow.getChild(previousRow.childCount - 1);\n          } // Move to next/previous cell.\n          else {\n              cellToFocus = tableRow.getChild(currentCellIndex + (isForward ? 1 : -1));\n            }\n\n        editor.model.change(function (writer) {\n          writer.setSelection(writer.createRangeIn(cellToFocus));\n        });\n      };\n    }\n  }], [{\n    key: \"requires\",\n    get: function get() {\n      return [TableUtils];\n    }\n  }]);\n\n  return TableEditing;\n}(Plugin);\n\nexport { TableEditing as default };","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/mouseobserver\n */\nimport DomEventObserver from \"./domeventobserver\";\n/**\n * Mouse events observer.\n *\n * Note that this observer is not available by default. To make it available it needs to be added to\n * {@link module:engine/view/view~View} by {@link module:engine/view/view~View#addObserver} method.\n *\n * @extends module:engine/view/observer/domeventobserver~DomEventObserver\n */\n\nvar MouseObserver =\n/*#__PURE__*/\nfunction (_DomEventObserver) {\n  _inherits(MouseObserver, _DomEventObserver);\n\n  function MouseObserver(view) {\n    var _this;\n\n    _classCallCheck(this, MouseObserver);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MouseObserver).call(this, view));\n    _this.domEventType = 'mousedown';\n    return _this;\n  }\n\n  _createClass(MouseObserver, [{\n    key: \"onDomEvent\",\n    value: function onDomEvent(domEvent) {\n      this.fire(domEvent.type, domEvent);\n    }\n  }]);\n\n  return MouseObserver;\n}(DomEventObserver);\n/**\n * Fired when mouse button is pressed down on one of the editables.\n *\n * Introduced by {@link module:engine/view/observer/mouseobserver~MouseObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:engine/view/observer/mouseobserver~MouseObserver}\n * needs to be added to {@link module:engine/view/view~View} by a {@link module:engine/view/view~View#addObserver} method.\n *\n * @see module:engine/view/observer/mouseobserver~MouseObserver\n * @event module:engine/view/document~Document#event:mousedown\n * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.\n */\n\n\nexport { MouseObserver as default };","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/table\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport TableEditing from \"./tableediting\";\nimport TableUI from \"./tableui\";\nimport Widget from '@ckeditor/ckeditor5-widget/src/widget';\nimport \"../theme/table.css\";\n/**\n * The table plugin.\n *\n * For a detailed overview, check the {@glink features/table Table feature documentation}.\n *\n * This is a \"glue\" plugin which loads the {@link module:table/tableediting~TableEditing table editing feature}\n * and {@link module:table/tableui~TableUI table UI feature}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar Table =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Table, _Plugin);\n\n  function Table() {\n    _classCallCheck(this, Table);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Table).apply(this, arguments));\n  }\n\n  _createClass(Table, null, [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [TableEditing, TableUI, Widget];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'Table';\n    }\n  }]);\n\n  return Table;\n}(Plugin);\n/**\n * The configuration of the table features. Used by the table features in the `@ckeditor/ckeditor5-table` package.\n *\n *\t\tClassicEditor\n *\t\t\t.create( editorElement, {\n * \t\t\t\ttable: ... // Table feature options.\n *\t\t\t} )\n *\t\t\t.then( ... )\n *\t\t\t.catch( ... );\n *\n * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.\n *\n * @interface TableConfig\n */\n\n/**\n * The configuration of the {@link module:table/table~Table} feature.\n *\n * Read more in {@link module:table/table~TableConfig}.\n *\n * @member {module:table/table~TableConfig} module:core/editor/editorconfig~EditorConfig#table\n */\n\n\nexport { Table as default };","import \"core-js/modules/es6.function.name\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module media-embed/converters\n */\n\n/**\n * Returns a function that converts the model \"url\" attribute to the view representation.\n *\n * Depending on the configuration, the view representation can be \"semantic\" (for the data pipeline):\n *\n *\t\t<figure class=\"media\">\n *\t\t\t<oembed url=\"foo\"></oembed>\n *\t\t</figure>\n *\n * or \"non-semantic\" (for the editing view pipeline):\n *\n *\t\t<figure class=\"media\">\n *\t\t\t<div data-oembed-url=\"foo\">[ non-semantic media preview for \"foo\" ]</div>\n *\t\t</figure>\n *\n * **Note:** Changing the model \"url\" attribute replaces the entire content of the\n * `<figure>` in the view.\n *\n * @param {module:media-embed/mediaregistry~MediaRegistry} registry The registry providing\n * the media and their content.\n * @param {Object} options\n * @param {String} [options.renderMediaPreview] When `true`, the converter will create the view in the non-semantic form.\n * @param {String} [options.renderForEditingView] When `true`, the converter will create a view specific for the\n * editing pipeline (e.g. including CSS classes, content placeholders).\n * @returns {Function}\n */\nexport function modelToViewUrlAttributeConverter(registry, options) {\n  return function (dispatcher) {\n    dispatcher.on('attribute:url:media', converter);\n  };\n\n  function converter(evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    var url = data.attributeNewValue;\n    var viewWriter = conversionApi.writer;\n    var figure = conversionApi.mapper.toViewElement(data.item); // TODO: removing it and creating it from scratch is a hack. We can do better than that.\n\n    viewWriter.remove(viewWriter.createRangeIn(figure));\n    var mediaViewElement = registry.getMediaViewElement(viewWriter, url, options);\n    viewWriter.insert(viewWriter.createPositionAt(figure, 0), mediaViewElement);\n  }\n}","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module media-embed/utils\n */\nimport { isWidget, toWidget } from '@ckeditor/ckeditor5-widget/src/utils';\n/**\n * Converts a given {@link module:engine/view/element~Element} to a media embed widget:\n * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the media widget element.\n * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.\n * @param {String} label The element's label.\n * @returns {module:engine/view/element~Element}\n */\n\nexport function toMediaWidget(viewElement, writer, label) {\n  writer.setCustomProperty('media', true, viewElement);\n  return toWidget(viewElement, writer, {\n    label: label\n  });\n}\n/**\n * Returns a media widget editing view element if one is selected.\n *\n * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection\n * @returns {module:engine/view/element~Element|null}\n */\n\nexport function getSelectedMediaViewWidget(selection) {\n  var viewElement = selection.getSelectedElement();\n\n  if (viewElement && isMediaWidget(viewElement)) {\n    return viewElement;\n  }\n\n  return null;\n}\n/**\n * Checks if a given view element is a media widget.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @returns {Boolean}\n */\n\nexport function isMediaWidget(viewElement) {\n  return !!viewElement.getCustomProperty('media') && isWidget(viewElement);\n}\n/**\n * Creates a view element representing the media. Either \"semantic\" one for the data pipeline:\n *\n *\t\t<figure class=\"media\">\n *\t\t\t<oembed url=\"foo\"></oembed>\n *\t\t</figure>\n *\n * or \"non-semantic\" (for the editing view pipeline):\n *\n *\t\t<figure class=\"media\">\n *\t\t\t<div data-oembed-url=\"foo\">[ non-semantic media preview for \"foo\" ]</div>\n *\t\t</figure>\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:media-embed/mediaregistry~MediaRegistry} registry\n * @param {String} url\n * @param {Object} options\n * @param {String} [options.useSemanticWrapper]\n * @param {String} [options.renderForEditingView]\n * @returns {module:engine/view/containerelement~ContainerElement}\n */\n\nexport function createMediaFigureElement(writer, registry, url, options) {\n  var figure = writer.createContainerElement('figure', {\n    class: 'media'\n  }); // TODO: This is a hack. Without it, the figure in the data pipeline will contain &nbsp; because\n  // its only child is the UIElement (wrapper).\n  //\n  // Note: The hack is a copy&paste from widget utils; it makes the figure act like it's a widget.\n\n  figure.getFillerOffset = getFillerOffset;\n  writer.insert(writer.createPositionAt(figure, 0), registry.getMediaViewElement(writer, url, options));\n  return figure;\n}\n/**\n * Returns a selected media element in the model, if any.\n *\n * @param {module:engine/model/selection~Selection} selection\n * @returns {module:engine/model/element~Element|null}\n */\n\nexport function getSelectedMediaModelWidget(selection) {\n  var selectedElement = selection.getSelectedElement();\n\n  if (selectedElement && selectedElement.is('media')) {\n    return selectedElement;\n  }\n\n  return null;\n}\n/**\n * Creates a media element and inserts it into the model.\n *\n * **Note**: This method will use {@link module:engine/model/model~Model#insertContent `model.insertContent()`} logic of inserting content\n * if no `insertPosition` is passed.\n *\n * @param {module:engine/model/model~Model} model\n * @param {String} url An URL of an embeddable media.\n * @param {module:engine/model/position~Position} [insertPosition] Position to insert media. If not specified,\n * the default behavior of {@link module:engine/model/model~Model#insertContent `model.insertContent()`} will\n * be applied.\n */\n\nexport function insertMedia(model, url, insertPosition) {\n  model.change(function (writer) {\n    var mediaElement = writer.createElement('media', {\n      url: url\n    });\n    model.insertContent(mediaElement, insertPosition);\n    writer.setSelection(mediaElement, 'on');\n  });\n}\n\nfunction getFillerOffset() {\n  return null;\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module media-embed/mediaembedcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { findOptimalInsertionPosition } from '@ckeditor/ckeditor5-widget/src/utils';\nimport { getSelectedMediaModelWidget, insertMedia } from \"./utils\";\n/**\n * The insert media command.\n *\n * The command is registered by the {@link module:media-embed/mediaembedediting~MediaEmbedEditing} as `'mediaEmbed'`.\n *\n * To insert media at the current selection, execute the command and specify the URL:\n *\n *\t\teditor.execute( 'mediaEmbed', 'http://url.to.the/media' );\n *\n * @extends module:core/command~Command\n */\n\nvar MediaEmbedCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(MediaEmbedCommand, _Command);\n\n  function MediaEmbedCommand() {\n    _classCallCheck(this, MediaEmbedCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MediaEmbedCommand).apply(this, arguments));\n  }\n\n  _createClass(MediaEmbedCommand, [{\n    key: \"refresh\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      var model = this.editor.model;\n      var selection = model.document.selection;\n      var schema = model.schema;\n      var position = selection.getFirstPosition();\n      var selectedMedia = getSelectedMediaModelWidget(selection);\n      var parent = position.parent;\n\n      if (parent != parent.root) {\n        parent = parent.parent;\n      }\n\n      this.value = selectedMedia ? selectedMedia.getAttribute('url') : null;\n      this.isEnabled = schema.checkChild(parent, 'media');\n    }\n    /**\n     * Executes the command, which either:\n     *\n     * * updates the URL of the selected media,\n     * * inserts the new media into the editor and puts the selection around it.\n     *\n     * @fires execute\n     * @param {String} url The URL of the media.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(url) {\n      var model = this.editor.model;\n      var selection = model.document.selection;\n      var selectedMedia = getSelectedMediaModelWidget(selection);\n\n      if (selectedMedia) {\n        model.change(function (writer) {\n          writer.setAttribute('url', url, selectedMedia);\n        });\n      } else {\n        var insertPosition = findOptimalInsertionPosition(selection, model);\n        insertMedia(model, url, insertPosition);\n      }\n    }\n  }]);\n\n  return MediaEmbedCommand;\n}(Command);\n\nexport { MediaEmbedCommand as default };","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module media-embed/mediaembed\n */\nimport MediaEmbedEditing from \"./mediaembedediting\";\nimport AutoMediaEmbed from \"./automediaembed\";\nimport MediaEmbedUI from \"./mediaembedui\";\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Widget from '@ckeditor/ckeditor5-widget/src/widget';\nimport \"../theme/mediaembed.css\";\n/**\n * The media embed plugin.\n *\n * For a detailed overview, check the {@glink features/media-embed Media Embed feature documentation}.\n *\n * This is a \"glue\" plugin which loads the following plugins:\n *\n * * The {@link module:media-embed/mediaembedediting~MediaEmbedEditing media embed editing feature},\n * * The {@link module:media-embed/mediaembedui~MediaEmbedUI media embed UI feature} and\n * * The {@link module:media-embed/automediaembed~AutoMediaEmbed auto-media embed feature}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar MediaEmbed =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(MediaEmbed, _Plugin);\n\n  function MediaEmbed() {\n    _classCallCheck(this, MediaEmbed);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MediaEmbed).apply(this, arguments));\n  }\n\n  _createClass(MediaEmbed, null, [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [MediaEmbedEditing, MediaEmbedUI, AutoMediaEmbed, Widget];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'MediaEmbed';\n    }\n  }]);\n\n  return MediaEmbed;\n}(Plugin);\n/**\n * The media embed provider descriptor. Used in\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#providers `config.mediaEmbed.providers`} and\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#extraProviders `config.mediaEmbed.extraProviders`}.\n *\n * See {@link module:media-embed/mediaembed~MediaEmbedConfig} to learn more.\n *\n *\t\t{\n *\t\t\tname: 'example',\n *\n *\t\t\t// The following RegExp matches https://www.example.com/media/{media id},\n *\t\t\t// (either with \"http(s)://\" and \"www\" or without), so the valid URLs are:\n *\t\t\t//\n *\t\t\t// * https://www.example.com/media/{media id},\n *\t\t\t// * http://www.example.com/media/{media id},\n *\t\t\t// * www.example.com/media/{media id},\n *\t\t\t// * example.com/media/{media id}\n *\t\t\turl: /^example\\.com\\/media\\/(\\w+)/,\n *\n *\t\t\t// The rendering function of the provider.\n *\t\t\t// Used to represent the media when editing the content (i.e. in the view)\n *\t\t\t// and also in the data output of the editor if semantic data output is disabled.\n *\t\t\thtml: match => `The HTML representing the media with ID=${ match[ 1 ] }.`\n *\t\t}\n *\n * You can allow any sort of media in the editor using the \"allowall\" `RegExp`.\n * But mind that, since URLs are processed in the order of configuration, if one of the previous\n * `RegExps` matches the URL, it will have a precedence over this one.\n *\n *\t\t{\n *\t\t\tname: 'allow-all',\n *\t\t\turl: /^.+/\n *\t\t}\n *\n * To implement responsive media, you can use the following HTML structure:\n *\n *\t\t{\n *\t\t\t...\n *\t\t\thtml: match =>\n *\t\t\t\t'<div style=\"position:relative; padding-bottom:100%; height:0\">' +\n *\t\t\t\t\t'<iframe src=\"...\" frameborder=\"0\" ' +\n *\t\t\t\t\t\t'style=\"position:absolute; width:100%; height:100%; top:0; left:0\">' +\n *\t\t\t\t\t'</iframe>' +\n *\t\t\t\t'</div>'\n *\t\t}\n *\n * @typedef {Object} module:media-embed/mediaembed~MediaEmbedProvider\n * @property {String} name The name of the provider. Used e.g. when\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#removeProviders removing providers}.\n * @property {RegExp|Array.<RegExp>} url The `RegExp` object (or array of objects) defining the URL of the media.\n * If any URL matches the `RegExp`, it becomes the media in the editor model, as defined by the provider. The result\n * of matching (output of `String.prototype.match()`) is passed to the `html` rendering function of the media.\n *\n * **Note:** You do not need to include the protocol (`http://`, `https://`) and `www` subdomain in your `RegExps`,\n * they are stripped from the URLs before matching anyway.\n * @property {Function} [html] (optional) The rendering function of the media. The function receives the entire matching\n * array from the corresponding `url` `RegExp` as an argument, allowing rendering a dedicated\n * preview of the media identified by a certain ID or a hash. When not defined, the media embed feature\n * will use a generic media representation in the view and output data.\n * Note that when\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#previewsInData `config.mediaEmbed.previewsInData`}\n * is `true`, the rendering function **will always** be used for the media in the editor data output.\n */\n\n/**\n * The configuration of the {@link module:media-embed/mediaembed~MediaEmbed} feature.\n *\n * Read more in {@link module:media-embed/mediaembed~MediaEmbedConfig}.\n *\n * @member {module:media-embed/mediaembed~MediaEmbedConfig} module:core/editor/editorconfig~EditorConfig#mediaEmbed\n */\n\n/**\n * The configuration of the media embed features.\n *\n * Read more about {@glink features/media-embed#configuration configuring the media embed feature}.\n *\n *\t\tClassicEditor\n *\t\t\t.create( editorElement, {\n * \t\t\t\tmediaEmbed: ... // Media embed feature options.\n *\t\t\t} )\n *\t\t\t.then( ... )\n *\t\t\t.catch( ... );\n *\n * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.\n *\n * @interface MediaEmbedConfig\n */\n\n/**\n * The default media providers supported by the editor.\n *\n * The names of providers with rendering functions (previews):\n *\n * * \"dailymotion\",\n * * \"spotify\",\n * * \"youtube\",\n * * \"vimeo\"\n *\n * The names of providers without rendering functions:\n *\n * * \"instagram\",\n * * \"twitter\",\n * * \"googleMaps\",\n * * \"flickr\",\n * * \"facebook\"\n *\n * See the {@link module:media-embed/mediaembed~MediaEmbedProvider provider syntax} to learn more about\n * different kinds of media and media providers.\n *\n * **Note**: The default media provider configuration may not support all possible media URLs,\n * only the most common are included.\n *\n * Media without rendering functions are always represented in the data using the \"semantic\" markup. See\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#previewsInData `config.mediaEmbed.previewsInData`} to\n * learn more about possible data outputs.\n *\n * The priority of media providers corresponds to the order of configuration. The first provider\n * to match the URL is always used, even if there are other providers that support a particular URL.\n * The URL is never matched against the remaining providers.\n *\n * To discard **all** default media providers, simply override this configuration with your own\n * {@link module:media-embed/mediaembed~MediaEmbedProvider definitions}:\n *\n *\t\tClassicEditor\n *\t\t\t.create( editorElement, {\n *\t\t\t\tplugins: [ MediaEmbed, ... ],\n *\t\t\t\tmediaEmbed: {\n *\t\t\t\t\tproviders: [\n *\t\t\t\t\t\t{\n *\t\t\t\t\t\t\t name: 'myProvider',\n *\t\t\t\t\t\t\t url: /^example\\.com\\/media\\/(\\w+)/,\n *\t\t\t\t\t\t\t html: match => '...'\n *\t\t\t\t\t\t},\n *\t\t\t\t\t\t...\n * \t\t\t\t\t]\n *\t\t\t\t}\n *\t\t\t} )\n *\t\t\t.then( ... )\n *\t\t\t.catch( ... );\n *\n * You can take inspiration from the default configuration of this feature which you can find in:\n * https://github.com/ckeditor/ckeditor5-media-embed/blob/master/src/mediaembedediting.js\n *\n * To **extend** the list of default providers, use\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#extraProviders `config.mediaEmbed.extraProviders`}.\n *\n * To **remove** certain providers, use\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#removeProviders `config.mediaEmbed.removeProviders`}.\n *\n * @member {Array.<module:media-embed/mediaembed~MediaEmbedProvider>} module:media-embed/mediaembed~MediaEmbedConfig#providers\n */\n\n/**\n * The additional media providers supported by the editor. This configuration helps extend the default\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#providers}.\n *\n *\t\tClassicEditor\n *\t\t\t.create( editorElement, {\n *\t\t\t\tplugins: [ MediaEmbed, ... ],\n *\t\t\t\tmediaEmbed: {\n *\t\t\t\t\textraProviders: [\n *\t\t\t\t\t\t{\n *\t\t\t\t\t\t\t name: 'extraProvider',\n *\t\t\t\t\t\t\t url: /^example\\.com\\/media\\/(\\w+)/,\n *\t\t\t\t\t\t\t html: match => '...'\n *\t\t\t\t\t\t},\n *\t\t\t\t\t\t...\n * \t\t\t\t\t]\n *\t\t\t\t}\n *\t\t\t} )\n *\t\t\t.then( ... )\n *\t\t\t.catch( ... );\n *\n * See the {@link module:media-embed/mediaembed~MediaEmbedProvider provider syntax} to learn more.\n *\n * @member {Array.<module:media-embed/mediaembed~MediaEmbedProvider>} module:media-embed/mediaembed~MediaEmbedConfig#extraProviders\n */\n\n/**\n * The list of media providers that should not be used despite being available in\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#providers `config.mediaEmbed.providers`} and\n * {@link module:media-embed/mediaembed~MediaEmbedConfig#extraProviders `config.mediaEmbed.extraProviders`}\n *\n *\t\tmediaEmbed: {\n *\t\t\tremoveProviders: [ 'youtube', 'twitter' ]\n *\t\t}\n *\n * @member {Array.<String>} module:media-embed/mediaembed~MediaEmbedConfig#removeProviders\n */\n\n/**\n * Controls the data format produced by the feature.\n *\n * When `false` (default), the feature produces \"semantic\" data, i.e. it does not include the preview of\n * the media, just the `<oembed>` tag with the `url` attribute:\n *\n *\t\t<figure class=\"media\">\n *\t\t\t<oembed url=\"https://url\"></oembed>\n *\t\t</figure>\n *\n * When `true`, the media is represented in the output in the same way it looks in the editor,\n * i.e. the media preview is saved to the database:\n *\n *\t\t<figure class=\"media\">\n *\t\t\t<div data-oembed-url=\"https://url\">\n *\t\t\t\t<iframe src=\"https://preview\"></iframe>\n *\t\t\t</div>\n *\t\t</figure>\n *\n * **Note:** Media without preview are always represented in the data using the \"semantic\" markup\n * regardless of the value of the `previewsInData`. Learn more about different kinds of media\n * in the {@link module:media-embed/mediaembed~MediaEmbedConfig#providers `config.mediaEmbed.providers`}\n * configuration description.\n *\n * @member {Boolean} [module:media-embed/mediaembed~MediaEmbedConfig#previewsInData=false]\n */\n\n\nexport { MediaEmbed as default };","import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.replace\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paste-from-office/filters/space\n */\n\n/**\n * Replaces last space preceding elements closing tag with `&nbsp;`. Such operation prevents spaces from being removed\n * during further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDataFromDomText}).\n * This method also takes into account Word specific `<o:p></o:p>` empty tags.\n * Additionally multiline sequences of spaces and new lines between tags are removed (see #39 and #40).\n *\n * @param {String} htmlString HTML string in which spacing should be normalized.\n * @returns {String} Input HTML with spaces normalized.\n */\nexport function normalizeSpacing(htmlString) {\n  // Run normalizeSafariSpaceSpans() two times to cover nested spans.\n  return normalizeSafariSpaceSpans(normalizeSafariSpaceSpans(htmlString)) // Remove all \\r\\n from \"spacerun spans\" so the last replace line doesn't strip all whitespaces.\n  .replace(/(<span style=['\"]mso-spacerun:yes['\"]>[\\s]*?)[\\r\\n]+(\\s*<\\/span>)/g, '$1$2').replace(/<span style=['\"]mso-spacerun:yes['\"]><\\/span>/g, '').replace(/ <\\//g, \"\\xA0</\").replace(/ <o:p><\\/o:p>/g, \"\\xA0<o:p></o:p>\") // Remove all whitespaces when they contain any \\r or \\n.\n  .replace(/>(\\s*[\\r\\n]\\s*)</g, '><');\n}\n/**\n * Normalizes spacing in special Word `spacerun spans` (`<span style='mso-spacerun:yes'>\\s+</span>`) by replacing\n * all spaces with `&nbsp; ` pairs. This prevents spaces from being removed during further DOM/View processing\n * (see especially {@link module:engine/view/domconverter~DomConverter#_processDataFromDomText}).\n *\n * @param {Document} htmlDocument Native `Document` object in which spacing should be normalized.\n */\n\nexport function normalizeSpacerunSpans(htmlDocument) {\n  htmlDocument.querySelectorAll('span[style*=spacerun]').forEach(function (el) {\n    // Use `el.childNodes[ 0 ].data.length` instead of `el.innerText.length`. For `el.innerText.length` which\n    // contains spaces mixed with `&nbsp;` Edge browser returns incorrect length.\n    var innerTextLength = el.childNodes[0].data.length;\n    el.innerHTML = Array(innerTextLength + 1).join(\"\\xA0 \").substr(0, innerTextLength);\n  });\n} // Normalizes specific spacing generated by Safari when content pasted from Word (`<span class=\"Apple-converted-space\"> </span>`)\n// by replacing all spaces sequences longer than 1 space with `&nbsp; ` pairs. This prevents spaces from being removed during\n// further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDataFromDomText}).\n//\n// This function is similar to {@link module:clipboard/utils/normalizeclipboarddata normalizeClipboardData util} but uses\n// regular spaces / &nbsp; sequence for replacement.\n//\n// @param {String} htmlString HTML string in which spacing should be normalized\n// @returns {String} Input HTML with spaces normalized.\n\nfunction normalizeSafariSpaceSpans(htmlString) {\n  return htmlString.replace(/<span(?: class=\"Apple-converted-space\"|)>(\\s+)<\\/span>/g, function (fullMatch, spaces) {\n    return spaces.length === 1 ? ' ' : Array(spaces.length + 1).join(\"\\xA0 \").substr(0, spaces.length);\n  });\n}","import \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.regexp.replace\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paste-from-office/filters/parse\n */\n\n/* globals DOMParser */\nimport DomConverter from '@ckeditor/ckeditor5-engine/src/view/domconverter';\nimport { NBSP_FILLER } from '@ckeditor/ckeditor5-engine/src/view/filler';\nimport { normalizeSpacing, normalizeSpacerunSpans } from \"./space\";\n/**\n * Parses provided HTML extracting contents of `<body>` and `<style>` tags.\n *\n * @param {String} htmlString HTML string to be parsed.\n * @returns {Object} result\n * @returns {module:engine/view/documentfragment~DocumentFragment} result.body Parsed body\n * content as a traversable structure.\n * @returns {String} result.bodyString Entire body content as a string.\n * @returns {Array.<CSSStyleSheet>} result.styles Array of native `CSSStyleSheet` objects, each representing\n * separate `style` tag from the source HTML.\n * @returns {String} result.stylesString All `style` tags contents combined in the order of occurrence into one string.\n */\n\nexport function parseHtml(htmlString) {\n  var domParser = new DOMParser(); // Remove Word specific \"if comments\" so content inside is not omitted by the parser.\n\n  htmlString = htmlString.replace(/<!--\\[if gte vml 1]>/g, '');\n  var normalizedHtml = normalizeSpacing(cleanContentAfterBody(htmlString)); // Parse htmlString as native Document object.\n\n  var htmlDocument = domParser.parseFromString(normalizedHtml, 'text/html');\n  normalizeSpacerunSpans(htmlDocument); // Get `innerHTML` first as transforming to View modifies the source document.\n\n  var bodyString = htmlDocument.body.innerHTML; // Transform document.body to View.\n\n  var bodyView = documentToView(htmlDocument); // Extract stylesheets.\n\n  var stylesObject = extractStyles(htmlDocument);\n  return {\n    body: bodyView,\n    bodyString: bodyString,\n    styles: stylesObject.styles,\n    stylesString: stylesObject.stylesString\n  };\n} // Transforms native `Document` object into {@link module:engine/view/documentfragment~DocumentFragment}.\n//\n// @param {Document} htmlDocument Native `Document` object to be transformed.\n// @returns {module:engine/view/documentfragment~DocumentFragment}\n\nfunction documentToView(htmlDocument) {\n  var domConverter = new DomConverter({\n    blockFiller: NBSP_FILLER\n  });\n  var fragment = htmlDocument.createDocumentFragment();\n  var nodes = htmlDocument.body.childNodes;\n\n  while (nodes.length > 0) {\n    fragment.appendChild(nodes[0]);\n  }\n\n  return domConverter.domToView(fragment);\n} // Extracts both `CSSStyleSheet` and string representation from all `style` elements available in a provided `htmlDocument`.\n//\n// @param {Document} htmlDocument Native `Document` object from which styles will be extracted.\n// @returns {Object} result\n// @returns {Array.<CSSStyleSheet>} result.styles Array of native `CSSStyleSheet` object, each representing\n// separate `style` tag from the source object.\n// @returns {String} result.stylesString All `style` tags contents combined in the order of occurrence as one string.\n\n\nfunction extractStyles(htmlDocument) {\n  var styles = [];\n  var stylesString = [];\n  var styleTags = Array.from(htmlDocument.getElementsByTagName('style'));\n\n  for (var _i = 0, _styleTags = styleTags; _i < _styleTags.length; _i++) {\n    var style = _styleTags[_i];\n\n    if (style.sheet && style.sheet.cssRules && style.sheet.cssRules.length) {\n      styles.push(style.sheet);\n      stylesString.push(style.innerHTML);\n    }\n  }\n\n  return {\n    styles: styles,\n    stylesString: stylesString.join(' ')\n  };\n} // Removes leftover content from between closing </body> and closing </html> tag:\n//\n// \t\t<html><body><p>Foo Bar</p></body><span>Fo</span></html> -> <html><body><p>Foo Bar</p></body></html>\n//\n// This function is used as specific browsers (Edge) add some random content after `body` tag when pasting from Word.\n// @param {String} htmlString The HTML string to be cleaned.\n// @returns {String} The HTML string with leftover content removed.\n\n\nfunction cleanContentAfterBody(htmlString) {\n  var regexp = /<\\/body>(.*?)(<\\/html>|$)/;\n  var match = htmlString.match(regexp);\n\n  if (match && match[1]) {\n    htmlString = htmlString.slice(0, match.index) + htmlString.slice(match.index).replace(match[1], '');\n  }\n\n  return htmlString;\n}","import \"core-js/modules/es6.regexp.replace\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/view/upcastwriter\n */\nimport DocumentFragment from \"./documentfragment\";\nimport Element from \"./element\";\nimport Text from \"./text\";\nimport { isPlainObject } from 'lodash-es';\nimport Position from \"./position\";\nimport Range from \"./range\";\nimport Selection from \"./selection\";\n/**\n * View upcast writer. It provides a set of methods used to manipulate non-semantic view trees.\n *\n * It should be used only while working on a non-semantic view\n * (e.g. a view created from HTML string on paste).\n * To manipulate a view which was or is being downcasted from the the model use the\n * {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n *\n * Unlike `DowncastWriter`, which is available in the {@link module:engine/view/view~View#change `View#change()`} block,\n * `UpcastWriter` can wherever you need it:\n *\n *\t\tconst writer = new UpcastWriter();\n *\t\tconst text = writer.createText( 'foo!' );\n *\n *\t\twriter.appendChild( text, someViewElement );\n */\n\nvar UpcastWriter =\n/*#__PURE__*/\nfunction () {\n  function UpcastWriter() {\n    _classCallCheck(this, UpcastWriter);\n  }\n\n  _createClass(UpcastWriter, [{\n    key: \"createDocumentFragment\",\n\n    /**\n     * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.\n     *\n     * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n     * A list of nodes to be inserted into the created document fragment.\n     * @returns {module:engine/view/documentfragment~DocumentFragment} The created document fragment.\n     */\n    value: function createDocumentFragment(children) {\n      return new DocumentFragment(children);\n    }\n    /**\n     * Creates a new {@link module:engine/view/element~Element} instance.\n     *\n     * Attributes can be passed in various formats:\n     *\n     *\t\tupcastWriter.createElement( 'div', { class: 'editor', contentEditable: 'true' } ); // object\n     *\t\tupcastWriter.createElement( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator\n     *\t\tupcastWriter.createElement( 'div', mapOfAttributes ); // map\n     *\n     * @param {String} name Node name.\n     * @param {Object|Iterable} [attrs] Collection of attributes.\n     * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n     * A list of nodes to be inserted into created element.\n     * @returns {module:engine/view/element~Element} Created element.\n     */\n\n  }, {\n    key: \"createElement\",\n    value: function createElement(name, attrs, children) {\n      return new Element(name, attrs, children);\n    }\n    /**\n     * Creates a new {@link module:engine/view/text~Text} instance.\n     *\n     * @param {String} data The text's data.\n     * @returns {module:engine/view/text~Text} The created text node.\n     */\n\n  }, {\n    key: \"createText\",\n    value: function createText(data) {\n      return new Text(data);\n    }\n    /**\n     * Clones the provided element.\n     *\n     * @see module:engine/view/element~Element#_clone\n     * @param {module:engine/view/element~Element} element Element to be cloned.\n     * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n     * element will be cloned without any children.\n     * @returns {module:engine/view/element~Element} Clone of this element.\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone(element) {\n      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return element._clone(deep);\n    }\n    /**\n     * Appends a child node or a list of child nodes at the end of this node\n     * and sets the parent of these nodes to this element.\n     *\n     * @see module:engine/view/element~Element#_appendChild\n     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} element Element\n     * to which items will be appended.\n     * @fires module:engine/view/node~Node#event:change\n     * @returns {Number} Number of appended nodes.\n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(items, element) {\n      return element._appendChild(items);\n    }\n    /**\n     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n     * this element.\n     *\n     * @see module:engine/view/element~Element#_insertChild\n     * @param {Number} index Offset at which nodes should be inserted.\n     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} element Element\n     * to which items will be inserted.\n     * @fires module:engine/view/node~Node#event:change\n     * @returns {Number} Number of inserted nodes.\n     */\n\n  }, {\n    key: \"insertChild\",\n    value: function insertChild(index, items, element) {\n      return element._insertChild(index, items);\n    }\n    /**\n     * Removes the given number of child nodes starting at the given index and set the parent of these nodes to `null`.\n     *\n     * @see module:engine/view/element~Element#_removeChildren\n     * @param {Number} index Offset from which nodes will be removed.\n     * @param {Number} howMany Number of nodes to remove.\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} element Element\n     * which children will be removed.\n     * @fires module:engine/view/node~Node#event:change\n     * @returns {Array.<module:engine/view/node~Node>} The array containing removed nodes.\n     */\n\n  }, {\n    key: \"removeChildren\",\n    value: function removeChildren(index, howMany, element) {\n      return element._removeChildren(index, howMany);\n    }\n    /**\n     * Removes given element from the view structure. Will not have effect on detached elements.\n     *\n     * @param {module:engine/view/element~Element} element Element which will be removed.\n     * @returns {Array.<module:engine/view/node~Node>} The array containing removed nodes.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(element) {\n      var parent = element.parent;\n\n      if (parent) {\n        return this.removeChildren(parent.getChildIndex(element), 1, parent);\n      }\n\n      return [];\n    }\n    /**\n     * Replaces given element with the new one in the view structure. Will not have effect on detached elements.\n     *\n     * @param {module:engine/view/element~Element} oldElement Element which will be replaced.\n     * @param {module:engine/view/element~Element} newElement Element which will be inserted in the place of the old element.\n     * @returns {Boolean} Whether old element was successfully replaced.\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(oldElement, newElement) {\n      var parent = oldElement.parent;\n\n      if (parent) {\n        var index = parent.getChildIndex(oldElement);\n        this.removeChildren(index, 1, parent);\n        this.insertChild(index, newElement, parent);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Renames element by creating a copy of a given element but with its name changed and then moving contents of the\n     * old element to the new one.\n     *\n     * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n     *\n     * @param {String} newName New element name.\n     * @param {module:engine/view/element~Element} element Element to be renamed.\n     * @returns {module:engine/view/element~Element|null} New element or null if the old element\n     * was not replaced (happens for detached elements).\n     */\n\n  }, {\n    key: \"rename\",\n    value: function rename(newName, element) {\n      var newElement = new Element(newName, element.getAttributes(), element.getChildren());\n      return this.replace(element, newElement) ? newElement : null;\n    }\n    /**\n     * Adds or overwrites element's attribute with a specified key and value.\n     *\n     *\t\twriter.setAttribute( linkElement, 'href', 'http://ckeditor.com' );\n     *\n     * @see module:engine/view/element~Element#_setAttribute\n     * @param {String} key Attribute key.\n     * @param {String} value Attribute value.\n     * @param {module:engine/view/element~Element} element Element for which attribute will be set.\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value, element) {\n      element._setAttribute(key, value);\n    }\n    /**\n     * Removes attribute from the element.\n     *\n     *\t\twriter.removeAttribute( linkElement, 'href' );\n     *\n     * @see module:engine/view/element~Element#_removeAttribute\n     * @param {String} key Attribute key.\n     * @param {module:engine/view/element~Element} element Element from which attribute will be removed.\n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key, element) {\n      element._removeAttribute(key);\n    }\n    /**\n     * Adds specified class to the element.\n     *\n     *\t\twriter.addClass( linkElement, 'foo' );\n     *\t\twriter.addClass( linkElement, [ 'foo', 'bar' ] );\n     *\n     * @see module:engine/view/element~Element#_addClass\n     * @param {Array.<String>|String} className Single class name or array of class names which will be added.\n     * @param {module:engine/view/element~Element} element Element for which class will be added.\n     */\n\n  }, {\n    key: \"addClass\",\n    value: function addClass(className, element) {\n      element._addClass(className);\n    }\n    /**\n     * Removes specified class from the element.\n     *\n     *\t\twriter.removeClass( linkElement, 'foo' );\n     *\t\twriter.removeClass( linkElement, [ 'foo', 'bar' ] );\n     *\n     * @see module:engine/view/element~Element#_removeClass\n     * @param {Array.<String>|String} className Single class name or array of class names which will be removed.\n     * @param {module:engine/view/element~Element} element Element from which class will be removed.\n     */\n\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(className, element) {\n      element._removeClass(className);\n    }\n    /**\n     * Adds style to the element.\n     *\n     *\t\twriter.setStyle( element, 'color', 'red' );\n     *\t\twriter.setStyle( element, {\n     *\t\t\tcolor: 'red',\n     *\t\t\tposition: 'fixed'\n     *\t\t} );\n     *\n     * @see module:engine/view/element~Element#_setStyle\n     * @param {String|Object} property Property name or object with key - value pairs.\n     * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n     * @param {module:engine/view/element~Element} element Element for which style will be added.\n     */\n\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(property, value, element) {\n      if (isPlainObject(property) && element === undefined) {\n        element = value;\n      }\n\n      element._setStyle(property, value);\n    }\n    /**\n     * Removes specified style from the element.\n     *\n     *\t\twriter.removeStyle( element, 'color' );  // Removes 'color' style.\n     *\t\twriter.removeStyle( element, [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.\n     *\n     * @see module:engine/view/element~Element#_removeStyle\n     * @param {Array.<String>|String} property Style property name or names to be removed.\n     * @param {module:engine/view/element~Element} element Element from which style will be removed.\n     */\n\n  }, {\n    key: \"removeStyle\",\n    value: function removeStyle(property, element) {\n      element._removeStyle(property);\n    }\n    /**\n     * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n     * so they can be used to add special data to elements.\n     *\n     * @see module:engine/view/element~Element#_setCustomProperty\n     * @param {String|Symbol} key Custom property name/key.\n     * @param {*} value Custom property value to be stored.\n     * @param {module:engine/view/element~Element} element Element for which custom property will be set.\n     */\n\n  }, {\n    key: \"setCustomProperty\",\n    value: function setCustomProperty(key, value, element) {\n      element._setCustomProperty(key, value);\n    }\n    /**\n     * Removes a custom property stored under the given key.\n     *\n     * @see module:engine/view/element~Element#_removeCustomProperty\n     * @param {String|Symbol} key Name/key of the custom property to be removed.\n     * @param {module:engine/view/element~Element} element Element from which the custom property will be removed.\n     * @returns {Boolean} Returns true if property was removed.\n     */\n\n  }, {\n    key: \"removeCustomProperty\",\n    value: function removeCustomProperty(key, element) {\n      return element._removeCustomProperty(key);\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/view/position~Position position},\n     * * parent element and offset (offset defaults to `0`),\n     * * parent element and `'end'` (sets position at the end of that element),\n     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n     *\n     * This method is a shortcut to other constructors such as:\n     *\n     * * {@link #createPositionBefore},\n     * * {@link #createPositionAfter},\n     *\n     * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     */\n\n  }, {\n    key: \"createPositionAt\",\n    value: function createPositionAt(itemOrPosition, offset) {\n      return Position._createAt(itemOrPosition, offset);\n    }\n    /**\n     * Creates a new position after given view item.\n     *\n     * @param {module:engine/view/item~Item} item View item after which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAfter\",\n    value: function createPositionAfter(item) {\n      return Position._createAfter(item);\n    }\n    /**\n     * Creates a new position before given view item.\n     *\n     * @param {module:engine/view/item~Item} item View item before which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"createPositionBefore\",\n    value: function createPositionBefore(item) {\n      return Position._createBefore(item);\n    }\n    /**\n     * Creates a range spanning from `start` position to `end` position.\n     *\n     * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n     *\n     * @param {module:engine/view/position~Position} start Start position.\n     * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"createRange\",\n    value: function createRange(start, end) {\n      return new Range(start, end);\n    }\n    /**\n     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n     *\n     * @param {module:engine/view/item~Item} item\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"createRangeOn\",\n    value: function createRangeOn(item) {\n      return Range._createOn(item);\n    }\n    /**\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"createRangeIn\",\n    value: function createRangeIn(element) {\n      return Range._createIn(element);\n    }\n    /**\n     * Creates a new {@link module:engine/view/selection~Selection} instance.\n     *\n     * \t\t// Creates empty selection without ranges.\n     *\t\tconst selection = writer.createSelection();\n     *\n     *\t\t// Creates selection at the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tconst selection = writer.createSelection( range );\n     *\n     *\t\t// Creates selection at the given ranges\n     * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tconst selection = writer.createSelection( ranges );\n     *\n     *\t\t// Creates selection from the other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tconst selection = writer.createSelection( otherSelection );\n     *\n     *\t\t// Creates selection from the document selection.\n     *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n     *\n     * \t\t// Creates selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tconst selection = writer.createSelection( position );\n     *\n     *\t\t// Creates collapsed selection at the position of given item and offset.\n     *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n     *\t\tconst selection = writer.createSelection( paragraph, offset );\n     *\n     *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n     *\t\t// first child of that element and ends after the last child of that element.\n     *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n     *\t\t// just after the item.\n     *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n     *\n     * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n     *\n     *\t\t// Creates backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n     * represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n     * (and be  properly handled by screen readers).\n     *\n     *\t\t// Creates fake selection with label.\n     *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n     *\n     * @param {module:engine/view/selection~Selectable} [selectable=null]\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n     * @param {String} [options.label] Label for the fake selection.\n     * @returns {module:engine/view/selection~Selection}\n     */\n\n  }, {\n    key: \"createSelection\",\n    value: function createSelection(selectable, placeOrOffset, options) {\n      return new Selection(selectable, placeOrOffset, options);\n    }\n  }]);\n\n  return UpcastWriter;\n}();\n\nexport { UpcastWriter as default };","import \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paste-from-office/filters/list\n */\nimport Element from '@ckeditor/ckeditor5-engine/src/view/element';\nimport Matcher from '@ckeditor/ckeditor5-engine/src/view/matcher';\nimport UpcastWriter from '@ckeditor/ckeditor5-engine/src/view/upcastwriter';\n/**\n * Transforms Word specific list-like elements to the semantic HTML lists.\n *\n * Lists in Word are represented by block elements with special attributes like:\n *\n *\t\t<p class=MsoListParagraphCxSpFirst style='mso-list:l1 level1 lfo1'>...</p> // Paragraph based list.\n *\t\t<h1 style='mso-list:l0 level1 lfo1'>...</h1> // Heading 1 based list.\n *\n * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment The view structure which to transform.\n * @param {String} stylesString Styles from which list-like elements styling will be extracted.\n */\n\nexport function transformListItemLikeElementsIntoLists(documentFragment, stylesString) {\n  if (!documentFragment.childCount) {\n    return;\n  }\n\n  var writer = new UpcastWriter();\n  var itemLikeElements = findAllItemLikeElements(documentFragment, writer);\n\n  if (!itemLikeElements.length) {\n    return;\n  }\n\n  var currentList = null;\n  itemLikeElements.forEach(function (itemLikeElement, i) {\n    if (!currentList || isNewListNeeded(itemLikeElements[i - 1], itemLikeElement)) {\n      var listStyle = detectListStyle(itemLikeElement, stylesString);\n      currentList = insertNewEmptyList(listStyle, itemLikeElement.element, writer);\n    }\n\n    var listItem = transformElementIntoListItem(itemLikeElement.element, writer);\n    writer.appendChild(listItem, currentList);\n  });\n} // Finds all list-like elements in a given document fragment.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment\n// in which to look for list-like nodes.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {Array.<Object>} Array of found list-like items. Each item is an object containing:\n//\n//\t\t* {module:engine/src/view/element~Element} element List-like element.\n//\t\t* {Number} id List item id parsed from `mso-list` style (see `getListItemData()` function).\n//\t\t* {Number} order List item creation order parsed from `mso-list` style (see `getListItemData()` function).\n//\t\t* {Number} indent List item indentation level parsed from `mso-list` style (see `getListItemData()` function).\n\nfunction findAllItemLikeElements(documentFragment, writer) {\n  var range = writer.createRangeIn(documentFragment); // Matcher for finding list-like elements.\n\n  var itemLikeElementsMatcher = new Matcher({\n    name: /^p|h\\d+$/,\n    styles: {\n      'mso-list': /.*/\n    }\n  });\n  var itemLikeElements = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = range[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      if (value.type === 'elementStart' && itemLikeElementsMatcher.match(value.item)) {\n        var itemData = getListItemData(value.item);\n        itemLikeElements.push({\n          element: value.item,\n          id: itemData.id,\n          order: itemData.order,\n          indent: itemData.indent\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return itemLikeElements;\n} // Extracts list item style from the provided CSS.\n//\n// List item style is extracted from CSS stylesheet. Each list with its specific style attribute\n// value (`mso-list:l1 level1 lfo1`) has its dedicated properties in a CSS stylesheet defined with a selector like:\n//\n// \t\t@list l1:level1 { ... }\n//\n// It contains `mso-level-number-format` property which defines list numbering/bullet style. If this property\n// is not defined it means default `decimal` numbering.\n//\n// Here CSS string representation is used as `mso-level-number-format` property is an invalid CSS property\n// and will be removed during CSS parsing.\n//\n// @param {Object} listLikeItem List-like item for which list style will be searched for. Usually\n// a result of `findAllItemLikeElements()` function.\n// @param {String} stylesString CSS stylesheet.\n// @returns {Object} result\n// @returns {String} result.type List type, could be `ul` or `ol`.\n// @returns {String} result.style List style, for example: `decimal`, `lower-roman`, etc. It is extracted\n// directly from Word stylesheet without further processing and may be not compatible\n// with CSS `list-style-type` property accepted values.\n\n\nfunction detectListStyle(listLikeItem, stylesString) {\n  var listStyleRegexp = new RegExp(\"@list l\".concat(listLikeItem.id, \":level\").concat(listLikeItem.indent, \"\\\\s*({[^}]*)\"), 'gi');\n  var listStyleTypeRegex = /mso-level-number-format:([^;]*);/gi;\n  var listStyleMatch = listStyleRegexp.exec(stylesString);\n  var listStyleType = 'decimal'; // Decimal is default one.\n\n  if (listStyleMatch && listStyleMatch[1]) {\n    var listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);\n\n    if (listStyleTypeMatch && listStyleTypeMatch[1]) {\n      listStyleType = listStyleTypeMatch[1].trim();\n    }\n  }\n\n  return {\n    type: listStyleType !== 'bullet' && listStyleType !== 'image' ? 'ol' : 'ul',\n    style: listStyleType\n  };\n} // Creates empty list of a given type and inserts it after a specified element.\n//\n// @param {Object} listStyle List style object which determines the type of newly created list.\n// Usually a result of `detectListStyle()` function.\n// @param {module:engine/view/element~Element} element Element before which list is inserted.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {module:engine/view/element~Element} Newly created list element.\n\n\nfunction insertNewEmptyList(listStyle, element, writer) {\n  var list = new Element(listStyle.type);\n  var position = element.parent.getChildIndex(element);\n  writer.insertChild(position, list, element.parent);\n  return list;\n} // Transforms given element into a semantic list item. As the function operates on a provided\n// {module:engine/src/view/element~Element element} it will modify the view structure to which this element belongs.\n//\n// @param {module:engine/view/element~Element} element Element which will be transformed into list item.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {module:engine/view/element~Element} New element to which the given one was transformed. It is\n// inserted in place of the old element (the reference to the old element is lost due to renaming).\n\n\nfunction transformElementIntoListItem(element, writer) {\n  removeBulletElement(element, writer);\n  return writer.rename('li', element);\n} // Extracts list item information from Word specific list-like element style:\n//\n//\t\t`style=\"mso-list:l1 level1 lfo1\"`\n//\n// where:\n//\n//\t\t* `l1` is a list id (however it does not mean this is a continuous list - see #43),\n//\t\t* `level1` is a list item indentation level,\n//\t\t* `lfo1` is a list insertion order in a document.\n//\n// @param {module:engine/view/element~Element} element Element from which style data is extracted.\n// @returns {Object} result\n// @returns {Number} result.id Parent list id.\n// @returns {Number} result.order List item creation order.\n// @returns {Number} result.indent List item indentation level.\n\n\nfunction getListItemData(element) {\n  var data = {};\n  var listStyle = element.getStyle('mso-list');\n\n  if (listStyle) {\n    data.id = parseInt(listStyle.match(/(^|\\s+)l(\\d+)/i)[2]);\n    data.order = parseInt(listStyle.match(/\\s*lfo(\\d+)/i)[1]);\n    data.indent = parseInt(listStyle.match(/\\s*level(\\d+)/i)[1]);\n  }\n\n  return data;\n} // Removes span with a numbering/bullet from a given element.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n\n\nfunction removeBulletElement(element, writer) {\n  // Matcher for finding `span` elements holding lists numbering/bullets.\n  var bulletMatcher = new Matcher({\n    name: 'span',\n    styles: {\n      'mso-list': 'Ignore'\n    }\n  });\n  var range = writer.createRangeIn(element);\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = range[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var value = _step2.value;\n\n      if (value.type === 'elementStart' && bulletMatcher.match(value.item)) {\n        writer.remove(value.item);\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n} // Whether previous and current item belongs to the same list. It is determined based on `item.id`\n// (extracted from `mso-list` style, see #getListItemData) and previous sibling of the current item.\n//\n// @param {Object} previousItem\n// @param {Object} currentItem\n// @returns {Boolean}\n\n\nfunction isNewListNeeded(previousItem, currentItem) {\n  if (previousItem.id !== currentItem.id) {\n    return true;\n  }\n\n  var previousSibling = currentItem.element.previousSibling;\n\n  if (!previousSibling) {\n    return true;\n  } // Even with the same id the list does not have to be continuous (#43).\n\n\n  return !previousSibling.is('ul') && !previousSibling.is('ol');\n}","import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/es6.string.starts-with\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.match\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paste-from-office/filters/image\n */\n\n/* globals btoa */\nimport ViewMatcher from '@ckeditor/ckeditor5-engine/src/view/matcher';\nimport UpcastWriter from '@ckeditor/ckeditor5-engine/src/view/upcastwriter';\n/**\n * Replaces source attribute of all `<img>` elements representing regular\n * images (not the Word shapes) with inlined base64 image representation extracted from RTF or Blob data.\n *\n * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment on which transform images.\n * @param {String} rtfData The RTF data from which images representation will be used.\n */\n\nexport function replaceImagesSourceWithBase64(documentFragment, rtfData) {\n  if (!documentFragment.childCount) {\n    return;\n  }\n\n  var upcastWriter = new UpcastWriter();\n  var shapesIds = findAllShapesIds(documentFragment, upcastWriter);\n  removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);\n  removeAllShapeElements(documentFragment, upcastWriter);\n  var images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);\n\n  if (images.length) {\n    replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);\n  }\n}\n/**\n * Converts given HEX string to base64 representation.\n *\n * @protected\n * @param {String} hexString The HEX string to be converted.\n * @returns {String} Base64 representation of a given HEX string.\n */\n\nexport function _convertHexToBase64(hexString) {\n  return btoa(hexString.match(/\\w{2}/g).map(function (char) {\n    return String.fromCharCode(parseInt(char, 16));\n  }).join(''));\n} // Finds all shapes (`<v:*>...</v:*>`) ids. Shapes can represent images (canvas)\n// or Word shapes (which does not have RTF or Blob representation).\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment\n// from which to extract shape ids.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {Array.<String>} Array of shape ids.\n\nfunction findAllShapesIds(documentFragment, writer) {\n  var range = writer.createRangeIn(documentFragment);\n  var shapeElementsMatcher = new ViewMatcher({\n    name: /v:(.+)/\n  });\n  var shapesIds = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = range[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n      var el = value.item;\n      var prevSiblingName = el.previousSibling && el.previousSibling.name || null; // If shape element have 'o:gfxdata' attribute and is not directly before `<v:shapetype>` element it means it represent Word shape.\n\n      if (shapeElementsMatcher.match(el) && el.getAttribute('o:gfxdata') && prevSiblingName !== 'v:shapetype') {\n        shapesIds.push(value.item.getAttribute('id'));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return shapesIds;\n} // Removes all `<img>` elements which represents Word shapes and not regular images.\n//\n// @param {Array.<String>} shapesIds Shape ids which will be checked against `<img>` elements.\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment from which to remove `<img>` elements.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n\n\nfunction removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {\n  var range = writer.createRangeIn(documentFragment);\n  var imageElementsMatcher = new ViewMatcher({\n    name: 'img'\n  });\n  var imgs = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = range[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var value = _step2.value;\n\n      if (imageElementsMatcher.match(value.item)) {\n        var el = value.item;\n        var shapes = el.getAttribute('v:shapes') ? el.getAttribute('v:shapes').split(' ') : [];\n\n        if (shapes.length && shapes.every(function (shape) {\n          return shapesIds.indexOf(shape) > -1;\n        })) {\n          imgs.push(el); // Shapes may also have empty source while content is paste in some browsers (Safari).\n        } else if (!el.getAttribute('src')) {\n          imgs.push(el);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  for (var _i = 0, _imgs = imgs; _i < _imgs.length; _i++) {\n    var img = _imgs[_i];\n    writer.remove(img);\n  }\n} // Removes all shape elements (`<v:*>...</v:*>`) so they do not pollute the output structure.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment from which to remove shape elements.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n\n\nfunction removeAllShapeElements(documentFragment, writer) {\n  var range = writer.createRangeIn(documentFragment);\n  var shapeElementsMatcher = new ViewMatcher({\n    name: /v:(.+)/\n  });\n  var shapes = [];\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = range[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var value = _step3.value;\n\n      if (shapeElementsMatcher.match(value.item)) {\n        shapes.push(value.item);\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  for (var _i2 = 0, _shapes = shapes; _i2 < _shapes.length; _i2++) {\n    var shape = _shapes[_i2];\n    writer.remove(shape);\n  }\n} // Finds all `<img>` elements in a given document fragment which have source pointing to local `file://` resource.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment in which to look for `<img>` elements.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n// @returns {Object} result All found images grouped by source type.\n// @returns {Array.<module:engine/view/element~Element>} result.file Array of found `<img>` elements with `file://` source.\n// @returns {Array.<module:engine/view/element~Element>} result.blob Array of found `<img>` elements with `blob:` source.\n\n\nfunction findAllImageElementsWithLocalSource(documentFragment, writer) {\n  var range = writer.createRangeIn(documentFragment);\n  var imageElementsMatcher = new ViewMatcher({\n    name: 'img'\n  });\n  var imgs = [];\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = range[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var value = _step4.value;\n\n      if (imageElementsMatcher.match(value.item)) {\n        if (value.item.getAttribute('src').startsWith('file://')) {\n          imgs.push(value.item);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return imgs;\n} // Extracts all images HEX representations from a given RTF data.\n//\n// @param {String} rtfData The RTF data from which to extract images HEX representation.\n// @returns {Array.<Object>} Array of found HEX representations. Each array item is an object containing:\n//\n// \t\t* {String} hex Image representation in HEX format.\n// \t\t* {string} type Type of image, `image/png` or `image/jpeg`.\n\n\nfunction extractImageDataFromRtf(rtfData) {\n  if (!rtfData) {\n    return [];\n  }\n\n  var regexPictureHeader = /{\\\\pict[\\s\\S]+?\\\\bliptag-?\\d+(\\\\blipupi-?\\d+)?({\\\\\\*\\\\blipuid\\s?[\\da-fA-F]+)?[\\s}]*?/;\n  var regexPicture = new RegExp('(?:(' + regexPictureHeader.source + '))([\\\\da-fA-F\\\\s]+)\\\\}', 'g');\n  var images = rtfData.match(regexPicture);\n  var result = [];\n\n  if (images) {\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = images[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var image = _step5.value;\n        var imageType = false;\n\n        if (image.includes('\\\\pngblip')) {\n          imageType = 'image/png';\n        } else if (image.includes('\\\\jpegblip')) {\n          imageType = 'image/jpeg';\n        }\n\n        if (imageType) {\n          result.push({\n            hex: image.replace(regexPictureHeader, '').replace(/[^\\da-fA-F]/g, ''),\n            type: imageType\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n  }\n\n  return result;\n} // Replaces `src` attribute value of all given images with the corresponding base64 image representation.\n//\n// @param {Array.<module:engine/view/element~Element>} imageElements Array of image elements which will have its source replaced.\n// @param {Array.<Object>} imagesHexSources Array of images hex sources (usually the result of `extractImageDataFromRtf()` function).\n// The array should be the same length as `imageElements` parameter.\n// @param {module:engine/view/upcastwriter~UpcastWriter} writer\n\n\nfunction replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {\n  // Assume there is an equal amount of image elements and images HEX sources so they can be matched accordingly based on existing order.\n  if (imageElements.length === imagesHexSources.length) {\n    for (var i = 0; i < imageElements.length; i++) {\n      var newSrc = \"data:\".concat(imagesHexSources[i].type, \";base64,\").concat(_convertHexToBase64(imagesHexSources[i].hex));\n      writer.setAttribute('src', newSrc, imageElements[i]);\n    }\n  }\n}","import \"core-js/modules/es6.regexp.match\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paste-from-office/pastefromoffice\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport { parseHtml } from \"./filters/parse\";\nimport { transformListItemLikeElementsIntoLists } from \"./filters/list\";\nimport { replaceImagesSourceWithBase64 } from \"./filters/image\";\n/**\n * The Paste from Office plugin.\n *\n * This plugin handles content pasted from Office apps (for now only Word) and transforms it (if necessary)\n * to a valid structure which can then be understood by the editor features.\n *\n * For more information about this feature check the {@glink api/paste-from-office package page}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar PasteFromOffice =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(PasteFromOffice, _Plugin);\n\n  function PasteFromOffice() {\n    _classCallCheck(this, PasteFromOffice);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PasteFromOffice).apply(this, arguments));\n  }\n\n  _createClass(PasteFromOffice, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var _this = this;\n\n      var editor = this.editor;\n      this.listenTo(editor.plugins.get('Clipboard'), 'inputTransformation', function (evt, data) {\n        var html = data.dataTransfer.getData('text/html');\n\n        if (data.pasteFromOfficeProcessed !== true && isWordInput(html)) {\n          data.content = _this._normalizeWordInput(html, data.dataTransfer); // Set the flag so if `inputTransformation` is re-fired, PFO will not process it again (#44).\n\n          data.pasteFromOfficeProcessed = true;\n        }\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * Normalizes input pasted from Word to format suitable for editor {@link module:engine/model/model~Model}.\n     *\n     * **Note**: this function was exposed mainly for testing purposes and should not be called directly.\n     *\n     * @protected\n     * @param {String} input Word input.\n     * @param {module:clipboard/datatransfer~DataTransfer} dataTransfer Data transfer instance.\n     * @returns {module:engine/view/documentfragment~DocumentFragment} Normalized input.\n     */\n\n  }, {\n    key: \"_normalizeWordInput\",\n    value: function _normalizeWordInput(input, dataTransfer) {\n      var _parseHtml = parseHtml(input),\n          body = _parseHtml.body,\n          stylesString = _parseHtml.stylesString;\n\n      transformListItemLikeElementsIntoLists(body, stylesString);\n      replaceImagesSourceWithBase64(body, dataTransfer.getData('text/rtf'));\n      return body;\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'PasteFromOffice';\n    }\n  }]);\n\n  return PasteFromOffice;\n}(Plugin); // Checks if given HTML string is a result of pasting content from Word.\n//\n// @param {String} html HTML string to test.\n// @returns {Boolean} True if given HTML string is a Word HTML.\n\n\nexport { PasteFromOffice as default };\n\nfunction isWordInput(html) {\n  return !!(html && (html.match(/<meta\\s*name=\"?generator\"?\\s*content=\"?microsoft\\s*word\\s*\\d+\"?\\/?>/gi) || html.match(/xmlns:o=\"urn:schemas-microsoft-com/gi)));\n}","import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.array.find\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/converters\n */\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n/**\n * Returns a function that converts the image view representation:\n *\n *\t\t<figure class=\"image\"><img src=\"...\" alt=\"...\"></img></figure>\n *\n * to the model representation:\n *\n *\t\t<image src=\"...\" alt=\"...\"></image>\n *\n * The entire content of the `<figure>` element except the first `<img>` is being converted as children\n * of the `<image>` model element.\n *\n * @returns {Function}\n */\n\nexport function viewFigureToModel() {\n  return function (dispatcher) {\n    dispatcher.on('element:figure', converter);\n  };\n\n  function converter(evt, data, conversionApi) {\n    // Do not convert if this is not an \"image figure\".\n    if (!conversionApi.consumable.test(data.viewItem, {\n      name: true,\n      classes: 'image'\n    })) {\n      return;\n    } // Find an image element inside the figure element.\n\n\n    var viewImage = Array.from(data.viewItem.getChildren()).find(function (viewChild) {\n      return viewChild.is('img');\n    }); // Do not convert if image element is absent, is missing src attribute or was already converted.\n\n    if (!viewImage || !viewImage.hasAttribute('src') || !conversionApi.consumable.test(viewImage, {\n      name: true\n    })) {\n      return;\n    } // Convert view image to model image.\n\n\n    var conversionResult = conversionApi.convertItem(viewImage, data.modelCursor); // Get image element from conversion result.\n\n    var modelImage = first(conversionResult.modelRange.getItems()); // When image wasn't successfully converted then finish conversion.\n\n    if (!modelImage) {\n      return;\n    } // Convert rest of the figure element's children as an image children.\n\n\n    conversionApi.convertChildren(data.viewItem, conversionApi.writer.createPositionAt(modelImage, 0)); // Set image range as conversion result.\n\n    data.modelRange = conversionResult.modelRange; // Continue conversion where image conversion ends.\n\n    data.modelCursor = conversionResult.modelCursor;\n  }\n}\n/**\n * Converter used to convert the `srcset` model image attribute to the `srcset`, `sizes` and `width` attributes in the view.\n *\n * @returns {Function}\n */\n\nexport function srcsetAttributeConverter() {\n  return function (dispatcher) {\n    dispatcher.on('attribute:srcset:image', converter);\n  };\n\n  function converter(evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    var writer = conversionApi.writer;\n    var figure = conversionApi.mapper.toViewElement(data.item);\n    var img = figure.getChild(0);\n\n    if (data.attributeNewValue === null) {\n      var srcset = data.attributeOldValue;\n\n      if (srcset.data) {\n        writer.removeAttribute('srcset', img);\n        writer.removeAttribute('sizes', img);\n\n        if (srcset.width) {\n          writer.removeAttribute('width', img);\n        }\n      }\n    } else {\n      var _srcset = data.attributeNewValue;\n\n      if (_srcset.data) {\n        writer.setAttribute('srcset', _srcset.data, img); // Always outputting `100vw`. See https://github.com/ckeditor/ckeditor5-image/issues/2.\n\n        writer.setAttribute('sizes', '100vw', img);\n\n        if (_srcset.width) {\n          writer.setAttribute('width', _srcset.width, img);\n        }\n      }\n    }\n  }\n}\nexport function modelToViewAttributeConverter(attributeKey) {\n  return function (dispatcher) {\n    dispatcher.on(\"attribute:\".concat(attributeKey, \":image\"), converter);\n  };\n\n  function converter(evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    var viewWriter = conversionApi.writer;\n    var figure = conversionApi.mapper.toViewElement(data.item);\n    var img = figure.getChild(0);\n\n    if (data.attributeNewValue !== null) {\n      viewWriter.setAttribute(data.attributeKey, data.attributeNewValue, img);\n    } else {\n      viewWriter.removeAttribute(data.attributeKey, img);\n    }\n  }\n}","import _toConsumableArray from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/utils\n */\nimport { findOptimalInsertionPosition, isWidget, toWidget } from '@ckeditor/ckeditor5-widget/src/utils';\n/**\n * Converts a given {@link module:engine/view/element~Element} to an image widget:\n * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget element.\n * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.\n * @param {String} label The element's label. It will be concatenated with the image `alt` attribute if one is present.\n * @returns {module:engine/view/element~Element}\n */\n\nexport function toImageWidget(viewElement, writer, label) {\n  writer.setCustomProperty('image', true, viewElement);\n  return toWidget(viewElement, writer, {\n    label: labelCreator\n  });\n\n  function labelCreator() {\n    var imgElement = viewElement.getChild(0);\n    var altText = imgElement.getAttribute('alt');\n    return altText ? \"\".concat(altText, \" \").concat(label) : label;\n  }\n}\n/**\n * Checks if a given view element is an image widget.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @returns {Boolean}\n */\n\nexport function isImageWidget(viewElement) {\n  return !!viewElement.getCustomProperty('image') && isWidget(viewElement);\n}\n/**\n * Returns an image widget editing view element if one is selected.\n *\n * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection\n * @returns {module:engine/view/element~Element|null}\n */\n\nexport function getSelectedImageWidget(selection) {\n  var viewElement = selection.getSelectedElement();\n\n  if (viewElement && isImageWidget(viewElement)) {\n    return viewElement;\n  }\n\n  return null;\n}\n/**\n * Checks if the provided model element is an `image`.\n *\n * @param {module:engine/model/element~Element} modelElement\n * @returns {Boolean}\n */\n\nexport function isImage(modelElement) {\n  return !!modelElement && modelElement.is('image');\n}\n/**\n * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionPosition} method.\n *\n *\t\tmodel.change( writer => {\n *\t\t\tinsertImage( writer, model, { src: 'path/to/image.jpg' } );\n *\t\t} );\n *\n * @param {module:engine/model/writer~Writer} writer\n * @param {module:engine/model/model~Model} model\n * @param {Object} [attributes={}] Attributes of inserted image\n */\n\nexport function insertImage(writer, model) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var imageElement = writer.createElement('image', attributes);\n  var insertAtSelection = findOptimalInsertionPosition(model.document.selection, model);\n  model.insertContent(imageElement, insertAtSelection); // Inserting an image might've failed due to schema regulations.\n\n  if (imageElement.parent) {\n    writer.setSelection(imageElement, 'on');\n  }\n}\n/**\n * Checks if image can be inserted at current model selection.\n *\n * @param {module:engine/model/model~Model} model\n * @returns {Boolean}\n */\n\nexport function isImageAllowed(model) {\n  var schema = model.schema;\n  var selection = model.document.selection;\n  return isImageAllowedInParent(selection, schema, model) && !checkSelectionOnObject(selection, schema) && isInOtherImage(selection);\n} // Checks if image is allowed by schema in optimal insertion parent.\n//\n// @returns {Boolean}\n\nfunction isImageAllowedInParent(selection, schema, model) {\n  var parent = getInsertImageParent(selection, model);\n  return schema.checkChild(parent, 'image');\n} // Check if selection is on object.\n//\n// @returns {Boolean}\n\n\nfunction checkSelectionOnObject(selection, schema) {\n  var selectedElement = selection.getSelectedElement();\n  return selectedElement && schema.isObject(selectedElement);\n} // Checks if selection is placed in other image (ie. in caption).\n\n\nfunction isInOtherImage(selection) {\n  return _toConsumableArray(selection.focus.getAncestors()).every(function (ancestor) {\n    return !ancestor.is('image');\n  });\n} // Returns a node that will be used to insert image with `model.insertContent` to check if image can be placed there.\n\n\nfunction getInsertImageParent(selection, model) {\n  var insertAt = findOptimalInsertionPosition(selection, model);\n  var parent = insertAt.parent;\n\n  if (parent.isEmpty && !parent.is('$root')) {\n    return parent.parent;\n  }\n\n  return parent;\n}","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { insertImage, isImageAllowed } from \"./utils\";\n/**\n * @module image/image/imageinsertcommand\n */\n\n/**\n * Insert image command.\n *\n * The command is registered by the {@link module:image/image/imageediting~ImageEditing} plugin as `'imageInsert'`.\n *\n * In order to insert an image at the current selection position\n * (according to the {@link module:widget/utils~findOptimalInsertionPosition} algorithm),\n * execute the command and specify the image source:\n *\n *\t\teditor.execute( 'imageInsert', { source: 'http://url.to.the/image' } );\n *\n * It is also possible to insert multiple images at once:\n *\n *\t\teditor.execute( 'imageInsert', {\n *\t\t\tsource:  [\n *\t\t\t\t'path/to/image.jpg',\n *\t\t\t\t'path/to/other-image.jpg'\n *\t\t\t]\n *\t\t} );\n *\n * @extends module:core/command~Command\n */\n\nvar ImageInsertCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(ImageInsertCommand, _Command);\n\n  function ImageInsertCommand() {\n    _classCallCheck(this, ImageInsertCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageInsertCommand).apply(this, arguments));\n  }\n\n  _createClass(ImageInsertCommand, [{\n    key: \"refresh\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      this.isEnabled = isImageAllowed(this.editor.model);\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param {Object} options Options for the executed command.\n     * @param {String|Array.<String>} options.source The image source or an array of image sources to insert.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(options) {\n      var model = this.editor.model;\n      model.change(function (writer) {\n        var sources = Array.isArray(options.source) ? options.source : [options.source];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var src = _step.value;\n            insertImage(writer, model, {\n              src: src\n            });\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      });\n    }\n  }]);\n\n  return ImageInsertCommand;\n}(Command);\n\nexport { ImageInsertCommand as default };","import _classCallCheck from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck';\nimport _createClass from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass';\nimport _possibleConstructorReturn from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn';\nimport _getPrototypeOf from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf';\nimport _inherits from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits';\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module image/image/imageediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ImageLoadObserver from './imageloadobserver';\nimport {\n    viewFigureToModel,\n    modelToViewAttributeConverter,\n    srcsetAttributeConverter\n} from './converters';\nimport { toImageWidget } from './utils';\nimport ImageInsertCommand from './imageinsertcommand';\n/**\n * The image engine plugin.\n *\n * It registers:\n *\n * * `<image>` as a block element in the document schema, and allows `alt`, `src` and `srcset` attributes.\n * * converters for editing and data pipelines.\n * * `'imageInsert'` command.\n *\n * @extends module:core/plugin~Plugin\n */\nvar ImageEditing = /*#__PURE__*/\nfunction (_Plugin) {\n    _inherits(ImageEditing, _Plugin);\n    function ImageEditing() {\n        _classCallCheck(this, ImageEditing);\n        return _possibleConstructorReturn(this, _getPrototypeOf(ImageEditing).apply(this, arguments));\n    }\n    _createClass(ImageEditing, [{\n            key: 'init',\n            /**\n     * @inheritDoc\n     */\n            value: function init() {\n                var editor = this.editor;\n                var schema = editor.model.schema;\n                var t = editor.t;\n                var conversion = editor.conversion;\n                // See https://github.com/ckeditor/ckeditor5-image/issues/142.\n                editor.editing.view.addObserver(ImageLoadObserver);\n                // Configure schema.\n                schema.register('image', {\n                    isObject: true,\n                    isBlock: true,\n                    allowWhere: '$block',\n                    allowAttributes: [\n                        'alt',\n                        'src',\n                        'srcset'\n                    ]\n                });\n                conversion.for('dataDowncast').elementToElement({\n                    model: 'image',\n                    view: function view(modelElement, viewWriter) {\n                        return createImageViewElement(viewWriter);\n                    }\n                });\n                conversion.for('editingDowncast').elementToElement({\n                    model: 'image',\n                    view: function view(modelElement, viewWriter) {\n                        return toImageWidget(createImageViewElement(viewWriter), viewWriter, t('i'));\n                    }\n                });\n                conversion.for('downcast').add(modelToViewAttributeConverter('src')).add(modelToViewAttributeConverter('alt')).add(srcsetAttributeConverter());\n                conversion.for('upcast').elementToElement({\n                    view: {\n                        name: 'img',\n                        attributes: { src: true }\n                    },\n                    model: function model(viewImage, modelWriter) {\n                        return modelWriter.createElement('image', { src: viewImage.getAttribute('src') });\n                    }\n                }).attributeToAttribute({\n                    view: {\n                        name: 'img',\n                        key: 'alt'\n                    },\n                    model: 'alt'\n                }).attributeToAttribute({\n                    view: {\n                        name: 'img',\n                        key: 'srcset'\n                    },\n                    model: {\n                        key: 'srcset',\n                        value: function value(viewImage) {\n                            var value = { data: viewImage.getAttribute('srcset') };\n                            if (viewImage.hasAttribute('width')) {\n                                value.width = viewImage.getAttribute('width');\n                            }\n                            return value;\n                        }\n                    }\n                }).add(viewFigureToModel());\n                // Register imageUpload command.\n                editor.commands.add('imageInsert', new ImageInsertCommand(editor));\n            }\n        }]);\n    return ImageEditing;\n}(Plugin);\n// Creates a view element representing the image.\n//\n//\t\t<figure class=\"image\"><img></img></figure>\n//\n// Note that `alt` and `src` attributes are converted separately, so they are not included.\n//\n// @private\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n// @returns {module:engine/view/containerelement~ContainerElement}\nexport {\n    ImageEditing as default\n};\nexport function createImageViewElement(writer) {\n    var emptyElement = writer.createEmptyElement('img');\n    var figure = writer.createContainerElement('figure', { class: 'image' });\n    writer.insert(writer.createPositionAt(figure, 0), emptyElement);\n    return figure;\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imagetextalternative/imagetextalternativecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { isImage } from \"../image/utils\";\n/**\n * The image text alternative command. It is used to change the `alt` attribute of `<image>` elements.\n *\n * @extends module:core/command~Command\n */\n\nvar ImageTextAlternativeCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(ImageTextAlternativeCommand, _Command);\n\n  function ImageTextAlternativeCommand() {\n    _classCallCheck(this, ImageTextAlternativeCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageTextAlternativeCommand).apply(this, arguments));\n  }\n\n  _createClass(ImageTextAlternativeCommand, [{\n    key: \"refresh\",\n\n    /**\n     * The command value: `false` if there is no `alt` attribute, otherwise the value of the `alt` attribute.\n     *\n     * @readonly\n     * @observable\n     * @member {String|Boolean} #value\n     */\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      var element = this.editor.model.document.selection.getSelectedElement();\n      this.isEnabled = isImage(element);\n\n      if (isImage(element) && element.hasAttribute('alt')) {\n        this.value = element.getAttribute('alt');\n      } else {\n        this.value = false;\n      }\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param {Object} options\n     * @param {String} options.newValue The new value of the `alt` attribute to set.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(options) {\n      var model = this.editor.model;\n      var imageElement = model.document.selection.getSelectedElement();\n      model.change(function (writer) {\n        writer.setAttribute('alt', options.newValue, imageElement);\n      });\n    }\n  }]);\n\n  return ImageTextAlternativeCommand;\n}(Command);\n\nexport { ImageTextAlternativeCommand as default };","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/ui/utils\n */\nimport BalloonPanelView from '@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview';\nimport { getSelectedImageWidget } from \"../utils\";\n/**\n * A helper utility that positions the\n * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} instance\n * with respect to the image in the editor content, if one is selected.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\n\nexport function repositionContextualBalloon(editor) {\n  var balloon = editor.plugins.get('ContextualBalloon');\n\n  if (getSelectedImageWidget(editor.editing.view.document.selection)) {\n    var position = getBalloonPositionData(editor);\n    balloon.updatePosition(position);\n  }\n}\n/**\n * Returns the positioning options that control the geometry of the\n * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} with respect\n * to the selected element in the editor content.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n * @returns {module:utils/dom/position~Options}\n */\n\nexport function getBalloonPositionData(editor) {\n  var editingView = editor.editing.view;\n  var defaultPositions = BalloonPanelView.defaultPositions;\n  return {\n    target: editingView.domConverter.viewToDom(editingView.document.selection.getSelectedElement()),\n    positions: [defaultPositions.northArrowSouth, defaultPositions.northArrowSouthWest, defaultPositions.northArrowSouthEast, defaultPositions.southArrowNorth, defaultPositions.southArrowNorthWest, defaultPositions.southArrowNorthEast]\n  };\n}","import _classCallCheck from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck';\nimport _createClass from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass';\nimport _possibleConstructorReturn from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn';\nimport _getPrototypeOf from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf';\nimport _get from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get';\nimport _inherits from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits';\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module image/imagetextalternative/imagetextalternativeui\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';\nimport clickOutsideHandler from '@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler';\nimport TextAlternativeFormView from './ui/textalternativeformview';\nimport ContextualBalloon from '@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon';\nimport textAlternativeIcon from '@ckeditor/ckeditor5-core/theme/icons/low-vision.svg';\nimport {\n    repositionContextualBalloon,\n    getBalloonPositionData\n} from '../image/ui/utils';\nimport { getSelectedImageWidget } from '../image/utils';\n/**\n * The image text alternative UI plugin.\n *\n * The plugin uses the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon}.\n *\n * @extends module:core/plugin~Plugin\n */\nvar ImageTextAlternativeUI = /*#__PURE__*/\nfunction (_Plugin) {\n    _inherits(ImageTextAlternativeUI, _Plugin);\n    function ImageTextAlternativeUI() {\n        _classCallCheck(this, ImageTextAlternativeUI);\n        return _possibleConstructorReturn(this, _getPrototypeOf(ImageTextAlternativeUI).apply(this, arguments));\n    }\n    _createClass(ImageTextAlternativeUI, [\n        {\n            key: 'init',\n            /**\n     * @inheritDoc\n     */\n            value: function init() {\n                this._createButton();\n                this._createForm();\n            }    /**\n     * @inheritDoc\n     */\n        },\n        {\n            key: 'destroy',\n            value: function destroy() {\n                _get(_getPrototypeOf(ImageTextAlternativeUI.prototype), 'destroy', this).call(this);\n                // Destroy created UI components as they are not automatically destroyed (see ckeditor5#1341).\n                this._form.destroy();\n            }    /**\n     * Creates a button showing the balloon panel for changing the image text alternative and\n     * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.\n     *\n     * @private\n     */\n        },\n        {\n            key: '_createButton',\n            value: function _createButton() {\n                var _this = this;\n                var editor = this.editor;\n                var t = editor.t;\n                editor.ui.componentFactory.add('imageTextAlternative', function (locale) {\n                    var command = editor.commands.get('imageTextAlternative');\n                    var view = new ButtonView(locale);\n                    view.set({\n                        label: t('ao'),\n                        icon: textAlternativeIcon,\n                        tooltip: true\n                    });\n                    view.bind('isEnabled').to(command, 'isEnabled');\n                    _this.listenTo(view, 'execute', function () {\n                        return _this._showForm();\n                    });\n                    return view;\n                });\n            }    /**\n     * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}\n     * form.\n     *\n     * @private\n     */\n        },\n        {\n            key: '_createForm',\n            value: function _createForm() {\n                var _this2 = this;\n                var editor = this.editor;\n                var view = editor.editing.view;\n                var viewDocument = view.document;\n                /**\n       * The contextual balloon plugin instance.\n       *\n       * @private\n       * @member {module:ui/panel/balloon/contextualballoon~ContextualBalloon}\n       */\n                this._balloon = this.editor.plugins.get('ContextualBalloon');\n                /**\n       * A form containing a textarea and buttons, used to change the `alt` text value.\n       *\n       * @member {module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}\n       */\n                this._form = new TextAlternativeFormView(editor.locale);\n                // Render the form so its #element is available for clickOutsideHandler.\n                this._form.render();\n                this.listenTo(this._form, 'submit', function () {\n                    editor.execute('imageTextAlternative', { newValue: _this2._form.labeledInput.inputView.element.value });\n                    _this2._hideForm(true);\n                });\n                this.listenTo(this._form, 'cancel', function () {\n                    _this2._hideForm(true);\n                });\n                // Close the form on Esc key press.\n                this._form.keystrokes.set('Esc', function (data, cancel) {\n                    _this2._hideForm(true);\n                    cancel();\n                });\n                // Reposition the balloon or hide the form if an image widget is no longer selected.\n                this.listenTo(editor.ui, 'update', function () {\n                    if (!getSelectedImageWidget(viewDocument.selection)) {\n                        _this2._hideForm(true);\n                    } else if (_this2._isVisible) {\n                        repositionContextualBalloon(editor);\n                    }\n                });\n                // Close on click outside of balloon panel element.\n                clickOutsideHandler({\n                    emitter: this._form,\n                    activator: function activator() {\n                        return _this2._isVisible;\n                    },\n                    contextElements: [this._balloon.view.element],\n                    callback: function callback() {\n                        return _this2._hideForm();\n                    }\n                });\n            }    /**\n     * Shows the {@link #_form} in the {@link #_balloon}.\n     *\n     * @private\n     */\n        },\n        {\n            key: '_showForm',\n            value: function _showForm() {\n                if (this._isVisible) {\n                    return;\n                }\n                var editor = this.editor;\n                var command = editor.commands.get('imageTextAlternative');\n                var labeledInput = this._form.labeledInput;\n                if (!this._balloon.hasView(this._form)) {\n                    this._balloon.add({\n                        view: this._form,\n                        position: getBalloonPositionData(editor)\n                    });\n                }\n                // Make sure that each time the panel shows up, the field remains in sync with the value of\n                // the command. If the user typed in the input, then canceled the balloon (`labeledInput#value`\n                // stays unaltered) and re-opened it without changing the value of the command, they would see the\n                // old value instead of the actual value of the command.\n                // https://github.com/ckeditor/ckeditor5-image/issues/114\n                labeledInput.value = labeledInput.inputView.element.value = command.value || '';\n                this._form.labeledInput.select();\n            }    /**\n     * Removes the {@link #_form} from the {@link #_balloon}.\n     *\n     * @param {Boolean} [focusEditable=false] Controls whether the editing view is focused afterwards.\n     * @private\n     */\n        },\n        {\n            key: '_hideForm',\n            value: function _hideForm(focusEditable) {\n                if (!this._isVisible) {\n                    return;\n                }\n                // Blur the input element before removing it from DOM to prevent issues in some browsers.\n                // See https://github.com/ckeditor/ckeditor5/issues/1501.\n                this._form.saveButtonView.focus();\n                this._balloon.remove(this._form);\n                if (focusEditable) {\n                    this.editor.editing.view.focus();\n                }\n            }    /**\n     * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.\n     *\n     * @private\n     * @type {Boolean}\n     */\n        },\n        {\n            key: '_isVisible',\n            get: function get() {\n                return this._balloon.visibleView == this._form;\n            }\n        }\n    ], [\n        {\n            key: 'requires',\n            /**\n     * @inheritDoc\n     */\n            get: function get() {\n                return [ContextualBalloon];\n            }    /**\n     * @inheritDoc\n     */\n        },\n        {\n            key: 'pluginName',\n            get: function get() {\n                return 'ImageTextAlternativeUI';\n            }\n        }\n    ]);\n    return ImageTextAlternativeUI;\n}(Plugin);\nexport {\n    ImageTextAlternativeUI as default\n};","import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imagecaption/utils\n */\nimport { enablePlaceholder } from '@ckeditor/ckeditor5-engine/src/view/placeholder';\nimport { toWidgetEditable } from '@ckeditor/ckeditor5-widget/src/utils';\n/**\n * Returns a function that creates a caption editable element for the given {@link module:engine/view/document~Document}.\n *\n * @param {module:engine/view/view~View} view\n * @param {String} placeholderText The text to be displayed when the caption is empty.\n * @returns {Function}\n */\n\nexport function captionElementCreator(view, placeholderText) {\n  return function (writer) {\n    var editable = writer.createEditableElement('figcaption');\n    writer.setCustomProperty('imageCaption', true, editable);\n    enablePlaceholder({\n      view: view,\n      element: editable,\n      text: placeholderText\n    });\n    return toWidgetEditable(editable, writer);\n  };\n}\n/**\n * Returns `true` if a given view element is the image caption editable.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @returns {Boolean}\n */\n\nexport function isCaption(viewElement) {\n  return !!viewElement.getCustomProperty('imageCaption');\n}\n/**\n * Returns the caption model element from a given image element. Returns `null` if no caption is found.\n *\n * @param {module:engine/model/element~Element} imageModelElement\n * @returns {module:engine/model/element~Element|null}\n */\n\nexport function getCaptionFromImage(imageModelElement) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = imageModelElement.getChildren()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n\n      if (!!node && node.is('caption')) {\n        return node;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * {@link module:engine/view/matcher~Matcher} pattern. Checks if a given element is a `<figcaption>` element that is placed\n * inside the image `<figure>` element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {Object|null} Returns the object accepted by {@link module:engine/view/matcher~Matcher} or `null` if the element\n * cannot be matched.\n */\n\nexport function matchImageCaption(element) {\n  var parent = element.parent; // Convert only captions for images.\n\n  if (element.name == 'figcaption' && parent && parent.name == 'figure' && parent.hasClass('image')) {\n    return {\n      name: true\n    };\n  }\n\n  return null;\n}","import 'core-js/modules/es6.array.find';\nimport 'core-js/modules/es6.function.name';\nimport 'core-js/modules/es7.symbol.async-iterator';\nimport 'core-js/modules/es6.symbol';\nimport 'core-js/modules/web.dom.iterable';\nimport _classCallCheck from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck';\nimport _createClass from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass';\nimport _possibleConstructorReturn from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn';\nimport _getPrototypeOf from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf';\nimport _inherits from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits';\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module image/imagecaption/imagecaptionediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport { isImage } from '../image/utils';\nimport {\n    captionElementCreator,\n    getCaptionFromImage,\n    matchImageCaption\n} from './utils';\n/**\n * The image caption engine plugin.\n *\n * It registers proper converters. It takes care of adding a caption element if the image without it is inserted\n * to the model document.\n *\n * @extends module:core/plugin~Plugin\n */\nvar ImageCaptionEditing = /*#__PURE__*/\nfunction (_Plugin) {\n    _inherits(ImageCaptionEditing, _Plugin);\n    function ImageCaptionEditing() {\n        _classCallCheck(this, ImageCaptionEditing);\n        return _possibleConstructorReturn(this, _getPrototypeOf(ImageCaptionEditing).apply(this, arguments));\n    }\n    _createClass(ImageCaptionEditing, [\n        {\n            key: 'init',\n            /**\n     * @inheritDoc\n     */\n            value: function init() {\n                var _this = this;\n                var editor = this.editor;\n                var view = editor.editing.view;\n                var schema = editor.model.schema;\n                var data = editor.data;\n                var editing = editor.editing;\n                var t = editor.t;\n                /**\n       * The last selected caption editable.\n       * It is used for hiding the editable when it is empty and the image widget is no longer selected.\n       *\n       * @private\n       * @member {module:engine/view/editableelement~EditableElement} #_lastSelectedCaption\n       */\n                // Schema configuration.\n                schema.register('caption', {\n                    allowIn: 'image',\n                    allowContentOf: '$block',\n                    isLimit: true\n                });\n                // Add caption element to each image inserted without it.\n                editor.model.document.registerPostFixer(function (writer) {\n                    return _this._insertMissingModelCaptionElement(writer);\n                });\n                // View to model converter for the data pipeline.\n                editor.conversion.for('upcast').elementToElement({\n                    view: matchImageCaption,\n                    model: 'caption'\n                });\n                // Model to view converter for the data pipeline.\n                var createCaptionForData = function createCaptionForData(writer) {\n                    return writer.createContainerElement('figcaption');\n                };\n                data.downcastDispatcher.on('insert:caption', captionModelToView(createCaptionForData, false));\n                // Model to view converter for the editing pipeline.\n                var createCaptionForEditing = captionElementCreator(view, t('am'));\n                editing.downcastDispatcher.on('insert:caption', captionModelToView(createCaptionForEditing));\n                // Always show caption in view when something is inserted in model.\n                editing.downcastDispatcher.on('insert', this._fixCaptionVisibility(function (data) {\n                    return data.item;\n                }), { priority: 'high' });\n                // Hide caption when everything is removed from it.\n                editing.downcastDispatcher.on('remove', this._fixCaptionVisibility(function (data) {\n                    return data.position.parent;\n                }), { priority: 'high' });\n                // Update caption visibility on view in post fixer.\n                view.document.registerPostFixer(function (writer) {\n                    return _this._updateCaptionVisibility(writer);\n                });\n            }    /**\n     * Updates the view before each rendering, making sure that empty captions (so unnecessary ones) are hidden\n     * and then visible when the image is selected.\n     *\n     * @private\n     * @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n     * @returns {Boolean} Returns `true` when the view is updated.\n     */\n        },\n        {\n            key: '_updateCaptionVisibility',\n            value: function _updateCaptionVisibility(viewWriter) {\n                var mapper = this.editor.editing.mapper;\n                var lastCaption = this._lastSelectedCaption;\n                var viewCaption;\n                // If whole image is selected.\n                var modelSelection = this.editor.model.document.selection;\n                var selectedElement = modelSelection.getSelectedElement();\n                if (selectedElement && selectedElement.is('image')) {\n                    var _modelCaption = getCaptionFromImage(selectedElement);\n                    viewCaption = mapper.toViewElement(_modelCaption);\n                }\n                // If selection is placed inside caption.\n                var position = modelSelection.getFirstPosition();\n                var modelCaption = getParentCaption(position.parent);\n                if (modelCaption) {\n                    viewCaption = mapper.toViewElement(modelCaption);\n                }\n                // Is currently any caption selected?\n                if (viewCaption) {\n                    // Was any caption selected before?\n                    if (lastCaption) {\n                        // Same caption as before?\n                        if (lastCaption === viewCaption) {\n                            return showCaption(viewCaption, viewWriter);\n                        } else {\n                            hideCaptionIfEmpty(lastCaption, viewWriter);\n                            this._lastSelectedCaption = viewCaption;\n                            return showCaption(viewCaption, viewWriter);\n                        }\n                    } else {\n                        this._lastSelectedCaption = viewCaption;\n                        return showCaption(viewCaption, viewWriter);\n                    }\n                } else {\n                    // Was any caption selected before?\n                    if (lastCaption) {\n                        var viewModified = hideCaptionIfEmpty(lastCaption, viewWriter);\n                        this._lastSelectedCaption = null;\n                        return viewModified;\n                    } else {\n                        return false;\n                    }\n                }\n            }    /**\n     * Returns a converter that fixes caption visibility during the model-to-view conversion.\n     * Checks if the changed node is placed inside the caption element and fixes its visibility in the view.\n     *\n     * @private\n     * @param {Function} nodeFinder\n     * @returns {Function}\n     */\n        },\n        {\n            key: '_fixCaptionVisibility',\n            value: function _fixCaptionVisibility(nodeFinder) {\n                var _this2 = this;\n                return function (evt, data, conversionApi) {\n                    var node = nodeFinder(data);\n                    var modelCaption = getParentCaption(node);\n                    var mapper = _this2.editor.editing.mapper;\n                    var viewWriter = conversionApi.writer;\n                    if (modelCaption) {\n                        var viewCaption = mapper.toViewElement(modelCaption);\n                        if (viewCaption) {\n                            if (modelCaption.childCount) {\n                                viewWriter.removeClass('ck-hidden', viewCaption);\n                            } else {\n                                viewWriter.addClass('ck-hidden', viewCaption);\n                            }\n                        }\n                    }\n                };\n            }    /**\n     * Checks whether the data inserted to the model document have an image element that has no caption element inside it.\n     * If there is none, it adds it to the image element.\n     *\n     * @private\n     * @param {module:engine/model/writer~Writer} writer The writer to make changes with.\n     * @returns {Boolean} `true` if any change was applied, `false` otherwise.\n     */\n        },\n        {\n            key: '_insertMissingModelCaptionElement',\n            value: function _insertMissingModelCaptionElement(writer) {\n                var model = this.editor.model;\n                var changes = model.document.differ.getChanges();\n                var imagesWithoutCaption = [];\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n                try {\n                    for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var entry = _step.value;\n                        if (entry.type == 'insert' && entry.name != '$text') {\n                            var item = entry.position.nodeAfter;\n                            if (item.is('image') && !getCaptionFromImage(item)) {\n                                imagesWithoutCaption.push(item);\n                            }\n                            // Check elements with children for nested images.\n                            if (!item.is('image') && item.childCount) {\n                                var _iteratorNormalCompletion2 = true;\n                                var _didIteratorError2 = false;\n                                var _iteratorError2 = undefined;\n                                try {\n                                    for (var _iterator2 = model.createRangeIn(item).getItems()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                                        var nestedItem = _step2.value;\n                                        if (nestedItem.is('image') && !getCaptionFromImage(nestedItem)) {\n                                            imagesWithoutCaption.push(nestedItem);\n                                        }\n                                    }\n                                } catch (err) {\n                                    _didIteratorError2 = true;\n                                    _iteratorError2 = err;\n                                } finally {\n                                    try {\n                                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                                            _iterator2.return();\n                                        }\n                                    } finally {\n                                        if (_didIteratorError2) {\n                                            throw _iteratorError2;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n                for (var _i = 0, _imagesWithoutCaption = imagesWithoutCaption; _i < _imagesWithoutCaption.length; _i++) {\n                    var image = _imagesWithoutCaption[_i];\n                    writer.appendElement('caption', image);\n                }\n                return !!imagesWithoutCaption.length;\n            }\n        }\n    ]);\n    return ImageCaptionEditing;\n}(Plugin);\n// Creates a converter that converts image caption model element to view element.\n//\n// @private\n// @param {Function} elementCreator\n// @param {Boolean} [hide=true] When set to `false` view element will not be inserted when it's empty.\n// @returns {Function}\nexport {\n    ImageCaptionEditing as default\n};\nfunction captionModelToView(elementCreator) {\n    var hide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return function (evt, data, conversionApi) {\n        var captionElement = data.item;\n        // Return if element shouldn't be present when empty.\n        if (!captionElement.childCount && !hide) {\n            return;\n        }\n        if (isImage(captionElement.parent)) {\n            if (!conversionApi.consumable.consume(data.item, 'insert')) {\n                return;\n            }\n            var viewImage = conversionApi.mapper.toViewElement(data.range.start.parent);\n            var viewCaption = elementCreator(conversionApi.writer);\n            var viewWriter = conversionApi.writer;\n            // Hide if empty.\n            if (!captionElement.childCount) {\n                viewWriter.addClass('ck-hidden', viewCaption);\n            }\n            insertViewCaptionAndBind(viewCaption, data.item, viewImage, conversionApi);\n        }\n    };\n}\n// Inserts `viewCaption` at the end of `viewImage` and binds it to `modelCaption`.\n//\n// @private\n// @param {module:engine/view/containerelement~ContainerElement} viewCaption\n// @param {module:engine/model/element~Element} modelCaption\n// @param {module:engine/view/containerelement~ContainerElement} viewImage\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction insertViewCaptionAndBind(viewCaption, modelCaption, viewImage, conversionApi) {\n    var viewPosition = conversionApi.writer.createPositionAt(viewImage, 'end');\n    conversionApi.writer.insert(viewPosition, viewCaption);\n    conversionApi.mapper.bindElements(modelCaption, viewCaption);\n}\n// Checks if the provided node or one of its ancestors is a caption element, and returns it.\n//\n// @private\n// @param {module:engine/model/node~Node} node\n// @returns {module:engine/model/element~Element|null}\nfunction getParentCaption(node) {\n    var ancestors = node.getAncestors({ includeSelf: true });\n    var caption = ancestors.find(function (ancestor) {\n        return ancestor.name == 'caption';\n    });\n    if (caption && caption.parent && caption.parent.name == 'image') {\n        return caption;\n    }\n    return null;\n}\n// Hides a given caption in the view if it is empty.\n//\n// @private\n// @param {module:engine/view/containerelement~ContainerElement} caption\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @returns {Boolean} Returns `true` if the view was modified.\nfunction hideCaptionIfEmpty(caption, viewWriter) {\n    if (!caption.childCount && !caption.hasClass('ck-hidden')) {\n        viewWriter.addClass('ck-hidden', caption);\n        return true;\n    }\n    return false;\n}\n// Shows the caption.\n//\n// @private\n// @param {module:engine/view/containerelement~ContainerElement} caption\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @returns {Boolean} Returns `true` if the view was modified.\nfunction showCaption(caption, viewWriter) {\n    if (caption.hasClass('ck-hidden')) {\n        viewWriter.removeClass('ck-hidden', caption);\n        return true;\n    }\n    return false;\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imagecaption\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ImageCaptionEditing from \"./imagecaption/imagecaptionediting\";\nimport \"../theme/imagecaption.css\";\n/**\n * The image caption plugin.\n *\n * For a detailed overview, check the {@glink features/image#image-captions image caption} documentation.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ImageCaption =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ImageCaption, _Plugin);\n\n  function ImageCaption() {\n    _classCallCheck(this, ImageCaption);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageCaption).apply(this, arguments));\n  }\n\n  _createClass(ImageCaption, null, [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [ImageCaptionEditing];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'ImageCaption';\n    }\n  }]);\n\n  return ImageCaption;\n}(Plugin);\n\nexport { ImageCaption as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n/**\n * @module image/imagestyle/converters\n */\n\n/**\n * Returns a converter for the `imageStyle` attribute. It can be used for adding, changing and removing the attribute.\n *\n * @param {Object} styles An object containing available styles. See {@link module:image/imagestyle/imagestyleediting~ImageStyleFormat}\n * for more details.\n * @returns {Function} A model-to-view attribute converter.\n */\n\nexport function modelToViewStyleAttribute(styles) {\n  return function (evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    } // Check if there is class name associated with given value.\n\n\n    var newStyle = getStyleByName(data.attributeNewValue, styles);\n    var oldStyle = getStyleByName(data.attributeOldValue, styles);\n    var viewElement = conversionApi.mapper.toViewElement(data.item);\n    var viewWriter = conversionApi.writer;\n\n    if (oldStyle) {\n      viewWriter.removeClass(oldStyle.className, viewElement);\n    }\n\n    if (newStyle) {\n      viewWriter.addClass(newStyle.className, viewElement);\n    }\n  };\n}\n/**\n * Returns a view-to-model converter converting image CSS classes to a proper value in the model.\n *\n * @param {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat>} styles The styles for which the converter is created.\n * @returns {Function} A view-to-model converter.\n */\n\nexport function viewToModelStyleAttribute(styles) {\n  // Convert only nondefault styles.\n  var filteredStyles = styles.filter(function (style) {\n    return !style.isDefault;\n  });\n  return function (evt, data, conversionApi) {\n    if (!data.modelRange) {\n      return;\n    }\n\n    var viewFigureElement = data.viewItem;\n    var modelImageElement = first(data.modelRange.getItems()); // Check if `imageStyle` attribute is allowed for current element.\n\n    if (!conversionApi.schema.checkAttribute(modelImageElement, 'imageStyle')) {\n      return;\n    } // Convert style one by one.\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = filteredStyles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var style = _step.value;\n\n        // Try to consume class corresponding with style.\n        if (conversionApi.consumable.consume(viewFigureElement, {\n          classes: style.className\n        })) {\n          // And convert this style to model attribute.\n          conversionApi.writer.setAttribute('imageStyle', style.name, modelImageElement);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  };\n} // Returns the style with a given `name` from an array of styles.\n//\n// @param {String} name\n// @param {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat> } styles\n// @returns {module:image/imagestyle/imagestyleediting~ImageStyleFormat|undefined}\n\nfunction getStyleByName(name, styles) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = styles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var style = _step2.value;\n\n      if (style.name === name) {\n        return style;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imagestyle/imagestyleediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ImageStyleCommand from \"./imagestylecommand\";\nimport { viewToModelStyleAttribute, modelToViewStyleAttribute } from \"./converters\";\nimport { normalizeImageStyles } from \"./utils\";\n/**\n * The image style engine plugin. It sets the default configuration, creates converters and registers\n * {@link module:image/imagestyle/imagestylecommand~ImageStyleCommand ImageStyleCommand}.\n *\n * @extends {module:core/plugin~Plugin}\n */\n\nvar ImageStyleEditing =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ImageStyleEditing, _Plugin);\n\n  function ImageStyleEditing() {\n    _classCallCheck(this, ImageStyleEditing);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageStyleEditing).apply(this, arguments));\n  }\n\n  _createClass(ImageStyleEditing, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var editor = this.editor;\n      var schema = editor.model.schema;\n      var data = editor.data;\n      var editing = editor.editing; // Define default configuration.\n\n      editor.config.define('image.styles', ['full', 'side']); // Get configuration.\n\n      var styles = normalizeImageStyles(editor.config.get('image.styles')); // Allow imageStyle attribute in image.\n      // We could call it 'style' but https://github.com/ckeditor/ckeditor5-engine/issues/559.\n\n      schema.extend('image', {\n        allowAttributes: 'imageStyle'\n      }); // Converters for imageStyle attribute from model to view.\n\n      var modelToViewConverter = modelToViewStyleAttribute(styles);\n      editing.downcastDispatcher.on('attribute:imageStyle:image', modelToViewConverter);\n      data.downcastDispatcher.on('attribute:imageStyle:image', modelToViewConverter); // Converter for figure element from view to model.\n\n      data.upcastDispatcher.on('element:figure', viewToModelStyleAttribute(styles), {\n        priority: 'low'\n      }); // Register imageStyle command.\n\n      editor.commands.add('imageStyle', new ImageStyleCommand(editor, styles));\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'ImageStyleEditing';\n    }\n  }]);\n\n  return ImageStyleEditing;\n}(Plugin);\n/**\n * The image style format descriptor.\n *\n *\t\timport fullSizeIcon from 'path/to/icon.svg';\n *\n *\t\tconst imageStyleFormat = {\n *\t\t\tname: 'fullSize',\n *\t\t\ticon: fullSizeIcon,\n *\t\t\ttitle: 'Full size image',\n *\t\t\tclassName: 'image-full-size'\n *\t\t}\n *\n * @typedef {Object} module:image/imagestyle/imagestyleediting~ImageStyleFormat\n *\n * @property {String} name The unique name of the style. It will be used to:\n *\n * * Store the chosen style in the model by setting the `imageStyle` attribute of the `<image>` element.\n * * As a value of the {@link module:image/imagestyle/imagestylecommand~ImageStyleCommand#execute `imageStyle` command},\n * * when registering a button for each of the styles (`'imageStyle:{name}'`) in the\n * {@link module:ui/componentfactory~ComponentFactory UI components factory} (this functionality is provided by the\n * {@link module:image/imagestyle/imagestyleui~ImageStyleUI} plugin).\n *\n * @property {Boolean} [isDefault] When set, the style will be used as the default one.\n * A default style does not apply any CSS class to the view element.\n *\n * @property {String} icon One of the following to be used when creating the style's button:\n *\n * * An SVG icon source (as an XML string).\n * * One of {@link module:image/imagestyle/utils~defaultIcons} to use a default icon provided by the plugin.\n *\n * @property {String} title The style's title.\n *\n * @property {String} className The CSS class used to represent the style in the view.\n */\n\n\nexport { ImageStyleEditing as default };","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imagestyle\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ImageStyleEditing from \"./imagestyle/imagestyleediting\";\nimport ImageStyleUI from \"./imagestyle/imagestyleui\";\n/**\n * The image style plugin.\n *\n * For a detailed overview, check the {@glink features/image#image-styles image styles} documentation.\n *\n * This is a \"glue\" plugin which loads the {@link module:image/imagestyle/imagestyleediting~ImageStyleEditing}\n * and {@link module:image/imagestyle/imagestyleui~ImageStyleUI} plugins.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ImageStyle =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ImageStyle, _Plugin);\n\n  function ImageStyle() {\n    _classCallCheck(this, ImageStyle);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageStyle).apply(this, arguments));\n  }\n\n  _createClass(ImageStyle, null, [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [ImageStyleEditing, ImageStyleUI];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'ImageStyle';\n    }\n  }]);\n\n  return ImageStyle;\n}(Plugin);\n/**\n * Available image styles.\n *\n * The default value is:\n *\n *\t\tconst imageConfig = {\n *\t\t\tstyles: [ 'full', 'side' ]\n *\t\t};\n *\n * which configures two default styles:\n *\n *  * the \"full\" style which does not apply any class, e.g. for images styled to span 100% width of the content,\n *  * the \"side\" style with the `.image-style-side` CSS class.\n *\n * See {@link module:image/imagestyle/utils~defaultStyles} to learn more about default\n * styles provided by the image feature.\n *\n * The {@link module:image/imagestyle/utils~defaultStyles default styles} can be customized,\n * e.g. to change the icon, title or CSS class of the style. The feature also provides several\n * {@link module:image/imagestyle/utils~defaultIcons default icons} to choose from.\n *\n *\t\timport customIcon from 'custom-icon.svg';\n *\n *\t\t// ...\n *\n *\t\tconst imageConfig = {\n *\t\t\tstyles: [\n *\t\t\t\t// This will only customize the icon of the \"full\" style.\n *\t\t\t\t// Note: 'right' is one of default icons provided by the feature.\n *\t\t\t\t{ name: 'full', icon: 'right' },\n *\n *\t\t\t\t// This will customize the icon, title and CSS class of the default \"side\" style.\n *\t\t\t\t{ name: 'side', icon: customIcon, title: 'My side style', className: 'custom-side-image' }\n *\t\t\t]\n *\t\t};\n *\n * If none of the default styles is good enough, it is possible to define independent custom styles, too:\n *\n *\t\timport fullSizeIcon from '@ckeditor/ckeditor5-core/theme/icons/object-center.svg';\n *\t\timport sideIcon from '@ckeditor/ckeditor5-core/theme/icons/object-right.svg';\n *\n *\t\t// ...\n *\n *\t\tconst imageConfig = {\n *\t\t\tstyles: [\n *\t\t\t\t// A completely custom full size style with no class, used as a default.\n *\t\t\t\t{ name: 'fullSize', title: 'Full size', icon: fullSizeIcon, isDefault: true },\n *\n *\t\t\t\t{ name: 'side', title: 'To the side', icon: sideIcon, className: 'side-image' }\n *\t\t\t]\n *\t\t};\n *\n * Note: Setting `title` to one of {@link module:image/imagestyle/imagestyleui~ImageStyleUI#localizedDefaultStylesTitles}\n * will automatically translate it to the language of the editor.\n *\n * Read more about styling images in the {@glink features/image#image-styles Image styles guide}.\n *\n * The feature creates commands based on defined styles, so you can change the style of a selected image by executing\n * the following command:\n *\n *\t\teditor.execute( 'imageStyle' { value: 'side' } );\n *\n * The feature also creates buttons that execute the commands. So, assuming that you use the\n * default image styles setting, you can {@link module:image/image~ImageConfig#toolbar configure the image toolbar}\n * (or any other toolbar) to contain these options:\n *\n *\t\tconst imageConfig = {\n *\t\t\ttoolbar: [ 'imageStyle:full', 'imageStyle:side' ]\n *\t\t};\n *\n * @member {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat>} module:image/image~ImageConfig#styles\n */\n\n\nexport { ImageStyle as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.map\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widgettoolbarrepository\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ContextualBalloon from '@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon';\nimport ToolbarView from '@ckeditor/ckeditor5-ui/src/toolbar/toolbarview';\nimport BalloonPanelView from '@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview';\nimport { isWidget } from \"./utils\";\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Widget toolbar repository plugin. A central point for registering widget toolbars. This plugin handles the whole\n * toolbar rendering process and exposes a concise API.\n *\n * To add a toolbar for your widget use the {@link ~WidgetToolbarRepository#register `WidgetToolbarRepository#register()`} method.\n *\n * The following example comes from the {@link module:image/imagetoolbar~ImageToolbar} plugin:\n *\n * \t\tclass ImageToolbar extends Plugin {\n *\t\t\tstatic get requires() {\n *\t\t\t\treturn [ WidgetToolbarRepository ];\n *\t\t\t}\n *\n *\t\t\tafterInit() {\n *\t\t\t\tconst editor = this.editor;\n *\t\t\t\tconst widgetToolbarRepository = editor.plugins.get( WidgetToolbarRepository );\n *\n *\t\t\t\twidgetToolbarRepository.register( 'image', {\n *\t\t\t\t\titems: editor.config.get( 'image.toolbar' ),\n *\t\t\t\t\tgetRelatedElement: getSelectedImageWidget\n *\t\t\t\t} );\n *\t\t\t}\n *\t\t}\n */\n\nvar WidgetToolbarRepository =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(WidgetToolbarRepository, _Plugin);\n\n  function WidgetToolbarRepository() {\n    _classCallCheck(this, WidgetToolbarRepository);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WidgetToolbarRepository).apply(this, arguments));\n  }\n\n  _createClass(WidgetToolbarRepository, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var _this = this;\n\n      var editor = this.editor; // Disables the default balloon toolbar for all widgets.\n\n      if (editor.plugins.has('BalloonToolbar')) {\n        var balloonToolbar = editor.plugins.get('BalloonToolbar');\n        this.listenTo(balloonToolbar, 'show', function (evt) {\n          if (isWidgetSelected(editor.editing.view.document.selection)) {\n            evt.stop();\n          }\n        }, {\n          priority: 'high'\n        });\n      }\n      /**\n       * A map of toolbar definitions.\n       *\n       * @protected\n       * @member {Map.<String,module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition>} #_toolbarDefinitions\n       */\n\n\n      this._toolbarDefinitions = new Map();\n      /**\n       * @private\n       */\n\n      this._balloon = this.editor.plugins.get('ContextualBalloon');\n      this.listenTo(editor.ui, 'update', function () {\n        _this._updateToolbarsVisibility();\n      }); // UI#update is not fired after focus is back in editor, we need to check if balloon panel should be visible.\n\n      this.listenTo(editor.ui.focusTracker, 'change:isFocused', function () {\n        _this._updateToolbarsVisibility();\n      }, {\n        priority: 'low'\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(WidgetToolbarRepository.prototype), \"destroy\", this).call(this);\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._toolbarDefinitions.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var toolbarConfig = _step.value;\n          toolbarConfig.view.destroy();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked\n     * `getRelatedElement` function. Toolbar items are gathered from `items` array.\n     * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.\n     *\n     * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}\n     * callback (or later) to make sure that the given toolbar items were already registered by other plugins.\n     *\n     * @param {String} toolbarId An id for the toolbar. Used to\n     * @param {Object} options\n     * @param {Array.<String>} options.items Array of toolbar items.\n     * @param {Function} options.getRelatedElement Callback which returns an element the toolbar should be attached to.\n     * @param {String} [options.balloonClassName='ck-toolbar-container'] CSS class for the widget balloon.\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(toolbarId, _ref) {\n      var items = _ref.items,\n          getRelatedElement = _ref.getRelatedElement,\n          _ref$balloonClassName = _ref.balloonClassName,\n          balloonClassName = _ref$balloonClassName === void 0 ? 'ck-toolbar-container' : _ref$balloonClassName;\n      var editor = this.editor;\n      var toolbarView = new ToolbarView();\n\n      if (this._toolbarDefinitions.has(toolbarId)) {\n        /**\n         * Toolbar with the given id was already added.\n         *\n         * @error widget-toolbar-duplicated\n         * @param toolbarId Toolbar id.\n         */\n        throw new CKEditorError('widget-toolbar-duplicated: Toolbar with the given id was already added.', {\n          toolbarId: toolbarId\n        });\n      }\n\n      toolbarView.fillFromConfig(items, editor.ui.componentFactory);\n\n      this._toolbarDefinitions.set(toolbarId, {\n        view: toolbarView,\n        getRelatedElement: getRelatedElement,\n        balloonClassName: balloonClassName\n      });\n    }\n    /**\n     * Iterates over stored toolbars and makes them visible or hidden.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateToolbarsVisibility\",\n    value: function _updateToolbarsVisibility() {\n      var maxRelatedElementDepth = 0;\n      var deepestRelatedElement = null;\n      var deepestToolbarDefinition = null;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._toolbarDefinitions.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var definition = _step2.value;\n          var relatedElement = definition.getRelatedElement(this.editor.editing.view.document.selection);\n\n          if (!this.editor.ui.focusTracker.isFocused) {\n            if (this._isToolbarVisible(definition)) {\n              this._hideToolbar(definition);\n            }\n          } else if (!relatedElement) {\n            if (this._isToolbarInBalloon(definition)) {\n              this._hideToolbar(definition);\n            }\n          } else {\n            var relatedElementDepth = relatedElement.getAncestors().length; // Many toolbars can express willingness to be displayed but they do not know about\n            // each other. Figure out which toolbar is deepest in the view tree to decide which\n            // should be displayed. For instance, if a selected image is inside a table cell, display\n            // the ImageToolbar rather than the TableToolbar (#60).\n\n            if (relatedElementDepth > maxRelatedElementDepth) {\n              maxRelatedElementDepth = relatedElementDepth;\n              deepestRelatedElement = relatedElement;\n              deepestToolbarDefinition = definition;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      if (deepestToolbarDefinition) {\n        this._showToolbar(deepestToolbarDefinition, deepestRelatedElement);\n      }\n    }\n    /**\n     * Hides the given toolbar.\n     *\n     * @private\n     * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition\n     */\n\n  }, {\n    key: \"_hideToolbar\",\n    value: function _hideToolbar(toolbarDefinition) {\n      this._balloon.remove(toolbarDefinition.view);\n    }\n    /**\n     * Shows up the toolbar if the toolbar is not visible.\n     * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.\n     *\n     * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view\n     * should be still visible after the {@link module:core/editor/editorui~EditorUI#event:update}.\n     *\n     * @private\n     * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition\n     * @param {module:engine/view/element~Element} relatedElement\n     */\n\n  }, {\n    key: \"_showToolbar\",\n    value: function _showToolbar(toolbarDefinition, relatedElement) {\n      if (this._isToolbarVisible(toolbarDefinition)) {\n        repositionContextualBalloon(this.editor, relatedElement);\n      } else if (!this._isToolbarInBalloon(toolbarDefinition)) {\n        this._balloon.add({\n          view: toolbarDefinition.view,\n          position: getBalloonPositionData(this.editor, relatedElement),\n          balloonClassName: toolbarDefinition.balloonClassName\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {Object} toolbar\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isToolbarVisible\",\n    value: function _isToolbarVisible(toolbar) {\n      return this._balloon.visibleView === toolbar.view;\n    }\n    /**\n     * @private\n     * @param {Object} toolbar\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isToolbarInBalloon\",\n    value: function _isToolbarInBalloon(toolbar) {\n      return this._balloon.hasView(toolbar.view);\n    }\n  }], [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [ContextualBalloon];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'WidgetToolbarRepository';\n    }\n  }]);\n\n  return WidgetToolbarRepository;\n}(Plugin);\n\nexport { WidgetToolbarRepository as default };\n\nfunction repositionContextualBalloon(editor, relatedElement) {\n  var balloon = editor.plugins.get('ContextualBalloon');\n  var position = getBalloonPositionData(editor, relatedElement);\n  balloon.updatePosition(position);\n}\n\nfunction getBalloonPositionData(editor, relatedElement) {\n  var editingView = editor.editing.view;\n  var defaultPositions = BalloonPanelView.defaultPositions;\n  return {\n    target: editingView.domConverter.viewToDom(relatedElement),\n    positions: [defaultPositions.northArrowSouth, defaultPositions.northArrowSouthWest, defaultPositions.northArrowSouthEast, defaultPositions.southArrowNorth, defaultPositions.southArrowNorthWest, defaultPositions.southArrowNorthEast]\n  };\n}\n\nfunction isWidgetSelected(selection) {\n  var viewElement = selection.getSelectedElement();\n  return !!(viewElement && isWidget(viewElement));\n}\n/**\n * The toolbar definition object used by the toolbar repository to manage toolbars.\n * It contains information necessary to display the toolbar in the\n * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} and\n * update it during its life (display) cycle.\n *\n * @typedef {Object} module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition\n *\n * @property {module:ui/view~View} view The UI view of the toolbar.\n * @property {Function} getRelatedElement A function that returns an engine {@link module:engine/view/view~View}\n * element the toolbar is to be attached to. For instance, an image widget or a table widget (or `null` when\n * there is no such element). The function accepts an instance of {@link module:engine/view/selection~Selection}.\n * @property {String} balloonClassName CSS class for the widget balloon when a toolbar is displayed.\n */","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imagetoolbar\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport { getSelectedImageWidget } from \"./image/utils\";\nimport WidgetToolbarRepository from '@ckeditor/ckeditor5-widget/src/widgettoolbarrepository';\n/**\n * The image toolbar plugin. It creates and manages the image toolbar (the toolbar displayed when an image is selected).\n *\n * For a detailed overview, check the {@glink features/image#image-contextual-toolbar image contextual toolbar} documentation.\n *\n * Instances of toolbar components (e.g. buttons) are created using the editor's\n * {@link module:ui/componentfactory~ComponentFactory component factory}\n * based on the {@link module:image/image~ImageConfig#toolbar `image.toolbar` configuration option}.\n *\n * The toolbar uses the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ImageToolbar =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ImageToolbar, _Plugin);\n\n  function ImageToolbar() {\n    _classCallCheck(this, ImageToolbar);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageToolbar).apply(this, arguments));\n  }\n\n  _createClass(ImageToolbar, [{\n    key: \"afterInit\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function afterInit() {\n      var editor = this.editor;\n      var widgetToolbarRepository = editor.plugins.get(WidgetToolbarRepository);\n      widgetToolbarRepository.register('image', {\n        items: editor.config.get('image.toolbar') || [],\n        getRelatedElement: getSelectedImageWidget\n      });\n    }\n  }], [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [WidgetToolbarRepository];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'ImageToolbar';\n    }\n  }]);\n\n  return ImageToolbar;\n}(Plugin);\n/**\n * Items to be placed in the image toolbar.\n * This option is used by the {@link module:image/imagetoolbar~ImageToolbar} feature.\n *\n * Assuming that you use the following features:\n *\n * * {@link module:image/imagestyle~ImageStyle} (with a default configuration),\n * * {@link module:image/imagetextalternative~ImageTextAlternative},\n *\n * three toolbar items will be available in {@link module:ui/componentfactory~ComponentFactory}:\n * `'imageStyle:full'`, `'imageStyle:side'`, and `'imageTextAlternative'` so you can configure the toolbar like this:\n *\n *\t\tconst imageConfig = {\n *\t\t\ttoolbar: [ 'imageStyle:full', 'imageStyle:side', '|', 'imageTextAlternative' ]\n *\t\t};\n *\n * Of course, the same buttons can also be used in the\n * {@link module:core/editor/editorconfig~EditorConfig#toolbar main editor toolbar}.\n *\n * Read more about configuring toolbar in {@link module:core/editor/editorconfig~EditorConfig#toolbar}.\n *\n * @member {Array.<String>} module:image/image~ImageConfig#toolbar\n */\n\n\nexport { ImageToolbar as default };","import \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.regexp.replace\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageupload/utils\n */\n\n/* global fetch, File */\n\n/**\n * Checks if a given file is an image.\n *\n * @param {File} file\n * @returns {Boolean}\n */\nexport function isImageType(file) {\n  var types = /^image\\/(jpeg|png|gif|bmp)$/;\n  return types.test(file.type);\n}\n/**\n * Creates a promise which fetches the image local source (base64 or blob) and resolves with a `File` object.\n *\n * @param {module:engine/view/element~Element} image Image which source to fetch.\n * @returns {Promise.<File>} A promise which resolves when image source is fetched and converted to `File` instance.\n * It resolves with a `File` object. If there were any errors during file processing the promise will be rejected.\n */\n\nexport function fetchLocalImage(image) {\n  return new Promise(function (resolve, reject) {\n    var imageSrc = image.getAttribute('src'); // Fetch works asynchronously and so does not block browser UI when processing data.\n\n    fetch(imageSrc).then(function (resource) {\n      return resource.blob();\n    }).then(function (blob) {\n      var mimeType = getImageMimeType(blob, imageSrc);\n      var ext = mimeType.replace('image/', '');\n      var filename = \"image.\".concat(ext);\n      var file = createFileFromBlob(blob, filename, mimeType);\n      file ? resolve(file) : reject();\n    }).catch(reject);\n  });\n}\n/**\n * Checks whether given node is an image element with local source (base64 or blob).\n *\n * @param {module:engine/view/node~Node} node Node to check.\n * @returns {Boolean}\n */\n\nexport function isLocalImage(node) {\n  if (!node.is('element', 'img') || !node.getAttribute('src')) {\n    return false;\n  }\n\n  return node.getAttribute('src').match(/^data:image\\/\\w+;base64,/g) || node.getAttribute('src').match(/^blob:/g);\n} // Extracts image type based on its blob representation or its source.\n//\n// @param {String} src Image src attribute value.\n// @param {Blob} blob Image blob representation.\n// @returns {String}\n\nfunction getImageMimeType(blob, src) {\n  if (blob.type) {\n    return blob.type;\n  } else if (src.match(/data:(image\\/\\w+);base64/)) {\n    return src.match(/data:(image\\/\\w+);base64/)[1].toLowerCase();\n  } else {\n    // Fallback to 'jpeg' as common extension.\n    return 'image/jpeg';\n  }\n} // Creates `File` instance from the given `Blob` instance using specified filename.\n//\n// @param {Blob} blob The `Blob` instance from which file will be created.\n// @param {String} filename Filename used during file creation.\n// @param {String} mimeType File mime type.\n// @returns {File|null} The `File` instance created from the given blob or `null` if `File API` is not available.\n\n\nfunction createFileFromBlob(blob, filename, mimeType) {\n  try {\n    return new File([blob], filename, {\n      type: mimeType\n    });\n  } catch (err) {\n    // Edge does not support `File` constructor ATM, see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9551546/.\n    // However, the `File` function is present (so cannot be checked with `!window.File` or `typeof File === 'function'`), but\n    // calling it with `new File( ... )` throws an error. This try-catch prevents that. Also when the function will\n    // be implemented correctly in Edge the code will start working without any changes (see #247).\n    return null;\n  }\n}","import 'core-js/modules/es6.string.iterator';\nimport 'core-js/modules/es6.array.from';\nimport _classCallCheck from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck';\nimport _createClass from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass';\nimport _possibleConstructorReturn from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn';\nimport _getPrototypeOf from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf';\nimport _inherits from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits';\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module image/imageupload/imageuploadui\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport FileDialogButtonView from '@ckeditor/ckeditor5-upload/src/ui/filedialogbuttonview';\nimport imageIcon from '@ckeditor/ckeditor5-core/theme/icons/image.svg';\nimport { isImageType } from './utils';\n/**\n * The image upload button plugin.\n *\n * For a detailed overview, check the {@glink features/image-upload/image-upload Image upload feature} documentation.\n *\n * Adds the `'imageUpload'` button to the {@link module:ui/componentfactory~ComponentFactory UI component factory}.\n *\n * @extends module:core/plugin~Plugin\n */\nvar ImageUploadUI = /*#__PURE__*/\nfunction (_Plugin) {\n    _inherits(ImageUploadUI, _Plugin);\n    function ImageUploadUI() {\n        _classCallCheck(this, ImageUploadUI);\n        return _possibleConstructorReturn(this, _getPrototypeOf(ImageUploadUI).apply(this, arguments));\n    }\n    _createClass(ImageUploadUI, [{\n            key: 'init',\n            /**\n     * @inheritDoc\n     */\n            value: function init() {\n                var editor = this.editor;\n                var t = editor.t;\n                // Setup `imageUpload` button.\n                editor.ui.componentFactory.add('imageUpload', function (locale) {\n                    var view = new FileDialogButtonView(locale);\n                    var command = editor.commands.get('imageUpload');\n                    view.set({\n                        acceptedType: 'image/*',\n                        allowMultipleFiles: true\n                    });\n                    view.buttonView.set({\n                        label: t('f'),\n                        icon: imageIcon,\n                        tooltip: true\n                    });\n                    view.buttonView.bind('isEnabled').to(command);\n                    view.on('done', function (evt, files) {\n                        var imagesToUpload = Array.from(files).filter(isImageType);\n                        if (imagesToUpload.length) {\n                            editor.execute('imageUpload', { file: imagesToUpload });\n                        }\n                    });\n                    return view;\n                });\n            }\n        }]);\n    return ImageUploadUI;\n}(Plugin);\nexport {\n    ImageUploadUI as default\n};","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module upload/filereader\n */\n\n/* globals window */\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Wrapper over the native `FileReader`.\n */\n\nvar FileReader =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of the FileReader.\n   */\n  function FileReader() {\n    var _this = this;\n\n    _classCallCheck(this, FileReader);\n\n    var reader = new window.FileReader();\n    /**\n     * Instance of native FileReader.\n     *\n     * @private\n     * @member {FileReader} #_reader\n     */\n\n    this._reader = reader;\n    /**\n     * Number of bytes loaded.\n     *\n     * @readonly\n     * @observable\n     * @member {Number} #loaded\n     */\n\n    this.set('loaded', 0);\n\n    reader.onprogress = function (evt) {\n      _this.loaded = evt.loaded;\n    };\n  }\n  /**\n   * Returns error that occurred during file reading.\n   *\n   * @returns {Error}\n   */\n\n\n  _createClass(FileReader, [{\n    key: \"read\",\n\n    /**\n     * Reads the provided file.\n     *\n     * @param {File} file Native File object.\n     * @returns {Promise.<String>} Returns a promise that will be resolved with file's content.\n     * The promise will be rejected in case of an error or when the reading process is aborted.\n     */\n    value: function read(file) {\n      var _this2 = this;\n\n      var reader = this._reader;\n      this.total = file.size;\n      return new Promise(function (resolve, reject) {\n        reader.onload = function () {\n          resolve(reader.result);\n        };\n\n        reader.onerror = function () {\n          reject('error');\n        };\n\n        reader.onabort = function () {\n          reject('aborted');\n        };\n\n        _this2._reader.readAsDataURL(file);\n      });\n    }\n    /**\n     * Aborts file reader.\n     */\n\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._reader.abort();\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      return this._reader.error;\n    }\n  }]);\n\n  return FileReader;\n}();\n\nexport { FileReader as default };\nmix(FileReader, ObservableMixin);","import 'core-js/modules/es7.symbol.async-iterator';\nimport 'core-js/modules/es6.symbol';\nimport 'core-js/modules/web.dom.iterable';\nimport 'core-js/modules/es6.string.iterator';\nimport 'core-js/modules/es6.map';\nimport _classCallCheck from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck';\nimport _createClass from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass';\nimport _possibleConstructorReturn from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn';\nimport _getPrototypeOf from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf';\nimport _inherits from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits';\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module upload/filerepository\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport PendingActions from '@ckeditor/ckeditor5-core/src/pendingactions';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport FileReader from './filereader.js';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid.js';\n/**\n * File repository plugin. A central point for managing file upload.\n *\n * To use it, first you need an upload adapter. Upload adapter's job is to handle communication with the server\n * (sending the file and handling server's response). You can use one of the existing plugins introducing upload adapters\n * (e.g. {@link module:easy-image/cloudservicesuploadadapter~CloudServicesUploadAdapter} or\n * {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter}) or write your own one  see\n * the {@glink framework/guides/deep-dive/upload-adapter \"Custom image upload adapter\" deep dive guide}.\n *\n * Then, you can use {@link module:upload/filerepository~FileRepository#createLoader `createLoader()`} and the returned\n * {@link module:upload/filerepository~FileLoader} instance to load and upload files.\n *\n * @extends module:core/plugin~Plugin\n */\nvar FileRepository = /*#__PURE__*/\nfunction (_Plugin) {\n    _inherits(FileRepository, _Plugin);\n    function FileRepository() {\n        _classCallCheck(this, FileRepository);\n        return _possibleConstructorReturn(this, _getPrototypeOf(FileRepository).apply(this, arguments));\n    }\n    _createClass(FileRepository, [\n        {\n            key: 'init',\n            /**\n     * @inheritDoc\n     */\n            value: function init() {\n                var _this = this;\n                /**\n       * Collection of loaders associated with this repository.\n       *\n       * @member {module:utils/collection~Collection} #loaders\n       */\n                this.loaders = new Collection();\n                // Keeps upload in a sync with pending actions.\n                this.loaders.on('add', function () {\n                    return _this._updatePendingAction();\n                });\n                this.loaders.on('remove', function () {\n                    return _this._updatePendingAction();\n                });\n                /**\n       * Loaders mappings used to retrieve loaders references.\n       *\n       * @private\n       * @member {Map<File|Promise, FileLoader>} #_loadersMap\n       */\n                this._loadersMap = new Map();\n                /**\n       * Reference to a pending action registered in a {@link module:core/pendingactions~PendingActions} plugin\n       * while upload is in progress. When there is no upload then value is `null`.\n       *\n       * @private\n       * @member {Object} #_pendingAction\n       */\n                this._pendingAction = null;\n                /**\n       * A factory function which should be defined before using `FileRepository`.\n       *\n       * It should return a new instance of {@link module:upload/filerepository~UploadAdapter} that will be used to upload files.\n       * {@link module:upload/filerepository~FileLoader} instance associated with the adapter\n       * will be passed to that function.\n       *\n       * For more information and example see {@link module:upload/filerepository~UploadAdapter}.\n       *\n       * @member {Function} #createUploadAdapter\n       */\n                /**\n       * Number of bytes uploaded.\n       *\n       * @readonly\n       * @observable\n       * @member {Number} #uploaded\n       */\n                this.set('uploaded', 0);\n                /**\n       * Number of total bytes to upload.\n       *\n       * It might be different than the file size because of headers and additional data.\n       * It contains `null` if value is not available yet, so it's better to use {@link #uploadedPercent} to monitor\n       * the progress.\n       *\n       * @readonly\n       * @observable\n       * @member {Number|null} #uploadTotal\n       */\n                this.set('uploadTotal', null);\n                /**\n       * Upload progress in percents.\n       *\n       * @readonly\n       * @observable\n       * @member {Number} #uploadedPercent\n       */\n                this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', function (uploaded, total) {\n                    return total ? uploaded / total * 100 : 0;\n                });\n            }    /**\n     * Returns the loader associated with specified file or promise.\n     *\n     * To get loader by id use `fileRepository.loaders.get( id )`.\n     *\n     * @param {File|Promise.<File>} fileOrPromise Native file or promise handle.\n     * @returns {module:upload/filerepository~FileLoader|null}\n     */\n        },\n        {\n            key: 'getLoader',\n            value: function getLoader(fileOrPromise) {\n                return this._loadersMap.get(fileOrPromise) || null;\n            }    /**\n     * Creates a loader instance for the given file.\n     *\n     * Requires {@link #createUploadAdapter} factory to be defined.\n     *\n     * @param {File|Promise.<File>} fileOrPromise Native File object or native Promise object which resolves to a File.\n     * @returns {module:upload/filerepository~FileLoader|null}\n     */\n        },\n        {\n            key: 'createLoader',\n            value: function createLoader(fileOrPromise) {\n                var _this2 = this;\n                if (!this.createUploadAdapter) {\n                    /**\n         * You need to enable an upload adapter in order to be able to upload files.\n         *\n         * This warning shows up when {@link module:upload/filerepository~FileRepository} is being used\n         * without {@link #createUploadAdapter definining an upload adapter}.\n         *\n         * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**\n         * it means that you did not configure any of the upload adapters available by default in those builds.\n         *\n         * See the {@glink features/image-upload/image-upload comprehensive \"Image upload overview\"} to learn which upload\n         * adapters are available in the builds and how to configure them.\n         *\n         * **If you see this warning when using a custom build** there is a chance that you enabled\n         * a feature like {@link module:image/imageupload~ImageUpload},\n         * or {@link module:image/imageupload/imageuploadui~ImageUploadUI} but you did not enable any upload adapter.\n         * You can choose one of the existing upload adapters listed in the\n         * {@glink features/image-upload/image-upload \"Image upload overview\"}.\n         *\n         * You can also implement your {@glink framework/guides/deep-dive/upload-adapter own image upload adapter}.\n         *\n         * @error filerepository-no-upload-adapter\n         */\n                    log.error('filerepository-no-upload-adapter: Upload adapter is not defined.');\n                    return null;\n                }\n                var loader = new FileLoader(Promise.resolve(fileOrPromise), this.createUploadAdapter);\n                this.loaders.add(loader);\n                this._loadersMap.set(fileOrPromise, loader);\n                // Store also file => loader mapping so loader can be retrieved by file instance returned upon Promise resolution.\n                if (fileOrPromise instanceof Promise) {\n                    loader.file.then(function (file) {\n                        _this2._loadersMap.set(file, loader);\n                    });\n                }\n                // Catch the file promise rejection. If there are no `catch` clause, the browser\n                // will throw an error (see https://github.com/ckeditor/ckeditor5-upload/pull/90).\n                loader.file.catch(function () {\n                });\n                loader.on('change:uploaded', function () {\n                    var aggregatedUploaded = 0;\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n                    try {\n                        for (var _iterator = _this2.loaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                            var _loader = _step.value;\n                            aggregatedUploaded += _loader.uploaded;\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                _iterator.return();\n                            }\n                        } finally {\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                    _this2.uploaded = aggregatedUploaded;\n                });\n                loader.on('change:uploadTotal', function () {\n                    var aggregatedTotal = 0;\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n                    try {\n                        for (var _iterator2 = _this2.loaders[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var _loader2 = _step2.value;\n                            if (_loader2.uploadTotal) {\n                                aggregatedTotal += _loader2.uploadTotal;\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                    _this2.uploadTotal = aggregatedTotal;\n                });\n                return loader;\n            }    /**\n     * Destroys the given loader.\n     *\n     * @param {File|Promise|module:upload/filerepository~FileLoader} fileOrPromiseOrLoader File or Promise associated\n     * with that loader or loader itself.\n     */\n        },\n        {\n            key: 'destroyLoader',\n            value: function destroyLoader(fileOrPromiseOrLoader) {\n                var _this3 = this;\n                var loader = fileOrPromiseOrLoader instanceof FileLoader ? fileOrPromiseOrLoader : this.getLoader(fileOrPromiseOrLoader);\n                loader._destroy();\n                this.loaders.remove(loader);\n                this._loadersMap.forEach(function (value, key) {\n                    if (value === loader) {\n                        _this3._loadersMap.delete(key);\n                    }\n                });\n            }    /**\n     * Registers or deregisters pending action bound with upload progress.\n     *\n     * @private\n     */\n        },\n        {\n            key: '_updatePendingAction',\n            value: function _updatePendingAction() {\n                var pendingActions = this.editor.plugins.get(PendingActions);\n                if (this.loaders.length) {\n                    if (!this._pendingAction) {\n                        var t = this.editor.t;\n                        var getMessage = function getMessage(value) {\n                            return ''.concat(t('bp'), ' ').concat(parseInt(value), '%.');\n                        };\n                        this._pendingAction = pendingActions.add(getMessage(this.uploadedPercent));\n                        this._pendingAction.bind('message').to(this, 'uploadedPercent', getMessage);\n                    }\n                } else {\n                    pendingActions.remove(this._pendingAction);\n                    this._pendingAction = null;\n                }\n            }\n        }\n    ], [\n        {\n            key: 'pluginName',\n            /**\n     * @inheritDoc\n     */\n            get: function get() {\n                return 'FileRepository';\n            }    /**\n     * @inheritDoc\n     */\n        },\n        {\n            key: 'requires',\n            get: function get() {\n                return [PendingActions];\n            }\n        }\n    ]);\n    return FileRepository;\n}(Plugin);\nexport {\n    FileRepository as default\n};\nmix(FileRepository, ObservableMixin);\n/**\n * File loader class.\n *\n * It is used to control the process of reading the file and uploading it using the specified upload adapter.\n */\nvar FileLoader = /*#__PURE__*/\nfunction () {\n    /**\n   * Creates a new instance of `FileLoader`.\n   *\n   * @param {Promise.<File>} filePromise A promise which resolves to a file instance.\n   * @param {Function} uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.\n   */\n    function FileLoader(filePromise, uploadAdapterCreator) {\n        _classCallCheck(this, FileLoader);\n        /**\n     * Unique id of FileLoader instance.\n     *\n     * @readonly\n     * @member {Number}\n     */\n        this.id = uid();\n        /**\n     * Additional wrapper over the initial file promise passed to this loader.\n     *\n     * @private\n     * @member {module:upload/filerepository~FilePromiseWrapper}\n     */\n        this._filePromiseWrapper = this._createFilePromiseWrapper(filePromise);\n        /**\n     * Adapter instance associated with this file loader.\n     *\n     * @private\n     * @member {module:upload/filerepository~UploadAdapter}\n     */\n        this._adapter = uploadAdapterCreator(this);\n        /**\n     * FileReader used by FileLoader.\n     *\n     * @protected\n     * @member {module:upload/filereader~FileReader}\n     */\n        this._reader = new FileReader();\n        /**\n     * Current status of FileLoader. It can be one of the following:\n     *\n     * * 'idle',\n     * * 'reading',\n     * * 'uploading',\n     * * 'aborted',\n     * * 'error'.\n     *\n     * When reading status can change in a following way:\n     *\n     * `idle` -> `reading` -> `idle`\n     * `idle` -> `reading -> `aborted`\n     * `idle` -> `reading -> `error`\n     *\n     * When uploading status can change in a following way:\n     *\n     * `idle` -> `uploading` -> `idle`\n     * `idle` -> `uploading` -> `aborted`\n     * `idle` -> `uploading` -> `error`\n     *\n     * @readonly\n     * @observable\n     * @member {String} #status\n     */\n        this.set('status', 'idle');\n        /**\n     * Number of bytes uploaded.\n     *\n     * @readonly\n     * @observable\n     * @member {Number} #uploaded\n     */\n        this.set('uploaded', 0);\n        /**\n     * Number of total bytes to upload.\n     *\n     * @readonly\n     * @observable\n     * @member {Number|null} #uploadTotal\n     */\n        this.set('uploadTotal', null);\n        /**\n     * Upload progress in percents.\n     *\n     * @readonly\n     * @observable\n     * @member {Number} #uploadedPercent\n     */\n        this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', function (uploaded, total) {\n            return total ? uploaded / total * 100 : 0;\n        });\n        /**\n     * Response of the upload.\n     *\n     * @readonly\n     * @observable\n     * @member {Object|null} #uploadResponse\n     */\n        this.set('uploadResponse', null);\n    }\n    /**\n   * A `Promise` which resolves to a `File` instance associated with this file loader.\n   *\n   * @type {Promise.<File|null>}\n   */\n    _createClass(FileLoader, [\n        {\n            key: 'read',\n            /**\n     * Reads file using {@link module:upload/filereader~FileReader}.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status\n     * is different than `idle`.\n     *\n     * Example usage:\n     *\n     *\tfileLoader.read()\n     *\t\t.then( data => { ... } )\n     *\t\t.catch( err => {\n     *\t\t\tif ( err === 'aborted' ) {\n     *\t\t\t\tconsole.log( 'Reading aborted.' );\n     *\t\t\t} else {\n     *\t\t\t\tconsole.log( 'Reading error.', err );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @returns {Promise.<String>} Returns promise that will be resolved with read data. Promise will be rejected if error\n     * occurs or if read process is aborted.\n     */\n            value: function read() {\n                var _this4 = this;\n                if (this.status != 'idle') {\n                    throw new CKEditorError('filerepository-read-wrong-status: You cannot call read if the status is different than idle.');\n                }\n                this.status = 'reading';\n                return this._filePromiseWrapper.promise.then(function (file) {\n                    return _this4._reader.read(file);\n                }).then(function (data) {\n                    _this4.status = 'idle';\n                    return data;\n                }).catch(function (err) {\n                    if (err === 'aborted') {\n                        _this4.status = 'aborted';\n                        throw 'aborted';\n                    }\n                    _this4.status = 'error';\n                    throw _this4._reader.error ? _this4._reader.error : err;\n                });\n            }    /**\n     * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status\n     * is different than `idle`.\n     * Example usage:\n     *\n     *\tfileLoader.upload()\n     *\t\t.then( data => { ... } )\n     *\t\t.catch( e => {\n     *\t\t\tif ( e === 'aborted' ) {\n     *\t\t\t\tconsole.log( 'Uploading aborted.' );\n     *\t\t\t} else {\n     *\t\t\t\tconsole.log( 'Uploading error.', e );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @returns {Promise.<Object>} Returns promise that will be resolved with response data. Promise will be rejected if error\n     * occurs or if read process is aborted.\n     */\n        },\n        {\n            key: 'upload',\n            value: function upload() {\n                var _this5 = this;\n                if (this.status != 'idle') {\n                    throw new CKEditorError('filerepository-upload-wrong-status: You cannot call upload if the status is different than idle.');\n                }\n                this.status = 'uploading';\n                return this._filePromiseWrapper.promise.then(function () {\n                    return _this5._adapter.upload();\n                }).then(function (data) {\n                    _this5.uploadResponse = data;\n                    _this5.status = 'idle';\n                    return data;\n                }).catch(function (err) {\n                    if (_this5.status === 'aborted') {\n                        throw 'aborted';\n                    }\n                    _this5.status = 'error';\n                    throw err;\n                });\n            }    /**\n     * Aborts loading process.\n     */\n        },\n        {\n            key: 'abort',\n            value: function abort() {\n                var status = this.status;\n                this.status = 'aborted';\n                if (!this._filePromiseWrapper.isFulfilled) {\n                    this._filePromiseWrapper.rejecter('aborted');\n                } else if (status == 'reading') {\n                    this._reader.abort();\n                } else if (status == 'uploading' && this._adapter.abort) {\n                    this._adapter.abort();\n                }\n                this._destroy();\n            }    /**\n     * Performs cleanup.\n     *\n     * @private\n     */\n        },\n        {\n            key: '_destroy',\n            value: function _destroy() {\n                this._filePromiseWrapper = undefined;\n                this._reader = undefined;\n                this._adapter = undefined;\n                this.data = undefined;\n                this.uploadResponse = undefined;\n            }    /**\n     * Wraps a given file promise into another promise giving additional\n     * control (resolving, rejecting, checking if fulfilled) over it.\n     *\n     * @private\n     * @param filePromise The initial file promise to be wrapped.\n     * @returns {module:upload/filerepository~FilePromiseWrapper}\n     */\n        },\n        {\n            key: '_createFilePromiseWrapper',\n            value: function _createFilePromiseWrapper(filePromise) {\n                var wrapper = {};\n                wrapper.promise = new Promise(function (resolve, reject) {\n                    wrapper.resolver = resolve;\n                    wrapper.rejecter = reject;\n                    wrapper.isFulfilled = false;\n                    filePromise.then(function (file) {\n                        wrapper.isFulfilled = true;\n                        resolve(file);\n                    }).catch(function (err) {\n                        wrapper.isFulfilled = true;\n                        reject(err);\n                    });\n                });\n                return wrapper;\n            }\n        },\n        {\n            key: 'file',\n            get: function get() {\n                var _this6 = this;\n                if (!this._filePromiseWrapper) {\n                    // Loader was destroyed, return promise which resolves to null.\n                    return Promise.resolve(null);\n                } else {\n                    // The `this._filePromiseWrapper.promise` is chained and not simply returned to handle a case when:\n                    //\n                    //\t\t* The `loader.file.then( ... )` is called by external code (returned promise is pending).\n                    //\t\t* Then `loader._destroy()` is called (call is synchronous) which destroys the `loader`.\n                    //\t\t* Promise returned by the first `loader.file.then( ... )` call is resolved.\n                    //\n                    // Returning `this._filePromiseWrapper.promise` will still resolve to a `File` instance so there\n                    // is an additional check needed in the chain to see if `loader` was destroyed in the meantime.\n                    return this._filePromiseWrapper.promise.then(function (file) {\n                        return _this6._filePromiseWrapper ? file : null;\n                    });\n                }\n            }\n        }\n    ]);\n    return FileLoader;\n}();\nmix(FileLoader, ObservableMixin);    /**\n * Upload adapter interface used by the {@link module:upload/filerepository~FileRepository file repository}\n * to handle file upload. An upload adapter is a bridge between the editor and server that handles file uploads.\n * It should contain a logic necessary to initiate an upload process and monitor its progress.\n *\n * Learn how to develop your own upload adapter for CKEditor 5 in the\n * {@glink framework/guides/deep-dive/upload-adapter \"Custom upload adapter\" guide}.\n *\n * @interface UploadAdapter\n */\n                                     /**\n * Executes the upload process.\n * This method should return a promise that will resolve when data will be uploaded to server. Promise should be\n * resolved with an object containing information about uploaded file:\n *\n *\t\t{\n *\t\t\tdefault: 'http://server/default-size.image.png'\n *\t\t}\n *\n * Additionally, other image sizes can be provided:\n *\n *\t\t{\n *\t\t\tdefault: 'http://server/default-size.image.png',\n *\t\t\t'160': 'http://server/size-160.image.png',\n *\t\t\t'500': 'http://server/size-500.image.png',\n *\t\t\t'1000': 'http://server/size-1000.image.png',\n *\t\t\t'1052': 'http://server/default-size.image.png'\n *\t\t}\n *\n * NOTE: When returning multiple images, the widest returned one should equal the default one. It is essential to\n * correctly set `width` attribute of the image. See this discussion:\n * https://github.com/ckeditor/ckeditor5-easy-image/issues/4 for more information.\n *\n * Take a look at {@link module:upload/filerepository~UploadAdapter example Adapter implementation} and\n * {@link module:upload/filerepository~FileRepository#createUploadAdapter createUploadAdapter method}.\n *\n * @method module:upload/filerepository~UploadAdapter#upload\n * @returns {Promise.<Object>} Promise that should be resolved when data is uploaded.\n */\n                                     /**\n * Aborts the upload process.\n * After aborting it should reject promise returned from {@link #upload upload()}.\n *\n * Take a look at {@link module:upload/filerepository~UploadAdapter example Adapter implementation} and\n * {@link module:upload/filerepository~FileRepository#createUploadAdapter createUploadAdapter method}.\n *\n * @method module:upload/filerepository~UploadAdapter#abort\n */\n                                     /**\n * Object returned by {@link module:upload/filerepository~FileLoader#_createFilePromiseWrapper} method\n * to add more control over the initial file promise passed to {@link module:upload/filerepository~FileLoader}.\n *\n * @typedef {Object} module:upload/filerepository~FilePromiseWrapper\n * @property {Promise.<File>} promise Wrapper promise which can be chained for further processing.\n * @property {Function} resolver Resolves the promise when called.\n * @property {Function} rejecter Rejects the promise when called.\n * @property {Boolean} isFulfilled Whether original promise is already fulfilled.\n */","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/notification/notification\n */\n\n/* globals window */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n/**\n * The Notification plugin.\n *\n * This plugin sends a few types of notifications: `success`, `info` and `warning`. The notifications need to be\n * handled and displayed by a plugin responsible for showing the UI of the notifications. Using this plugin for dispatching\n * notifications makes it possible to switch the notifications UI.\n *\n * Note that every unhandled and not stopped `warning` notification will be displayed as a system alert.\n * See {@link module:ui/notification/notification~Notification#showWarning}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar Notification =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Notification, _Plugin);\n\n  function Notification() {\n    _classCallCheck(this, Notification);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Notification).apply(this, arguments));\n  }\n\n  _createClass(Notification, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      // Each unhandled and not stopped `show:warning` event is displayed as a system alert.\n      this.on('show:warning', function (evt, data) {\n        window.alert(data.message); // eslint-disable-line no-alert\n      }, {\n        priority: 'lowest'\n      });\n    }\n    /**\n     * Shows a success notification.\n     *\n     * By default, it fires the {@link #event:show:success `show:success` event} with the given `data`. The event namespace can be extended\n     * using the `data.namespace` option. For example:\n     *\n     * \t\tshowSuccess( 'Image is uploaded.', {\n     * \t\t\tnamespace: 'upload:image'\n     * \t\t} );\n     *\n     * will fire the `show:success:upload:image` event.\n     *\n     * You can provide the title of the notification:\n     *\n     *\t\tshowSuccess( 'Image is uploaded.', {\n     *\t\t\ttitle: 'Image upload success'\n     *\t\t} );\n     *\n     * @param {String} message The content of the notification.\n     * @param {Object} [data={}] Additional data.\n     * @param {String} [data.namespace] Additional event namespace.\n     * @param {String} [data.title] The title of the notification.\n     */\n\n  }, {\n    key: \"showSuccess\",\n    value: function showSuccess(message) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._showNotification({\n        message: message,\n        type: 'success',\n        namespace: data.namespace,\n        title: data.title\n      });\n    }\n    /**\n     * Shows an information notification.\n     *\n     * By default, it fires the {@link #event:show:info `show:info` event} with the given `data`. The event namespace can be extended\n     * using the `data.namespace` option. For example:\n     *\n     * \t\tshowInfo( 'Editor is offline.', {\n     * \t\t\tnamespace: 'editor:status'\n     * \t\t} );\n     *\n     * will fire the `show:info:editor:status` event.\n     *\n     * You can provide the title of the notification:\n     *\n     *\t\tshowInfo( 'Editor is offline.', {\n     *\t\t\ttitle: 'Network information'\n     *\t\t} );\n     *\n     * @param {String} message The content of the notification.\n     * @param {Object} [data={}] Additional data.\n     * @param {String} [data.namespace] Additional event namespace.\n     * @param {String} [data.title] The title of the notification.\n     */\n\n  }, {\n    key: \"showInfo\",\n    value: function showInfo(message) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._showNotification({\n        message: message,\n        type: 'info',\n        namespace: data.namespace,\n        title: data.title\n      });\n    }\n    /**\n     * Shows a warning notification.\n     *\n     * By default, it fires the {@link #event:show:warning `show:warning` event}\n     * with the given `data`. The event namespace can be extended using the `data.namespace` option. For example:\n     *\n     * \t\tshowWarning( 'Image upload error.', {\n     * \t\t\tnamespace: 'upload:image'\n     * \t\t} );\n     *\n     * will fire the `show:warning:upload:image` event.\n     *\n     * You can provide the title of the notification:\n     *\n     *\t\tshowWarning( 'Image upload error.', {\n     *\t\t\ttitle: 'Upload failed'\n     *\t\t} );\n     *\n     * Note that each unhandled and not stopped `warning` notification will be displayed as a system alert.\n     * The plugin responsible for displaying warnings should `stop()` the event to prevent displaying it as an alert:\n     *\n     * \t\tnotifications.on( 'show:warning', ( evt, data ) => {\n     * \t\t\t// Do something with the data.\n     *\n     * \t\t\t// Stop this event to prevent displaying it as an alert.\n     * \t\t\tevt.stop();\n     * \t\t} );\n     *\n     * You can attach many listeners to the same event and `stop()` this event in a listener with a low priority:\n     *\n     * \t\tnotifications.on( 'show:warning', ( evt, data ) => {\n     * \t\t\t// Show the warning in the UI, but do not stop it.\n     * \t\t} );\n     *\n     * \t\tnotifications.on( 'show:warning', ( evt, data ) => {\n     * \t\t\t// Log the warning to some error tracker.\n     *\n     * \t\t\t// Stop this event to prevent displaying it as an alert.\n     * \t\t\tevt.stop();\n     * \t\t}, { priority: 'low' } );\n     *\n     * @param {String} message The content of the notification.\n     * @param {Object} [data={}] Additional data.\n     * @param {String} [data.namespace] Additional event namespace.\n     * @param {String} [data.title] The title of the notification.\n     */\n\n  }, {\n    key: \"showWarning\",\n    value: function showWarning(message) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._showNotification({\n        message: message,\n        type: 'warning',\n        namespace: data.namespace,\n        title: data.title\n      });\n    }\n    /**\n     * Fires the `show` event with the specified type, namespace and message.\n     *\n     * @private\n     * @param {Object} data The message data.\n     * @param {String} data.message The content of the notification.\n     * @param {'success'|'info'|'warning'} data.type The type of the message.\n     * @param {String} [data.namespace] Additional event namespace.\n     * @param {String} [data.title=''] The title of the notification.\n     */\n\n  }, {\n    key: \"_showNotification\",\n    value: function _showNotification(data) {\n      var event = \"show:\".concat(data.type) + (data.namespace ? \":\".concat(data.namespace) : '');\n      this.fire(event, {\n        message: data.message,\n        type: data.type,\n        title: data.title || ''\n      });\n    }\n    /**\n     * Fired when one of the `showSuccess()`, `showInfo()`, `showWarning()` methods is called.\n     *\n     * @event show\n     * @param {Object} data The notification data.\n     * @param {String} data.message The content of the notification.\n     * @param {String} data.title The title of the notification.\n     * @param {'success'|'info'|'warning'} data.type The type of the notification.\n     */\n\n    /**\n     * Fired when the `showSuccess()` method is called.\n     *\n     * @event show:success\n     * @param {Object} data The notification data.\n     * @param {String} data.message The content of the notification.\n     * @param {String} data.title The title of the notification.\n     * @param {'success'} data.type The type of the notification.\n     */\n\n    /**\n     * Fired when the `showInfo()` method is called.\n     *\n     * @event show:info\n     * @param {Object} data The notification data.\n     * @param {String} data.message The content of the notification.\n     * @param {String} data.title The title of the notification.\n     * @param {'info'} data.type The type of the notification.\n     */\n\n    /**\n     * Fired when the `showWarning()` method is called.\n     *\n     * When this event is not handled or stopped by `event.stop()`, the `data.message` of this event will\n     * be automatically displayed as a system alert.\n     *\n     * @event show:warning\n     * @param {Object} data The notification data.\n     * @param {String} data.message The content of the notification.\n     * @param {String} data.title The title of the notification.\n     * @param {'warning'} data.type The type of the notification.\n     */\n\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'Notification';\n    }\n  }]);\n\n  return Notification;\n}(Plugin);\n\nexport { Notification as default };","import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport FileRepository from '@ckeditor/ckeditor5-upload/src/filerepository';\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { insertImage, isImageAllowed } from \"../image/utils\";\n/**\n * @module image/imageupload/imageuploadcommand\n */\n\n/**\n * Image upload command.\n *\n * The command is registered by the {@link module:image/imageupload/imageuploadediting~ImageUploadEditing} plugin as `'imageUpload'`.\n *\n * In order to upload an image at the current selection position\n * (according to the {@link module:widget/utils~findOptimalInsertionPosition} algorithm),\n * execute the command and pass the native image file instance:\n *\n *\t\tthis.listenTo( editor.editing.view.document, 'clipboardInput', ( evt, data ) => {\n *\t\t\t// Assuming that only images were pasted:\n *\t\t\tconst images = Array.from( data.dataTransfer.files );\n *\n *\t\t\t// Upload the first image:\n *\t\t\teditor.execute( 'imageUpload', { file: images[ 0 ] } );\n *\t\t} );\n *\n * It is also possible to insert multiple images at once:\n *\n *\t\teditor.execute( 'imageUpload', {\n *\t\t\tfile: [\n *\t\t\t\tfile1,\n *\t\t\t\tfile2\n *\t\t\t]\n *\t\t} );\n *\n * @extends module:core/command~Command\n */\n\nvar ImageUploadCommand =\n/*#__PURE__*/\nfunction (_Command) {\n  _inherits(ImageUploadCommand, _Command);\n\n  function ImageUploadCommand() {\n    _classCallCheck(this, ImageUploadCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageUploadCommand).apply(this, arguments));\n  }\n\n  _createClass(ImageUploadCommand, [{\n    key: \"refresh\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      this.isEnabled = isImageAllowed(this.editor.model);\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param {Object} options Options for the executed command.\n     * @param {File|Array.<File>} options.file The image file or an array of image files to upload.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(options) {\n      var editor = this.editor;\n      var model = editor.model;\n      var fileRepository = editor.plugins.get(FileRepository);\n      model.change(function (writer) {\n        var filesToUpload = Array.isArray(options.file) ? options.file : [options.file];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = filesToUpload[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var file = _step.value;\n            uploadImage(writer, model, fileRepository, file);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      });\n    }\n  }]);\n\n  return ImageUploadCommand;\n}(Command); // Handles uploading single file.\n//\n// @param {module:engine/model/writer~writer} writer\n// @param {module:engine/model/model~Model} model\n// @param {File} file\n\n\nexport { ImageUploadCommand as default };\n\nfunction uploadImage(writer, model, fileRepository, file) {\n  var loader = fileRepository.createLoader(file); // Do not throw when upload adapter is not set. FileRepository will log an error anyway.\n\n  if (!loader) {\n    return;\n  }\n\n  insertImage(writer, model, {\n    uploadId: loader.id\n  });\n}","import 'core-js/modules/es7.array.includes';\nimport 'core-js/modules/es6.string.includes';\nimport 'core-js/modules/es6.object.keys';\nimport 'core-js/modules/es6.function.name';\nimport 'core-js/modules/es7.symbol.async-iterator';\nimport 'core-js/modules/es6.symbol';\nimport 'core-js/modules/web.dom.iterable';\nimport 'core-js/modules/es6.string.iterator';\nimport 'core-js/modules/es6.array.from';\nimport _classCallCheck from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck';\nimport _createClass from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass';\nimport _possibleConstructorReturn from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn';\nimport _getPrototypeOf from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf';\nimport _inherits from 'C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits';\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module image/imageupload/imageuploadediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport FileRepository from '@ckeditor/ckeditor5-upload/src/filerepository';\nimport Notification from '@ckeditor/ckeditor5-ui/src/notification/notification';\nimport UpcastWriter from '@ckeditor/ckeditor5-engine/src/view/upcastwriter';\nimport ImageUploadCommand from '../../src/imageupload/imageuploadcommand';\nimport {\n    isImageType,\n    isLocalImage,\n    fetchLocalImage\n} from '../../src/imageupload/utils';\n/**\n * The editing part of the image upload feature. It registers the `'imageUpload'` command.\n *\n * @extends module:core/plugin~Plugin\n */\nvar ImageUploadEditing = /*#__PURE__*/\nfunction (_Plugin) {\n    _inherits(ImageUploadEditing, _Plugin);\n    function ImageUploadEditing() {\n        _classCallCheck(this, ImageUploadEditing);\n        return _possibleConstructorReturn(this, _getPrototypeOf(ImageUploadEditing).apply(this, arguments));\n    }\n    _createClass(ImageUploadEditing, [\n        {\n            key: 'init',\n            /**\n     * @inheritDoc\n     */\n            value: function init() {\n                var _this = this;\n                var editor = this.editor;\n                var doc = editor.model.document;\n                var schema = editor.model.schema;\n                var conversion = editor.conversion;\n                var fileRepository = editor.plugins.get(FileRepository);\n                // Setup schema to allow uploadId and uploadStatus for images.\n                schema.extend('image', {\n                    allowAttributes: [\n                        'uploadId',\n                        'uploadStatus'\n                    ]\n                });\n                // Register imageUpload command.\n                editor.commands.add('imageUpload', new ImageUploadCommand(editor));\n                // Register upcast converter for uploadId.\n                conversion.for('upcast').attributeToAttribute({\n                    view: {\n                        name: 'img',\n                        key: 'uploadId'\n                    },\n                    model: 'uploadId'\n                });\n                // Handle pasted images.\n                // For every image file, a new file loader is created and a placeholder image is\n                // inserted into the content. Then, those images are uploaded once they appear in the model\n                // (see Document#change listener below).\n                this.listenTo(editor.editing.view.document, 'clipboardInput', function (evt, data) {\n                    // Skip if non empty HTML data is included.\n                    // https://github.com/ckeditor/ckeditor5-upload/issues/68\n                    if (isHtmlIncluded(data.dataTransfer)) {\n                        return;\n                    }\n                    var images = Array.from(data.dataTransfer.files).filter(function (file) {\n                        // See https://github.com/ckeditor/ckeditor5-image/pull/254.\n                        if (!file) {\n                            return false;\n                        }\n                        return isImageType(file);\n                    });\n                    var ranges = data.targetRanges.map(function (viewRange) {\n                        return editor.editing.mapper.toModelRange(viewRange);\n                    });\n                    editor.model.change(function (writer) {\n                        // Set selection to paste target.\n                        writer.setSelection(ranges);\n                        if (images.length) {\n                            evt.stop();\n                            // Upload images after the selection has changed in order to ensure the command's state is refreshed.\n                            editor.model.enqueueChange('default', function () {\n                                editor.execute('imageUpload', { file: images });\n                            });\n                        }\n                    });\n                });\n                // Handle HTML pasted with images with base64 or blob sources.\n                // For every image file, a new file loader is created and a placeholder image is\n                // inserted into the content. Then, those images are uploaded once they appear in the model\n                // (see Document#change listener below).\n                if (editor.plugins.has('Clipboard')) {\n                    this.listenTo(editor.plugins.get('Clipboard'), 'inputTransformation', function (evt, data) {\n                        var fetchableImages = Array.from(editor.editing.view.createRangeIn(data.content)).filter(function (value) {\n                            return isLocalImage(value.item) && !value.item.getAttribute('uploadProcessed');\n                        }).map(function (value) {\n                            return {\n                                promise: fetchLocalImage(value.item),\n                                imageElement: value.item\n                            };\n                        });\n                        if (!fetchableImages.length) {\n                            return;\n                        }\n                        var writer = new UpcastWriter();\n                        var _iteratorNormalCompletion = true;\n                        var _didIteratorError = false;\n                        var _iteratorError = undefined;\n                        try {\n                            for (var _iterator = fetchableImages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                                var fetchableImage = _step.value;\n                                // Set attribute marking that the image was processed already.\n                                writer.setAttribute('uploadProcessed', true, fetchableImage.imageElement);\n                                var loader = fileRepository.createLoader(fetchableImage.promise);\n                                if (loader) {\n                                    writer.setAttribute('src', '', fetchableImage.imageElement);\n                                    writer.setAttribute('uploadId', loader.id, fetchableImage.imageElement);\n                                }\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                    _iterator.return();\n                                }\n                            } finally {\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n                    });\n                }\n                // Prevents from the browser redirecting to the dropped image.\n                editor.editing.view.document.on('dragover', function (evt, data) {\n                    data.preventDefault();\n                });\n                // Upload placeholder images that appeared in the model.\n                doc.on('change', function () {\n                    var changes = doc.differ.getChanges({ includeChangesInGraveyard: true });\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n                    try {\n                        for (var _iterator2 = changes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var entry = _step2.value;\n                            if (entry.type == 'insert' && entry.name == 'image') {\n                                var item = entry.position.nodeAfter;\n                                var isInGraveyard = entry.position.root.rootName == '$graveyard';\n                                // Check if the image element still has upload id.\n                                var uploadId = item.getAttribute('uploadId');\n                                if (!uploadId) {\n                                    continue;\n                                }\n                                // Check if the image is loaded on this client.\n                                var loader = fileRepository.loaders.get(uploadId);\n                                if (!loader) {\n                                    continue;\n                                }\n                                if (isInGraveyard) {\n                                    // If the image was inserted to the graveyard - abort the loading process.\n                                    loader.abort();\n                                } else if (loader.status == 'idle') {\n                                    // If the image was inserted into content and has not been loaded yet, start loading it.\n                                    _this._readAndUpload(loader, item);\n                                }\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                });\n            }    /**\n     * Read and upload an image.\n     *\n     * The image is read from the disk and as a base64 encoded string it is set temporarily to\n     * `image[src]`. When the image is successfully uploaded the temporary data is replaced with the target\n     * image's URL (the URL to the uploaded image on the server).\n     *\n     * @protected\n     * @param {module:upload/filerepository~FileLoader} loader\n     * @param {module:engine/model/element~Element} imageElement\n     * @returns {Promise}\n     */\n        },\n        {\n            key: '_readAndUpload',\n            value: function _readAndUpload(loader, imageElement) {\n                var _this2 = this;\n                var editor = this.editor;\n                var model = editor.model;\n                var t = editor.locale.t;\n                var fileRepository = editor.plugins.get(FileRepository);\n                var notification = editor.plugins.get(Notification);\n                model.enqueueChange('transparent', function (writer) {\n                    writer.setAttribute('uploadStatus', 'reading', imageElement);\n                });\n                return loader.read().then(function (data) {\n                    var viewFigure = editor.editing.mapper.toViewElement(imageElement);\n                    var viewImg = viewFigure.getChild(0);\n                    var promise = loader.upload();\n                    editor.editing.view.change(function (writer) {\n                        writer.setAttribute('src', data, viewImg);\n                    });\n                    model.enqueueChange('transparent', function (writer) {\n                        writer.setAttribute('uploadStatus', 'uploading', imageElement);\n                    });\n                    return promise;\n                }).then(function (data) {\n                    model.enqueueChange('transparent', function (writer) {\n                        writer.setAttributes({\n                            uploadStatus: 'complete',\n                            src: data.default\n                        }, imageElement);\n                        _this2._parseAndSetSrcsetAttributeOnImage(data, imageElement, writer);\n                    });\n                    clean();\n                }).catch(function (error) {\n                    // If status is not 'error' nor 'aborted' - throw error because it means that something else went wrong,\n                    // it might be generic error and it would be real pain to find what is going on.\n                    if (loader.status !== 'error' && loader.status !== 'aborted') {\n                        throw error;\n                    }\n                    // Might be 'aborted'.\n                    if (loader.status == 'error' && error) {\n                        notification.showWarning(error, {\n                            title: t('al'),\n                            namespace: 'upload'\n                        });\n                    }\n                    clean();\n                    // Permanently remove image from insertion batch.\n                    model.enqueueChange('transparent', function (writer) {\n                        writer.remove(imageElement);\n                    });\n                });\n                function clean() {\n                    model.enqueueChange('transparent', function (writer) {\n                        writer.removeAttribute('uploadId', imageElement);\n                        writer.removeAttribute('uploadStatus', imageElement);\n                    });\n                    fileRepository.destroyLoader(loader);\n                }\n            }    /**\n     * Creates `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.\n     *\n     * @protected\n     * @param {Object} data Data object from which `srcset` will be created.\n     * @param {module:engine/model/element~Element} image The image element on which `srcset` attribute will be set.\n     * @param {module:engine/model/writer~Writer} writer\n     */\n        },\n        {\n            key: '_parseAndSetSrcsetAttributeOnImage',\n            value: function _parseAndSetSrcsetAttributeOnImage(data, image, writer) {\n                // Srcset attribute for responsive images support.\n                var maxWidth = 0;\n                var srcsetAttribute = Object.keys(data)    // Filter out keys that are not integers.\n.filter(function (key) {\n                    var width = parseInt(key, 10);\n                    if (!isNaN(width)) {\n                        maxWidth = Math.max(maxWidth, width);\n                        return true;\n                    }\n                })    // Convert each key to srcset entry.\n.map(function (key) {\n                    return ''.concat(data[key], ' ').concat(key, 'w');\n                })    // Join all entries.\n.join(', ');\n                if (srcsetAttribute != '') {\n                    writer.setAttribute('srcset', {\n                        data: srcsetAttribute,\n                        width: maxWidth\n                    }, image);\n                }\n            }\n        }\n    ], [{\n            key: 'requires',\n            /**\n     * @inheritDoc\n     */\n            get: function get() {\n                return [\n                    FileRepository,\n                    Notification\n                ];\n            }\n        }]);\n    return ImageUploadEditing;\n}(Plugin);\n// Returns `true` if non-empty `text/html` is included in the data transfer.\n//\n// @param {module:clipboard/datatransfer~DataTransfer} dataTransfer\n// @returns {Boolean}\nexport {\n    ImageUploadEditing as default\n};\nexport function isHtmlIncluded(dataTransfer) {\n    return Array.from(dataTransfer.types).includes('text/html') && dataTransfer.getData('text/html') !== '';\n}","import _classCallCheck from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Developement\\\\LimeSurveyDevelop\\\\webroot\\\\assets\\\\packages\\\\emailtemplates\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageupload\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ImageUploadUI from \"./imageupload/imageuploadui\";\nimport ImageUploadProgress from \"./imageupload/imageuploadprogress\";\nimport ImageUploadEditing from \"./imageupload/imageuploadediting\";\n/**\n * The image upload plugin.\n *\n * For a detailed overview, check the {@glink features/image-upload/image-upload image upload feature} documentation.\n *\n * This plugin does not do anything directly, but it loads a set of specific plugins to enable image uploading:\n *\n * * {@link module:image/imageupload/imageuploadediting~ImageUploadEditing},\n * * {@link module:image/imageupload/imageuploadui~ImageUploadUI},\n * * {@link module:image/imageupload/imageuploadprogress~ImageUploadProgress}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ImageUpload =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ImageUpload, _Plugin);\n\n  function ImageUpload() {\n    _classCallCheck(this, ImageUpload);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageUpload).apply(this, arguments));\n  }\n\n  _createClass(ImageUpload, null, [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'ImageUpload';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"requires\",\n    get: function get() {\n      return [ImageUploadEditing, ImageUploadUI, ImageUploadProgress];\n    }\n  }]);\n\n  return ImageUpload;\n}(Plugin);\n\nexport { ImageUpload as default };","/**\n * vuex v3.1.0\n * (c) 2019 Evan You\n * @license MIT\n */\nfunction applyMixin (Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit });\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    var options = this.$options;\n    // store injection\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n}\n\nvar devtoolHook =\n  typeof window !== 'undefined' &&\n  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\nfunction devtoolPlugin (store) {\n  if (!devtoolHook) { return }\n\n  store._devtoolHook = devtoolHook;\n\n  devtoolHook.emit('vuex:init', store);\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState);\n  });\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state);\n  });\n}\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\n\n/**\n * forEach for object\n */\nfunction forEachValue (obj, fn) {\n  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });\n}\n\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nfunction isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n\nfunction assert (condition, msg) {\n  if (!condition) { throw new Error((\"[vuex] \" + msg)) }\n}\n\n// Base data struct for store's module, package with some attribute and method\nvar Module = function Module (rawModule, runtime) {\n  this.runtime = runtime;\n  // Store some children item\n  this._children = Object.create(null);\n  // Store the origin module object which passed by programmer\n  this._rawModule = rawModule;\n  var rawState = rawModule.state;\n\n  // Store the origin module's state\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};\n};\n\nvar prototypeAccessors = { namespaced: { configurable: true } };\n\nprototypeAccessors.namespaced.get = function () {\n  return !!this._rawModule.namespaced\n};\n\nModule.prototype.addChild = function addChild (key, module) {\n  this._children[key] = module;\n};\n\nModule.prototype.removeChild = function removeChild (key) {\n  delete this._children[key];\n};\n\nModule.prototype.getChild = function getChild (key) {\n  return this._children[key]\n};\n\nModule.prototype.update = function update (rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced;\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions;\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations;\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters;\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild (fn) {\n  forEachValue(this._children, fn);\n};\n\nModule.prototype.forEachGetter = function forEachGetter (fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn);\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction (fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn);\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation (fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn);\n  }\n};\n\nObject.defineProperties( Module.prototype, prototypeAccessors );\n\nvar ModuleCollection = function ModuleCollection (rawRootModule) {\n  // register root module (Vuex.Store options)\n  this.register([], rawRootModule, false);\n};\n\nModuleCollection.prototype.get = function get (path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key)\n  }, this.root)\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace (path) {\n  var module = this.root;\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key);\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n};\n\nModuleCollection.prototype.update = function update$1 (rawRootModule) {\n  update([], this.root, rawRootModule);\n};\n\nModuleCollection.prototype.register = function register (path, rawModule, runtime) {\n    var this$1 = this;\n    if ( runtime === void 0 ) runtime = true;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertRawModule(path, rawModule);\n  }\n\n  var newModule = new Module(rawModule, runtime);\n  if (path.length === 0) {\n    this.root = newModule;\n  } else {\n    var parent = this.get(path.slice(0, -1));\n    parent.addChild(path[path.length - 1], newModule);\n  }\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime);\n    });\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister (path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n  if (!parent.getChild(key).runtime) { return }\n\n  parent.removeChild(key);\n};\n\nfunction update (path, targetModule, newModule) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertRawModule(path, newModule);\n  }\n\n  // update target module\n  targetModule.update(newModule);\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            \"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" +\n            'manual reload is needed'\n          );\n        }\n        return\n      }\n      update(\n        path.concat(key),\n        targetModule.getChild(key),\n        newModule.modules[key]\n      );\n    }\n  }\n}\n\nvar functionAssert = {\n  assert: function (value) { return typeof value === 'function'; },\n  expected: 'function'\n};\n\nvar objectAssert = {\n  assert: function (value) { return typeof value === 'function' ||\n    (typeof value === 'object' && typeof value.handler === 'function'); },\n  expected: 'function or object with \"handler\" function'\n};\n\nvar assertTypes = {\n  getters: functionAssert,\n  mutations: functionAssert,\n  actions: objectAssert\n};\n\nfunction assertRawModule (path, rawModule) {\n  Object.keys(assertTypes).forEach(function (key) {\n    if (!rawModule[key]) { return }\n\n    var assertOptions = assertTypes[key];\n\n    forEachValue(rawModule[key], function (value, type) {\n      assert(\n        assertOptions.assert(value),\n        makeAssertionMessage(path, key, type, value, assertOptions.expected)\n      );\n    });\n  });\n}\n\nfunction makeAssertionMessage (path, key, type, value, expected) {\n  var buf = key + \" should be \" + expected + \" but \\\"\" + key + \".\" + type + \"\\\"\";\n  if (path.length > 0) {\n    buf += \" in module \\\"\" + (path.join('.')) + \"\\\"\";\n  }\n  buf += \" is \" + (JSON.stringify(value)) + \".\";\n  return buf\n}\n\nvar Vue; // bind on install\n\nvar Store = function Store (options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  // Auto install if it is not done yet and `window` has `Vue`.\n  // To allow users to avoid auto-installation in some cases,\n  // this code should be placed here. See #731\n  if (!Vue && typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\");\n    assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\");\n    assert(this instanceof Store, \"store must be called with the new operator.\");\n  }\n\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n  // store internal state\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._actionSubscribers = [];\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n\n  // bind commit and dispatch to self\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n  };\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n  };\n\n  // strict mode\n  this.strict = strict;\n\n  var state = this._modules.root.state;\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root);\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state);\n\n  // apply plugins\n  plugins.forEach(function (plugin) { return plugin(this$1); });\n\n  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;\n  if (useDevtools) {\n    devtoolPlugin(this);\n  }\n};\n\nvar prototypeAccessors$1 = { state: { configurable: true } };\n\nprototypeAccessors$1.state.get = function () {\n  return this._vm._data.$$state\n};\n\nprototypeAccessors$1.state.set = function (v) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(false, \"use store.replaceState() to explicit replace store state.\");\n  }\n};\n\nStore.prototype.commit = function commit (_type, _payload, _options) {\n    var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n    var type = ref.type;\n    var payload = ref.payload;\n    var options = ref.options;\n\n  var mutation = { type: type, payload: payload };\n  var entry = this._mutations[type];\n  if (!entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error((\"[vuex] unknown mutation type: \" + type));\n    }\n    return\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload);\n    });\n  });\n  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    options && options.silent\n  ) {\n    console.warn(\n      \"[vuex] mutation type: \" + type + \". Silent option has been removed. \" +\n      'Use the filter functionality in the vue-devtools'\n    );\n  }\n};\n\nStore.prototype.dispatch = function dispatch (_type, _payload) {\n    var this$1 = this;\n\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n    var type = ref.type;\n    var payload = ref.payload;\n\n  var action = { type: type, payload: payload };\n  var entry = this._actions[type];\n  if (!entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error((\"[vuex] unknown action type: \" + type));\n    }\n    return\n  }\n\n  try {\n    this._actionSubscribers\n      .filter(function (sub) { return sub.before; })\n      .forEach(function (sub) { return sub.before(action, this$1.state); });\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\"[vuex] error in before action subscribers: \");\n      console.error(e);\n    }\n  }\n\n  var result = entry.length > 1\n    ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n    : entry[0](payload);\n\n  return result.then(function (res) {\n    try {\n      this$1._actionSubscribers\n        .filter(function (sub) { return sub.after; })\n        .forEach(function (sub) { return sub.after(action, this$1.state); });\n    } catch (e) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\"[vuex] error in after action subscribers: \");\n        console.error(e);\n      }\n    }\n    return res\n  })\n};\n\nStore.prototype.subscribe = function subscribe (fn) {\n  return genericSubscribe(fn, this._subscribers)\n};\n\nStore.prototype.subscribeAction = function subscribeAction (fn) {\n  var subs = typeof fn === 'function' ? { before: fn } : fn;\n  return genericSubscribe(subs, this._actionSubscribers)\n};\n\nStore.prototype.watch = function watch (getter, cb, options) {\n    var this$1 = this;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof getter === 'function', \"store.watch only accepts a function.\");\n  }\n  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)\n};\n\nStore.prototype.replaceState = function replaceState (state) {\n    var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm._data.$$state = state;\n  });\n};\n\nStore.prototype.registerModule = function registerModule (path, rawModule, options) {\n    if ( options === void 0 ) options = {};\n\n  if (typeof path === 'string') { path = [path]; }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(Array.isArray(path), \"module path must be a string or an Array.\");\n    assert(path.length > 0, 'cannot register the root module by using registerModule.');\n  }\n\n  this._modules.register(path, rawModule);\n  installModule(this, this.state, path, this._modules.get(path), options.preserveState);\n  // reset store to update getters...\n  resetStoreVM(this, this.state);\n};\n\nStore.prototype.unregisterModule = function unregisterModule (path) {\n    var this$1 = this;\n\n  if (typeof path === 'string') { path = [path]; }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  }\n\n  this._modules.unregister(path);\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1));\n    Vue.delete(parentState, path[path.length - 1]);\n  });\n  resetStore(this);\n};\n\nStore.prototype.hotUpdate = function hotUpdate (newOptions) {\n  this._modules.update(newOptions);\n  resetStore(this, true);\n};\n\nStore.prototype._withCommit = function _withCommit (fn) {\n  var committing = this._committing;\n  this._committing = true;\n  fn();\n  this._committing = committing;\n};\n\nObject.defineProperties( Store.prototype, prototypeAccessors$1 );\n\nfunction genericSubscribe (fn, subs) {\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn);\n  }\n  return function () {\n    var i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1);\n    }\n  }\n}\n\nfunction resetStore (store, hot) {\n  store._actions = Object.create(null);\n  store._mutations = Object.create(null);\n  store._wrappedGetters = Object.create(null);\n  store._modulesNamespaceMap = Object.create(null);\n  var state = store.state;\n  // init all modules\n  installModule(store, state, [], store._modules.root, true);\n  // reset vm\n  resetStoreVM(store, state, hot);\n}\n\nfunction resetStoreVM (store, state, hot) {\n  var oldVm = store._vm;\n\n  // bind store public getters\n  store.getters = {};\n  var wrappedGetters = store._wrappedGetters;\n  var computed = {};\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = function () { return fn(store); };\n    Object.defineProperty(store.getters, key, {\n      get: function () { return store._vm[key]; },\n      enumerable: true // for local getters\n    });\n  });\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed: computed\n  });\n  Vue.config.silent = silent;\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store);\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(function () {\n        oldVm._data.$$state = null;\n      });\n    }\n    Vue.nextTick(function () { return oldVm.$destroy(); });\n  }\n}\n\nfunction installModule (store, rootState, path, module, hot) {\n  var isRoot = !path.length;\n  var namespace = store._modules.getNamespace(path);\n\n  // register in namespace map\n  if (module.namespaced) {\n    store._modulesNamespaceMap[namespace] = module;\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1));\n    var moduleName = path[path.length - 1];\n    store._withCommit(function () {\n      Vue.set(parentState, moduleName, module.state);\n    });\n  }\n\n  var local = module.context = makeLocalContext(store, namespace, path);\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key;\n    registerMutation(store, namespacedType, mutation, local);\n  });\n\n  module.forEachAction(function (action, key) {\n    var type = action.root ? key : namespace + key;\n    var handler = action.handler || action;\n    registerAction(store, type, handler, local);\n  });\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key;\n    registerGetter(store, namespacedType, getter, local);\n  });\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot);\n  });\n}\n\n/**\n * make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext (store, namespace, path) {\n  var noNamespace = namespace === '';\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (process.env.NODE_ENV !== 'production' && !store._actions[type]) {\n          console.error((\"[vuex] unknown local action type: \" + (args.type) + \", global type: \" + type));\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (process.env.NODE_ENV !== 'production' && !store._mutations[type]) {\n          console.error((\"[vuex] unknown local mutation type: \" + (args.type) + \", global type: \" + type));\n          return\n        }\n      }\n\n      store.commit(type, payload, options);\n    }\n  };\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? function () { return store.getters; }\n        : function () { return makeLocalGetters(store, namespace); }\n    },\n    state: {\n      get: function () { return getNestedState(store.state, path); }\n    }\n  });\n\n  return local\n}\n\nfunction makeLocalGetters (store, namespace) {\n  var gettersProxy = {};\n\n  var splitPos = namespace.length;\n  Object.keys(store.getters).forEach(function (type) {\n    // skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) { return }\n\n    // extract local getter type\n    var localType = type.slice(splitPos);\n\n    // Add a port to the getters proxy.\n    // Define as getter property because\n    // we do not want to evaluate the getters in this time.\n    Object.defineProperty(gettersProxy, localType, {\n      get: function () { return store.getters[type]; },\n      enumerable: true\n    });\n  });\n\n  return gettersProxy\n}\n\nfunction registerMutation (store, type, handler, local) {\n  var entry = store._mutations[type] || (store._mutations[type] = []);\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload);\n  });\n}\n\nfunction registerAction (store, type, handler, local) {\n  var entry = store._actions[type] || (store._actions[type] = []);\n  entry.push(function wrappedActionHandler (payload, cb) {\n    var res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb);\n    if (!isPromise(res)) {\n      res = Promise.resolve(res);\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err);\n        throw err\n      })\n    } else {\n      return res\n    }\n  });\n}\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error((\"[vuex] duplicate getter key: \" + type));\n    }\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  };\n}\n\nfunction enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, function () {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(store._committing, \"do not mutate vuex store state outside mutation handlers.\");\n    }\n  }, { deep: true, sync: true });\n}\n\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce(function (state, key) { return state[key]; }, state)\n    : state\n}\n\nfunction unifyObjectStyle (type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload;\n    payload = type;\n    type = type.type;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof type === 'string', (\"expects string as the type, but found \" + (typeof type) + \".\"));\n  }\n\n  return { type: type, payload: payload, options: options }\n}\n\nfunction install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      );\n    }\n    return\n  }\n  Vue = _Vue;\n  applyMixin(Vue);\n}\n\n/**\n * Reduce the code which written in Vue.js for getting the state.\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.\n * @param {Object}\n */\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {};\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState () {\n      var state = this.$store.state;\n      var getters = this.$store.getters;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapState', namespace);\n        if (!module) {\n          return\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\n/**\n * Reduce the code which written in Vue.js for committing the mutation\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.\n * @return {Object}\n */\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {};\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedMutation () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Get the commit method from store\n      var commit = this.$store.commit;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);\n        if (!module) {\n          return\n        }\n        commit = module.context.commit;\n      }\n      return typeof val === 'function'\n        ? val.apply(this, [commit].concat(args))\n        : commit.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\n/**\n * Reduce the code which written in Vue.js for getting the getters\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} getters\n * @return {Object}\n */\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {};\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    // The namespace has been mutated by normalizeNamespace\n    val = namespace + val;\n    res[key] = function mappedGetter () {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return\n      }\n      if (process.env.NODE_ENV !== 'production' && !(val in this.$store.getters)) {\n        console.error((\"[vuex] unknown getter: \" + val));\n        return\n      }\n      return this.$store.getters[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\n/**\n * Reduce the code which written in Vue.js for dispatch the action\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.\n * @return {Object}\n */\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {};\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedAction () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // get dispatch function from store\n      var dispatch = this.$store.dispatch;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);\n        if (!module) {\n          return\n        }\n        dispatch = module.context.dispatch;\n      }\n      return typeof val === 'function'\n        ? val.apply(this, [dispatch].concat(args))\n        : dispatch.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\n/**\n * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object\n * @param {String} namespace\n * @return {Object}\n */\nvar createNamespacedHelpers = function (namespace) { return ({\n  mapState: mapState.bind(null, namespace),\n  mapGetters: mapGetters.bind(null, namespace),\n  mapMutations: mapMutations.bind(null, namespace),\n  mapActions: mapActions.bind(null, namespace)\n}); };\n\n/**\n * Normalize the map\n * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]\n * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]\n * @param {Array|Object} map\n * @return {Object}\n */\nfunction normalizeMap (map) {\n  return Array.isArray(map)\n    ? map.map(function (key) { return ({ key: key, val: key }); })\n    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n}\n\n/**\n * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.\n * @param {Function} fn\n * @return {Function}\n */\nfunction normalizeNamespace (fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace;\n      namespace = '';\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/';\n    }\n    return fn(namespace, map)\n  }\n}\n\n/**\n * Search a special module from store by namespace. if module not exist, print error message.\n * @param {Object} store\n * @param {String} helper\n * @param {String} namespace\n * @return {Object}\n */\nfunction getModuleByNamespace (store, helper, namespace) {\n  var module = store._modulesNamespaceMap[namespace];\n  if (process.env.NODE_ENV !== 'production' && !module) {\n    console.error((\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace));\n  }\n  return module\n}\n\nvar index_esm = {\n  Store: Store,\n  install: install,\n  version: '3.1.0',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions,\n  createNamespacedHelpers: createNamespacedHelpers\n};\n\nexport default index_esm;\nexport { Store, install, mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers };\n","/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global console */\n\n/**\n * @module utils/log\n */\nimport { attachLinkToDocumentation } from \"./ckeditorerror\";\n/**\n * The logging module.\n *\n * This object features two functions that should be used across CKEditor code base to log errors and warnings.\n * Despite being an overridable interface for native `console.*` this module serves also the goal to limit the\n * code size of a minified CKEditor package. During minification process the messages will be shortened and\n * links to their documentation will be logged to the console.\n *\n * All errors and warning should be documented in the following way:\n *\n *\t\t/**\n *\t\t * Error thrown when a plugin cannot be loaded due to JavaScript errors, lack of plugins with a given name, etc.\n *\t\t *\n *\t\t * @error plugin-load\n *\t\t * @param pluginName The name of the plugin that could not be loaded.\n *\t\t * @param moduleName The name of the module which tried to load this plugin.\n *\t\t * /\n *\t\tlog.error( 'plugin-load: It was not possible to load the \"{$pluginName}\" plugin in module \"{$moduleName}', {\n *\t\t\tpluginName: 'foo',\n *\t\t\tmoduleName: 'bar'\n *\t\t} );\n *\n * ### Warning vs Error vs Throw\n *\n * * Whenever a potentially incorrect situation occurs, which does not directly lead to an incorrect behavior,\n * log a warning.\n * * Whenever an incorrect situation occurs, but the app may continue working (although perhaps incorrectly),\n * log an error.\n * * Whenever it's really bad and it does not make sense to continue working, throw a {@link module:utils/ckeditorerror~CKEditorError}.\n *\n * @namespace\n */\n\nvar log = {\n  /**\n   * Logs an error to the console.\n   *\n   * Read more about error logging in the {@link module:utils/log} module.\n   *\n   * @param {String} message The error message in an `error-name: Error message.` format.\n   * During the minification process the \"Error message\" part will be removed to limit the code size\n   * and a link to this error documentation will be logged to the console.\n   * @param {Object} [data] Additional data describing the error.\n   */\n  error: function error(message, data) {\n    console.error(attachLinkToDocumentation(message), data);\n  },\n\n  /**\n   * Logs a warning to the console.\n   *\n   * Read more about error logging in the {@link module:utils/log} module.\n   *\n   * @param {String} message The warning message in a `warning-name: Warning message.` format.\n   * During the minification process the \"Warning message\" part will be removed to limit the code size\n   * and a link to this error documentation will be logged to the console.\n   * @param {Object} [data] Additional data describing the warning.\n   */\n  warn: function warn(message, data) {\n    console.warn(attachLinkToDocumentation(message), data);\n  }\n};\nexport default log;","/**\n * vue-local-storage v0.5.0\n * (c) 2017 Alexander Avakov\n * @license MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.VueLocalStorage = factory());\n}(this, (function () { 'use strict';\n\nvar VueLocalStorage = function VueLocalStorage () {\n  this._properties = {};\n};\n\n/**\n * Get value from localStorage\n *\n * @param {String} lsKey\n * @param {*} defaultValue\n * @returns {*}\n */\nVueLocalStorage.prototype.get = function get (lsKey, defaultValue) {\n    var this$1 = this;\n    if ( defaultValue === void 0 ) defaultValue = null;\n\n  if (window.localStorage[lsKey]) {\n    var type = String;\n\n    for (var key in this$1._properties) {\n      if (key === lsKey) {\n        type = this$1._properties[key].type;\n        break\n      }\n    }\n\n    return this._process(type, window.localStorage[lsKey])\n  }\n\n  return defaultValue !== null ? defaultValue : null\n};\n\n/**\n * Set localStorage value\n *\n * @param {String} lsKey\n * @param {*} value\n * @returns {*}\n */\nVueLocalStorage.prototype.set = function set (lsKey, value) {\n    var this$1 = this;\n\n  for (var key in this$1._properties) {\n    var type = this$1._properties[key].type;\n\n    if ((key === lsKey) && [Array, Object].includes(type)) {\n      window.localStorage.setItem(lsKey, JSON.stringify(value));\n\n      return value\n    }\n  }\n\n  window.localStorage.setItem(lsKey, value);\n\n  return value\n};\n\n/**\n * Remove value from localStorage\n *\n * @param {String} lsKey\n */\nVueLocalStorage.prototype.remove = function remove (lsKey) {\n  return window.localStorage.removeItem(lsKey)\n};\n\n/**\n * Add new property to localStorage\n *\n * @param {String} key\n * @param {function} type\n * @param {*} defaultValue\n */\nVueLocalStorage.prototype.addProperty = function addProperty (key, type, defaultValue) {\n    if ( defaultValue === void 0 ) defaultValue = undefined;\n\n  type = type || String;\n\n  this._properties[key] = { type: type };\n\n  if (!window.localStorage[key] && defaultValue !== null) {\n    window.localStorage.setItem(\n      key,\n      [Array, Object].includes(type) ? JSON.stringify(defaultValue) : defaultValue\n    );\n  }\n};\n\n/**\n * Process the value before return it from localStorage\n *\n * @param {String} type\n * @param {*} value\n * @returns {*}\n * @private\n */\nVueLocalStorage.prototype._process = function _process (type, value) {\n  switch (type) {\n    case Boolean:\n      return value === 'true'\n    case Number:\n      return parseInt(value, 10)\n    case Array:\n      try {\n        var array = JSON.parse(value);\n\n        return Array.isArray(array) ? array : []\n      } catch (e) {\n        return []\n      }\n    case Object:\n      try {\n        return JSON.parse(value)\n      } catch (e) {\n        return {}\n      }\n    default:\n      return value\n  }\n};\n\nvar VueLocalStorage$1 = new VueLocalStorage();\n\nvar index = {\n  /**\n   * Install vue-local-storage plugin\n   *\n   * @param {Vue} Vue\n   * @param {Object} options\n   */\n  install: function (Vue, options) {\n    if ( options === void 0 ) options = {};\n\n    if (typeof process !== 'undefined' &&\n      (\n        process.server ||\n        process.SERVER_BUILD ||\n        (process.env && process.env.VUE_ENV === 'server')\n      )\n    ) {\n      return\n    }\n\n    try {\n      var test = '__vue-localstorage-test__';\n\n      window.localStorage.setItem(test, test);\n      window.localStorage.removeItem(test);\n    } catch (e) {\n      console.error('Local storage is not supported');\n    }\n\n    var name = options.name || 'localStorage';\n    var bind = options.bind;\n\n    Vue.mixin({\n      beforeCreate: function beforeCreate () {\n        var this$1 = this;\n\n        if (this.$options[name]) {\n          Object.keys(this.$options[name]).forEach(function (key) {\n            var config = this$1.$options[name][key];\n            var ref = [config.type, config.default];\n            var type = ref[0];\n            var defaultValue = ref[1];\n\n            VueLocalStorage$1.addProperty(key, type, defaultValue);\n\n            var existingProp = Object.getOwnPropertyDescriptor(VueLocalStorage$1, key);\n\n            if (!existingProp) {\n              var prop = {\n                get: function () { return Vue.localStorage.get(key, defaultValue); },\n                set: function (val) { return Vue.localStorage.set(key, val); },\n                configurable: true\n              };\n\n              Object.defineProperty(VueLocalStorage$1, key, prop);\n              Vue.util.defineReactive(VueLocalStorage$1, key, defaultValue);\n            } else if (!Vue.config.silent) {\n              console.log((key + \": is already defined and will be reused\"));\n            }\n\n            if ((bind || config.bind) && config.bind !== false) {\n              this$1.$options.computed = this$1.$options.computed || {};\n\n              if (!this$1.$options.computed[key]) {\n                this$1.$options.computed[key] = {\n                  get: function () { return Vue.localStorage[key]; },\n                  set: function (val) { Vue.localStorage[key] = val; }\n                };\n              }\n            }\n          });\n        }\n      }\n    });\n\n    Vue[name] = VueLocalStorage$1;\n    Vue.prototype[(\"$\" + name)] = VueLocalStorage$1;\n  }\n};\n\nreturn index;\n\n})));\n"],"mappings":"AACA;;;;;ACmBA;;;;;;;;ACZA;;;;;;;;;;;;;;;;;;;;;;;ACcA;;;;;;ACfA;;;;AC4RA;;;;;ACjRA;;;;;;;;;ACDA;;;;ACGA;;;;ACcA;;;;ACTA;;;;ACoXA;;;;;ACjXA;;;;;;;;;ACNA;;;;ACJA;;;;ACGA;;;;AC2CA;;;;ACrBA;;;;ACrBA;;;;;ACHA;;;;ACEA;;;;ACoBA;;;;;ACbA;;;;ACOA;;;;;ACRA;;;;ACJA;;;;AA2MA;;;;ACtNA;;;;ACEA;;;;ACgCA;;;;ACjBA;;;;AAmPA;;;;AC/PA;;;;AC0DA;;;;ACyBA;;;;ACxEA;;;;;ACZA;;;;ACFA;;;;ACCA;;;;AH8GA;;;;;AI9GA;;;;ACKA;;;;ACHA;;;;ACmCA;;;;ACnCA;;;;ACqBA;;;;AAgIA;;;;AC/IA;;;;AC+HA;;;;;ACrIA;;;;ACDA;;;;ACGA;;;;ACRA;;;;AAmFA;;;;;ACrEA;;;;AC20BA;;;;AC7XA;;;;ACjdA;;;;ACqtBA;;;;;AC1oBA;;;;ACcA;;;;AA4xBA;;;;ACh3BA;;;;;ACWA;;;;ACpBA;;;;ACuXA;;;;ACpWA;;;;ACTA;;;;;ACKA;;;;;ACXA;;;;ACgDA;;;;AAtDA;;;;ACorCA;;;;ACplCA;;;;AA2YA;;;;ACoOA;;;;ACpsBA;;;;ACUA;;;;AC+mDA;;;;AClnDA;;;;ACZA;;;;ACLA;;;;ACWA;;;;AAghBA;;;;;ACzgBA;;;;;ACYA;;;;ACaA;;;;AC5CA;;;;ACoBA;;;;AC8BA;;;;AC3BA;;;;;ACMA;;;;ACoRA;;;;;AClTA;;;;;ACEA;;;;ACAA;;;;;ACEA;;;;ACCA;;;;ACsNA;;;;ACxMA;;;;;ACVA;;;;;ACEA;;;;ACIA;;;;ACVA;;;;ACHA;;;;AC+PA;;;;AChPA;;;;ACyDA;;;;AC/DA;;;;;ACVA;;;;ACIA;;;;ACAA;;;;ACWA;;;;ACGA;;;;;ACjBA;;;;ACsCA;;;;AAoLA;;;;;AC1NA;;;;ACsBA;;;;ACtBA;;;;ACAA;;;;ACAA;;;;ACcA;;;;ACuOA;;;;AAFA;;;;AC7OA;;;;ACgDA;;;;AC5CA;;;;;;;;;ACRA;;;;ACeA;;;;ACXA;;;;ACIA;;;;ACHA;;;;;;;;;ACDA;;;;ACCA;;;;AC4BA;;;;AAkxBA;;;;AC5yBA;;;;ACuNA;;;;AClNA;;;;ACAA;;;;;;;;;AChBA;;;;ACYA;;;;ACEA;;;;ACCA;;;;AAuLA;;;;AChMA;;;;;ACEA;;;;;ACPA;;;;ACiEA;;;;ACTA;;;;;;;;;AC1CA;;;;;ACyDA;;;;ACxEA;;;;ACcA;;;;ACPA;;;;ACKA;;;;;ACRA;;;;ACOA;;;;ACLA;;;;ACmEA;;;;AC9DA;;;;;ACkBA;;;;AClBA;;;;AC4UA;;;;AC1UA;;;;ACVA;;;;ACeA;;;;ACFA;;;;;ACbA;;;;ACMA;;;;ACFA;;;;ACwIA;;;;AC7HA;;;;ACZA;;;;;ACSA;;;;ACFA;;;;ACKA;;;;ACiJA;;;;ACjJA;;;;AC2HA;;;;AC5HA;;;;ACutBA;;;;;ACvhBA;;;;ACxLA;;;;ACyCA;;;;ACtCA;;;;ACnBA;;;;ACMA;;;;;ACOA;;;;ACjBA;;;;ACSA;;;;ACKA;;;;;ACbA;;;;ACUA;;;;ACQA;;;;ACVA;;;;ACGA;;;;ACFA;;;;;ACDA;;;;ACPA;;;;ACoBA;;;;ACiFA;;;;ACrGA;;;;;;;;;ACJA;;;;ACaA;;;;;;;;;ACRA;;;;ACSA;;;;ACPA;;;;;ACHA;;;;ACGA;;;;ACGA;;;;AC0SA;;;;ACvSA;;;;;;;;;ACXA;;;;ACOA;;;;ACoFA;;;;;ACvEA;;;;ACVA;;;;AC4FA;;;;ACtFA;;;;ACJA;;;;;;AC3BA;;;;ACoEA;;;;;;ACpEA","sourceRoot":""}